import {
  Account,
  JazzContextManager,
  activeAccountContext,
  createAnonymousJazzContext,
  createJazzContext,
  randomSessionProvider
} from "./chunk-PYBQOYML.js";

// src/testing.ts
import { LocalNode } from "cojson";
import { cojsonInternals } from "cojson";
import { PureJSCrypto } from "cojson/dist/crypto/PureJSCrypto";
var syncServer = { current: null };
var TestJSCrypto = class extends PureJSCrypto {
  static async create() {
    if ("navigator" in globalThis && navigator.userAgent?.includes("jsdom")) {
      const crypto = new PureJSCrypto();
      crypto.seal = (options) => `sealed_U${cojsonInternals.stableStringify(options.message)}`;
      crypto.unseal = (sealed) => JSON.parse(sealed.substring("sealed_U".length));
      crypto.encrypt = (message) => `encrypted_U${cojsonInternals.stableStringify(message)}`;
      crypto.decryptRaw = (encrypted) => encrypted.substring("encrypted_U".length);
      return crypto;
    }
    return new PureJSCrypto();
  }
};
function getPeerConnectedToTestSyncServer() {
  if (!syncServer.current) {
    throw new Error("Sync server not initialized");
  }
  const [aPeer, bPeer] = cojsonInternals.connectedPeers(
    Math.random().toString(),
    Math.random().toString(),
    {
      peer1role: "server",
      peer2role: "server"
    }
  );
  syncServer.current.syncManager.addPeer(aPeer);
  return bPeer;
}
var SecretSeedMap = /* @__PURE__ */ new Map();
var isMigrationActive = false;
async function createJazzTestAccount(options) {
  const AccountSchema = options?.AccountSchema ?? Account;
  const peers = [];
  if (syncServer.current) {
    peers.push(getPeerConnectedToTestSyncServer());
  }
  const crypto = await TestJSCrypto.create();
  const secretSeed = crypto.newRandomSecretSeed();
  const { node } = await LocalNode.withNewlyCreatedAccount({
    creationProps: {
      name: "Test Account",
      ...options?.creationProps
    },
    initialAgentSecret: crypto.agentSecretFromSecretSeed(secretSeed),
    crypto,
    peersToLoadFrom: peers,
    migration: async (rawAccount, _node, creationProps) => {
      if (isMigrationActive) {
        throw new Error(
          "It is not possible to create multiple accounts in parallel inside the test environment."
        );
      }
      isMigrationActive = true;
      const account2 = new AccountSchema({
        fromRaw: rawAccount
      });
      const prevActiveAccount = activeAccountContext.maybeGet();
      activeAccountContext.set(account2);
      await account2.applyMigration?.(creationProps);
      if (!options?.isCurrentActiveAccount) {
        activeAccountContext.set(prevActiveAccount);
      }
      isMigrationActive = false;
    }
  });
  const account = AccountSchema.fromNode(node);
  SecretSeedMap.set(account.id, secretSeed);
  if (options?.isCurrentActiveAccount) {
    activeAccountContext.set(account);
  }
  return account;
}
function setActiveAccount(account) {
  activeAccountContext.set(account);
}
async function createJazzTestGuest() {
  const ctx = await createAnonymousJazzContext({
    crypto: await PureJSCrypto.create(),
    peersToLoadFrom: []
  });
  return {
    guest: ctx.agent
  };
}
var TestJazzContextManager = class _TestJazzContextManager extends JazzContextManager {
  static fromAccountOrGuest(account, props) {
    if (account && "guest" in account) {
      return this.fromGuest(account, props);
    }
    return this.fromAccount(account ?? Account.getMe(), props);
  }
  static fromAccount(account, props) {
    const context = new _TestJazzContextManager();
    const provider = props?.isAuthenticated ? "testProvider" : "anonymous";
    const storage = context.getAuthSecretStorage();
    const node = account._raw.core.node;
    const credentials = {
      accountID: account.id,
      accountSecret: node.account.agentSecret,
      secretSeed: SecretSeedMap.get(account.id),
      provider
    };
    storage.set(credentials);
    context.updateContext(
      {
        AccountSchema: account.constructor,
        ...props
      },
      {
        me: account,
        node,
        done: () => {
          node.gracefulShutdown();
        },
        logOut: async () => {
          await storage.clear();
          node.gracefulShutdown();
        }
      },
      {
        credentials
      }
    );
    return context;
  }
  static fromGuest({ guest }, props = {}) {
    const context = new _TestJazzContextManager();
    const node = guest.node;
    context.updateContext(props, {
      guest,
      node,
      done: () => {
        node.gracefulShutdown();
      },
      logOut: async () => {
        node.gracefulShutdown();
      }
    });
    return context;
  }
  async getNewContext(props, authProps) {
    if (!syncServer.current) {
      throw new Error(
        "You need to setup a test sync server with setupJazzTestSync to use the Auth functions"
      );
    }
    const context = await createJazzContext({
      credentials: authProps?.credentials,
      defaultProfileName: props.defaultProfileName,
      newAccountProps: authProps?.newAccountProps,
      peersToLoadFrom: [getPeerConnectedToTestSyncServer()],
      crypto: await TestJSCrypto.create(),
      sessionProvider: randomSessionProvider,
      authSecretStorage: this.getAuthSecretStorage(),
      AccountSchema: props.AccountSchema
    });
    return {
      me: context.account,
      node: context.node,
      done: () => {
        context.done();
      },
      logOut: () => {
        return context.logOut();
      }
    };
  }
};
async function linkAccounts(a, b, aRole = "server", bRole = "server") {
  const [aPeer, bPeer] = cojsonInternals.connectedPeers(b.id, a.id, {
    peer1role: aRole,
    peer2role: bRole
  });
  a._raw.core.node.syncManager.addPeer(aPeer);
  b._raw.core.node.syncManager.addPeer(bPeer);
  await a.waitForAllCoValuesSync();
  await b.waitForAllCoValuesSync();
}
async function setupJazzTestSync() {
  if (syncServer.current) {
    syncServer.current.gracefulShutdown();
  }
  const account = await Account.create({
    creationProps: {
      name: "Test Account"
    },
    crypto: await TestJSCrypto.create()
  });
  syncServer.current = account._raw.core.node;
  return account;
}
export {
  TestJSCrypto,
  TestJazzContextManager,
  createJazzTestAccount,
  createJazzTestGuest,
  getPeerConnectedToTestSyncServer,
  linkAccounts,
  setActiveAccount,
  setupJazzTestSync
};
//# sourceMappingURL=testing.js.map