import { type Account } from "../coValues/account.js";
import type { AnonymousJazzAgent, CoValue, ID, RefEncoded, UnCo } from "../internal.js";
export declare class Ref<out V extends CoValue> {
    readonly id: ID<V>;
    readonly controlledAccount: Account | AnonymousJazzAgent;
    readonly schema: RefEncoded<V>;
    constructor(id: ID<V>, controlledAccount: Account | AnonymousJazzAgent, schema: RefEncoded<V>);
    private getNode;
    hasReadAccess(): boolean;
    getValueWithoutAccessCheck(): V | null;
    get value(): V | null;
    private loadHelper;
    syncLoad(): V | undefined;
    load(): Promise<V | undefined>;
    accessFrom(fromScopeValue: CoValue, key: string | number | symbol): V | null;
}
export declare function makeRefs<Keys extends string | number>(getIdForKey: (key: Keys) => ID<CoValue> | undefined, getKeysWithIds: () => Keys[], controlledAccount: Account | AnonymousJazzAgent, refSchemaForKey: (key: Keys) => RefEncoded<CoValue>): {
    [K in Keys]: Ref<CoValue>;
} & {
    [Symbol.iterator]: () => IterableIterator<Ref<CoValue>>;
    length: number;
};
export type RefIfCoValue<V> = NonNullable<V> extends CoValue ? Ref<UnCo<NonNullable<V>>> : never;
//# sourceMappingURL=refs.d.ts.map