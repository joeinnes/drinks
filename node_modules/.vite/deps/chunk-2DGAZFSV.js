import {
  __commonJS,
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/.pnpm/fast-myers-diff@3.2.0/node_modules/fast-myers-diff/bin/index.js
var require_bin = __commonJS({
  "node_modules/.pnpm/fast-myers-diff@3.2.0/node_modules/fast-myers-diff/bin/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calcSlices = exports.applyPatch = exports.calcPatch = exports.lcs = exports.diff = exports.diff_core = void 0;
    function diff_internal(state, c2) {
      const { b, eq, stack_base } = state;
      let { i: i2, N, j, M, Z, stack_top } = state;
      for (; ; ) {
        switch (c2) {
          case 0: {
            Z_block: while (N > 0 && M > 0) {
              b.fill(0, 0, 2 * Z);
              const W = N - M;
              const L = N + M;
              const parity = L & 1;
              const offsetx = i2 + N - 1;
              const offsety = j + M - 1;
              const hmax = (L + parity) / 2;
              let z;
              h_loop: for (let h2 = 0; h2 <= hmax; h2++) {
                const kmin = 2 * Math.max(0, h2 - M) - h2;
                const kmax = h2 - 2 * Math.max(0, h2 - N);
                for (let k = kmin; k <= kmax; k += 2) {
                  const gkm = b[k - 1 - Z * Math.floor((k - 1) / Z)];
                  const gkp = b[k + 1 - Z * Math.floor((k + 1) / Z)];
                  const u2 = k === -h2 || k !== h2 && gkm < gkp ? gkp : gkm + 1;
                  const v2 = u2 - k;
                  let x = u2;
                  let y = v2;
                  while (x < N && y < M && eq(i2 + x, j + y))
                    x++, y++;
                  b[k - Z * Math.floor(k / Z)] = x;
                  if (parity === 1 && (z = W - k) >= 1 - h2 && z < h2 && x + b[Z + z - Z * Math.floor(z / Z)] >= N) {
                    if (h2 > 1 || x !== u2) {
                      stack_base[stack_top++] = i2 + x;
                      stack_base[stack_top++] = N - x;
                      stack_base[stack_top++] = j + y;
                      stack_base[stack_top++] = M - y;
                      N = u2;
                      M = v2;
                      Z = 2 * (Math.min(N, M) + 1);
                      continue Z_block;
                    } else
                      break h_loop;
                  }
                }
                for (let k = kmin; k <= kmax; k += 2) {
                  const pkm = b[Z + k - 1 - Z * Math.floor((k - 1) / Z)];
                  const pkp = b[Z + k + 1 - Z * Math.floor((k + 1) / Z)];
                  const u2 = k === -h2 || k !== h2 && pkm < pkp ? pkp : pkm + 1;
                  const v2 = u2 - k;
                  let x = u2;
                  let y = v2;
                  while (x < N && y < M && eq(offsetx - x, offsety - y))
                    x++, y++;
                  b[Z + k - Z * Math.floor(k / Z)] = x;
                  if (parity === 0 && (z = W - k) >= -h2 && z <= h2 && x + b[z - Z * Math.floor(z / Z)] >= N) {
                    if (h2 > 0 || x !== u2) {
                      stack_base[stack_top++] = i2 + N - u2;
                      stack_base[stack_top++] = u2;
                      stack_base[stack_top++] = j + M - v2;
                      stack_base[stack_top++] = v2;
                      N = N - x;
                      M = M - y;
                      Z = 2 * (Math.min(N, M) + 1);
                      continue Z_block;
                    } else
                      break h_loop;
                  }
                }
              }
              if (N === M)
                continue;
              if (M > N) {
                i2 += N;
                j += N;
                M -= N;
                N = 0;
              } else {
                i2 += M;
                j += M;
                N -= M;
                M = 0;
              }
              break;
            }
            if (N + M !== 0) {
              if (state.pxe === i2 || state.pye === j) {
                state.pxe = i2 + N;
                state.pye = j + M;
              } else {
                const sx = state.pxs;
                state.oxs = state.pxs;
                state.oxe = state.pxe;
                state.oys = state.pys;
                state.oye = state.pye;
                state.pxs = i2;
                state.pxe = i2 + N;
                state.pys = j;
                state.pye = j + M;
                if (sx >= 0) {
                  state.i = i2;
                  state.N = N;
                  state.j = j;
                  state.M = M;
                  state.Z = Z;
                  state.stack_top = stack_top;
                  return 1;
                }
              }
            }
          }
          case 1: {
            if (stack_top === 0)
              return 2;
            M = stack_base[--stack_top];
            j = stack_base[--stack_top];
            N = stack_base[--stack_top];
            i2 = stack_base[--stack_top];
            Z = 2 * (Math.min(N, M) + 1);
            c2 = 0;
          }
        }
      }
    }
    var DiffGen = class {
      constructor(state) {
        this.state = state;
        this.c = 0;
        this.result = { value: null, done: false };
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        const { state, result } = this;
        if (this.c > 1) {
          result.done = true;
          result.value = void 0;
          return result;
        }
        const c2 = diff_internal(state, this.c);
        this.c = c2;
        if (c2 === 1) {
          result.value = [state.oxs, state.oxe, state.oys, state.oye];
          return result;
        }
        if (state.pxs >= 0) {
          result.value = [state.pxs, state.pxe, state.pys, state.pye];
          return result;
        }
        result.done = true;
        result.value = void 0;
        return result;
      }
    };
    function diff_core(i2, N, j, M, eq) {
      const Z = (Math.min(N, M) + 1) * 2;
      const L = N + M;
      const b = new (L < 256 ? Uint8Array : L < 65536 ? Uint16Array : Uint32Array)(2 * Z);
      return new DiffGen({ i: i2, N, j, M, Z, b, eq, pxs: -1, pxe: -1, pys: -1, pye: -1, oxs: -1, oxe: -1, oys: -1, oye: -1, stack_top: 0, stack_base: [] });
    }
    exports.diff_core = diff_core;
    function diff(xs, ys, eq) {
      let [i2, N, M] = [0, xs.length, ys.length];
      if (typeof eq === "function") {
        while (i2 < N && i2 < M && eq(i2, i2))
          i2++;
        if (i2 === N && i2 === M)
          return [][Symbol.iterator]();
        while (eq(--N, --M) && N > i2 && M > i2) ;
      } else {
        while (i2 < N && i2 < M && xs[i2] === ys[i2])
          i2++;
        if (i2 === N && i2 === M)
          return [][Symbol.iterator]();
        while (xs[--N] === ys[--M] && N > i2 && M > i2) ;
        eq = (i3, j) => xs[i3] === ys[j];
      }
      return diff_core(i2, N + 1 - i2, i2, M + 1 - i2, eq);
    }
    exports.diff = diff;
    var LCSGen = class {
      constructor(diff2, N) {
        this.diff = diff2;
        this.N = N;
        this.i = 0;
        this.j = 0;
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        const rec = this.diff.next();
        if (rec.done) {
          const { i: i3, j: j2, N } = this;
          if (i3 < N) {
            rec.done = false;
            rec.value = [i3, j2, N - i3];
            this.i = N;
          }
          return rec;
        }
        const v2 = rec.value;
        const sx = v2[0];
        const ex = v2[1];
        const ey = v2[3];
        const { i: i2, j } = this;
        if (i2 !== sx) {
          v2.length--;
          v2[0] = i2;
          v2[1] = j;
          v2[2] = sx - i2;
        }
        this.i = ex;
        this.j = ey;
        return rec;
      }
    };
    function lcs(xs, ys, eq) {
      return new LCSGen(diff(xs, ys, eq), xs.length);
    }
    exports.lcs = lcs;
    function* calcPatch3(xs, ys, eq) {
      const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
      for (const v2 of diff(xs, ys, eq)) {
        v2[2] = slice.call(ys, v2[2], v2[3]);
        yield v2;
      }
    }
    exports.calcPatch = calcPatch3;
    function* applyPatch(xs, patch) {
      let i2 = 0;
      const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
      for (const [dels, dele, ins] of patch) {
        if (i2 < dels)
          yield slice.call(xs, i2, dels);
        if (ins.length > 0)
          yield ins;
        i2 = dele;
      }
      if (i2 < xs.length)
        yield slice.call(xs, i2);
    }
    exports.applyPatch = applyPatch;
    function* calcSlices(xs, ys, eq) {
      let i2 = 0;
      const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
      for (const [dels, dele, inss, inse] of diff(xs, ys, eq)) {
        if (i2 < dels)
          yield [0, slice.call(xs, i2, dels)];
        if (dels < dele)
          yield [-1, slice.call(xs, dels, dele)];
        if (inss < inse)
          yield [1, slice.call(ys, inss, inse)];
        i2 = dele;
      }
      if (i2 < xs.length)
        yield [0, xs.slice(i2)];
    }
    exports.calcSlices = calcSlices;
  }
});

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/base64url.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
function base64URLtoBytes(base643) {
  base643 = base643.replace(/=/g, "");
  const n2 = base643.length;
  const rem = n2 % 4;
  const k = rem && rem - 1;
  const m2 = (n2 >> 2) * 3 + k;
  const encoded = new Uint8Array(n2 + 3);
  encoder.encodeInto(base643 + "===", encoded);
  for (let i2 = 0, j = 0; i2 < n2; i2 += 4, j += 3) {
    const x = (lookup[encoded[i2]] << 18) + (lookup[encoded[i2 + 1]] << 12) + (lookup[encoded[i2 + 2]] << 6) + lookup[encoded[i2 + 3]];
    encoded[j] = x >> 16;
    encoded[j + 1] = x >> 8 & 255;
    encoded[j + 2] = x & 255;
  }
  return new Uint8Array(encoded.buffer, 0, m2);
}
function bytesToBase64url(bytes) {
  const m2 = bytes.length;
  const k = m2 % 3;
  const n2 = Math.floor(m2 / 3) * 4 + (k && k + 1);
  const N = Math.ceil(m2 / 3) * 4;
  const encoded = new Uint8Array(N);
  for (let i2 = 0, j = 0; j < m2; i2 += 4, j += 3) {
    const y = (bytes[j] << 16) + (bytes[j + 1] << 8) + (bytes[j + 2] | 0);
    encoded[i2] = encodeLookup[y >> 18];
    encoded[i2 + 1] = encodeLookup[y >> 12 & 63];
    encoded[i2 + 2] = encodeLookup[y >> 6 & 63];
    encoded[i2 + 3] = encodeLookup[y & 63];
  }
  let base643 = decoder.decode(new Uint8Array(encoded.buffer, 0, n2));
  if (k === 1)
    base643 += "==";
  if (k === 2)
    base643 += "=";
  return base643;
}
var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var lookup = new Uint8Array(128);
for (const [i2, a2] of Array.from(alphabet).entries()) {
  lookup[a2.charCodeAt(0)] = i2;
}
lookup["=".charCodeAt(0)] = 0;
var encodeLookup = new Uint8Array(64);
for (const [i2, a2] of Array.from(alphabet).entries()) {
  encodeLookup[i2] = a2.charCodeAt(0);
}

// node_modules/.pnpm/neverthrow@7.2.0/node_modules/neverthrow/dist/index.es.js
var defaultErrorConfig = {
  withStackTrace: false
};
var createNeverThrowError = (message, result, config = defaultErrorConfig) => {
  const data = result.isOk() ? { type: "Ok", value: result.value } : { type: "Err", value: result.error };
  const maybeStack = config.withStackTrace ? new Error().stack : void 0;
  return {
    data,
    message,
    stack: maybeStack
  };
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2]) i2[n2] = function(v2) {
      return new Promise(function(a2, b) {
        q.push([n2, v2, a2, b]) > 1 || resume(n2, v2);
      });
    };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
var ResultAsync = class _ResultAsync {
  constructor(res) {
    this._promise = res;
  }
  static fromSafePromise(promise) {
    const newPromise = promise.then((value) => new Ok(value));
    return new _ResultAsync(newPromise);
  }
  static fromPromise(promise, errorFn) {
    const newPromise = promise.then((value) => new Ok(value)).catch((e2) => new Err(errorFn(e2)));
    return new _ResultAsync(newPromise);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromThrowable(fn, errorFn) {
    return (...args) => {
      return new _ResultAsync((() => __awaiter(this, void 0, void 0, function* () {
        try {
          return new Ok(yield fn(...args));
        } catch (error) {
          return new Err(errorFn ? errorFn(error) : error);
        }
      }))());
    };
  }
  static combine(asyncResultList) {
    return combineResultAsyncList(asyncResultList);
  }
  static combineWithAllErrors(asyncResultList) {
    return combineResultAsyncListWithAllErrors(asyncResultList);
  }
  map(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      return new Ok(yield f2(res.value));
    })));
  }
  andThrough(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newRes = yield f2(res.value);
      if (newRes.isErr()) {
        return new Err(newRes.error);
      }
      return new Ok(res.value);
    })));
  }
  andTee(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      try {
        yield f2(res.value);
      } catch (e2) {
      }
      return new Ok(res.value);
    })));
  }
  mapErr(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isOk()) {
        return new Ok(res.value);
      }
      return new Err(yield f2(res.error));
    })));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f2) {
    return new _ResultAsync(this._promise.then((res) => {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newValue = f2(res.value);
      return newValue instanceof _ResultAsync ? newValue._promise : newValue;
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return f2(res.error);
      }
      return new Ok(res.value);
    })));
  }
  match(ok2, _err) {
    return this._promise.then((res) => res.match(ok2, _err));
  }
  unwrapOr(t2) {
    return this._promise.then((res) => res.unwrapOr(t2));
  }
  /**
   * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.
   */
  safeUnwrap() {
    return __asyncGenerator(this, arguments, function* safeUnwrap_1() {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));
    });
  }
  // Makes ResultAsync implement PromiseLike<Result>
  then(successCallback, failureCallback) {
    return this._promise.then(successCallback, failureCallback);
  }
};
var okAsync = (value) => new ResultAsync(Promise.resolve(new Ok(value)));
var errAsync = (err2) => new ResultAsync(Promise.resolve(new Err(err2)));
var fromPromise = ResultAsync.fromPromise;
var fromSafePromise = ResultAsync.fromSafePromise;
var fromAsyncThrowable = ResultAsync.fromThrowable;
var combineResultList = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr()) {
      acc = err(result.error);
      break;
    } else {
      acc.map((list) => list.push(result.value));
    }
  }
  return acc;
};
var combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);
var combineResultListWithAllErrors = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr() && acc.isErr()) {
      acc.error.push(result.error);
    } else if (result.isErr() && acc.isOk()) {
      acc = err([result.error]);
    } else if (result.isOk() && acc.isOk()) {
      acc.value.push(result.value);
    }
  }
  return acc;
};
var combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);
var Result;
(function(Result2) {
  function fromThrowable2(fn, errorFn) {
    return (...args) => {
      try {
        const result = fn(...args);
        return ok(result);
      } catch (e2) {
        return err(errorFn ? errorFn(e2) : e2);
      }
    };
  }
  Result2.fromThrowable = fromThrowable2;
  function combine(resultList) {
    return combineResultList(resultList);
  }
  Result2.combine = combine;
  function combineWithAllErrors(resultList) {
    return combineResultListWithAllErrors(resultList);
  }
  Result2.combineWithAllErrors = combineWithAllErrors;
})(Result || (Result = {}));
var ok = (value) => new Ok(value);
function err(err2) {
  return new Err(err2);
}
var Ok = class {
  constructor(value) {
    this.value = value;
  }
  isOk() {
    return true;
  }
  isErr() {
    return !this.isOk();
  }
  map(f2) {
    return ok(f2(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  mapErr(_f) {
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f2) {
    return f2(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThrough(f2) {
    return f2(this.value).map((_value) => this.value);
  }
  andTee(f2) {
    try {
      f2(this.value);
    } catch (e2) {
    }
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(_f) {
    return ok(this.value);
  }
  asyncAndThen(f2) {
    return f2(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  asyncAndThrough(f2) {
    return f2(this.value).map(() => this.value);
  }
  asyncMap(f2) {
    return ResultAsync.fromSafePromise(f2(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrapOr(_v) {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  match(ok2, _err) {
    return ok2(this.value);
  }
  safeUnwrap() {
    const value = this.value;
    return function* () {
      return value;
    }();
  }
  _unsafeUnwrap(_2) {
    return this.value;
  }
  _unsafeUnwrapErr(config) {
    throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, config);
  }
};
var Err = class {
  constructor(error) {
    this.error = error;
  }
  isOk() {
    return false;
  }
  isErr() {
    return !this.isOk();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_f) {
    return err(this.error);
  }
  mapErr(f2) {
    return err(f2(this.error));
  }
  andThrough(_f) {
    return err(this.error);
  }
  andTee(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f2) {
    return f2(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncAndThen(_f) {
    return errAsync(this.error);
  }
  asyncAndThrough(_f) {
    return errAsync(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncMap(_f) {
    return errAsync(this.error);
  }
  unwrapOr(v2) {
    return v2;
  }
  match(_ok, err2) {
    return err2(this.error);
  }
  safeUnwrap() {
    const error = this.error;
    return function* () {
      yield err(error);
      throw new Error("Do not use this generator out of `safeTry`");
    }();
  }
  _unsafeUnwrap(config) {
    throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, config);
  }
  _unsafeUnwrapErr(_2) {
    return this.error;
  }
};
var fromThrowable = Result.fromThrowable;

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValue.js
var RawUnknownCoValue = class {
  constructor(core) {
    this.totalValidTransactions = 0;
    this.id = core.id;
    this.core = core;
  }
  get type() {
    return this.core.header.type;
  }
  get headerMeta() {
    return this.core.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  toJSON() {
    return {};
  }
  atTime() {
    return this;
  }
  subscribe(listener) {
    return this.core.subscribe((content) => {
      listener(content);
    });
  }
};
function expectMap(content) {
  if (content.type !== "comap") {
    throw new Error("Expected map");
  }
  return content;
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/logger.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
var ConsoleLogSystem = class {
  debug(message, attributes) {
    console.debug(message, attributes);
  }
  info(message, attributes) {
    console.info(message, attributes);
  }
  warn(message, attributes) {
    console.warn(message, attributes);
  }
  error(message, attributes) {
    console.error(message, attributes);
  }
};
var Logger = class {
  constructor(level = LogLevel.INFO, logSystem = new ConsoleLogSystem()) {
    this.level = level;
    this.logSystem = logSystem;
  }
  setLevel(level) {
    this.level = level;
  }
  setLogSystem(logSystem) {
    this.logSystem = logSystem;
  }
  debug(message, attributes) {
    if (this.level <= LogLevel.DEBUG) {
      this.logSystem.debug(message, attributes);
    }
  }
  info(message, attributes) {
    if (this.level <= LogLevel.INFO) {
      this.logSystem.info(message, attributes);
    }
  }
  warn(message, attributes) {
    if (this.level <= LogLevel.WARN) {
      this.logSystem.warn(message, attributes);
    }
  }
  error(message, attributes) {
    if (this.level <= LogLevel.ERROR) {
      this.logSystem.error(message, attributes);
    }
  }
};
var logger = new Logger();

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/typeUtils/accountOrAgentIDfromSessionID.js
function accountOrAgentIDfromSessionID(sessionID) {
  const until = sessionID.indexOf("_session");
  return sessionID.slice(0, until);
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValues/coList.js
var RawCoList = class _RawCoList {
  /** @internal */
  constructor(core) {
    this.type = "colist";
    this.totalValidTransactions = 0;
    this.knownTransactions = {};
    this.id = core.id;
    this.core = core;
    this.insertions = {};
    this.deletionsByInsertion = {};
    this.afterStart = [];
    this.beforeEnd = [];
    this.knownTransactions = {};
    this.processNewTransactions();
  }
  processNewTransactions() {
    var _a2, _b2, _c, _d;
    const transactions = this.core.getValidSortedTransactions({
      ignorePrivateTransactions: false,
      knownTransactions: this.knownTransactions
    });
    if (transactions.length === 0) {
      return;
    }
    this.totalValidTransactions += transactions.length;
    let lastValidTransaction = void 0;
    let oldestValidTransaction = void 0;
    this._cachedEntries = void 0;
    for (const { txID, changes, madeAt } of transactions) {
      lastValidTransaction = Math.max(lastValidTransaction ?? 0, madeAt);
      oldestValidTransaction = Math.min(oldestValidTransaction ?? Infinity, madeAt);
      this.knownTransactions[txID.sessionID] = Math.max(this.knownTransactions[txID.sessionID] ?? 0, txID.txIndex);
      for (const [changeIdx, changeUntyped] of changes.entries()) {
        const change = changeUntyped;
        if (change.op === "pre" || change.op === "app") {
          let sessionEntry = this.insertions[txID.sessionID];
          if (!sessionEntry) {
            sessionEntry = {};
            this.insertions[txID.sessionID] = sessionEntry;
          }
          let txEntry = sessionEntry[txID.txIndex];
          if (!txEntry) {
            txEntry = {};
            sessionEntry[txID.txIndex] = txEntry;
          }
          txEntry[changeIdx] = {
            madeAt,
            predecessors: [],
            successors: [],
            ...change
          };
          if (change.op === "pre") {
            if (change.before === "end") {
              this.beforeEnd.push({
                ...txID,
                changeIdx
              });
            } else {
              const beforeEntry = (_b2 = (_a2 = this.insertions[change.before.sessionID]) == null ? void 0 : _a2[change.before.txIndex]) == null ? void 0 : _b2[change.before.changeIdx];
              if (!beforeEntry) {
                continue;
              }
              beforeEntry.predecessors.splice(0, 0, {
                ...txID,
                changeIdx
              });
            }
          } else {
            if (change.after === "start") {
              this.afterStart.push({
                ...txID,
                changeIdx
              });
            } else {
              const afterEntry = (_d = (_c = this.insertions[change.after.sessionID]) == null ? void 0 : _c[change.after.txIndex]) == null ? void 0 : _d[change.after.changeIdx];
              if (!afterEntry) {
                continue;
              }
              afterEntry.successors.push({
                ...txID,
                changeIdx
              });
            }
          }
        } else if (change.op === "del") {
          let sessionEntry = this.deletionsByInsertion[change.insertion.sessionID];
          if (!sessionEntry) {
            sessionEntry = {};
            this.deletionsByInsertion[change.insertion.sessionID] = sessionEntry;
          }
          let txEntry = sessionEntry[change.insertion.txIndex];
          if (!txEntry) {
            txEntry = {};
            sessionEntry[change.insertion.txIndex] = txEntry;
          }
          let changeEntry = txEntry[change.insertion.changeIdx];
          if (!changeEntry) {
            changeEntry = [];
            txEntry[change.insertion.changeIdx] = changeEntry;
          }
          changeEntry.push({
            madeAt,
            deletionID: {
              ...txID,
              changeIdx
            },
            ...change
          });
        } else {
          throw new Error("Unknown list operation " + change.op);
        }
      }
    }
    if (this.lastValidTransaction && oldestValidTransaction && oldestValidTransaction < this.lastValidTransaction) {
      this.rebuildFromCore();
    } else {
      this.lastValidTransaction = lastValidTransaction;
    }
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /**
   * Not yet implemented
   *
   * @category 4. Time travel
   */
  atTime(_time) {
    throw new Error("Not yet implemented");
  }
  /**
   * Get the item currently at `idx`.
   *
   * @category 1. Reading
   */
  get(idx) {
    const entry = this.entries()[idx];
    if (!entry) {
      return void 0;
    }
    return entry.value;
  }
  /**
   * Returns the current items in the CoList as an array.
   *
   * @category 1. Reading
   **/
  asArray() {
    return this.entries().map((entry) => entry.value);
  }
  /** @internal */
  entries() {
    if (this._cachedEntries) {
      return this._cachedEntries;
    }
    const arr = this.entriesUncached();
    this._cachedEntries = arr;
    return arr;
  }
  /** @internal */
  entriesUncached() {
    const arr = [];
    for (const opID of this.afterStart) {
      this.fillArrayFromOpID(opID, arr);
    }
    for (const opID of this.beforeEnd) {
      this.fillArrayFromOpID(opID, arr);
    }
    return arr;
  }
  /** @internal */
  fillArrayFromOpID(opID, arr) {
    var _a2, _b2, _c, _d, _e;
    const todo = [opID];
    const predecessorsVisited = /* @__PURE__ */ new Set();
    while (todo.length > 0) {
      const currentOpID = todo[todo.length - 1];
      const entry = (_b2 = (_a2 = this.insertions[currentOpID.sessionID]) == null ? void 0 : _a2[currentOpID.txIndex]) == null ? void 0 : _b2[currentOpID.changeIdx];
      if (!entry) {
        throw new Error("Missing op " + currentOpID);
      }
      const shouldTraversePredecessors = entry.predecessors.length > 0 && !predecessorsVisited.has(currentOpID);
      if (shouldTraversePredecessors) {
        for (let i2 = entry.predecessors.length - 1; i2 >= 0; i2--) {
          todo.push(entry.predecessors[i2]);
        }
        predecessorsVisited.add(currentOpID);
      } else {
        todo.pop();
        const deleted = (((_e = (_d = (_c = this.deletionsByInsertion[currentOpID.sessionID]) == null ? void 0 : _c[currentOpID.txIndex]) == null ? void 0 : _d[currentOpID.changeIdx]) == null ? void 0 : _e.length) || 0) > 0;
        if (!deleted) {
          arr.push({
            value: entry.value,
            madeAt: entry.madeAt,
            opID: currentOpID
          });
        }
        for (const successor of entry.successors) {
          todo.push(successor);
        }
      }
    }
  }
  /**
   * Returns the current items in the CoList as an array. (alias of `asArray`)
   *
   * @category 1. Reading
   */
  toJSON() {
    return this.asArray();
  }
  /** @category 5. Edit history */
  editAt(idx) {
    const entry = this.entries()[idx];
    if (!entry) {
      return void 0;
    }
    const madeAt = new Date(entry.madeAt);
    const by = accountOrAgentIDfromSessionID(entry.opID.sessionID);
    const value = entry.value;
    return {
      by,
      tx: {
        sessionID: entry.opID.sessionID,
        txIndex: entry.opID.txIndex
      },
      at: madeAt,
      value
    };
  }
  /** @category 5. Edit history */
  deletionEdits() {
    const edits = [];
    for (const sessionID in this.deletionsByInsertion) {
      const sessionEntry = this.deletionsByInsertion[sessionID];
      for (const txIdx in sessionEntry) {
        const txEntry = sessionEntry[Number(txIdx)];
        for (const changeIdx in txEntry) {
          const changeEntry = txEntry[Number(changeIdx)];
          for (const deletion of changeEntry || []) {
            const madeAt = new Date(deletion.madeAt);
            const by = accountOrAgentIDfromSessionID(deletion.deletionID.sessionID);
            edits.push({
              by,
              tx: deletion.deletionID,
              at: madeAt
            });
          }
        }
      }
    }
    return edits;
  }
  /** @category 3. Subscription */
  subscribe(listener) {
    return this.core.subscribe((content) => {
      listener(content);
    });
  }
  /** Appends `item` after the item currently at index `after`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  append(item, after, privacy = "private") {
    this.appendItems([item], after, privacy);
  }
  /**
   * Appends `items` to the list at index `after`. If `after` is negative, it is treated as `0`.
   *
   * If `privacy` is `"private"` **(default)**, `items` are encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `items` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  appendItems(items, after, privacy = "private") {
    const entries = this.entries();
    after = after === void 0 ? entries.length > 0 ? entries.length - 1 : 0 : Math.max(0, after);
    let opIDBefore;
    if (entries.length > 0) {
      const entryBefore = entries[after];
      if (!entryBefore) {
        throw new Error("Invalid index " + after);
      }
      opIDBefore = entryBefore.opID;
    } else {
      if (after !== 0) {
        throw new Error("Invalid index " + after);
      }
      opIDBefore = "start";
    }
    const changes = items.map((item) => ({
      op: "app",
      value: isCoValue(item) ? item.id : item,
      after: opIDBefore
    }));
    if (opIDBefore !== "start") {
      changes.reverse();
    }
    this.core.makeTransaction(changes, privacy);
    this.processNewTransactions();
  }
  /**
   * Prepends `item` before the item currently at index `before`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  prepend(item, before, privacy = "private") {
    const entries = this.entries();
    before = before === void 0 ? 0 : before;
    let opIDAfter;
    if (entries.length > 0) {
      const entryAfter = entries[before];
      if (entryAfter) {
        opIDAfter = entryAfter.opID;
      } else {
        if (before !== entries.length) {
          throw new Error("Invalid index " + before);
        }
        opIDAfter = "end";
      }
    } else {
      if (before !== 0) {
        throw new Error("Invalid index " + before);
      }
      opIDAfter = "end";
    }
    this.core.makeTransaction([
      {
        op: "pre",
        value: isCoValue(item) ? item.id : item,
        before: opIDAfter
      }
    ], privacy);
    this.processNewTransactions();
  }
  /** Deletes the item at index `at`.
   *
   * If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(at, privacy = "private") {
    const entries = this.entries();
    const entry = entries[at];
    if (!entry) {
      throw new Error("Invalid index " + at);
    }
    this.core.makeTransaction([
      {
        op: "del",
        insertion: entry.opID
      }
    ], privacy);
    this.processNewTransactions();
  }
  replace(at, newItem, privacy = "private") {
    const entries = this.entries();
    const entry = entries[at];
    if (!entry) {
      throw new Error("Invalid index " + at);
    }
    this.core.makeTransaction([
      {
        op: "app",
        value: isCoValue(newItem) ? newItem.id : newItem,
        after: entry.opID
      },
      {
        op: "del",
        insertion: entry.opID
      }
    ], privacy);
    this.processNewTransactions();
  }
  /** @internal */
  rebuildFromCore() {
    const listAfter = new _RawCoList(this.core);
    this.afterStart = listAfter.afterStart;
    this.beforeEnd = listAfter.beforeEnd;
    this.insertions = listAfter.insertions;
    this.deletionsByInsertion = listAfter.deletionsByInsertion;
    this._cachedEntries = void 0;
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/typeUtils/isAccountID.js
function isAccountID(id) {
  return id.startsWith("co_");
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValues/coStream.js
var RawCoStreamView = class {
  constructor(core) {
    this.type = "costream";
    this.totalValidTransactions = 0;
    this.id = core.id;
    this.core = core;
    this.items = {};
    this.knownTransactions = {};
    this.processNewTransactions();
  }
  get headerMeta() {
    return this.core.header.meta;
  }
  get group() {
    return this.core.getGroup();
  }
  /** Not yet implemented */
  atTime(_time) {
    throw new Error("Not yet implemented");
  }
  /** @internal */
  compareStreamItems(a2, b) {
    return a2.madeAt - b.madeAt || (a2.tx.sessionID === b.tx.sessionID ? 0 : a2.tx.sessionID < b.tx.sessionID ? -1 : 1) || a2.tx.txIndex - b.tx.txIndex;
  }
  /** @internal */
  processNewTransactions() {
    const changeEntries = /* @__PURE__ */ new Set();
    const newValidTransactions = this.core.getValidTransactions({
      ignorePrivateTransactions: false,
      knownTransactions: this.knownTransactions
    });
    if (newValidTransactions.length === 0) {
      return;
    }
    for (const { txID, madeAt, changes } of newValidTransactions) {
      this.totalValidTransactions++;
      for (const changeUntyped of changes) {
        const change = changeUntyped;
        let entries = this.items[txID.sessionID];
        if (!entries) {
          entries = [];
          this.items[txID.sessionID] = entries;
        }
        entries.push({ value: change, madeAt, tx: txID });
        changeEntries.add(entries);
      }
      this.knownTransactions[txID.sessionID] = Math.max(this.knownTransactions[txID.sessionID] ?? 0, txID.txIndex);
    }
    for (const entries of changeEntries) {
      entries.sort(this.compareStreamItems);
    }
  }
  getSingleStream() {
    const streams = Object.values(this.items);
    const firstStream = streams[0];
    if (!firstStream) {
      return void 0;
    }
    if (streams.length > 1) {
      throw new Error("CoStream.getSingleStream() can only be called when there is exactly one stream");
    }
    return firstStream.map((item) => item.value);
  }
  sessions() {
    return Object.keys(this.items);
  }
  accounts() {
    return new Set(this.sessions().map(accountOrAgentIDfromSessionID).filter(isAccountID));
  }
  nthItemIn(sessionID, n2) {
    const items = this.items[sessionID];
    if (!items)
      return;
    const item = items[n2];
    if (!item)
      return;
    return {
      by: accountOrAgentIDfromSessionID(sessionID),
      tx: item.tx,
      at: new Date(item.madeAt),
      value: item.value
    };
  }
  lastItemIn(sessionID) {
    const items = this.items[sessionID];
    if (!items)
      return;
    return this.nthItemIn(sessionID, items.length - 1);
  }
  *itemsIn(sessionID) {
    const items = this.items[sessionID];
    if (!items)
      return;
    for (const item of items) {
      yield {
        by: accountOrAgentIDfromSessionID(sessionID),
        tx: item.tx,
        at: new Date(item.madeAt),
        value: item.value
      };
    }
  }
  lastItemBy(account) {
    let latestItem;
    for (const sessionID of Object.keys(this.items)) {
      if (sessionID.startsWith(account)) {
        const item = this.lastItemIn(sessionID);
        if (!item)
          continue;
        if (!latestItem || item.at > latestItem.at) {
          latestItem = {
            by: item.by,
            tx: item.tx,
            at: item.at,
            value: item.value
          };
        }
      }
    }
    return latestItem;
  }
  *itemsBy(account) {
    const items = [
      ...Object.keys(this.items).flatMap((sessionID) => sessionID.startsWith(account) ? [...this.itemsIn(sessionID)].map((item) => ({
        in: sessionID,
        ...item
      })) : [])
    ];
    items.sort((a2, b) => a2.at.getTime() - b.at.getTime());
    for (const item of items) {
      yield item;
    }
  }
  toJSON() {
    return Object.fromEntries(Object.entries(this.items).map(([sessionID, items]) => [
      sessionID,
      items.map((item) => item.value)
    ]));
  }
  subscribe(listener) {
    return this.core.subscribe((content) => {
      listener(content);
    });
  }
};
var RawCoStream = class extends RawCoStreamView {
  push(item, privacy = "private") {
    this.core.makeTransaction([isCoValue(item) ? item.id : item], privacy);
    this.processNewTransactions();
  }
};
var binary_U_prefixLength = 8;
var RawBinaryCoStreamView = class extends RawCoStreamView {
  isBinaryStreamEnded() {
    const items = this.getSingleStream();
    if (!items || items.length === 0) {
      return false;
    }
    const lastItem = items[items.length - 1];
    return (lastItem == null ? void 0 : lastItem.type) === "end";
  }
  getBinaryChunks(allowUnfinished) {
    const items = this.getSingleStream();
    if (!items)
      return;
    const start = items[0];
    if ((start == null ? void 0 : start.type) !== "start") {
      logger.error("Invalid binary stream start", start);
      return;
    }
    const end = items[items.length - 1];
    if ((end == null ? void 0 : end.type) !== "end" && !allowUnfinished)
      return;
    const chunks = [];
    let finished = false;
    for (const item of items.slice(1)) {
      if (item.type === "end") {
        finished = true;
        break;
      }
      if (item.type !== "chunk") {
        logger.error("Invalid binary stream chunk", item);
        return void 0;
      }
      const chunk = base64URLtoBytes(item.chunk.slice(binary_U_prefixLength));
      chunks.push(chunk);
    }
    return {
      mimeType: start.mimeType,
      fileName: start.fileName,
      totalSizeBytes: start.totalSizeBytes,
      chunks,
      finished
    };
  }
};
var RawBinaryCoStream = class extends RawBinaryCoStreamView {
  /** @internal */
  push(item, privacy = "private", updateView = true) {
    this.core.makeTransaction([item], privacy);
    if (updateView) {
      this.processNewTransactions();
    }
  }
  startBinaryStream(settings, privacy = "private") {
    this.push({
      type: "start",
      ...settings
    }, privacy, false);
  }
  pushBinaryStreamChunk(chunk, privacy = "private") {
    this.push({
      type: "chunk",
      chunk: `binary_U${bytesToBase64url(chunk)}`
    }, privacy, false);
  }
  endBinaryStream(privacy = "private") {
    this.push({
      type: "end"
    }, privacy, true);
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/typeUtils/isCoValue.js
function isCoValue(value) {
  return value instanceof RawCoMap || value instanceof RawCoList || value instanceof RawCoStream || value instanceof RawBinaryCoStream;
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValues/coMap.js
var RawCoMapView = class {
  /** @internal */
  constructor(core, options) {
    this.type = "comap";
    this.atTimeFilter = void 0;
    this.totalValidTransactions = 0;
    this.id = core.id;
    this.core = core;
    this.latestTxMadeAt = 0;
    this.ignorePrivateTransactions = (options == null ? void 0 : options.ignorePrivateTransactions) ?? false;
    this.ops = {};
    this.latest = {};
    this.knownTransactions = {};
    this.processNewTransactions();
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot process transactions on a time travel entity");
    }
    const newValidTransactions = this.core.getValidTransactions({
      ignorePrivateTransactions: this.ignorePrivateTransactions,
      knownTransactions: this.knownTransactions
    });
    if (newValidTransactions.length === 0) {
      return;
    }
    const { ops } = this;
    const changedEntries = /* @__PURE__ */ new Map();
    for (const { txID, changes, madeAt } of newValidTransactions) {
      for (let changeIdx = 0; changeIdx < changes.length; changeIdx++) {
        const change = changes[changeIdx];
        const entry = {
          txID,
          madeAt,
          changeIdx,
          change
        };
        if (madeAt > this.latestTxMadeAt) {
          this.latestTxMadeAt = madeAt;
        }
        const entries = ops[change.key];
        if (!entries) {
          const entries2 = [entry];
          ops[change.key] = entries2;
          changedEntries.set(change.key, entries2);
        } else {
          entries.push(entry);
          changedEntries.set(change.key, entries);
        }
        this.knownTransactions[txID.sessionID] = Math.max(this.knownTransactions[txID.sessionID] ?? 0, txID.txIndex);
      }
    }
    this.totalValidTransactions += newValidTransactions.length;
    for (const entries of changedEntries.values()) {
      entries.sort(this.core.compareTransactions);
    }
    for (const [key, entries] of changedEntries.entries()) {
      this.latest[key] = entries[entries.length - 1];
    }
  }
  isTimeTravelEntity() {
    return Boolean(this.atTimeFilter);
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /** @category 4. Time travel */
  atTime(time) {
    if (time >= this.latestTxMadeAt) {
      return this;
    } else {
      const clone = Object.create(this);
      clone.atTimeFilter = time;
      clone.latest = {};
      return clone;
    }
  }
  /** @internal */
  timeFilteredOps(key) {
    var _a2;
    if (key === "constructor") {
      return void 0;
    }
    const atTimeFilter = this.atTimeFilter;
    if (atTimeFilter) {
      return (_a2 = this.ops[key]) == null ? void 0 : _a2.filter((op) => op.madeAt <= atTimeFilter);
    } else {
      return this.ops[key];
    }
  }
  /**
   * Get all keys currently in the map.
   *
   * @category 1. Reading */
  keys() {
    return Object.keys(this.ops).filter((key) => {
      const entry = this.getRaw(key);
      if (entry === void 0) {
        return false;
      }
      if (entry.change.op === "del") {
        return false;
      }
      return true;
    });
  }
  getRaw(key) {
    let latestChange = this.latest[key];
    if (latestChange === void 0) {
      const entries = this.ops[key];
      if (entries && !(key in this.latest)) {
        const atTimeFilter = this.atTimeFilter;
        if (!atTimeFilter) {
          latestChange = entries[entries.length - 1];
        } else {
          latestChange = entries.findLast((op) => op.madeAt <= atTimeFilter);
        }
        this.latest[key] = latestChange;
      }
      if (latestChange === void 0) {
        return void 0;
      }
    }
    return latestChange;
  }
  /**
   * Returns the current value for the given key.
   *
   * @category 1. Reading
   **/
  get(key) {
    const entry = this.getRaw(key);
    if ((entry == null ? void 0 : entry.change) === void 0) {
      return void 0;
    }
    if (entry.change.op === "del") {
      return void 0;
    } else {
      return entry.change.value;
    }
  }
  /** @category 1. Reading */
  asObject() {
    const object = {};
    for (const key of Object.keys(this.ops)) {
      const value = this.get(key);
      if (value !== void 0) {
        object[key] = value;
      }
    }
    return object;
  }
  /** @category 1. Reading */
  toJSON() {
    return this.asObject();
  }
  /** @category 5. Edit history */
  nthEditAt(key, n2) {
    const ops = this.ops[key];
    const atTimeFilter = this.atTimeFilter;
    const entry = ops == null ? void 0 : ops[n2];
    if (!entry) {
      return void 0;
    }
    if (atTimeFilter && entry.madeAt > atTimeFilter) {
      return void 0;
    }
    return operationToEditEntry(entry);
  }
  /** @category 5. Edit history */
  lastEditAt(key) {
    const entry = this.getRaw(key);
    if (!entry) {
      return void 0;
    }
    return operationToEditEntry(entry);
  }
  /** @category 5. Edit history */
  *editsAt(key) {
    const entries = this.ops[key];
    if (!entries) {
      return;
    }
    const atTimeFilter = this.atTimeFilter;
    for (const entry of entries) {
      if (atTimeFilter && entry.madeAt > atTimeFilter) {
        return;
      }
      yield operationToEditEntry(entry);
    }
  }
  /** @category 3. Subscription */
  subscribe(listener) {
    return this.core.subscribe((content) => {
      listener(content);
    });
  }
};
var RawCoMap = class extends RawCoMapView {
  /** Set a new value for the given key.
   *
   * If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  set(key, value, privacy = "private") {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot set value on a time travel entity");
    }
    this.core.makeTransaction([
      {
        op: "set",
        key,
        value: isCoValue(value) ? value.id : value
      }
    ], privacy);
    this.processNewTransactions();
  }
  assign(entries, privacy = "private") {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot set value on a time travel entity");
    }
    this.core.makeTransaction(Object.entries(entries).map(([key, value]) => ({
      op: "set",
      key,
      value: isCoValue(value) ? value.id : value
    })), privacy);
    this.processNewTransactions();
  }
  /** Delete the given key (setting it to undefined).
   *
   * If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(key, privacy = "private") {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot delete value on a time travel entity");
    }
    this.core.makeTransaction([
      {
        op: "del",
        key
      }
    ], privacy);
    this.processNewTransactions();
  }
};
function operationToEditEntry(op) {
  return {
    by: accountOrAgentIDfromSessionID(op.txID.sessionID),
    tx: op.txID,
    at: new Date(op.madeAt),
    value: op.change.op === "del" ? void 0 : op.change.value
  };
}

// node_modules/.pnpm/@scure+base@1.2.1/node_modules/@scure/base/lib/esm/index.js
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`invalid integer: ${n2}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a2) => a2;
  const wrap = (a2, b) => (c2) => a2(b(c2));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode };
}
function alphabet2(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l2, i2) => [l2, i2]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i2 = indexes.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  afn(fn);
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d2) => {
    anumber(d2);
    if (d2 < 0 || d2 >= from)
      throw new Error(`invalid integer: ${d2}`);
    return d2;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < dlen; i2++) {
      const digit = digits[i2];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i2] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd = (a2, b) => b === 0 ? a2 : gcd(b, a2 % b);
var radix2carry = (from, to) => from + (to - gcd(from, to));
var powers = (() => {
  let res = [];
  for (let i2 = 0; i2 < 40; i2++)
    res.push(2 ** i2);
  return res;
})();
function convertRadix2(data, from, to, padding3) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from];
  const mask = powers[to] - 1;
  const res = [];
  for (const n2 of data) {
    anumber(n2);
    if (n2 >= max)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
    carry = carry << from | n2;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding3 && pos >= from)
    throw new Error("Excess padding");
  if (!padding3 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding3 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e2) {
    }
  };
}
var base16 = chain(radix2(4), alphabet2("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s2) => s2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = chain(radix2(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet2(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c2 = prefix.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c2 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v2 of words)
    chk = bech32Polymod(chk) ^ v2;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex = chain(radix2(4), alphabet2("0123456789abcdef"), join(""), normalize((s2) => {
  if (typeof s2 !== "string" || s2.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s2} with length ${s2.length}`);
  return s2.toLowerCase();
}));

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/jsonStringify.js
function stableStringify(data) {
  const cycles = false;
  const seen = [];
  let node = data;
  if (node && node.toJSON && typeof node.toJSON === "function") {
    node = node.toJSON();
  }
  if (node === void 0)
    return;
  if (typeof node == "number")
    return isFinite(node) ? "" + node : "null";
  if (typeof node !== "object") {
    if (typeof node === "string" && (node.startsWith("encrypted_U") || node.startsWith("binary_U"))) {
      return `"${node}"`;
    }
    return JSON.stringify(node);
  }
  let i2, out;
  if (Array.isArray(node)) {
    out = "[";
    for (i2 = 0; i2 < node.length; i2++) {
      if (i2)
        out += ",";
      out += stableStringify(node[i2]) || "null";
    }
    return out + "]";
  }
  if (node === null)
    return "null";
  if (seen.indexOf(node) !== -1) {
    if (cycles)
      return JSON.stringify("__cycle__");
    throw new TypeError("Converting circular structure to JSON");
  }
  const seenIndex = seen.push(node) - 1;
  const keys = Object.keys(node).sort();
  out = "";
  for (i2 = 0; i2 < keys.length; i2++) {
    const key = keys[i2];
    const value = stableStringify(node[key]);
    if (!value)
      continue;
    if (out)
      out += ",";
    out += JSON.stringify(key) + ":" + value;
  }
  seen.splice(seenIndex, 1);
  return "{" + out + "}";
}
function parseJSON(json) {
  return JSON.parse(json);
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/crypto/crypto.js
function randomBytes(bytesLength = 32) {
  return crypto.getRandomValues(new Uint8Array(bytesLength));
}
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var CryptoProvider = class {
  randomBytes(length) {
    return randomBytes(length);
  }
  newRandomSigner() {
    return `signerSecret_z${base58.encode(this.newEd25519SigningKey())}`;
  }
  signerSecretToBytes(secret) {
    return base58.decode(secret.substring("signerSecret_z".length));
  }
  signerSecretFromBytes(bytes) {
    return `signerSecret_z${base58.encode(bytes)}`;
  }
  newRandomSealer() {
    return `sealerSecret_z${base58.encode(this.newX25519StaticSecret())}`;
  }
  sealerSecretToBytes(secret) {
    return base58.decode(secret.substring("sealerSecret_z".length));
  }
  sealerSecretFromBytes(bytes) {
    return `sealerSecret_z${base58.encode(bytes)}`;
  }
  newRandomAgentSecret() {
    return `${this.newRandomSealer()}/${this.newRandomSigner()}`;
  }
  agentSecretToBytes(secret) {
    const [sealerSecret, signerSecret] = secret.split("/");
    return new Uint8Array([
      ...this.sealerSecretToBytes(sealerSecret),
      ...this.signerSecretToBytes(signerSecret)
    ]);
  }
  agentSecretFromBytes(bytes) {
    const sealerSecret = this.sealerSecretFromBytes(bytes.slice(0, 32));
    const signerSecret = this.signerSecretFromBytes(bytes.slice(32));
    return `${sealerSecret}/${signerSecret}`;
  }
  getAgentID(secret) {
    const [sealerSecret, signerSecret] = secret.split("/");
    return `${this.getSealerID(sealerSecret)}/${this.getSignerID(signerSecret)}`;
  }
  getAgentSignerID(agentId) {
    return agentId.split("/")[1];
  }
  getAgentSignerSecret(agentSecret) {
    return agentSecret.split("/")[1];
  }
  getAgentSealerID(agentId) {
    return agentId.split("/")[0];
  }
  getAgentSealerSecret(agentSecret) {
    return agentSecret.split("/")[0];
  }
  secureHash(value) {
    return `hash_z${base58.encode(this.blake3HashOnce(textEncoder.encode(stableStringify(value))))}`;
  }
  shortHash(value) {
    return `shortHash_z${base58.encode(this.blake3HashOnce(textEncoder.encode(stableStringify(value))).slice(0, shortHashLength))}`;
  }
  encryptForTransaction(value, keySecret, nOnceMaterial) {
    return this.encrypt(value, keySecret, nOnceMaterial);
  }
  decrypt(encrypted, keySecret, nOnceMaterial) {
    try {
      return parseJSON(this.decryptRaw(encrypted, keySecret, nOnceMaterial));
    } catch (e2) {
      logger.error("Decryption error", { err: e2 });
      return void 0;
    }
  }
  newRandomKeySecret() {
    return {
      secret: `keySecret_z${base58.encode(this.randomBytes(32))}`,
      id: `key_z${base58.encode(this.randomBytes(12))}`
    };
  }
  decryptRawForTransaction(encrypted, keySecret, nOnceMaterial) {
    return this.decryptRaw(encrypted, keySecret, nOnceMaterial);
  }
  decryptForTransaction(encrypted, keySecret, nOnceMaterial) {
    return this.decrypt(encrypted, keySecret, nOnceMaterial);
  }
  encryptKeySecret(keys) {
    const nOnceMaterial = {
      encryptedID: keys.toEncrypt.id,
      encryptingID: keys.encrypting.id
    };
    return {
      encryptedID: keys.toEncrypt.id,
      encryptingID: keys.encrypting.id,
      encrypted: this.encrypt(keys.toEncrypt.secret, keys.encrypting.secret, nOnceMaterial)
    };
  }
  decryptKeySecret(encryptedInfo, sealingSecret) {
    const nOnceMaterial = {
      encryptedID: encryptedInfo.encryptedID,
      encryptingID: encryptedInfo.encryptingID
    };
    return this.decrypt(encryptedInfo.encrypted, sealingSecret, nOnceMaterial);
  }
  uniquenessForHeader() {
    return `z${base58.encode(this.randomBytes(12))}`;
  }
  createdNowUnique() {
    const createdAt = (/* @__PURE__ */ new Date()).toISOString();
    return {
      createdAt,
      uniqueness: this.uniquenessForHeader()
    };
  }
  newRandomSecretSeed() {
    return this.randomBytes(secretSeedLength);
  }
  agentSecretFromSecretSeed(secretSeed) {
    if (secretSeed.length !== secretSeedLength) {
      throw new Error(`Secret seed needs to be ${secretSeedLength} bytes long`);
    }
    return `sealerSecret_z${base58.encode(this.blake3HashOnceWithContext(secretSeed, {
      context: textEncoder.encode("seal")
    }))}/signerSecret_z${base58.encode(this.blake3HashOnceWithContext(secretSeed, {
      context: textEncoder.encode("sign")
    }))}`;
  }
  newRandomSessionID(accountID) {
    return `${accountID}_session_z${base58.encode(this.randomBytes(8))}`;
  }
};
var StreamingHash = class _StreamingHash {
  constructor(crypto3, fromClone) {
    this.state = fromClone || crypto3.emptyBlake3State();
    this.crypto = crypto3;
  }
  update(value) {
    const encoded = textEncoder.encode(stableStringify(value));
    this.state = this.crypto.blake3IncrementalUpdate(this.state, encoded);
    return encoded;
  }
  digest() {
    const hash = this.crypto.blake3DigestForState(this.state);
    return `hash_z${base58.encode(hash)}`;
  }
  clone() {
    return new _StreamingHash(this.crypto, this.crypto.cloneBlake3State(this.state));
  }
};
var shortHashLength = 19;
var secretSeedLength = 32;

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/ids.js
function rawCoIDtoBytes(id) {
  return base58.decode(id.substring("co_z".length));
}
function rawCoIDfromBytes(bytes) {
  return `co_z${base58.encode(bytes.slice(0, shortHashLength))}`;
}
function isAgentID(id) {
  return typeof id === "string" && id.startsWith("sealer_") && id.includes("/signer_");
}
function isParentGroupReference(key) {
  return key.startsWith("parent_");
}
function getParentGroupId(key) {
  return key.slice("parent_".length);
}
function isChildGroupReference(key) {
  return key.startsWith("child_");
}
function getChildGroupId(key) {
  return key.slice("child_".length);
}
function getGroupDependentKey(key) {
  if (typeof key !== "string")
    return void 0;
  if (isParentGroupReference(key)) {
    return getParentGroupId(key);
  } else if (key.startsWith("co_")) {
    return key;
  }
  return void 0;
}
function getGroupDependentKeyList(keys) {
  const groupDependentKeys = [];
  for (const key of keys) {
    const value = getGroupDependentKey(key);
    if (value) {
      groupDependentKeys.push(value);
    }
  }
  return groupDependentKeys;
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/typeUtils/expectGroup.js
function expectGroup(content) {
  const map = expectMap(content);
  if (map.core.header.ruleset.type !== "group") {
    throw new Error("Expected group ruleset in group");
  }
  if (!(map instanceof RawGroup)) {
    throw new Error("Expected group");
  }
  return map;
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValues/group.js
var EVERYONE = "everyone";
var RawGroup = class extends RawCoMap {
  /**
   * Returns the current role of a given account.
   *
   * @category 1. Role reading
   */
  roleOf(accountID) {
    return this.roleOfInternal(accountID);
  }
  /**
   *  This is a performance-critical function, micro-optimizing it is important
   *
   *  Avoid to add objects/array allocations in this function
   */
  /** @internal */
  roleOfInternal(accountID) {
    let roleHere = this.get(accountID);
    if (roleHere === "revoked") {
      roleHere = void 0;
    }
    let roleInfo = roleHere;
    for (const key of Object.keys(this.ops)) {
      if (!isParentGroupReference(key))
        continue;
      const group = this.getParentGroupFromKey(key, this.atTimeFilter);
      if (!group)
        continue;
      const role = this.get(key) ?? "extend";
      const parentRole = group.roleOfInternal(accountID);
      if (!isInheritableRole(parentRole)) {
        continue;
      }
      const roleToInherit = role !== "extend" ? role : parentRole;
      if (isMorePermissiveAndShouldInherit(roleToInherit, roleInfo)) {
        roleInfo = roleToInherit;
      }
    }
    if (!roleInfo && accountID !== "everyone") {
      const everyoneRole = this.get("everyone");
      if (everyoneRole && everyoneRole !== "revoked")
        return everyoneRole;
    }
    return roleInfo;
  }
  getParentGroupFromKey(key, atTime) {
    if (this.get(key) === "revoked") {
      return null;
    }
    const parent = this.core.node.expectCoValueLoaded(getParentGroupId(key), "Expected parent group to be loaded");
    const group = expectGroup(parent.getCurrentContent());
    if (atTime) {
      return group.atTime(atTime);
    } else {
      return group;
    }
  }
  getParentGroups(atTime) {
    const groups = [];
    for (const key of Object.keys(this.ops)) {
      if (!isParentGroupReference(key))
        continue;
      const group = this.getParentGroupFromKey(key, atTime);
      if (group) {
        if (atTime) {
          groups.push(group.atTime(atTime));
        } else {
          groups.push(group);
        }
      }
    }
    return groups;
  }
  loadAllChildGroups() {
    const requests = [];
    const store = this.core.node.coValuesStore;
    const peers = this.core.node.syncManager.getServerAndStoragePeers();
    for (const key of this.keys()) {
      if (!isChildGroupReference(key)) {
        continue;
      }
      const id = getChildGroupId(key);
      const child = store.get(id);
      if (child.highLevelState === "unknown" || child.highLevelState === "unavailable") {
        child.loadFromPeers(peers).catch(() => {
          logger.error(`Failed to load child group ${id}`);
        });
      }
      requests.push(child.getCoValue().then((coValue) => {
        if (coValue === "unavailable") {
          throw new Error(`Child group ${child.id} is unavailable`);
        }
        return expectGroup(coValue.getCurrentContent()).loadAllChildGroups();
      }));
    }
    return Promise.all(requests);
  }
  getChildGroups() {
    const groups = [];
    for (const key of this.keys()) {
      if (isChildGroupReference(key)) {
        if (this.get(key) === "revoked") {
          continue;
        }
        const child = this.core.node.expectCoValueLoaded(getChildGroupId(key), "Expected child group to be loaded");
        groups.push(expectGroup(child.getCurrentContent()));
      }
    }
    return groups;
  }
  /**
   * Returns the role of the current account in the group.
   *
   * @category 1. Role reading
   */
  myRole() {
    return this.roleOfInternal(this.core.node.account.id);
  }
  /**
   * Directly grants a new member a role in the group. The current account must be an
   * admin to be able to do so. Throws otherwise.
   *
   * @category 2. Role changing
   */
  addMember(account, role) {
    this.addMemberInternal(account, role);
  }
  /** @internal */
  addMemberInternal(account, role) {
    if (account === EVERYONE) {
      if (!(role === "reader" || role === "writer" || role === "writeOnly")) {
        throw new Error("Can't make everyone something other than reader, writer or writeOnly");
      }
      const currentReadKey = this.core.getCurrentReadKey();
      if (!currentReadKey.secret) {
        throw new Error("Can't add member without read key secret");
      }
      const previousRole = this.get(account);
      this.set(account, role, "trusting");
      if (this.get(account) !== role) {
        throw new Error("Failed to set role");
      }
      if (role === "writeOnly") {
        if (previousRole === "reader" || previousRole === "writer") {
          this.rotateReadKey();
        }
        this.delete(`${currentReadKey.id}_for_${EVERYONE}`);
      } else {
        this.set(`${currentReadKey.id}_for_${EVERYONE}`, currentReadKey.secret, "trusting");
      }
      return;
    }
    const memberKey = typeof account === "string" ? account : account.id;
    const agent = typeof account === "string" ? account : account.currentAgentID();
    if (role === "writeOnly" || role === "writeOnlyInvite") {
      const previousRole = this.get(memberKey);
      if (previousRole === "reader" || previousRole === "writer" || previousRole === "admin") {
        this.rotateReadKey();
      }
      this.set(memberKey, role, "trusting");
      this.internalCreateWriteOnlyKeyForMember(memberKey, agent);
    } else {
      const currentReadKey = this.core.getCurrentReadKey();
      if (!currentReadKey.secret) {
        throw new Error("Can't add member without read key secret");
      }
      this.set(memberKey, role, "trusting");
      if (this.get(memberKey) !== role) {
        throw new Error("Failed to set role");
      }
      this.storeKeyRevelationForMember(memberKey, agent, currentReadKey.id, currentReadKey.secret);
      for (const keyID of this.getWriteOnlyKeys()) {
        const secret = this.core.getReadKey(keyID);
        if (!secret) {
          logger.error("Can't find key " + keyID);
          continue;
        }
        this.storeKeyRevelationForMember(memberKey, agent, keyID, secret);
      }
    }
  }
  internalCreateWriteOnlyKeyForMember(memberKey, agent) {
    const writeKeyForNewMember = this.core.crypto.newRandomKeySecret();
    this.set(`writeKeyFor_${memberKey}`, writeKeyForNewMember.id, "trusting");
    this.storeKeyRevelationForMember(memberKey, agent, writeKeyForNewMember.id, writeKeyForNewMember.secret);
    for (const otherMemberKey of this.getMemberKeys()) {
      const memberRole = this.get(otherMemberKey);
      if (memberRole === "reader" || memberRole === "writer" || memberRole === "admin" || memberRole === "readerInvite" || memberRole === "writerInvite" || memberRole === "adminInvite") {
        const otherMemberAgent = this.core.node.resolveAccountAgent(otherMemberKey, "Expected member agent to be loaded")._unsafeUnwrap({ withStackTrace: true });
        this.storeKeyRevelationForMember(otherMemberKey, otherMemberAgent, writeKeyForNewMember.id, writeKeyForNewMember.secret);
      }
    }
  }
  storeKeyRevelationForMember(memberKey, agent, keyID, secret) {
    this.set(`${keyID}_for_${memberKey}`, this.core.crypto.seal({
      message: secret,
      from: this.core.node.account.currentSealerSecret(),
      to: this.core.crypto.getAgentSealerID(agent),
      nOnceMaterial: {
        in: this.id,
        tx: this.core.nextTransactionID()
      }
    }), "trusting");
  }
  getWriteOnlyKeys() {
    const keys = [];
    for (const key of this.keys()) {
      if (key.startsWith("writeKeyFor_")) {
        keys.push(this.get(key));
      }
    }
    return keys;
  }
  getCurrentReadKeyId() {
    if (this.myRole() === "writeOnly") {
      const accountId = this.core.node.account.id;
      const key = this.get(`writeKeyFor_${accountId}`);
      if (!key && this.get("everyone") === "writeOnly") {
        this.internalCreateWriteOnlyKeyForMember(accountId, this.core.node.account.currentAgentID());
        return this.get(`writeKeyFor_${accountId}`);
      }
      return key;
    }
    return this.get("readKey");
  }
  getMemberKeys() {
    return this.keys().filter((key) => {
      return key.startsWith("co_") || isAgentID(key);
    });
  }
  getAllMemberKeysSet() {
    const memberKeys = new Set(this.getMemberKeys());
    for (const group of this.getParentGroups()) {
      for (const key of group.getAllMemberKeysSet()) {
        memberKeys.add(key);
      }
    }
    return memberKeys;
  }
  /** @internal */
  rotateReadKey(removedMemberKey) {
    const memberKeys = this.getMemberKeys().filter((key) => key !== removedMemberKey);
    const currentlyPermittedReaders = memberKeys.filter((key) => {
      const role = this.get(key);
      return role === "admin" || role === "writer" || role === "reader" || role === "adminInvite" || role === "writerInvite" || role === "readerInvite";
    });
    const writeOnlyMembers = memberKeys.filter((key) => {
      const role = this.get(key);
      return role === "writeOnly" || role === "writeOnlyInvite";
    });
    const parentGroups = this.getParentGroups();
    const childGroups = this.getChildGroups();
    const maybeCurrentReadKey = this.core.getCurrentReadKey();
    if (!maybeCurrentReadKey.secret) {
      throw new Error("Can't rotate read key secret we don't have access to");
    }
    const currentReadKey = {
      id: maybeCurrentReadKey.id,
      secret: maybeCurrentReadKey.secret
    };
    const newReadKey = this.core.crypto.newRandomKeySecret();
    for (const readerID of currentlyPermittedReaders) {
      const agent = this.core.node.resolveAccountAgent(readerID, "Expected to know currently permitted reader")._unsafeUnwrap({ withStackTrace: true });
      this.storeKeyRevelationForMember(readerID, agent, newReadKey.id, newReadKey.secret);
    }
    for (const writeOnlyMemberID of writeOnlyMembers) {
      const agent = this.core.node.resolveAccountAgent(writeOnlyMemberID, "Expected to know writeOnly member")._unsafeUnwrap({ withStackTrace: true });
      const writeOnlyKey = this.core.crypto.newRandomKeySecret();
      this.storeKeyRevelationForMember(writeOnlyMemberID, agent, writeOnlyKey.id, writeOnlyKey.secret);
      this.set(`writeKeyFor_${writeOnlyMemberID}`, writeOnlyKey.id, "trusting");
      for (const readerID of currentlyPermittedReaders) {
        const agent2 = this.core.node.resolveAccountAgent(readerID, "Expected to know currently permitted reader")._unsafeUnwrap({ withStackTrace: true });
        this.storeKeyRevelationForMember(readerID, agent2, writeOnlyKey.id, writeOnlyKey.secret);
      }
    }
    this.set(`${currentReadKey.id}_for_${newReadKey.id}`, this.core.crypto.encryptKeySecret({
      encrypting: newReadKey,
      toEncrypt: currentReadKey
    }).encrypted, "trusting");
    this.set("readKey", newReadKey.id, "trusting");
    for (const parent of parentGroups) {
      const { id: parentReadKeyID, secret: parentReadKeySecret } = parent.core.getCurrentReadKey();
      if (!parentReadKeySecret) {
        throw new Error("Can't reveal new child key to parent where we don't have access to the parent read key");
      }
      this.set(`${newReadKey.id}_for_${parentReadKeyID}`, this.core.crypto.encryptKeySecret({
        encrypting: {
          id: parentReadKeyID,
          secret: parentReadKeySecret
        },
        toEncrypt: newReadKey
      }).encrypted, "trusting");
    }
    for (const child of childGroups) {
      if (child.isSelfExtension(this)) {
        continue;
      }
      child.rotateReadKey(removedMemberKey);
    }
  }
  /** Detect circular references in group inheritance */
  isSelfExtension(parent) {
    if (parent.id === this.id) {
      return true;
    }
    const childGroups = this.getChildGroups();
    for (const child of childGroups) {
      if (child.isSelfExtension(parent)) {
        return true;
      }
    }
    return false;
  }
  extend(parent, role = "inherit") {
    if (this.isSelfExtension(parent)) {
      return;
    }
    if (this.myRole() !== "admin") {
      throw new Error("To extend a group, the current account must be an admin in the child group");
    }
    if (parent.myRole() !== "admin" && parent.myRole() !== "writer" && parent.myRole() !== "reader" && parent.myRole() !== "writeOnly") {
      throw new Error("To extend a group, the current account must be a member of the parent group");
    }
    const value = role === "inherit" ? "extend" : role;
    this.set(`parent_${parent.id}`, value, "trusting");
    parent.set(`child_${this.id}`, "extend", "trusting");
    const { id: parentReadKeyID, secret: parentReadKeySecret } = parent.core.getCurrentReadKey();
    if (!parentReadKeySecret) {
      throw new Error("Can't extend group without parent read key secret");
    }
    const { id: childReadKeyID, secret: childReadKeySecret } = this.core.getCurrentReadKey();
    if (!childReadKeySecret) {
      throw new Error("Can't extend group without child read key secret");
    }
    this.set(`${childReadKeyID}_for_${parentReadKeyID}`, this.core.crypto.encryptKeySecret({
      encrypting: {
        id: parentReadKeyID,
        secret: parentReadKeySecret
      },
      toEncrypt: {
        id: childReadKeyID,
        secret: childReadKeySecret
      }
    }).encrypted, "trusting");
  }
  async revokeExtend(parent) {
    if (this.myRole() !== "admin") {
      throw new Error("To unextend a group, the current account must be an admin in the child group");
    }
    if (parent.myRole() !== "admin" && parent.myRole() !== "writer" && parent.myRole() !== "reader" && parent.myRole() !== "writeOnly") {
      throw new Error("To unextend a group, the current account must be a member of the parent group");
    }
    if (!this.get(`parent_${parent.id}`) || this.get(`parent_${parent.id}`) === "revoked") {
      return;
    }
    this.set(`parent_${parent.id}`, "revoked", "trusting");
    parent.set(`child_${this.id}`, "revoked", "trusting");
    await this.loadAllChildGroups();
    this.rotateReadKey();
  }
  /**
   * Strips the specified member of all roles (preventing future writes in
   *  the group and owned values) and rotates the read encryption key for that group
   * (preventing reads of new content in the group and owned values)
   *
   * @category 2. Role changing
   */
  async removeMember(account) {
    await this.loadAllChildGroups();
    this.removeMemberInternal(account);
  }
  /** @internal */
  removeMemberInternal(account) {
    const memberKey = typeof account === "string" ? account : account.id;
    this.rotateReadKey(memberKey);
    this.set(memberKey, "revoked", "trusting");
  }
  /**
   * Creates an invite for new members to indirectly join the group,
   * allowing them to grant themselves the specified role with the InviteSecret
   * (a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.
   *
   * @category 2. Role changing
   */
  createInvite(role) {
    const secretSeed = this.core.crypto.newRandomSecretSeed();
    const inviteSecret = this.core.crypto.agentSecretFromSecretSeed(secretSeed);
    const inviteID = this.core.crypto.getAgentID(inviteSecret);
    this.addMemberInternal(inviteID, `${role}Invite`);
    return inviteSecretFromSecretSeed(secretSeed);
  }
  /**
   * Creates a new `CoMap` within this group, with the specified specialized
   * `CoMap` type `M` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createMap(init, meta, initPrivacy = "private", uniqueness = this.core.crypto.createdNowUnique()) {
    const map = this.core.node.createCoValue({
      type: "comap",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: meta || null,
      ...uniqueness
    }).getCurrentContent();
    if (init) {
      map.assign(init, initPrivacy);
    }
    return map;
  }
  /**
   * Creates a new `CoList` within this group, with the specified specialized
   * `CoList` type `L` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createList(init, meta, initPrivacy = "private", uniqueness = this.core.crypto.createdNowUnique()) {
    const list = this.core.node.createCoValue({
      type: "colist",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: meta || null,
      ...uniqueness
    }).getCurrentContent();
    if (init == null ? void 0 : init.length) {
      list.appendItems(init, void 0, initPrivacy);
    }
    return list;
  }
  /**
   * Creates a new `CoPlainText` within this group, with the specified specialized
   * `CoPlainText` type `T` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createPlainText(init, meta, initPrivacy = "private") {
    const text = this.core.node.createCoValue({
      type: "coplaintext",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: meta || null,
      ...this.core.crypto.createdNowUnique()
    }).getCurrentContent();
    if (init) {
      text.insertAfter(0, init, initPrivacy);
    }
    return text;
  }
  /** @category 3. Value creation */
  createStream(meta, uniqueness = this.core.crypto.createdNowUnique()) {
    return this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: meta || null,
      ...uniqueness
    }).getCurrentContent();
  }
  /** @category 3. Value creation */
  createBinaryStream(meta = { type: "binary" }, uniqueness = this.core.crypto.createdNowUnique()) {
    return this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta,
      ...uniqueness
    }).getCurrentContent();
  }
};
function isInheritableRole(roleInParent) {
  return roleInParent === "revoked" || roleInParent === "admin" || roleInParent === "writer" || roleInParent === "reader";
}
function isMorePermissiveAndShouldInherit(roleInParent, roleInChild) {
  if (roleInParent === "revoked") {
    return true;
  }
  if (roleInParent === "admin") {
    return !roleInChild || roleInChild !== "admin";
  }
  if (roleInParent === "writer") {
    return !roleInChild || roleInChild === "reader" || roleInChild === "writeOnly";
  }
  if (roleInParent === "reader") {
    return !roleInChild;
  }
  if (roleInParent === "writeOnly") {
    return false;
  }
  return false;
}
function inviteSecretFromSecretSeed(secretSeed) {
  return `inviteSecret_z${base58.encode(secretSeed)}`;
}
function secretSeedFromInviteSecret(inviteSecret) {
  if (!inviteSecret.startsWith("inviteSecret_z")) {
    throw new Error("Invalid invite secret");
  }
  return base58.decode(inviteSecret.slice("inviteSecret_z".length));
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValues/account.js
function accountHeaderForInitialAgentSecret(agentSecret, crypto3) {
  const agent = crypto3.getAgentID(agentSecret);
  return {
    type: "comap",
    ruleset: { type: "group", initialAdmin: agent },
    meta: {
      type: "account"
    },
    createdAt: null,
    uniqueness: null
  };
}
var RawAccount = class extends RawGroup {
  currentAgentID() {
    if (this._cachedCurrentAgentID) {
      return this._cachedCurrentAgentID;
    }
    const agents = this.keys().filter((k) => k.startsWith("sealer_")).sort((a2, b) => {
      var _a2, _b2;
      return (((_a2 = this.lastEditAt(a2)) == null ? void 0 : _a2.at.getTime()) || 0) - (((_b2 = this.lastEditAt(b)) == null ? void 0 : _b2.at.getTime()) || 0);
    });
    if (agents.length !== 1) {
      logger.warn("Account has " + agents.length + " agents", { id: this.id });
    }
    this._cachedCurrentAgentID = agents[0];
    return agents[0];
  }
  createInvite(_2) {
    throw new Error("Cannot create invite from an account");
  }
};
var RawControlledAccount = class extends RawAccount {
  constructor(core, agentSecret) {
    super(core);
    this.agentSecret = agentSecret;
    this.crypto = core.node.crypto;
  }
  /**
   * Creates a new group (with the current account as the group's first admin).
   * @category 1. High-level
   */
  createGroup(uniqueness = this.core.crypto.createdNowUnique()) {
    return this.core.node.createGroup(uniqueness);
  }
  async acceptInvite(groupOrOwnedValueID, inviteSecret) {
    return this.core.node.acceptInvite(groupOrOwnedValueID, inviteSecret);
  }
  currentAgentID() {
    if (this._cachedCurrentAgentID) {
      return this._cachedCurrentAgentID;
    }
    const agentID = this.crypto.getAgentID(this.agentSecret);
    this._cachedCurrentAgentID = agentID;
    return agentID;
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
};
var ControlledAgent = class {
  constructor(agentSecret, crypto3) {
    this.agentSecret = agentSecret;
    this.crypto = crypto3;
  }
  get id() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentAgentID() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValues/coPlainText.js
function stringifyOpID(opID) {
  return `${opID.sessionID}:${opID.txIndex}:${opID.changeIdx}`;
}
var RawCoPlainText = class extends RawCoList {
  constructor(core) {
    super(core);
    this.type = "coplaintext";
    this._cachedMapping = /* @__PURE__ */ new WeakMap();
    if (!Intl.Segmenter) {
      throw new Error("Intl.Segmenter is not supported. Use a polyfill to get coPlainText support in Jazz. (eg. https://formatjs.github.io/docs/polyfills/intl-segmenter/)");
    }
    const effectiveLocale = (core.header.meta && typeof core.header.meta === "object" && "locale" in core.header.meta ? core.header.meta.locale : void 0) || (typeof navigator !== "undefined" ? navigator.language : "en");
    this._segmenter = new Intl.Segmenter(effectiveLocale, {
      granularity: "grapheme"
    });
  }
  get mapping() {
    const entries = this.entries();
    let mapping = this._cachedMapping.get(entries);
    if (mapping) {
      return mapping;
    }
    mapping = {
      opIDbeforeIdx: [],
      opIDafterIdx: [],
      idxAfterOpID: {},
      idxBeforeOpID: {}
    };
    let idxBefore = 0;
    for (const entry of entries) {
      const idxAfter = idxBefore + entry.value.length;
      mapping.opIDafterIdx[idxBefore] = entry.opID;
      mapping.opIDbeforeIdx[idxAfter] = entry.opID;
      mapping.idxAfterOpID[stringifyOpID(entry.opID)] = idxAfter;
      mapping.idxBeforeOpID[stringifyOpID(entry.opID)] = idxBefore;
      idxBefore = idxAfter;
    }
    this._cachedMapping.set(entries, mapping);
    return mapping;
  }
  toString() {
    return this.entries().map((entry) => entry.value).join("");
  }
  /**
   * Inserts `text` before the character at index `idx`.
   * If idx is 0, inserts at the start of the text.
   *
   * @param idx - The index of the character to insert before
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertBefore(idx, text, privacy = "private") {
    const graphemes = [...this._segmenter.segment(text)].map((g2) => g2.segment);
    if (idx === 0) {
      for (const grapheme of graphemes.reverse()) {
        this.prepend(grapheme, 0, privacy);
      }
    } else {
      this.appendItems(graphemes, idx - 1, privacy);
    }
  }
  /**
   * Inserts `text` after the character at index `idx`.
   *
   * @param idx - The index of the character to insert after
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertAfter(idx, text, privacy = "private") {
    const graphemes = [...this._segmenter.segment(text)].map((g2) => g2.segment);
    this.appendItems(graphemes, idx, privacy);
  }
  deleteRange({ from, to }, privacy = "private") {
    const ops = [];
    for (let idx = from; idx < to; ) {
      const insertion = this.mapping.opIDafterIdx[idx];
      if (!insertion) {
        throw new Error("Invalid idx to delete " + idx);
      }
      ops.push({
        op: "del",
        insertion
      });
      let nextIdx = idx + 1;
      while (!this.mapping.opIDbeforeIdx[nextIdx] && nextIdx < to) {
        nextIdx++;
      }
      idx = nextIdx;
    }
    this.core.makeTransaction(ops, privacy);
    this.processNewTransactions();
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coreToCoValue.js
function coreToCoValue(core, options) {
  var _a2;
  if (core.header.type === "comap") {
    if (core.header.ruleset.type === "group") {
      if (((_a2 = core.header.meta) == null ? void 0 : _a2.type) === "account" && !(options == null ? void 0 : options.ignorePrivateTransactions)) {
        if (core.id === core.node.account.id) {
          return new RawControlledAccount(core, core.node.account.agentSecret);
        } else {
          return new RawAccount(core);
        }
      } else {
        return new RawGroup(core, options);
      }
    } else {
      return new RawCoMap(core);
    }
  } else if (core.header.type === "coplaintext") {
    return new RawCoPlainText(core);
  } else if (core.header.type === "colist") {
    return new RawCoList(core);
  } else if (core.header.type === "costream") {
    if (core.header.meta && core.header.meta.type === "binary") {
      return new RawBinaryCoStream(core);
    } else {
      return new RawCoStream(core);
    }
  } else {
    return new RawUnknownCoValue(core);
  }
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/permissions.js
var logPermissionErrors = true;
function disablePermissionErrors() {
  logPermissionErrors = false;
}
function logPermissionError(message, attributes) {
  if (logPermissionErrors === false) {
    return;
  }
  logger.debug("Permission error: " + message, attributes);
}
function determineValidTransactions(coValue, knownTransactions) {
  if (coValue.header.ruleset.type === "group") {
    const initialAdmin = coValue.header.ruleset.initialAdmin;
    if (!initialAdmin) {
      throw new Error("Group must have initialAdmin");
    }
    return determineValidTransactionsForGroup(coValue, initialAdmin).validTransactions;
  } else if (coValue.header.ruleset.type === "ownedByGroup") {
    const groupContent = expectGroup(coValue.node.expectCoValueLoaded(coValue.header.ruleset.group, "Determining valid transaction in owned object but its group wasn't loaded").getCurrentContent());
    if (groupContent.type !== "comap") {
      throw new Error("Group must be a map");
    }
    const validTransactions = [];
    for (const [sessionID, sessionLog] of coValue.sessionLogs.entries()) {
      const transactor = accountOrAgentIDfromSessionID(sessionID);
      const knownTransactionsForSession = (knownTransactions == null ? void 0 : knownTransactions[sessionID]) ?? -1;
      sessionLog.transactions.forEach((tx, txIndex) => {
        if (knownTransactionsForSession >= txIndex) {
          return;
        }
        const groupAtTime = groupContent.atTime(tx.madeAt);
        const effectiveTransactor = agentInAccountOrMemberInGroup(transactor, groupAtTime);
        if (!effectiveTransactor) {
          return;
        }
        const transactorRoleAtTxTime = groupAtTime.roleOfInternal(effectiveTransactor);
        if (transactorRoleAtTxTime !== "admin" && transactorRoleAtTxTime !== "writer" && transactorRoleAtTxTime !== "writeOnly") {
          return;
        }
        validTransactions.push({ txID: { sessionID, txIndex }, tx });
      });
    }
    return validTransactions;
  } else if (coValue.header.ruleset.type === "unsafeAllowAll") {
    const validTransactions = [];
    for (const [sessionID, sessionLog] of coValue.sessionLogs.entries()) {
      const knownTransactionsForSession = (knownTransactions == null ? void 0 : knownTransactions[sessionID]) ?? -1;
      sessionLog.transactions.forEach((tx, txIndex) => {
        if (knownTransactionsForSession >= txIndex) {
          return;
        }
        validTransactions.push({ txID: { sessionID, txIndex }, tx });
      });
    }
    return validTransactions;
  } else {
    throw new Error("Unknown ruleset type " + coValue.header.ruleset.type);
  }
}
function isHigherRole(a2, b) {
  if (a2 === void 0 || a2 === "revoked")
    return false;
  if (b === void 0 || b === "revoked")
    return true;
  if (b === "admin")
    return false;
  if (a2 === "admin")
    return true;
  return a2 === "writer" && b === "reader";
}
function resolveMemberStateFromParentReference(coValue, memberState, parentReference, roleMapping, extendChain) {
  const parentGroup = coValue.node.expectCoValueLoaded(getParentGroupId(parentReference), "Expected parent group to be loaded");
  if (parentGroup.header.ruleset.type !== "group") {
    return;
  }
  if (extendChain.has(parentGroup.id)) {
    return;
  }
  const initialAdmin = parentGroup.header.ruleset.initialAdmin;
  if (!initialAdmin) {
    throw new Error("Group must have initialAdmin");
  }
  extendChain.add(parentGroup.id);
  const { memberState: parentGroupMemberState } = determineValidTransactionsForGroup(parentGroup, initialAdmin, extendChain);
  for (const agent of Object.keys(parentGroupMemberState)) {
    const parentRole = parentGroupMemberState[agent];
    const currentRole = memberState[agent];
    if (isInheritableRole(parentRole)) {
      if (roleMapping !== "extend" && isHigherRole(roleMapping, currentRole)) {
        memberState[agent] = roleMapping;
      } else if (isHigherRole(parentRole, currentRole)) {
        memberState[agent] = parentRole;
      }
    }
  }
}
function determineValidTransactionsForGroup(coValue, initialAdmin, extendChain) {
  const allTransactionsSorted = [];
  for (const [sessionID, sessionLog] of coValue.sessionLogs.entries()) {
    sessionLog.transactions.forEach((tx, txIndex) => {
      allTransactionsSorted.push({ sessionID, txIndex, tx });
    });
  }
  allTransactionsSorted.sort((a2, b) => {
    return a2.tx.madeAt - b.tx.madeAt;
  });
  const memberState = {};
  const writeOnlyKeys = {};
  const validTransactions = [];
  const keyRevelations = /* @__PURE__ */ new Set();
  const writeKeys = /* @__PURE__ */ new Set();
  for (const { sessionID, txIndex, tx } of allTransactionsSorted) {
    const transactor = accountOrAgentIDfromSessionID(sessionID);
    if (tx.privacy === "private") {
      if (memberState[transactor] === "admin") {
        validTransactions.push({
          txID: { sessionID, txIndex },
          tx
        });
        continue;
      } else {
        logPermissionError("Only admins can make private transactions in groups");
        continue;
      }
    }
    let changes;
    try {
      changes = parseJSON(tx.changes);
    } catch (e2) {
      logPermissionError("Invalid JSON in transaction", {
        id: coValue.id,
        tx
      });
      continue;
    }
    const change = changes[0];
    if (changes.length !== 1) {
      logPermissionError("Group transaction must have exactly one change");
      continue;
    }
    if (change.op !== "set") {
      logPermissionError("Group transaction must set a role or readKey");
      continue;
    }
    if (change.key === "readKey") {
      if (memberState[transactor] !== "admin") {
        logPermissionError("Only admins can set readKeys");
        continue;
      }
      validTransactions.push({ txID: { sessionID, txIndex }, tx });
      continue;
    } else if (change.key === "profile") {
      if (memberState[transactor] !== "admin") {
        logPermissionError("Only admins can set profile");
        continue;
      }
      validTransactions.push({ txID: { sessionID, txIndex }, tx });
      continue;
    } else if (isKeyForKeyField(change.key) || isKeyForAccountField(change.key)) {
      if (memberState[transactor] !== "admin" && memberState[transactor] !== "adminInvite" && memberState[transactor] !== "writerInvite" && memberState[transactor] !== "readerInvite" && memberState[transactor] !== "writeOnlyInvite" && !isOwnWriteKeyRevelation(change.key, transactor, writeOnlyKeys)) {
        logPermissionError("Only admins can reveal keys");
        continue;
      }
      if (keyRevelations.has(change.key) && memberState[transactor] !== "admin") {
        logPermissionError("Key revelation already exists and can't be overridden by invite");
        continue;
      }
      keyRevelations.add(change.key);
      validTransactions.push({ txID: { sessionID, txIndex }, tx });
      continue;
    } else if (isParentExtension(change.key)) {
      if (memberState[transactor] !== "admin") {
        logPermissionError("Only admins can set parent extensions");
        continue;
      }
      extendChain = extendChain ?? /* @__PURE__ */ new Set([]);
      resolveMemberStateFromParentReference(coValue, memberState, change.key, change.value, extendChain);
      if (extendChain.has(coValue.id)) {
        logPermissionError("Circular extend detected, dropping the transaction");
        continue;
      }
      validTransactions.push({ txID: { sessionID, txIndex }, tx });
      continue;
    } else if (isChildExtension(change.key)) {
      if (memberState[transactor] !== "admin" && memberState[transactor] !== "writer" && memberState[transactor] !== "reader" && memberState[transactor] !== "writeOnly") {
        logPermissionError("Only admins, writers, readers and writeOnly can set child extensions");
        continue;
      }
      validTransactions.push({ txID: { sessionID, txIndex }, tx });
      continue;
    } else if (isWriteKeyForMember(change.key)) {
      const memberKey = getAccountOrAgentFromWriteKeyForMember(change.key);
      if (memberState[transactor] !== "admin" && memberState[transactor] !== "writeOnlyInvite" && memberKey !== transactor) {
        logPermissionError("Only admins can set writeKeys");
        continue;
      }
      writeOnlyKeys[memberKey] = change.value;
      if (writeKeys.has(change.key) && memberState[transactor] !== "admin") {
        logPermissionError("Write key already exists and can't be overridden by invite");
        continue;
      }
      writeKeys.add(change.key);
      validTransactions.push({ txID: { sessionID, txIndex }, tx });
      continue;
    }
    const affectedMember = change.key;
    const assignedRole = change.value;
    if (change.value !== "admin" && change.value !== "writer" && change.value !== "reader" && change.value !== "writeOnly" && change.value !== "revoked" && change.value !== "adminInvite" && change.value !== "writerInvite" && change.value !== "readerInvite" && change.value !== "writeOnlyInvite") {
      logPermissionError("Group transaction must set a valid role");
      continue;
    }
    if (affectedMember === EVERYONE && !(change.value === "reader" || change.value === "writer" || change.value === "writeOnly" || change.value === "revoked")) {
      logPermissionError("Everyone can only be set to reader, writer, writeOnly or revoked");
      continue;
    }
    const isFirstSelfAppointment = !memberState[transactor] && transactor === initialAdmin && change.op === "set" && change.key === transactor && change.value === "admin";
    if (!isFirstSelfAppointment) {
      if (memberState[transactor] === "admin") {
        if (memberState[affectedMember] === "admin" && affectedMember !== transactor && assignedRole !== "admin") {
          logPermissionError("Admins can only demote themselves.");
          continue;
        }
      } else if (memberState[transactor] === "adminInvite") {
        if (change.value !== "admin") {
          logPermissionError("AdminInvites can only create admins.");
          continue;
        }
      } else if (memberState[transactor] === "writerInvite") {
        if (change.value !== "writer") {
          logPermissionError("WriterInvites can only create writers.");
          continue;
        }
      } else if (memberState[transactor] === "readerInvite") {
        if (change.value !== "reader") {
          logPermissionError("ReaderInvites can only create reader.");
          continue;
        }
      } else if (memberState[transactor] === "writeOnlyInvite") {
        if (change.value !== "writeOnly") {
          logPermissionError("WriteOnlyInvites can only create writeOnly.");
          continue;
        }
      } else {
        logPermissionError("Group transaction must be made by current admin or invite");
        continue;
      }
    }
    memberState[affectedMember] = change.value;
    validTransactions.push({ txID: { sessionID, txIndex }, tx });
  }
  return { validTransactions, memberState };
}
function agentInAccountOrMemberInGroup(transactor, groupAtTime) {
  if (transactor === groupAtTime.id && groupAtTime instanceof RawAccount) {
    return groupAtTime.currentAgentID();
  }
  return transactor;
}
function isWriteKeyForMember(co2) {
  return co2.startsWith("writeKeyFor_");
}
function getAccountOrAgentFromWriteKeyForMember(co2) {
  return co2.slice("writeKeyFor_".length);
}
function isKeyForKeyField(co2) {
  return co2.startsWith("key_") && co2.includes("_for_key");
}
function isKeyForAccountField(co2) {
  return co2.startsWith("key_") && (co2.includes("_for_sealer") || co2.includes("_for_co")) || co2.includes("_for_everyone");
}
function isParentExtension(key) {
  return key.startsWith("parent_");
}
function isChildExtension(key) {
  return key.startsWith("child_");
}
function isOwnWriteKeyRevelation(key, memberKey, writeOnlyKeys) {
  if (Object.keys(writeOnlyKeys).length === 0) {
    return false;
  }
  const keyID = key.slice(0, key.indexOf("_for_"));
  return writeOnlyKeys[memberKey] === keyID;
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/priority.js
var CO_VALUE_PRIORITY = {
  HIGH: 0,
  MEDIUM: 3,
  LOW: 6
};
function getPriorityFromHeader(header) {
  var _a2, _b2;
  if (typeof header === "boolean" || !header) {
    return CO_VALUE_PRIORITY.MEDIUM;
  }
  if (((_a2 = header.meta) == null ? void 0 : _a2.type) === "account") {
    return CO_VALUE_PRIORITY.HIGH;
  }
  if (header.ruleset.type === "group") {
    return CO_VALUE_PRIORITY.HIGH;
  }
  if (header.type === "costream" && ((_b2 = header.meta) == null ? void 0 : _b2.type) === "binary") {
    return CO_VALUE_PRIORITY.LOW;
  }
  return CO_VALUE_PRIORITY.MEDIUM;
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValueCore.js
var MAX_RECOMMENDED_TX_SIZE = 100 * 1024;
function idforHeader(header, crypto3) {
  const hash = crypto3.shortHash(header);
  return `co_z${hash.slice("shortHash_z".length)}`;
}
var readKeyCache = /* @__PURE__ */ new WeakMap();
var CoValueCore = class {
  constructor(header, node, internalInitSessions = /* @__PURE__ */ new Map()) {
    this.listeners = /* @__PURE__ */ new Set();
    this._decryptionCache = {};
    this.deferredUpdates = 0;
    this.crypto = node.crypto;
    this.id = idforHeader(header, node.crypto);
    this.header = header;
    this._sessionLogs = internalInitSessions;
    this.node = node;
  }
  subscribeToGroupInvalidation() {
    if (this.groupInvalidationSubscription) {
      return;
    }
    const header = this.header;
    if (header.ruleset.type == "ownedByGroup") {
      const groupId = header.ruleset.group;
      const entry = this.node.coValuesStore.get(groupId);
      if (entry.isAvailable()) {
        this.groupInvalidationSubscription = entry.core.subscribe((_groupUpdate) => {
          this._cachedContent = void 0;
          this.notifyUpdate("immediate");
        }, false);
      } else {
        logger.error("CoValueCore: Owner group not available", {
          id: this.id,
          groupId
        });
      }
    }
  }
  get sessionLogs() {
    return this._sessionLogs;
  }
  testWithDifferentAccount(account, currentSessionID) {
    const newNode = this.node.testWithDifferentAccount(account, currentSessionID);
    return newNode.expectCoValueLoaded(this.id);
  }
  knownState() {
    if (this._cachedKnownState) {
      return this._cachedKnownState;
    } else {
      const knownState = this.knownStateUncached();
      this._cachedKnownState = knownState;
      return knownState;
    }
  }
  /** @internal */
  knownStateUncached() {
    const sessions = {};
    for (const [sessionID, sessionLog] of this.sessionLogs.entries()) {
      sessions[sessionID] = sessionLog.transactions.length;
    }
    return {
      id: this.id,
      header: true,
      sessions
    };
  }
  get meta() {
    var _a2;
    return ((_a2 = this.header) == null ? void 0 : _a2.meta) ?? null;
  }
  nextTransactionID() {
    var _a2, _b2;
    const sessionID = ((_a2 = this.header.meta) == null ? void 0 : _a2.type) === "account" ? this.node.currentSessionID.replace(this.node.account.id, this.node.account.currentAgentID()) : this.node.currentSessionID;
    return {
      sessionID,
      txIndex: ((_b2 = this.sessionLogs.get(sessionID)) == null ? void 0 : _b2.transactions.length) || 0
    };
  }
  tryAddTransactions(sessionID, newTransactions, givenExpectedNewHash, newSignature, skipVerify = false, givenNewStreamingHash) {
    return this.node.resolveAccountAgent(accountOrAgentIDfromSessionID(sessionID), "Expected to know signer of transaction").andThen((agent) => {
      const signerID = this.crypto.getAgentSignerID(agent);
      if (skipVerify === true && givenNewStreamingHash && givenExpectedNewHash) {
        this.doAddTransactions(sessionID, newTransactions, newSignature, givenExpectedNewHash, givenNewStreamingHash, "immediate");
      } else {
        const { expectedNewHash, newStreamingHash } = this.expectedNewHashAfter(sessionID, newTransactions);
        if (givenExpectedNewHash && givenExpectedNewHash !== expectedNewHash) {
          return err({
            type: "InvalidHash",
            id: this.id,
            expectedNewHash,
            givenExpectedNewHash
          });
        }
        if (!this.crypto.verify(newSignature, expectedNewHash, signerID)) {
          return err({
            type: "InvalidSignature",
            id: this.id,
            newSignature,
            sessionID,
            signerID
          });
        }
        this.doAddTransactions(sessionID, newTransactions, newSignature, expectedNewHash, newStreamingHash, "immediate");
      }
      return ok(true);
    });
  }
  doAddTransactions(sessionID, newTransactions, newSignature, expectedNewHash, newStreamingHash, notifyMode) {
    var _a2, _b2;
    if (this.node.crashed) {
      throw new Error("Trying to add transactions after node is crashed");
    }
    const transactions = ((_a2 = this.sessionLogs.get(sessionID)) == null ? void 0 : _a2.transactions) ?? [];
    for (const tx of newTransactions) {
      transactions.push(tx);
    }
    const signatureAfter = ((_b2 = this.sessionLogs.get(sessionID)) == null ? void 0 : _b2.signatureAfter) ?? {};
    const lastInbetweenSignatureIdx = Object.keys(signatureAfter).reduce((max, idx) => parseInt(idx) > max ? parseInt(idx) : max, -1);
    const sizeOfTxsSinceLastInbetweenSignature = transactions.slice(lastInbetweenSignatureIdx + 1).reduce((sum, tx) => sum + (tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length), 0);
    if (sizeOfTxsSinceLastInbetweenSignature > MAX_RECOMMENDED_TX_SIZE) {
      signatureAfter[transactions.length - 1] = newSignature;
    }
    this._sessionLogs.set(sessionID, {
      transactions,
      lastHash: expectedNewHash,
      streamingHash: newStreamingHash,
      lastSignature: newSignature,
      signatureAfter
    });
    if (this._cachedContent && "processNewTransactions" in this._cachedContent && typeof this._cachedContent.processNewTransactions === "function") {
      this._cachedContent.processNewTransactions();
    } else {
      this._cachedContent = void 0;
    }
    this._cachedKnownState = void 0;
    this._cachedDependentOn = void 0;
    this._cachedNewContentSinceEmpty = void 0;
    this.notifyUpdate(notifyMode);
  }
  notifyUpdate(notifyMode) {
    if (this.listeners.size === 0) {
      return;
    }
    if (notifyMode === "immediate") {
      const content = this.getCurrentContent();
      for (const listener of this.listeners) {
        try {
          listener(content);
        } catch (e2) {
          logger.error("Error in listener for coValue " + this.id, { err: e2 });
        }
      }
    } else {
      if (!this.nextDeferredNotify) {
        this.nextDeferredNotify = new Promise((resolve) => {
          setTimeout(() => {
            this.nextDeferredNotify = void 0;
            this.deferredUpdates = 0;
            const content = this.getCurrentContent();
            for (const listener of this.listeners) {
              try {
                listener(content);
              } catch (e2) {
                logger.error("Error in listener for coValue " + this.id, {
                  err: e2
                });
              }
            }
            resolve();
          }, 0);
        });
      }
      this.deferredUpdates++;
    }
  }
  subscribe(listener, immediateInvoke = true) {
    this.listeners.add(listener);
    if (immediateInvoke) {
      listener(this.getCurrentContent());
    }
    return () => {
      this.listeners.delete(listener);
    };
  }
  expectedNewHashAfter(sessionID, newTransactions) {
    var _a2;
    const streamingHash = ((_a2 = this.sessionLogs.get(sessionID)) == null ? void 0 : _a2.streamingHash.clone()) ?? new StreamingHash(this.crypto);
    for (const transaction of newTransactions) {
      streamingHash.update(transaction);
    }
    return {
      expectedNewHash: streamingHash.digest(),
      newStreamingHash: streamingHash
    };
  }
  makeTransaction(changes, privacy) {
    var _a2;
    const madeAt = Date.now();
    let transaction;
    if (privacy === "private") {
      const { secret: keySecret, id: keyID } = this.getCurrentReadKey();
      if (!keySecret) {
        throw new Error("Can't make transaction without read key secret");
      }
      const encrypted = this.crypto.encryptForTransaction(changes, keySecret, {
        in: this.id,
        tx: this.nextTransactionID()
      });
      this._decryptionCache[encrypted] = changes;
      transaction = {
        privacy: "private",
        madeAt,
        keyUsed: keyID,
        encryptedChanges: encrypted
      };
    } else {
      transaction = {
        privacy: "trusting",
        madeAt,
        changes: stableStringify(changes)
      };
    }
    const sessionID = ((_a2 = this.header.meta) == null ? void 0 : _a2.type) === "account" ? this.node.currentSessionID.replace(this.node.account.id, this.node.account.currentAgentID()) : this.node.currentSessionID;
    const { expectedNewHash, newStreamingHash } = this.expectedNewHashAfter(sessionID, [transaction]);
    const signature = this.crypto.sign(this.node.account.currentSignerSecret(), expectedNewHash);
    const success = this.tryAddTransactions(sessionID, [transaction], expectedNewHash, signature, true, newStreamingHash)._unsafeUnwrap({ withStackTrace: true });
    if (success) {
      this.node.syncManager.recordTransactionsSize([transaction], "local");
      void this.node.syncManager.requestCoValueSync(this);
    }
    return success;
  }
  getCurrentContent(options) {
    if (!(options == null ? void 0 : options.ignorePrivateTransactions) && this._cachedContent) {
      return this._cachedContent;
    }
    this.subscribeToGroupInvalidation();
    const newContent = coreToCoValue(this, options);
    if (!(options == null ? void 0 : options.ignorePrivateTransactions)) {
      this._cachedContent = newContent;
    }
    return newContent;
  }
  getValidTransactions(options) {
    var _a2;
    const validTransactions = determineValidTransactions(this, options == null ? void 0 : options.knownTransactions);
    const allTransactions = [];
    for (const { txID, tx } of validTransactions) {
      if (((_a2 = options == null ? void 0 : options.knownTransactions) == null ? void 0 : _a2[txID.sessionID]) >= txID.txIndex) {
        continue;
      }
      if (tx.privacy === "trusting") {
        allTransactions.push({
          txID,
          madeAt: tx.madeAt,
          changes: parseJSON(tx.changes)
        });
        continue;
      }
      if (options == null ? void 0 : options.ignorePrivateTransactions) {
        continue;
      }
      const readKey = this.getReadKey(tx.keyUsed);
      if (!readKey) {
        continue;
      }
      let decryptedChanges = this._decryptionCache[tx.encryptedChanges];
      if (!decryptedChanges) {
        const decryptedString = this.crypto.decryptRawForTransaction(tx.encryptedChanges, readKey, {
          in: this.id,
          tx: txID
        });
        decryptedChanges = decryptedString && parseJSON(decryptedString);
        this._decryptionCache[tx.encryptedChanges] = decryptedChanges;
      }
      if (!decryptedChanges) {
        logger.error("Failed to decrypt transaction despite having key", {
          err: new Error("Failed to decrypt transaction despite having key")
        });
        continue;
      }
      allTransactions.push({
        txID,
        madeAt: tx.madeAt,
        changes: decryptedChanges
      });
    }
    return allTransactions;
  }
  getValidSortedTransactions(options) {
    const allTransactions = this.getValidTransactions(options);
    allTransactions.sort(this.compareTransactions);
    return allTransactions;
  }
  compareTransactions(a2, b) {
    return a2.madeAt - b.madeAt || (a2.txID.sessionID === b.txID.sessionID ? 0 : a2.txID.sessionID < b.txID.sessionID ? -1 : 1) || a2.txID.txIndex - b.txID.txIndex;
  }
  getCurrentReadKey() {
    if (this.header.ruleset.type === "group") {
      const content = expectGroup(this.getCurrentContent());
      const currentKeyId = content.getCurrentReadKeyId();
      if (!currentKeyId) {
        throw new Error("No readKey set");
      }
      const secret = this.getReadKey(currentKeyId);
      return {
        secret,
        id: currentKeyId
      };
    } else if (this.header.ruleset.type === "ownedByGroup") {
      return this.node.expectCoValueLoaded(this.header.ruleset.group).getCurrentReadKey();
    } else {
      throw new Error("Only groups or values owned by groups have read secrets");
    }
  }
  getReadKey(keyID) {
    var _a2;
    let key = (_a2 = readKeyCache.get(this)) == null ? void 0 : _a2[keyID];
    if (!key) {
      key = this.getUncachedReadKey(keyID);
      if (key) {
        let cache = readKeyCache.get(this);
        if (!cache) {
          cache = {};
          readKeyCache.set(this, cache);
        }
        cache[keyID] = key;
      }
    }
    return key;
  }
  getUncachedReadKey(keyID) {
    var _a2;
    if (this.header.ruleset.type === "group") {
      const content = expectGroup(this.getCurrentContent({ ignorePrivateTransactions: true }));
      const keyForEveryone = content.get(`${keyID}_for_everyone`);
      if (keyForEveryone)
        return keyForEveryone;
      const lookupAccountOrAgentID = ((_a2 = this.header.meta) == null ? void 0 : _a2.type) === "account" ? this.node.account.currentAgentID() : this.node.account.id;
      const lastReadyKeyEdit = content.lastEditAt(`${keyID}_for_${lookupAccountOrAgentID}`);
      if (lastReadyKeyEdit == null ? void 0 : lastReadyKeyEdit.value) {
        const revealer = lastReadyKeyEdit.by;
        const revealerAgent = this.node.resolveAccountAgent(revealer, "Expected to know revealer")._unsafeUnwrap({ withStackTrace: true });
        const secret = this.crypto.unseal(lastReadyKeyEdit.value, this.node.account.currentSealerSecret(), this.crypto.getAgentSealerID(revealerAgent), {
          in: this.id,
          tx: lastReadyKeyEdit.tx
        });
        if (secret) {
          return secret;
        }
      }
      for (const co2 of content.keys()) {
        if (isKeyForKeyField(co2) && co2.startsWith(keyID)) {
          const encryptingKeyID = co2.split("_for_")[1];
          const encryptingKeySecret = this.getReadKey(encryptingKeyID);
          if (!encryptingKeySecret) {
            continue;
          }
          const encryptedPreviousKey = content.get(co2);
          const secret = this.crypto.decryptKeySecret({
            encryptedID: keyID,
            encryptingID: encryptingKeyID,
            encrypted: encryptedPreviousKey
          }, encryptingKeySecret);
          if (secret) {
            return secret;
          } else {
            logger.warn(`Encrypting ${encryptingKeyID} key didn't decrypt ${keyID}`);
          }
        }
      }
      for (const co2 of content.keys()) {
        if (isParentGroupReference(co2)) {
          const parentGroupID = getParentGroupId(co2);
          const parentGroup = this.node.expectCoValueLoaded(parentGroupID, "Expected parent group to be loaded");
          const parentKeys = this.findValidParentKeys(keyID, content, parentGroup);
          for (const parentKey of parentKeys) {
            const revelationForParentKey = content.get(`${keyID}_for_${parentKey.id}`);
            if (revelationForParentKey) {
              const secret = parentGroup.crypto.decryptKeySecret({
                encryptedID: keyID,
                encryptingID: parentKey.id,
                encrypted: revelationForParentKey
              }, parentKey.secret);
              if (secret) {
                return secret;
              } else {
                logger.warn(`Encrypting parent ${parentKey.id} key didn't decrypt ${keyID}`);
              }
            }
          }
        }
      }
      return void 0;
    } else if (this.header.ruleset.type === "ownedByGroup") {
      return this.node.expectCoValueLoaded(this.header.ruleset.group).getReadKey(keyID);
    } else {
      throw new Error("Only groups or values owned by groups have read secrets");
    }
  }
  findValidParentKeys(keyID, group, parentGroup) {
    const validParentKeys = [];
    for (const co2 of group.keys()) {
      if (isKeyForKeyField(co2) && co2.startsWith(keyID)) {
        const encryptingKeyID = co2.split("_for_")[1];
        const encryptingKeySecret = parentGroup.getReadKey(encryptingKeyID);
        if (!encryptingKeySecret) {
          continue;
        }
        validParentKeys.push({
          id: encryptingKeyID,
          secret: encryptingKeySecret
        });
      }
    }
    return validParentKeys;
  }
  getGroup() {
    if (this.header.ruleset.type !== "ownedByGroup") {
      throw new Error("Only values owned by groups have groups");
    }
    return expectGroup(this.node.expectCoValueLoaded(this.header.ruleset.group).getCurrentContent());
  }
  getTx(txID) {
    var _a2;
    return (_a2 = this.sessionLogs.get(txID.sessionID)) == null ? void 0 : _a2.transactions[txID.txIndex];
  }
  newContentSince(knownState) {
    const isKnownStateEmpty = !(knownState == null ? void 0 : knownState.header) && !(knownState == null ? void 0 : knownState.sessions);
    if (isKnownStateEmpty && this._cachedNewContentSinceEmpty) {
      return this._cachedNewContentSinceEmpty;
    }
    let currentPiece = {
      action: "content",
      id: this.id,
      header: (knownState == null ? void 0 : knownState.header) ? void 0 : this.header,
      priority: getPriorityFromHeader(this.header),
      new: {}
    };
    const pieces = [currentPiece];
    const sentState = {};
    let pieceSize = 0;
    let sessionsTodoAgain = "first";
    while (sessionsTodoAgain === "first" || (sessionsTodoAgain == null ? void 0 : sessionsTodoAgain.size) || 0 > 0) {
      if (sessionsTodoAgain === "first") {
        sessionsTodoAgain = void 0;
      }
      const sessionsTodo = sessionsTodoAgain ?? this.sessionLogs.keys();
      for (const sessionIDKey of sessionsTodo) {
        const sessionID = sessionIDKey;
        const log = this.sessionLogs.get(sessionID);
        const knownStateForSessionID = knownState == null ? void 0 : knownState.sessions[sessionID];
        const sentStateForSessionID = sentState[sessionID];
        const nextKnownSignatureIdx = getNextKnownSignatureIdx(log, knownStateForSessionID, sentStateForSessionID);
        const firstNewTxIdx = sentStateForSessionID ?? knownStateForSessionID ?? 0;
        const afterLastNewTxIdx = nextKnownSignatureIdx === void 0 ? log.transactions.length : nextKnownSignatureIdx + 1;
        const nNewTx = Math.max(0, afterLastNewTxIdx - firstNewTxIdx);
        if (nNewTx === 0) {
          sessionsTodoAgain == null ? void 0 : sessionsTodoAgain.delete(sessionID);
          continue;
        }
        if (afterLastNewTxIdx < log.transactions.length) {
          if (!sessionsTodoAgain) {
            sessionsTodoAgain = /* @__PURE__ */ new Set();
          }
          sessionsTodoAgain.add(sessionID);
        }
        const oldPieceSize = pieceSize;
        for (let txIdx = firstNewTxIdx; txIdx < afterLastNewTxIdx; txIdx++) {
          const tx = log.transactions[txIdx];
          pieceSize += tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length;
        }
        if (pieceSize >= MAX_RECOMMENDED_TX_SIZE) {
          currentPiece = {
            action: "content",
            id: this.id,
            header: void 0,
            new: {},
            priority: getPriorityFromHeader(this.header)
          };
          pieces.push(currentPiece);
          pieceSize = pieceSize - oldPieceSize;
        }
        let sessionEntry = currentPiece.new[sessionID];
        if (!sessionEntry) {
          sessionEntry = {
            after: sentStateForSessionID ?? knownStateForSessionID ?? 0,
            newTransactions: [],
            lastSignature: "WILL_BE_REPLACED"
          };
          currentPiece.new[sessionID] = sessionEntry;
        }
        for (let txIdx = firstNewTxIdx; txIdx < afterLastNewTxIdx; txIdx++) {
          const tx = log.transactions[txIdx];
          sessionEntry.newTransactions.push(tx);
        }
        sessionEntry.lastSignature = nextKnownSignatureIdx === void 0 ? log.lastSignature : log.signatureAfter[nextKnownSignatureIdx];
        sentState[sessionID] = (sentStateForSessionID ?? knownStateForSessionID ?? 0) + nNewTx;
      }
    }
    const piecesWithContent = pieces.filter((piece) => Object.keys(piece.new).length > 0 || piece.header);
    if (piecesWithContent.length === 0) {
      return void 0;
    }
    if (isKnownStateEmpty) {
      this._cachedNewContentSinceEmpty = piecesWithContent;
    }
    return piecesWithContent;
  }
  getDependedOnCoValues() {
    if (this._cachedDependentOn) {
      return this._cachedDependentOn;
    } else {
      const dependentOn = this.getDependedOnCoValuesUncached();
      this._cachedDependentOn = dependentOn;
      return dependentOn;
    }
  }
  /** @internal */
  getDependedOnCoValuesUncached() {
    return this.header.ruleset.type === "group" ? getGroupDependentKeyList(expectGroup(this.getCurrentContent()).keys()) : this.header.ruleset.type === "ownedByGroup" ? [
      this.header.ruleset.group,
      ...new Set([...this.sessionLogs.keys()].map((sessionID) => accountOrAgentIDfromSessionID(sessionID)).filter((session) => isAccountID(session) && session !== this.id))
    ] : [];
  }
  waitForSync(options) {
    return this.node.syncManager.waitForSync(this.id, options == null ? void 0 : options.timeout);
  }
};
function getNextKnownSignatureIdx(log, knownStateForSessionID, sentStateForSessionID) {
  return Object.keys(log.signatureAfter).map(Number).sort((a2, b) => a2 - b).find((idx) => idx >= (sentStateForSessionID ?? knownStateForSessionID ?? -1));
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js
var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/version.js
var VERSION = "1.9.0";

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/semver.js
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v2) {
    rejectedVersions.add(v2);
    return false;
  }
  function _accept(v2) {
    acceptedVersions.add(v2);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
var major = VERSION.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a2;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a2 !== void 0 ? _a2 : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err2 = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err2.stack || err2.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err2 = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err2.stack || err2.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a2, _b2;
  var globalVersion = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a2 === void 0 ? void 0 : _a2.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b2 === void 0 ? void 0 : _b2[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
var __read = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = (
  /** @class */
  function() {
    function DiagComponentLogger2(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger2.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger2;
  }()
);
function logProxy(funcName, namespace, args) {
  var logger2 = getGlobal("diag");
  if (!logger2) {
    return;
  }
  args.unshift(namespace);
  return logger2[funcName].apply(logger2, __spreadArray([], __read(args), false));
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
(function(DiagLogLevel2) {
  DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
  DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
  DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
  DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
  DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger2) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger2 = logger2 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger2[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger2);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI = (
  /** @class */
  function() {
    function DiagAPI2() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger2 = getGlobal("diag");
          if (!logger2)
            return;
          return logger2[funcName].apply(logger2, __spreadArray2([], __read2(args), false));
        };
      }
      var self2 = this;
      var setLogger = function(logger2, optionsOrLogLevel) {
        var _a2, _b2, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger2 === self2) {
          var err2 = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a2 = err2.stack) !== null && _a2 !== void 0 ? _a2 : err2.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal("diag");
        var newLogger = createLogLevelDiagLogger((_b2 = optionsOrLogLevel.logLevel) !== null && _b2 !== void 0 ? _b2 : DiagLogLevel.INFO, logger2);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = function() {
        unregisterGlobal(API_NAME, self2);
      };
      self2.createComponentLogger = function(options) {
        return new DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    DiagAPI2.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI2();
      }
      return this._instance;
    };
    return DiagAPI2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __values2 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = (
  /** @class */
  function() {
    function BaggageImpl2(entries) {
      this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
    }
    BaggageImpl2.prototype.getEntry = function(key) {
      var entry = this._entries.get(key);
      if (!entry) {
        return void 0;
      }
      return Object.assign({}, entry);
    };
    BaggageImpl2.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(_a2) {
        var _b2 = __read3(_a2, 2), k = _b2[0], v2 = _b2[1];
        return [k, v2];
      });
    };
    BaggageImpl2.prototype.setEntry = function(key, entry) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntry = function(key) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntries = function() {
      var e_1, _a2;
      var keys = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
      }
      var newBaggage = new BaggageImpl2(this._entries);
      try {
        for (var keys_1 = __values2(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
          var key = keys_1_1.value;
          newBaggage._entries.delete(key);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return)) _a2.call(keys_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return newBaggage;
    };
    BaggageImpl2.prototype.clear = function() {
      return new BaggageImpl2();
    };
    return BaggageImpl2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/utils.js
var diag = DiagAPI.instance();
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext = (
  /** @class */
  /* @__PURE__ */ function() {
    function BaseContext2(parentContext) {
      var self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self2.getValue = function(key) {
        return self2._currentContext.get(key);
      };
      self2.setValue = function(key, value) {
        var context2 = new BaseContext2(self2._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self2.deleteValue = function(key) {
        var context2 = new BaseContext2(self2._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    return BaseContext2;
  }()
);
var ROOT_CONTEXT = new BaseContext();

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NoopMeter = (
  /** @class */
  function() {
    function NoopMeter2() {
    }
    NoopMeter2.prototype.createGauge = function(_name, _options) {
      return NOOP_GAUGE_METRIC;
    };
    NoopMeter2.prototype.createHistogram = function(_name, _options) {
      return NOOP_HISTOGRAM_METRIC;
    };
    NoopMeter2.prototype.createCounter = function(_name, _options) {
      return NOOP_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
      return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
      return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
    };
    NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
    };
    return NoopMeter2;
  }()
);
var NoopMetric = (
  /** @class */
  /* @__PURE__ */ function() {
    function NoopMetric2() {
    }
    return NoopMetric2;
  }()
);
var NoopCounterMetric = (
  /** @class */
  function(_super) {
    __extends(NoopCounterMetric2, _super);
    function NoopCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopCounterMetric2;
  }(NoopMetric)
);
var NoopUpDownCounterMetric = (
  /** @class */
  function(_super) {
    __extends(NoopUpDownCounterMetric2, _super);
    function NoopUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopUpDownCounterMetric2;
  }(NoopMetric)
);
var NoopGaugeMetric = (
  /** @class */
  function(_super) {
    __extends(NoopGaugeMetric2, _super);
    function NoopGaugeMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
    };
    return NoopGaugeMetric2;
  }(NoopMetric)
);
var NoopHistogramMetric = (
  /** @class */
  function(_super) {
    __extends(NoopHistogramMetric2, _super);
    function NoopHistogramMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
    };
    return NoopHistogramMetric2;
  }(NoopMetric)
);
var NoopObservableMetric = (
  /** @class */
  function() {
    function NoopObservableMetric2() {
    }
    NoopObservableMetric2.prototype.addCallback = function(_callback) {
    };
    NoopObservableMetric2.prototype.removeCallback = function(_callback) {
    };
    return NoopObservableMetric2;
  }()
);
var NoopObservableCounterMetric = (
  /** @class */
  function(_super) {
    __extends(NoopObservableCounterMetric2, _super);
    function NoopObservableCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric2;
  }(NoopObservableMetric)
);
var NoopObservableGaugeMetric = (
  /** @class */
  function(_super) {
    __extends(NoopObservableGaugeMetric2, _super);
    function NoopObservableGaugeMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric2;
  }(NoopObservableMetric)
);
var NoopObservableUpDownCounterMetric = (
  /** @class */
  function(_super) {
    __extends(NoopObservableUpDownCounterMetric2, _super);
    function NoopObservableUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric2;
  }(NoopObservableMetric)
);
var NOOP_METER = new NoopMeter();
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
(function(ValueType2) {
  ValueType2[ValueType2["INT"] = 0] = "INT";
  ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
})(ValueType || (ValueType = {}));

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter = {
  get: function(carrier, key) {
    if (carrier == null) {
      return void 0;
    }
    return carrier[key];
  },
  keys: function(carrier) {
    if (carrier == null) {
      return [];
    }
    return Object.keys(carrier);
  }
};
var defaultTextMapSetter = {
  set: function(carrier, key, value) {
    if (carrier == null) {
      return;
    }
    carrier[key] = value;
  }
};

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = (
  /** @class */
  function() {
    function NoopContextManager2() {
    }
    NoopContextManager2.prototype.active = function() {
      return ROOT_CONTEXT;
    };
    NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
    };
    NoopContextManager2.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager2.prototype.enable = function() {
      return this;
    };
    NoopContextManager2.prototype.disable = function() {
      return this;
    };
    return NoopContextManager2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = (
  /** @class */
  function() {
    function ContextAPI2() {
    }
    ContextAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI2();
      }
      return this._instance;
    };
    ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI2.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI2.prototype.with = function(context2, fn, thisArg) {
      var _a2;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a2 = this._getContextManager()).with.apply(_a2, __spreadArray4([context2, fn, thisArg], __read5(args), false));
    };
    ContextAPI2.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI2.prototype._getContextManager = function() {
      return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI2.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
(function(TraceFlags2) {
  TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
  TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan = (
  /** @class */
  function() {
    function NonRecordingSpan2(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan2.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan2.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan2.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan2.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan2.prototype.end = function(_endTime) {
    };
    NonRecordingSpan2.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a2;
  return (_a2 = getSpan(context2)) === null || _a2 === void 0 ? void 0 : _a2.spanContext();
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
var contextApi = ContextAPI.getInstance();
var NoopTracer = (
  /** @class */
  function() {
    function NoopTracer2() {
    }
    NoopTracer2.prototype.startSpan = function(name, options, context2) {
      if (context2 === void 0) {
        context2 = contextApi.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context2 && getSpanContext(context2);
      if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer2;
  }()
);
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = (
  /** @class */
  function() {
    function ProxyTracer2(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    ProxyTracer2.prototype.startSpan = function(name, options, context2) {
      return this._getTracer().startSpan(name, options, context2);
    };
    ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer2.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider = (
  /** @class */
  function() {
    function NoopTracerProvider2() {
    }
    NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer();
    };
    return NoopTracerProvider2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = (
  /** @class */
  function() {
    function ProxyTracerProvider2() {
    }
    ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
      var _a2;
      return (_a2 = this.getDelegateTracer(name, version, options)) !== null && _a2 !== void 0 ? _a2 : new ProxyTracer(this, name, version, options);
    };
    ProxyTracerProvider2.prototype.getDelegate = function() {
      var _a2;
      return (_a2 = this._delegate) !== null && _a2 !== void 0 ? _a2 : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
      var _a2;
      return (_a2 = this._delegate) === null || _a2 === void 0 ? void 0 : _a2.getTracer(name, version, options);
    };
    return ProxyTracerProvider2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
(function(SamplingDecision2) {
  SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
  SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
  SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
(function(SpanKind2) {
  SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
  SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
  SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
  SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
  SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
(function(SpanStatusCode2) {
  SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
  SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
  SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ",";
var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
var TraceStateImpl = (
  /** @class */
  function() {
    function TraceStateImpl2(rawTraceState) {
      this._internalState = /* @__PURE__ */ new Map();
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    TraceStateImpl2.prototype.set = function(key, value) {
      var traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    };
    TraceStateImpl2.prototype.unset = function(key) {
      var traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    };
    TraceStateImpl2.prototype.get = function(key) {
      return this._internalState.get(key);
    };
    TraceStateImpl2.prototype.serialize = function() {
      var _this = this;
      return this._keys().reduce(function(agg, key) {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    };
    TraceStateImpl2.prototype._parse = function(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
        var listMember = part.trim();
        var i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i2 !== -1) {
          var key = listMember.slice(0, i2);
          var value = listMember.slice(i2 + 1, part.length);
          if (validateKey(key) && validateValue(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, /* @__PURE__ */ new Map());
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    };
    TraceStateImpl2.prototype._keys = function() {
      return Array.from(this._internalState.keys()).reverse();
    };
    TraceStateImpl2.prototype._clone = function() {
      var traceState = new TraceStateImpl2();
      traceState._internalState = new Map(this._internalState);
      return traceState;
    };
    return TraceStateImpl2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context-api.js
var context = ContextAPI.getInstance();

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2 = DiagAPI.instance();

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider = (
  /** @class */
  function() {
    function NoopMeterProvider2() {
    }
    NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
      return NOOP_METER;
    };
    return NoopMeterProvider2;
  }()
);
var NOOP_METER_PROVIDER = new NoopMeterProvider();

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3 = "metrics";
var MetricsAPI = (
  /** @class */
  function() {
    function MetricsAPI2() {
    }
    MetricsAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new MetricsAPI2();
      }
      return this._instance;
    };
    MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
      return registerGlobal(API_NAME3, provider, DiagAPI.instance());
    };
    MetricsAPI2.prototype.getMeterProvider = function() {
      return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
    };
    MetricsAPI2.prototype.getMeter = function(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    };
    MetricsAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME3, DiagAPI.instance());
    };
    return MetricsAPI2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics = MetricsAPI.getInstance();

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator = (
  /** @class */
  function() {
    function NoopTextMapPropagator2() {
    }
    NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
    };
    NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
      return context2;
    };
    NoopTextMapPropagator2.prototype.fields = function() {
      return [];
    };
    return NoopTextMapPropagator2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
var BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4 = "propagation";
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
var PropagationAPI = (
  /** @class */
  function() {
    function PropagationAPI2() {
      this.createBaggage = createBaggage;
      this.getBaggage = getBaggage;
      this.getActiveBaggage = getActiveBaggage;
      this.setBaggage = setBaggage;
      this.deleteBaggage = deleteBaggage;
    }
    PropagationAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new PropagationAPI2();
      }
      return this._instance;
    };
    PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
      return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
    };
    PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
      if (setter === void 0) {
        setter = defaultTextMapSetter;
      }
      return this._getGlobalPropagator().inject(context2, carrier, setter);
    };
    PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
      if (getter === void 0) {
        getter = defaultTextMapGetter;
      }
      return this._getGlobalPropagator().extract(context2, carrier, getter);
    };
    PropagationAPI2.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    };
    PropagationAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME4, DiagAPI.instance());
    };
    PropagationAPI2.prototype._getGlobalPropagator = function() {
      return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation = PropagationAPI.getInstance();

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5 = "trace";
var TraceAPI = (
  /** @class */
  function() {
    function TraceAPI2() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    TraceAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI2();
      }
      return this._instance;
    };
    TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI2.prototype.getTracerProvider = function() {
      return getGlobal(API_NAME5) || this._proxyTracerProvider;
    };
    TraceAPI2.prototype.getTracer = function(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    };
    TraceAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME5, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI2;
  }()
);

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace = TraceAPI.getInstance();

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/PeerKnownStates.js
var PeerKnownStates = class _PeerKnownStates {
  constructor() {
    this.coValues = /* @__PURE__ */ new Map();
    this.listeners = /* @__PURE__ */ new Set();
  }
  updateHeader(id, header) {
    const knownState = this.coValues.get(id) ?? emptyKnownState(id);
    knownState.header = header;
    this.coValues.set(id, knownState);
    this.triggerUpdate(id);
  }
  combineWith(id, value) {
    const knownState = this.coValues.get(id) ?? emptyKnownState(id);
    this.coValues.set(id, combinedKnownStates(knownState, value));
    this.triggerUpdate(id);
  }
  updateSessionCounter(id, sessionId, value) {
    const knownState = this.coValues.get(id) ?? emptyKnownState(id);
    const currentValue = knownState.sessions[sessionId] || 0;
    knownState.sessions[sessionId] = Math.max(currentValue, value);
    this.coValues.set(id, knownState);
    this.triggerUpdate(id);
  }
  set(id, knownState) {
    this.coValues.set(id, knownState === "empty" ? emptyKnownState(id) : knownState);
    this.triggerUpdate(id);
  }
  get(id) {
    return this.coValues.get(id);
  }
  has(id) {
    return this.coValues.has(id);
  }
  clone() {
    const clone = new _PeerKnownStates();
    clone.coValues = new Map(this.coValues);
    return clone;
  }
  triggerUpdate(id) {
    this.trigger(id, this.coValues.get(id) ?? emptyKnownState(id));
  }
  trigger(id, knownState) {
    for (const listener of this.listeners) {
      listener(id, knownState);
    }
  }
  subscribe(listener) {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/PriorityBasedMessageQueue.js
var LinkedList = class {
  constructor(meter) {
    this.meter = meter;
    this.head = void 0;
    this.tail = void 0;
    this.length = 0;
  }
  push(value) {
    var _a2;
    const node = { value, next: void 0 };
    if (this.head === void 0) {
      this.head = node;
      this.tail = node;
    } else if (this.tail) {
      this.tail.next = node;
      this.tail = node;
    } else {
      throw new Error("LinkedList is corrupted");
    }
    this.length++;
    (_a2 = this.meter) == null ? void 0 : _a2.push();
  }
  shift() {
    var _a2;
    if (!this.head) {
      return void 0;
    }
    const node = this.head;
    const value = node.value;
    this.head = node.next;
    node.next = void 0;
    if (this.head === void 0) {
      this.tail = void 0;
    }
    this.length--;
    (_a2 = this.meter) == null ? void 0 : _a2.pull();
    return value;
  }
};
var QueueMeter = class {
  constructor(prefix, attrs) {
    this.attrs = attrs;
    this.pullCounter = metrics.getMeter("cojosn").createCounter(`${prefix}.pulled`, {
      description: "Number of messages pulled from the queue",
      valueType: ValueType.INT,
      unit: "1"
    });
    this.pushCounter = metrics.getMeter("cojosn").createCounter(`${prefix}.pushed`, {
      description: "Number of messages pushed to the queue",
      valueType: ValueType.INT,
      unit: "1"
    });
    this.pullCounter.add(0, this.attrs);
    this.pushCounter.add(0, this.attrs);
  }
  pull() {
    this.pullCounter.add(1, this.attrs);
  }
  push() {
    this.pushCounter.add(1, this.attrs);
  }
};
function meteredList(attrs) {
  return new LinkedList(new QueueMeter("jazz.messagequeue", attrs));
}
var PRIORITY_TO_QUEUE_INDEX = {
  [CO_VALUE_PRIORITY.HIGH]: 0,
  [CO_VALUE_PRIORITY.MEDIUM]: 1,
  [CO_VALUE_PRIORITY.LOW]: 2
};
var PriorityBasedMessageQueue = class {
  constructor(defaultPriority, attrs) {
    this.defaultPriority = defaultPriority;
    this.queues = [
      meteredList({ priority: CO_VALUE_PRIORITY.HIGH, ...attrs }),
      meteredList({ priority: CO_VALUE_PRIORITY.MEDIUM, ...attrs }),
      meteredList({ priority: CO_VALUE_PRIORITY.LOW, ...attrs })
    ];
  }
  getQueue(priority) {
    return this.queues[PRIORITY_TO_QUEUE_INDEX[priority]];
  }
  push(msg) {
    const priority = "priority" in msg ? msg.priority : this.defaultPriority;
    this.getQueue(priority).push(msg);
  }
  pull() {
    var _a2;
    const priority = this.queues.findIndex((queue) => queue.length > 0);
    return (_a2 = this.queues[priority]) == null ? void 0 : _a2.shift();
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/PeerState.js
var PeerState = class {
  constructor(peer, knownStates) {
    this.peer = peer;
    this.toldKnownState = /* @__PURE__ */ new Set();
    this.processing = false;
    this.closed = false;
    this.closeListeners = /* @__PURE__ */ new Set();
    this.queue = new PriorityBasedMessageQueue(CO_VALUE_PRIORITY.HIGH, {
      peerRole: peer.role
    });
    this._knownStates = (knownStates == null ? void 0 : knownStates.clone()) ?? new PeerKnownStates();
    if (peer.role === "storage") {
      this._optimisticKnownStates = "assumeInfallible";
    } else {
      this._optimisticKnownStates = (knownStates == null ? void 0 : knownStates.clone()) ?? new PeerKnownStates();
    }
  }
  get knownStates() {
    return this._knownStates;
  }
  get optimisticKnownStates() {
    if (this._optimisticKnownStates === "assumeInfallible") {
      return this.knownStates;
    }
    return this._optimisticKnownStates;
  }
  updateHeader(id, header) {
    this._knownStates.updateHeader(id, header);
    if (this._optimisticKnownStates !== "assumeInfallible") {
      this._optimisticKnownStates.updateHeader(id, header);
    }
  }
  combineWith(id, value) {
    this._knownStates.combineWith(id, value);
    if (this._optimisticKnownStates !== "assumeInfallible") {
      this._optimisticKnownStates.combineWith(id, value);
    }
  }
  combineOptimisticWith(id, value) {
    if (this._optimisticKnownStates === "assumeInfallible") {
      this._knownStates.combineWith(id, value);
    } else {
      this._optimisticKnownStates.combineWith(id, value);
    }
  }
  updateSessionCounter(id, sessionId, value) {
    this._knownStates.updateSessionCounter(id, sessionId, value);
    if (this._optimisticKnownStates !== "assumeInfallible") {
      this._optimisticKnownStates.updateSessionCounter(id, sessionId, value);
    }
  }
  setKnownState(id, knownState) {
    this._knownStates.set(id, knownState);
    if (this._optimisticKnownStates !== "assumeInfallible") {
      this._optimisticKnownStates.set(id, knownState);
    }
  }
  setOptimisticKnownState(id, knownState) {
    if (this._optimisticKnownStates === "assumeInfallible") {
      this._knownStates.set(id, knownState);
    } else {
      this._optimisticKnownStates.set(id, knownState);
    }
  }
  get id() {
    return this.peer.id;
  }
  get role() {
    return this.peer.role;
  }
  get priority() {
    return this.peer.priority;
  }
  get crashOnClose() {
    return this.peer.crashOnClose;
  }
  shouldRetryUnavailableCoValues() {
    return this.peer.role === "server";
  }
  isServerOrStoragePeer() {
    return this.peer.role === "server" || this.peer.role === "storage";
  }
  async processQueue() {
    if (this.processing) {
      return;
    }
    this.processing = true;
    let msg;
    while (msg = this.queue.pull()) {
      if (this.closed) {
        break;
      }
      try {
        await this.peer.outgoing.push(msg);
      } catch (e2) {
        logger.error("Error sending message", {
          err: e2,
          action: msg.action,
          id: msg.id,
          peerId: this.id,
          peerRole: this.role
        });
      }
    }
    this.processing = false;
  }
  pushOutgoingMessage(msg) {
    if (this.closed) {
      return;
    }
    this.queue.push(msg);
    void this.processQueue();
  }
  isProcessing() {
    return this.processing;
  }
  get incoming() {
    if (this.closed) {
      return async function* () {
        yield "Disconnected";
      }();
    }
    return this.peer.incoming;
  }
  addCloseListener(listener) {
    if (this.closed) {
      listener();
      return () => {
      };
    }
    this.closeListeners.add(listener);
    return () => {
      this.closeListeners.delete(listener);
    };
  }
  emitClose() {
    for (const listener of this.closeListeners) {
      listener();
    }
    this.closeListeners.clear();
  }
  gracefulShutdown() {
    logger.debug("Gracefully closing", {
      peerId: this.id,
      peerRole: this.role
    });
    this.peer.outgoing.close();
    this.closed = true;
    this.emitClose();
  }
  async processIncomingMessages(callback) {
    if (this.closed) {
      throw new Error("Peer is closed");
    }
    const processIncomingMessages = async () => {
      for await (const msg of this.incoming) {
        if (this.closed) {
          return;
        }
        if (msg === "Disconnected") {
          return;
        }
        if (msg === "PingTimeout") {
          logger.error("Ping timeout from peer", {
            peerId: this.id,
            peerRole: this.role
          });
          return;
        }
        callback(msg);
      }
    };
    return processIncomingMessages();
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/SyncStateManager.js
var SyncStateManager = class {
  constructor(syncManager) {
    this.syncManager = syncManager;
    this.listeners = /* @__PURE__ */ new Set();
    this.listenersByPeers = /* @__PURE__ */ new Map();
  }
  subscribeToUpdates(listener) {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }
  subscribeToPeerUpdates(peerId, listener) {
    const listeners = this.listenersByPeers.get(peerId) ?? /* @__PURE__ */ new Set();
    if (listeners.size === 0) {
      this.listenersByPeers.set(peerId, listeners);
    }
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
  getCurrentSyncState(peerId, id) {
    const syncState = {};
    const getIsUploaded2 = () => this.getIsCoValueFullyUploadedIntoPeer(peerId, id);
    Object.defineProperties(syncState, {
      uploaded: {
        enumerable: true,
        get: getIsUploaded2
      }
    });
    return syncState;
  }
  triggerUpdate(peerId, id) {
    const peer = this.syncManager.peers[peerId];
    if (!peer) {
      return;
    }
    const peerListeners = this.listenersByPeers.get(peer.id);
    if (!(peerListeners == null ? void 0 : peerListeners.size) && !this.listeners.size) {
      return;
    }
    const knownState = peer.knownStates.get(id) ?? emptyKnownState(id);
    const syncState = this.getCurrentSyncState(peerId, id);
    for (const listener of this.listeners) {
      listener(peerId, knownState, syncState);
    }
    if (!peerListeners)
      return;
    for (const listener of peerListeners) {
      listener(knownState, syncState);
    }
  }
  getKnownStateSessions(peerId, id) {
    var _a2;
    const peer = this.syncManager.peers[peerId];
    if (!peer) {
      return void 0;
    }
    const peerSessions = (_a2 = peer.knownStates.get(id)) == null ? void 0 : _a2.sessions;
    if (!peerSessions) {
      return void 0;
    }
    const entry = this.syncManager.local.coValuesStore.get(id);
    if (!entry.isAvailable()) {
      return void 0;
    }
    const coValue = entry.core;
    const coValueSessions = coValue.knownState().sessions;
    return {
      peer: peerSessions,
      coValue: coValueSessions
    };
  }
  getIsCoValueFullyUploadedIntoPeer(peerId, id) {
    const sessions = this.getKnownStateSessions(peerId, id);
    if (!sessions) {
      return false;
    }
    return getIsUploaded(sessions.coValue, sessions.peer);
  }
};
function getIsUploaded(from, to) {
  for (const sessionId of Object.keys(from)) {
    if (from[sessionId] !== to[sessionId]) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/sync.js
function emptyKnownState(id) {
  return {
    id,
    header: false,
    sessions: {}
  };
}
function combinedKnownStates(stateA, stateB) {
  const sessionStates = {};
  const allSessions = /* @__PURE__ */ new Set([
    ...Object.keys(stateA.sessions),
    ...Object.keys(stateB.sessions)
  ]);
  for (const sessionID of allSessions) {
    const stateAValue = stateA.sessions[sessionID];
    const stateBValue = stateB.sessions[sessionID];
    sessionStates[sessionID] = Math.max(stateAValue || 0, stateBValue || 0);
  }
  return {
    id: stateA.id,
    header: stateA.header || stateB.header,
    sessions: sessionStates
  };
}
var SyncManager = class {
  constructor(local) {
    this.peers = {};
    this.peersCounter = metrics.getMeter("cojson").createUpDownCounter("jazz.peers", {
      description: "Amount of connected peers",
      valueType: ValueType.INT,
      unit: "peer"
    });
    this.requestedSyncs = /* @__PURE__ */ new Map();
    this.local = local;
    this.syncState = new SyncStateManager(this);
    this.transactionsSizeHistogram = metrics.getMeter("cojson").createHistogram("jazz.transactions.size", {
      description: "The size of transactions in a covalue",
      unit: "bytes",
      valueType: ValueType.INT
    });
  }
  peersInPriorityOrder() {
    return Object.values(this.peers).sort((a2, b) => {
      const aPriority = a2.priority || 0;
      const bPriority = b.priority || 0;
      return bPriority - aPriority;
    });
  }
  getPeers() {
    return Object.values(this.peers);
  }
  getServerAndStoragePeers(excludePeerId) {
    return this.peersInPriorityOrder().filter((peer) => peer.isServerOrStoragePeer() && peer.id !== excludePeerId && !peer.closed);
  }
  handleSyncMessage(msg, peer) {
    if (this.local.coValuesStore.get(msg.id).isErroredInPeer(peer.id)) {
      logger.warn(`Skipping message ${msg.action} on errored coValue ${msg.id} from peer ${peer.id}`);
      return;
    } else if (msg.id === void 0 || msg.id === null) {
      logger.warn("Received sync message with undefined id", {
        msg
      });
      return;
    } else if (!msg.id.startsWith("co_z")) {
      logger.warn("Received sync message with invalid id", {
        msg
      });
      return;
    }
    switch (msg.action) {
      case "load":
        return this.handleLoad(msg, peer);
      case "known":
        if (msg.isCorrection) {
          return this.handleCorrection(msg, peer);
        } else {
          return this.handleKnownState(msg, peer);
        }
      case "content":
        return this.handleNewContent(msg, peer);
      case "done":
        return this.handleUnsubscribe(msg);
      default:
        throw new Error(`Unknown message type ${msg.action}`);
    }
  }
  sendNewContentIncludingDependencies(id, peer) {
    const coValue = this.local.expectCoValueLoaded(id);
    coValue.getDependedOnCoValues().map((id2) => this.sendNewContentIncludingDependencies(id2, peer));
    const newContentPieces = coValue.newContentSince(peer.optimisticKnownStates.get(id));
    if (newContentPieces) {
      for (const piece of newContentPieces) {
        this.trySendToPeer(peer, piece);
      }
      peer.toldKnownState.add(id);
      peer.combineOptimisticWith(id, coValue.knownState());
    } else if (!peer.toldKnownState.has(id)) {
      this.trySendToPeer(peer, {
        action: "known",
        ...coValue.knownState()
      });
      peer.toldKnownState.add(id);
    }
  }
  startPeerReconciliation(peer) {
    const coValuesOrderedByDependency = [];
    const gathered = /* @__PURE__ */ new Set();
    const buildOrderedCoValueList = (coValue) => {
      if (gathered.has(coValue.id)) {
        return;
      }
      gathered.add(coValue.id);
      for (const id of coValue.getDependedOnCoValues()) {
        const entry = this.local.coValuesStore.get(id);
        if (entry.isAvailable()) {
          buildOrderedCoValueList(entry.core);
        }
      }
      coValuesOrderedByDependency.push(coValue);
    };
    for (const entry of this.local.coValuesStore.getValues()) {
      if (!entry.isAvailable()) {
        if (!peer.toldKnownState.has(entry.id)) {
          peer.toldKnownState.add(entry.id);
          this.trySendToPeer(peer, {
            action: "load",
            header: false,
            id: entry.id,
            sessions: {}
          });
        }
      } else {
        const coValue = entry.core;
        buildOrderedCoValueList(coValue);
      }
      if (!peer.optimisticKnownStates.has(entry.id)) {
        peer.setOptimisticKnownState(entry.id, "empty");
      }
    }
    for (const coValue of coValuesOrderedByDependency) {
      peer.toldKnownState.add(coValue.id);
      this.trySendToPeer(peer, {
        action: "load",
        ...coValue.knownState()
      });
    }
  }
  async addPeer(peer) {
    const prevPeer = this.peers[peer.id];
    if (prevPeer && !prevPeer.closed) {
      prevPeer.gracefulShutdown();
    }
    const peerState = new PeerState(peer, prevPeer == null ? void 0 : prevPeer.knownStates);
    this.peers[peer.id] = peerState;
    this.peersCounter.add(1, { role: peer.role });
    const unsubscribeFromKnownStatesUpdates = peerState.knownStates.subscribe((id) => {
      this.syncState.triggerUpdate(peer.id, id);
    });
    if (peerState.isServerOrStoragePeer()) {
      void this.startPeerReconciliation(peerState);
    }
    peerState.processIncomingMessages((msg) => {
      this.handleSyncMessage(msg, peerState);
    }).then(() => {
      if (peer.crashOnClose) {
        logger.error("Unexepcted close from peer", {
          peerId: peer.id,
          peerRole: peer.role
        });
        this.local.crashed = new Error("Unexpected close from peer");
        throw new Error("Unexpected close from peer");
      }
    }).catch((e2) => {
      logger.error("Error processing messages from peer", {
        err: e2,
        peerId: peer.id,
        peerRole: peer.role
      });
      if (peer.crashOnClose) {
        this.local.crashed = e2;
        throw new Error(e2);
      }
    }).finally(() => {
      peerState.gracefulShutdown();
      unsubscribeFromKnownStatesUpdates();
      this.peersCounter.add(-1, { role: peer.role });
      if (peer.deletePeerStateOnClose && this.peers[peer.id] === peerState) {
        delete this.peers[peer.id];
      }
    });
  }
  trySendToPeer(peer, msg) {
    return peer.pushOutgoingMessage(msg);
  }
  /**
   * Handles the load message from a peer.
   *
   * Differences with the known state message:
   * - The load message triggers the CoValue loading process on the other peer
   * - The peer known state is stored as-is instead of being merged
   * - The load message always replies with a known state message
   */
  handleLoad(msg, peer) {
    peer.setKnownState(msg.id, knownStateIn(msg));
    const entry = this.local.coValuesStore.get(msg.id);
    if (entry.highLevelState === "unknown" || entry.highLevelState === "unavailable") {
      const eligiblePeers = this.getServerAndStoragePeers(peer.id);
      if (eligiblePeers.length === 0) {
        peer.toldKnownState.add(msg.id);
        this.trySendToPeer(peer, {
          action: "known",
          id: msg.id,
          header: false,
          sessions: {}
        });
        return;
      } else {
        this.local.loadCoValueCore(msg.id, peer.id).catch((e2) => {
          logger.error("Error loading coValue in handleLoad", { err: e2 });
        });
      }
    }
    if (entry.highLevelState === "loading") {
      entry.getCoValue().then(async (value) => {
        if (value === "unavailable") {
          peer.toldKnownState.add(msg.id);
          this.trySendToPeer(peer, {
            action: "known",
            id: msg.id,
            header: false,
            sessions: {}
          });
          return;
        }
        this.sendNewContentIncludingDependencies(msg.id, peer);
      }).catch((e2) => {
        logger.error("Error loading coValue in handleLoad loading state", {
          err: e2
        });
      });
    } else if (entry.isAvailable()) {
      this.sendNewContentIncludingDependencies(msg.id, peer);
    } else {
      this.trySendToPeer(peer, {
        action: "known",
        id: msg.id,
        header: false,
        sessions: {}
      });
    }
  }
  handleKnownState(msg, peer) {
    var _a2;
    const entry = this.local.coValuesStore.get(msg.id);
    peer.combineWith(msg.id, knownStateIn(msg));
    const availableOnPeer = (_a2 = peer.optimisticKnownStates.get(msg.id)) == null ? void 0 : _a2.header;
    if (!availableOnPeer) {
      entry.markNotFoundInPeer(peer.id);
    }
    if (entry.isAvailable()) {
      this.sendNewContentIncludingDependencies(msg.id, peer);
    }
  }
  recordTransactionsSize(newTransactions, source) {
    for (const tx of newTransactions) {
      const txLength = tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length;
      this.transactionsSizeHistogram.record(txLength, {
        source
      });
    }
  }
  handleNewContent(msg, peer) {
    var _a2;
    const entry = this.local.coValuesStore.get(msg.id);
    let coValue;
    if (!entry.isAvailable()) {
      if (!msg.header) {
        this.trySendToPeer(peer, {
          action: "known",
          isCorrection: true,
          id: msg.id,
          header: false,
          sessions: {}
        });
        return;
      }
      peer.updateHeader(msg.id, true);
      coValue = new CoValueCore(msg.header, this.local);
      entry.markAvailable(coValue, peer.id);
    } else {
      coValue = entry.core;
    }
    let invalidStateAssumed = false;
    for (const [sessionID, newContentForSession] of Object.entries(msg.new)) {
      const ourKnownTxIdx = (_a2 = coValue.sessionLogs.get(sessionID)) == null ? void 0 : _a2.transactions.length;
      const theirFirstNewTxIdx = newContentForSession.after;
      if ((ourKnownTxIdx || 0) < theirFirstNewTxIdx) {
        invalidStateAssumed = true;
        continue;
      }
      const alreadyKnownOffset = ourKnownTxIdx ? ourKnownTxIdx - theirFirstNewTxIdx : 0;
      const newTransactions = newContentForSession.newTransactions.slice(alreadyKnownOffset);
      if (newTransactions.length === 0) {
        continue;
      }
      const result = coValue.tryAddTransactions(sessionID, newTransactions, void 0, newContentForSession.lastSignature);
      if (result.isErr()) {
        logger.error("Failed to add transactions", {
          peerId: peer.id,
          peerRole: peer.role,
          id: msg.id,
          err: result.error
        });
        entry.markErrored(peer.id, result.error);
        continue;
      }
      this.recordTransactionsSize(newTransactions, peer.role);
      peer.updateSessionCounter(msg.id, sessionID, newContentForSession.after + newContentForSession.newTransactions.length);
    }
    if (invalidStateAssumed) {
      this.trySendToPeer(peer, {
        action: "known",
        isCorrection: true,
        ...coValue.knownState()
      });
      peer.toldKnownState.add(msg.id);
    } else {
      this.trySendToPeer(peer, {
        action: "known",
        ...coValue.knownState()
      });
      peer.toldKnownState.add(msg.id);
    }
    this.requestCoValueSync(coValue);
  }
  handleCorrection(msg, peer) {
    peer.setKnownState(msg.id, knownStateIn(msg));
    return this.sendNewContentIncludingDependencies(msg.id, peer);
  }
  handleUnsubscribe(_msg) {
  }
  async requestCoValueSync(coValue) {
    const promise = this.requestedSyncs.get(coValue.id);
    if (promise) {
      return promise;
    } else {
      const promise2 = new Promise((resolve) => {
        queueMicrotask(() => {
          this.requestedSyncs.delete(coValue.id);
          this.syncCoValue(coValue);
          resolve();
        });
      });
      this.requestedSyncs.set(coValue.id, promise2);
      return promise2;
    }
  }
  async syncCoValue(coValue) {
    const entry = this.local.coValuesStore.get(coValue.id);
    for (const peer of this.peersInPriorityOrder()) {
      if (peer.closed)
        continue;
      if (entry.isErroredInPeer(peer.id))
        continue;
      if (peer.role === "client" && !peer.optimisticKnownStates.has(coValue.id)) {
        continue;
      }
      this.sendNewContentIncludingDependencies(coValue.id, peer);
    }
    for (const peer of this.getPeers()) {
      this.syncState.triggerUpdate(peer.id, coValue.id);
    }
  }
  async waitForSyncWithPeer(peerId, id, timeout) {
    const { syncState } = this;
    const currentSyncState = syncState.getCurrentSyncState(peerId, id);
    const isTheConditionAlreadyMet = currentSyncState.uploaded;
    if (isTheConditionAlreadyMet) {
      return true;
    }
    return new Promise((resolve, reject) => {
      const unsubscribe = this.syncState.subscribeToPeerUpdates(peerId, (knownState, syncState2) => {
        if (syncState2.uploaded && knownState.id === id) {
          resolve(true);
          unsubscribe == null ? void 0 : unsubscribe();
          clearTimeout(timeoutId);
        }
      });
      const timeoutId = setTimeout(() => {
        reject(new Error(`Timeout waiting for sync on ${peerId}/${id}`));
        unsubscribe == null ? void 0 : unsubscribe();
      }, timeout);
    });
  }
  async waitForSync(id, timeout = 3e4) {
    const peers = this.getPeers();
    return Promise.all(peers.map((peer) => this.waitForSyncWithPeer(peer.id, id, timeout)));
  }
  async waitForAllCoValuesSync(timeout = 6e4) {
    const coValues = this.local.coValuesStore.getValues();
    const validCoValues = Array.from(coValues).filter((coValue) => coValue.highLevelState === "available" || coValue.highLevelState === "loading");
    return Promise.all(validCoValues.map((coValue) => this.waitForSync(coValue.id, timeout)));
  }
  gracefulShutdown() {
    for (const peer of Object.values(this.peers)) {
      peer.gracefulShutdown();
    }
  }
};
function knownStateIn(msg) {
  return {
    id: msg.id,
    header: msg.header,
    sessions: msg.sessions
  };
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/coValueState.js
var CO_VALUE_LOADING_CONFIG = {
  MAX_RETRIES: 2,
  TIMEOUT: 3e4
};
var CoValueState = class {
  constructor(id) {
    this.peers = /* @__PURE__ */ new Map();
    this.core = null;
    this.listeners = /* @__PURE__ */ new Set();
    this.id = id;
    this.counter = metrics.getMeter("cojson").createUpDownCounter("jazz.covalues.loaded", {
      description: "The number of covalues in the system",
      unit: "covalue",
      valueType: ValueType.INT
    });
    this.updateCounter(null);
  }
  get highLevelState() {
    if (this.core) {
      return "available";
    } else if (this.peers.size === 0) {
      return "unknown";
    }
    for (const peer of this.peers.values()) {
      if (peer.type === "pending") {
        return "loading";
      } else if (peer.type === "unknown") {
        return "unknown";
      }
    }
    return "unavailable";
  }
  isErroredInPeer(peerId) {
    var _a2;
    return ((_a2 = this.peers.get(peerId)) == null ? void 0 : _a2.type) === "errored";
  }
  isAvailable() {
    return !!this.core;
  }
  addListener(listener) {
    this.listeners.add(listener);
    listener(this);
  }
  removeListener(listener) {
    this.listeners.delete(listener);
  }
  notifyListeners() {
    for (const listener of this.listeners) {
      listener(this);
    }
  }
  async getCoValue() {
    if (this.core) {
      return this.core;
    }
    if (this.highLevelState === "unavailable") {
      return "unavailable";
    }
    return new Promise((resolve) => {
      const listener = (state) => {
        if (state.core) {
          resolve(state.core);
          this.removeListener(listener);
        } else if (state.highLevelState === "unavailable") {
          resolve("unavailable");
          this.removeListener(listener);
        }
      };
      this.addListener(listener);
    });
  }
  async loadFromPeers(peers) {
    if (peers.length === 0) {
      return;
    }
    const peersToActuallyLoadFrom = [];
    for (const peer of peers) {
      const currentState = this.peers.get(peer.id);
      if ((currentState == null ? void 0 : currentState.type) === "available" || (currentState == null ? void 0 : currentState.type) === "pending") {
        continue;
      }
      if ((currentState == null ? void 0 : currentState.type) === "errored") {
        continue;
      }
      if ((currentState == null ? void 0 : currentState.type) === "unavailable") {
        if (peer.shouldRetryUnavailableCoValues()) {
          this.markPending(peer.id);
          peersToActuallyLoadFrom.push(peer);
        }
        continue;
      }
      if (!currentState || (currentState == null ? void 0 : currentState.type) === "unknown") {
        this.markPending(peer.id);
        peersToActuallyLoadFrom.push(peer);
      }
    }
    for (const peer of peersToActuallyLoadFrom) {
      if (peer.closed) {
        this.markNotFoundInPeer(peer.id);
        continue;
      }
      peer.pushOutgoingMessage({
        action: "load",
        ...this.core ? this.core.knownState() : emptyKnownState(this.id)
      });
      const timeoutDuration = peer.role === "storage" ? CO_VALUE_LOADING_CONFIG.TIMEOUT * 10 : CO_VALUE_LOADING_CONFIG.TIMEOUT;
      const waitingForPeer = new Promise((resolve) => {
        const markNotFound = () => {
          var _a2;
          if (((_a2 = this.peers.get(peer.id)) == null ? void 0 : _a2.type) === "pending") {
            this.markNotFoundInPeer(peer.id);
          }
        };
        const timeout = setTimeout(markNotFound, timeoutDuration);
        const removeCloseListener = peer.addCloseListener(markNotFound);
        const listener = (state) => {
          const peerState = state.peers.get(peer.id);
          if (state.isAvailable() || // might have become available from another peer e.g. through handleNewContent
          (peerState == null ? void 0 : peerState.type) === "available" || (peerState == null ? void 0 : peerState.type) === "errored" || (peerState == null ? void 0 : peerState.type) === "unavailable") {
            state.removeListener(listener);
            removeCloseListener();
            clearTimeout(timeout);
            resolve();
          }
        };
        this.addListener(listener);
      });
      await waitingForPeer;
    }
  }
  updateCounter(previousState) {
    const newState = this.highLevelState;
    if (previousState !== newState) {
      if (previousState) {
        this.counter.add(-1, { state: previousState });
      }
      this.counter.add(1, { state: newState });
    }
  }
  markNotFoundInPeer(peerId) {
    const previousState = this.highLevelState;
    this.peers.set(peerId, { type: "unavailable" });
    this.updateCounter(previousState);
    this.notifyListeners();
  }
  // TODO: rename to "provided"
  markAvailable(coValue, fromPeerId) {
    const previousState = this.highLevelState;
    this.core = coValue;
    this.peers.set(fromPeerId, { type: "available" });
    this.updateCounter(previousState);
    this.notifyListeners();
  }
  internalMarkMagicallyAvailable(coValue) {
    const previousState = this.highLevelState;
    this.core = coValue;
    this.updateCounter(previousState);
    this.notifyListeners();
  }
  markErrored(peerId, error) {
    const previousState = this.highLevelState;
    this.peers.set(peerId, { type: "errored", error });
    this.updateCounter(previousState);
    this.notifyListeners();
  }
  markPending(peerId) {
    const previousState = this.highLevelState;
    this.peers.set(peerId, { type: "pending" });
    this.updateCounter(previousState);
    this.notifyListeners();
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/CoValuesStore.js
var CoValuesStore = class {
  constructor() {
    this.coValues = /* @__PURE__ */ new Map();
  }
  get(id) {
    let entry = this.coValues.get(id);
    if (!entry) {
      entry = new CoValueState(id);
      this.coValues.set(id, entry);
    }
    return entry;
  }
  markAsAvailable(id, coValue, fromPeerId) {
    const entry = this.get(id);
    entry.markAvailable(coValue, fromPeerId);
  }
  internalMarkMagicallyAvailable(id, coValue) {
    const entry = this.get(id);
    entry.internalMarkMagicallyAvailable(coValue);
  }
  getEntries() {
    return this.coValues.entries();
  }
  getValues() {
    return this.coValues.values();
  }
  getKeys() {
    return this.coValues.keys();
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/localNode.js
var LocalNode = class _LocalNode {
  /** @category 3. Low-level */
  constructor(account, currentSessionID, crypto3) {
    this.coValuesStore = new CoValuesStore();
    this.syncManager = new SyncManager(this);
    this.crashed = void 0;
    this.account = account;
    this.currentSessionID = currentSessionID;
    this.crypto = crypto3;
  }
  /** @category 2. Node Creation */
  static async withNewlyCreatedAccount({ creationProps, peersToLoadFrom, migration, crypto: crypto3, initialAgentSecret = crypto3.newRandomAgentSecret() }) {
    const throwawayAgent = crypto3.newRandomAgentSecret();
    const setupNode = new _LocalNode(new ControlledAgent(throwawayAgent, crypto3), crypto3.newRandomSessionID(crypto3.getAgentID(throwawayAgent)), crypto3);
    const account = setupNode.createAccount(initialAgentSecret);
    const nodeWithAccount = account.core.node.testWithDifferentAccount(account, crypto3.newRandomSessionID(account.id));
    const accountOnNodeWithAccount = nodeWithAccount.account;
    if (peersToLoadFrom) {
      for (const peer of peersToLoadFrom) {
        nodeWithAccount.syncManager.addPeer(peer);
      }
    }
    if (migration) {
      await migration(accountOnNodeWithAccount, nodeWithAccount, creationProps);
    } else {
      const profileGroup = accountOnNodeWithAccount.createGroup();
      profileGroup.addMember("everyone", "reader");
      const profile = profileGroup.createMap({
        name: creationProps.name
      });
      accountOnNodeWithAccount.set("profile", profile.id, "trusting");
    }
    const controlledAccount = new RawControlledAccount(accountOnNodeWithAccount.core, accountOnNodeWithAccount.agentSecret);
    nodeWithAccount.account = controlledAccount;
    nodeWithAccount.coValuesStore.internalMarkMagicallyAvailable(controlledAccount.id, controlledAccount.core);
    controlledAccount.core._cachedContent = void 0;
    if (!controlledAccount.get("profile")) {
      throw new Error("Must set account profile in initial migration");
    }
    function syncAllCoValuesAfterCreateAccount() {
      for (const coValueEntry of nodeWithAccount.coValuesStore.getValues()) {
        if (coValueEntry.isAvailable()) {
          void nodeWithAccount.syncManager.requestCoValueSync(coValueEntry.core);
        }
      }
    }
    syncAllCoValuesAfterCreateAccount();
    setTimeout(syncAllCoValuesAfterCreateAccount, 500);
    return {
      node: nodeWithAccount,
      accountID: accountOnNodeWithAccount.id,
      accountSecret: accountOnNodeWithAccount.agentSecret,
      sessionID: nodeWithAccount.currentSessionID
    };
  }
  /** @category 2. Node Creation */
  static async withLoadedAccount({ accountID, accountSecret, sessionID, peersToLoadFrom, crypto: crypto3, migration }) {
    try {
      const loadingNode = new _LocalNode(new ControlledAgent(accountSecret, crypto3), crypto3.newRandomSessionID(accountID), crypto3);
      for (const peer of peersToLoadFrom) {
        loadingNode.syncManager.addPeer(peer);
      }
      const accountPromise = loadingNode.load(accountID);
      const account = await accountPromise;
      if (account === "unavailable") {
        throw new Error("Account unavailable from all peers");
      }
      const controlledAccount = new RawControlledAccount(account.core, accountSecret);
      const node = loadingNode.testWithDifferentAccount(controlledAccount, sessionID || crypto3.newRandomSessionID(accountID));
      node.syncManager = loadingNode.syncManager;
      node.syncManager.local = node;
      controlledAccount.core.node = node;
      node.coValuesStore.internalMarkMagicallyAvailable(accountID, controlledAccount.core);
      controlledAccount.core._cachedContent = void 0;
      const profileID = account.get("profile");
      if (!profileID) {
        throw new Error("Account has no profile");
      }
      const profile = await node.load(profileID);
      if (profile === "unavailable") {
        throw new Error("Profile unavailable from all peers");
      }
      if (migration) {
        await migration(controlledAccount, node);
        node.account = new RawControlledAccount(controlledAccount.core, controlledAccount.agentSecret);
      }
      return node;
    } catch (e2) {
      logger.error("Error withLoadedAccount", { err: e2 });
      throw e2;
    }
  }
  /** @internal */
  createCoValue(header) {
    if (this.crashed) {
      throw new Error("Trying to create CoValue after node has crashed", {
        cause: this.crashed
      });
    }
    const coValue = new CoValueCore(header, this);
    this.coValuesStore.internalMarkMagicallyAvailable(coValue.id, coValue);
    void this.syncManager.requestCoValueSync(coValue);
    return coValue;
  }
  /** @internal */
  async loadCoValueCore(id, skipLoadingFromPeer) {
    if (this.crashed) {
      throw new Error("Trying to load CoValue after node has crashed", {
        cause: this.crashed
      });
    }
    let retries = 0;
    while (true) {
      const entry = this.coValuesStore.get(id);
      if (entry.highLevelState === "unknown" || entry.highLevelState === "unavailable") {
        const peers = this.syncManager.getServerAndStoragePeers(skipLoadingFromPeer);
        if (peers.length === 0) {
          return "unavailable";
        }
        entry.loadFromPeers(peers).catch((e2) => {
          logger.error("Error loading from peers", {
            id,
            err: e2
          });
        });
      }
      const result = await entry.getCoValue();
      if (result !== "unavailable" || retries >= 1) {
        return result;
      }
      await new Promise((resolve) => setTimeout(resolve, 300));
      retries++;
    }
  }
  /**
   * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
   * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
   * for listening to subsequent updates to the CoValue.
   *
   * @category 3. Low-level
   */
  async load(id) {
    if (!id) {
      throw new Error("Trying to load CoValue with undefined id");
    }
    if (!id.startsWith("co_z")) {
      throw new Error(`Trying to load CoValue with invalid id ${id}`);
    }
    const core = await this.loadCoValueCore(id);
    if (core === "unavailable") {
      return "unavailable";
    }
    return core.getCurrentContent();
  }
  getLoaded(id) {
    const entry = this.coValuesStore.get(id);
    if (entry.isAvailable()) {
      return entry.core.getCurrentContent();
    }
    return void 0;
  }
  /** @category 3. Low-level */
  subscribe(id, callback) {
    let stopped = false;
    let unsubscribe;
    this.load(id).then((coValue) => {
      if (stopped) {
        return;
      }
      if (coValue === "unavailable") {
        callback("unavailable");
        return;
      }
      unsubscribe = coValue.subscribe(callback);
    }).catch((e2) => {
      logger.error("Subscription error", {
        id,
        err: e2
      });
    });
    return () => {
      stopped = true;
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }
  /** @deprecated Use Account.acceptInvite instead */
  async acceptInvite(groupOrOwnedValueID, inviteSecret) {
    const groupOrOwnedValue = await this.load(groupOrOwnedValueID);
    if (groupOrOwnedValue === "unavailable") {
      throw new Error("Trying to accept invite: Group/owned value unavailable from all peers");
    }
    if (groupOrOwnedValue.core.header.ruleset.type === "ownedByGroup") {
      return this.acceptInvite(groupOrOwnedValue.core.header.ruleset.group, inviteSecret);
    } else if (groupOrOwnedValue.core.header.ruleset.type !== "group") {
      throw new Error("Can only accept invites to groups");
    }
    const group = expectGroup(groupOrOwnedValue);
    const inviteAgentSecret = this.crypto.agentSecretFromSecretSeed(secretSeedFromInviteSecret(inviteSecret));
    const inviteAgentID = this.crypto.getAgentID(inviteAgentSecret);
    const inviteRole = await new Promise((resolve, reject) => {
      group.subscribe((groupUpdate) => {
        const role = groupUpdate.get(inviteAgentID);
        if (role) {
          resolve(role);
        }
      });
      setTimeout(() => reject(new Error("Couldn't find invite before timeout")), 2e3);
    });
    if (!inviteRole) {
      throw new Error("No invite found");
    }
    const existingRole = group.get(this.account.id);
    if (existingRole === "admin" || existingRole === "writer" && inviteRole === "writerInvite" || existingRole === "writer" && inviteRole === "reader" || existingRole === "reader" && inviteRole === "readerInvite" || existingRole && inviteRole === "writeOnlyInvite") {
      logger.debug("Not accepting invite that would replace or downgrade role");
      return;
    }
    const groupAsInvite = expectGroup(group.core.testWithDifferentAccount(new ControlledAgent(inviteAgentSecret, this.crypto), this.crypto.newRandomSessionID(inviteAgentID)).getCurrentContent());
    groupAsInvite.addMemberInternal(this.account, inviteRole === "adminInvite" ? "admin" : inviteRole === "writerInvite" ? "writer" : inviteRole === "writeOnlyInvite" ? "writeOnly" : "reader");
    group.core._sessionLogs = groupAsInvite.core.sessionLogs;
    group.core._cachedContent = void 0;
    for (const groupListener of group.core.listeners) {
      groupListener(group.core.getCurrentContent());
    }
  }
  /** @internal */
  expectCoValueLoaded(id, expectation) {
    const entry = this.coValuesStore.get(id);
    if (!entry.isAvailable()) {
      throw new Error(`${expectation ? expectation + ": " : ""}CoValue ${id} not yet loaded. Current state: ${JSON.stringify(entry)}`);
    }
    return entry.core;
  }
  /** @internal */
  expectProfileLoaded(id, expectation) {
    const account = this.expectCoValueLoaded(id, expectation);
    const profileID = expectGroup(account.getCurrentContent()).get("profile");
    if (!profileID) {
      throw new Error(`${expectation ? expectation + ": " : ""}Account ${id} has no profile`);
    }
    return this.expectCoValueLoaded(profileID, expectation).getCurrentContent();
  }
  /** @internal */
  createAccount(agentSecret = this.crypto.newRandomAgentSecret()) {
    const accountAgentID = this.crypto.getAgentID(agentSecret);
    const account = expectGroup(this.createCoValue(accountHeaderForInitialAgentSecret(agentSecret, this.crypto)).testWithDifferentAccount(new ControlledAgent(agentSecret, this.crypto), this.crypto.newRandomSessionID(accountAgentID)).getCurrentContent());
    account.set(accountAgentID, "admin", "trusting");
    const readKey = this.crypto.newRandomKeySecret();
    const sealed = this.crypto.seal({
      message: readKey.secret,
      from: this.crypto.getAgentSealerSecret(agentSecret),
      to: this.crypto.getAgentSealerID(accountAgentID),
      nOnceMaterial: {
        in: account.id,
        tx: account.core.nextTransactionID()
      }
    });
    account.set(`${readKey.id}_for_${accountAgentID}`, sealed, "trusting");
    account.set("readKey", readKey.id, "trusting");
    const accountOnThisNode = this.expectCoValueLoaded(account.id);
    accountOnThisNode._sessionLogs = new Map(account.core.sessionLogs);
    accountOnThisNode._cachedContent = void 0;
    return new RawControlledAccount(accountOnThisNode, agentSecret);
  }
  /** @internal */
  resolveAccountAgent(id, expectation) {
    if (isAgentID(id)) {
      return ok(id);
    }
    let coValue;
    try {
      coValue = this.expectCoValueLoaded(id, expectation);
    } catch (e2) {
      return err({
        type: "ErrorLoadingCoValueCore",
        expectation,
        id,
        error: e2
      });
    }
    if (coValue.header.type !== "comap" || coValue.header.ruleset.type !== "group" || !coValue.header.meta || !("type" in coValue.header.meta) || coValue.header.meta.type !== "account") {
      return err({
        type: "UnexpectedlyNotAccount",
        expectation,
        id
      });
    }
    return ok(coValue.getCurrentContent().currentAgentID());
  }
  resolveAccountAgentAsync(id, expectation) {
    if (isAgentID(id)) {
      return okAsync(id);
    }
    return ResultAsync.fromPromise(this.loadCoValueCore(id), (e2) => ({
      type: "ErrorLoadingCoValueCore",
      expectation,
      id,
      error: e2
    })).andThen((coValue) => {
      if (coValue === "unavailable") {
        return err({
          type: "AccountUnavailableFromAllPeers",
          expectation,
          id
        });
      }
      if (coValue.header.type !== "comap" || coValue.header.ruleset.type !== "group" || !coValue.header.meta || !("type" in coValue.header.meta) || coValue.header.meta.type !== "account") {
        return err({
          type: "UnexpectedlyNotAccount",
          expectation,
          id
        });
      }
      return ok(coValue.getCurrentContent().currentAgentID());
    });
  }
  /**
   * @deprecated use Account.createGroup() instead
   */
  createGroup(uniqueness = this.crypto.createdNowUnique()) {
    const groupCoValue = this.createCoValue({
      type: "comap",
      ruleset: { type: "group", initialAdmin: this.account.id },
      meta: null,
      ...uniqueness
    });
    const group = expectGroup(groupCoValue.getCurrentContent());
    group.set(this.account.id, "admin", "trusting");
    const readKey = this.crypto.newRandomKeySecret();
    group.set(`${readKey.id}_for_${this.account.id}`, this.crypto.seal({
      message: readKey.secret,
      from: this.account.currentSealerSecret(),
      to: this.account.currentSealerID(),
      nOnceMaterial: {
        in: groupCoValue.id,
        tx: groupCoValue.nextTransactionID()
      }
    }), "trusting");
    group.set("readKey", readKey.id, "trusting");
    return group;
  }
  /** @internal */
  testWithDifferentAccount(account, currentSessionID) {
    const newNode = new _LocalNode(account, currentSessionID, this.crypto);
    const coValuesToCopy = Array.from(this.coValuesStore.getEntries());
    while (coValuesToCopy.length > 0) {
      const [coValueID, entry] = coValuesToCopy[coValuesToCopy.length - 1];
      if (!entry.isAvailable()) {
        coValuesToCopy.pop();
        continue;
      } else {
        const allDepsCopied = entry.core.getDependedOnCoValues().every((dep) => newNode.coValuesStore.get(dep).isAvailable());
        if (!allDepsCopied) {
          coValuesToCopy.unshift(coValuesToCopy.pop());
          continue;
        }
        const newCoValue = new CoValueCore(entry.core.header, newNode, new Map(entry.core.sessionLogs));
        newNode.coValuesStore.internalMarkMagicallyAvailable(coValueID, newCoValue);
        coValuesToCopy.pop();
      }
    }
    if (account instanceof RawControlledAccount) {
      const accountInNode = new RawControlledAccount(newNode.expectCoValueLoaded(account.id), account.agentSecret);
      if (accountInNode.core.node !== newNode) {
        throw new Error("Account's node is not the new node");
      }
      newNode.account = accountInNode;
    }
    return newNode;
  }
  gracefulShutdown() {
    this.syncManager.gracefulShutdown();
  }
};

// node_modules/.pnpm/queueueue@4.1.2/node_modules/queueueue/dist/queueable.modern.mjs
var t = class {
  constructor() {
    this.promise = new Promise((t2, e2) => {
      this.resolve = (e3) => (t2(e3), this.promise), this.reject = (t3) => (e2(t3), this.promise);
    });
  }
};
var e = 0;
function r(t2) {
  return "__private_" + e++ + "_" + t2;
}
function s(t2, e2) {
  if (!Object.prototype.hasOwnProperty.call(t2, e2)) throw new TypeError("attempted to use private field on non-instance");
  return t2;
}
var i;
var n;
var h = (i = function(t2, e2) {
  !function() {
    function e3(t3, e4, r3) {
      this.next = r3, r3 && (r3.prev = this), this.prev = e4, e4 && (e4.next = this), this.data = t3;
    }
    function r2() {
      if (!(this instanceof r2)) return new r2();
      this._head = null, this._tail = null, this.length = 0;
    }
    r2.prototype = { push: function(t3) {
      this._tail = new e3(t3, this._tail, null), this._head || (this._head = this._tail), this.length++;
    }, pop: function() {
      if (0 !== this.length) {
        var t3 = this._tail;
        return this._tail = t3.prev, t3.prev && (t3.prev = this._tail.next = null), this.length--, 1 === this.length ? this._head = this._tail : 0 === this.length && (this._head = this._tail = null), t3.data;
      }
    }, unshift: function(t3) {
      this._head = new e3(t3, null, this._head), this._tail || (this._tail = this._head), this.length++;
    }, shift: function() {
      if (0 !== this.length) {
        var t3 = this._head;
        return this._head = t3.next, t3.next && (t3.next = this._head.prev = null), this.length--, 1 === this.length ? this._tail = this._head : 0 === this.length && (this._head = this._tail = null), t3.data;
      }
    }, item: function(t3) {
      t3 < 0 && (t3 = this.length + t3);
      for (var e4 = this._head; t3-- > 0 && e4; ) e4 = e4.next;
      return e4 ? e4.data : void 0;
    }, slice: function(t3, e4) {
      if (t3 || (t3 = 0), e4 || (e4 = this.length), e4 < 0 && (e4 = this.length + e4), t3 < 0 && (t3 = this.length + t3), e4 === t3) return [];
      if (e4 < t3) throw new Error("invalid offset: " + t3 + "," + e4 + " (length=" + this.length + ")");
      for (var r3 = e4 - t3, s2 = new Array(r3), i2 = 0, n2 = this._head; t3-- > 0 && n2; ) n2 = n2.next;
      for (; i2 < r3 && n2; ) s2[i2++] = n2.data, n2 = n2.next;
      return s2;
    }, drop: function() {
      r2.call(this);
    }, forEach: function(t3, e4) {
      for (var r3 = this._head, s2 = 0, i2 = this.length; s2 < i2 && r3; ) t3.call(e4 || this, r3.data, s2, this), r3 = r3.next, s2++;
    }, map: function(t3, e4) {
      var s2 = new r2();
      return this.forEach(function(r3, i2, n2) {
        s2.push(t3.call(e4 || n2, r3, i2, n2));
      }), s2;
    }, filter: function(t3, e4) {
      var s2 = new r2();
      return this.forEach(function(r3, i2, n2) {
        t3.call(e4 || n2, r3, i2, n2) && s2.push(r3);
      }), s2;
    }, reduce: function(t3, e4, r3) {
      var s2 = 0, i2 = this._head, n2 = this.length;
      for (e4 || (s2 = 1, e4 = i2 && i2.data, i2 = i2 && i2.next); s2 < n2 && i2; ) e4 = t3.call(r3 || this, e4, i2.data, this), s2++, i2 = i2.next;
      return e4;
    } }, t2.exports = r2;
  }();
}, i(n = { exports: {} }), n.exports);
var o;
var l = r("list");
var u = r("reversed");
o = Symbol.iterator;
var a = class _a2 {
  constructor(t2 = Infinity) {
    Object.defineProperty(this, l, { writable: true, value: void 0 }), Object.defineProperty(this, u, { writable: true, value: false }), this.length = 0, this.limit = t2, s(this, l)[l] = new h();
  }
  enqueue(t2) {
    const e2 = s(this, l)[l];
    e2.length === this.limit ? e2.shift() : this.length += 1, e2.push(t2);
  }
  dequeue() {
    if (0 === this.length) throw Error("Buffer is empty");
    return this.length -= 1, s(this, u)[u] ? s(this, l)[l].pop() : s(this, l)[l].shift();
  }
  clear() {
    this.length = 0, s(this, l)[l].drop();
  }
  forEach(t2) {
    s(this, l)[l].forEach(t2);
  }
  reverse() {
    return s(this, u)[u] = true, this;
  }
  [o]() {
    return { next: () => this.length > 0 ? { value: this.dequeue(), done: false } : { done: true, value: void 0 }, [Symbol.iterator]() {
      return this;
    } };
  }
  static from(t2, e2) {
    const r2 = new _a2(e2);
    for (const e3 of t2) r2.enqueue(e3);
    return r2;
  }
};
var f = Object.freeze({ value: void 0, done: true });
Promise.resolve(f);
var c = (t2) => (e2, r2, s2) => {
  const i2 = t2(), n2 = (t3) => {
    i2.push(t3);
  };
  return r2.addEventListener(e2, n2, s2), i2.wrap(() => r2.removeEventListener(e2, n2, s2));
};
var d = (t2) => (e2, r2) => {
  const s2 = t2(), i2 = (t3) => {
    s2.push(t3);
  };
  return r2.addListener(e2, i2), s2.wrap(() => {
    r2.removeListener(e2, i2);
  });
};
var p;
var v;
var m;
p = Symbol.asyncIterator;
var w = class {
  constructor(t2 = Infinity) {
    this.closed = false, this.pushBuffer = new a(t2), this.pullBuffer = new a(t2);
  }
  next() {
    if (this.closed) return Promise.resolve(f);
    if (0 === this.pushBuffer.length) {
      const e3 = new t();
      return this.pullBuffer.enqueue(e3), e3.promise;
    }
    const { result: e2, defer: r2 } = this.pushBuffer.dequeue();
    return r2.resolve(e2), e2.done && this.close(), r2.promise;
  }
  push(e2, r2 = false) {
    if (this.closed) return Promise.resolve(f);
    const s2 = { value: e2, done: r2 };
    if (this.pullBuffer.length > 0) return this.pullBuffer.dequeue().resolve(s2);
    const i2 = new t();
    return this.pushBuffer.enqueue({ result: s2, defer: i2 }), i2.promise;
  }
  [p]() {
    return this;
  }
  async return(t2) {
    return this.close(), { done: true, value: t2 };
  }
  close() {
    this.closed || (this.closed = true, this.pushBuffer.forEach(({ defer: { resolve: t2 } }) => {
      t2(f);
    }), this.pushBuffer.clear(), this.pullBuffer.forEach(({ resolve: t2 }) => {
      t2(f);
    }), this.pullBuffer.clear());
  }
  wrap(t2) {
    var e2 = this;
    if (this.closed) throw Error("Balancer is closed");
    return { [Symbol.asyncIterator]() {
      return this;
    }, next: () => this.next(), return: async function(r2) {
      return t2 && t2(), e2.return(r2);
    } };
  }
};
w.fromDom = c(() => new w()), w.fromEmitter = d(() => new w()), v = Symbol.asyncIterator;
var _ = class {
  constructor(t2 = () => new w()) {
    this.receivers = /* @__PURE__ */ new Set(), this.init = t2;
  }
  push(t2) {
    return this.receivers.forEach((e2) => e2.push(t2)), this;
  }
  [v]() {
    const t2 = this.init(), { receivers: e2 } = this;
    return e2.add(t2), this.onStart && 1 === e2.size && this.onStart(), t2.wrap(() => {
      e2.delete(t2), this.onStop && 0 === e2.size && this.onStop();
    });
  }
};
m = Symbol.asyncIterator;
var g = class {
  constructor() {
    this.buffer = new t(), this.closed = false, this.resolved = false, this.requested = false;
  }
  push(e2, r2 = false) {
    if (this.closed) throw Error("Iterator closed");
    const s2 = { value: e2, done: r2 };
    return false === this.resolved ? this.resolved = true : (this.buffer = new t(), this.resolved = false), this.requested = false, this.buffer.resolve(s2), this.buffer.promise;
  }
  async next() {
    return this.closed ? f : (this.requested = true, this.buffer.promise);
  }
  async return(t2) {
    return this.closed = true, !this.resolved && this.requested && this.buffer.resolve(f), Promise.resolve({ value: t2, done: true });
  }
  wrap(t2) {
    return { next: () => this.next(), [Symbol.asyncIterator]() {
      return this;
    }, return: (e2) => (t2 && t2(), this.return(e2)) };
  }
  [m]() {
    return this;
  }
};
g.fromDom = c(() => new g()), g.fromEmitter = d(() => new g());

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/streamUtils.js
function connectedPeers(peer1id, peer2id, { trace: trace2 = false, peer1role = "client", peer2role = "client", crashOnClose = false } = {}) {
  const [from1to2Rx, from1to2Tx] = newQueuePair(trace2 ? { traceAs: `${peer1id} -> ${peer2id}` } : void 0);
  const [from2to1Rx, from2to1Tx] = newQueuePair(trace2 ? { traceAs: `${peer2id} -> ${peer1id}` } : void 0);
  const peer2AsPeer = {
    id: peer2id,
    incoming: from2to1Rx,
    outgoing: from1to2Tx,
    role: peer2role,
    crashOnClose
  };
  const peer1AsPeer = {
    id: peer1id,
    incoming: from1to2Rx,
    outgoing: from2to1Tx,
    role: peer1role,
    crashOnClose
  };
  return [peer1AsPeer, peer2AsPeer];
}
function newQueuePair(options = {}) {
  const channel = new w();
  if (options.traceAs) {
    return [
      async function* () {
        for await (const msg of channel) {
          console.debug(options.traceAs, JSON.stringify(msg, (k, v2) => k === "changes" || k === "encryptedChanges" ? v2.slice(0, 20) + "..." : v2, 2));
          yield msg;
        }
      }(),
      channel
    ];
  } else {
    return [channel.wrap(), channel];
  }
}

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/exports.js
var cojsonInternals = {
  connectedPeers,
  rawCoIDtoBytes,
  rawCoIDfromBytes,
  secretSeedLength,
  shortHashLength,
  expectGroup,
  base64URLtoBytes,
  bytesToBase64url,
  parseJSON,
  stableStringify,
  accountOrAgentIDfromSessionID,
  isAccountID,
  accountHeaderForInitialAgentSecret,
  idforHeader,
  StreamingHash,
  Channel: w,
  getPriorityFromHeader,
  getGroupDependentKeyList,
  getGroupDependentKey,
  disablePermissionErrors,
  CO_VALUE_LOADING_CONFIG
};

// node_modules/.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/dist/chunk-PYBQOYML.js
var import_fast_myers_diff = __toESM(require_bin(), 1);
var import_fast_myers_diff2 = __toESM(require_bin(), 1);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js
function isBytes2(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber2(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber2(h2.outputLen);
  anumber2(h2.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
var swap8IfBE = isLE ? (n2) => n2 : (n2) => byteSwap(n2);
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u2) => u2 : byteSwap32;
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad);
    pad += a2.length;
  }
  return res;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function createOptHasher(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function createXOFer(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
function Chi(a2, b, c2) {
  return a2 & b ^ ~a2 & c2;
}
function Maj(a2, b, c2) {
  return a2 & b ^ a2 & c2 ^ b & c2;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h: h2, l: l2 } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h2, l2];
  }
  return [Ah, Al];
}
var shrSH = (h2, _l, s2) => h2 >>> s2;
var shrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
var rotrSH = (h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2;
var rotrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
var rotrBH = (h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32;
var rotrBL = (h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2;
var rotr32H = (_h, l2) => l2;
var rotr32L = (h2, _l) => h2;
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = SHA224_IV[0] | 0;
    this.B = SHA224_IV[1] | 0;
    this.C = SHA224_IV[2] | 0;
    this.D = SHA224_IV[3] | 0;
    this.E = SHA224_IV[4] | 0;
    this.F = SHA224_IV[5] | 0;
    this.G = SHA224_IV[6] | 0;
    this.H = SHA224_IV[7] | 0;
  }
};
var K512 = (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh = (() => K512[0])();
var SHA512_Kl = (() => K512[1])();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var SHA512_224 = class extends SHA512 {
  constructor() {
    super(28);
    this.Ah = T224_IV[0] | 0;
    this.Al = T224_IV[1] | 0;
    this.Bh = T224_IV[2] | 0;
    this.Bl = T224_IV[3] | 0;
    this.Ch = T224_IV[4] | 0;
    this.Cl = T224_IV[5] | 0;
    this.Dh = T224_IV[6] | 0;
    this.Dl = T224_IV[7] | 0;
    this.Eh = T224_IV[8] | 0;
    this.El = T224_IV[9] | 0;
    this.Fh = T224_IV[10] | 0;
    this.Fl = T224_IV[11] | 0;
    this.Gh = T224_IV[12] | 0;
    this.Gl = T224_IV[13] | 0;
    this.Hh = T224_IV[14] | 0;
    this.Hl = T224_IV[15] | 0;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super(32);
    this.Ah = T256_IV[0] | 0;
    this.Al = T256_IV[1] | 0;
    this.Bh = T256_IV[2] | 0;
    this.Bl = T256_IV[3] | 0;
    this.Ch = T256_IV[4] | 0;
    this.Cl = T256_IV[5] | 0;
    this.Dh = T256_IV[6] | 0;
    this.Dl = T256_IV[7] | 0;
    this.Eh = T256_IV[8] | 0;
    this.El = T256_IV[9] | 0;
    this.Fh = T256_IV[10] | 0;
    this.Fl = T256_IV[11] | 0;
    this.Gh = T256_IV[12] | 0;
    this.Gl = T256_IV[13] | 0;
    this.Hh = T256_IV[14] | 0;
    this.Hl = T256_IV[15] | 0;
  }
};
var sha256 = createHasher(() => new SHA256());
var sha224 = createHasher(() => new SHA224());
var sha512 = createHasher(() => new SHA512());
var sha384 = createHasher(() => new SHA384());
var sha512_256 = createHasher(() => new SHA512_256());
var sha512_224 = createHasher(() => new SHA512_224());

// node_modules/.pnpm/@scure+base@1.2.5/node_modules/@scure/base/lib/esm/index.js
function isBytes3(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abytes2(b, ...lengths) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf2(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn2(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr2(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber3(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`invalid integer: ${n2}`);
}
function aArr2(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr2(label, input) {
  if (!isArrayOf2(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr2(label, input) {
  if (!isArrayOf2(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain2(...args) {
  const id = (a2) => a2;
  const wrap = (a2, b) => (c2) => a2(b(c2));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode };
}
function alphabet3(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr2("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l2, i2) => [l2, i2]));
  return {
    encode: (digits) => {
      aArr2(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr2(input);
      return input.map((letter) => {
        astr2("alphabet.decode", letter);
        const i2 = indexes.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
function join2(separator = "") {
  astr2("join", separator);
  return {
    encode: (from) => {
      astrArr2("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr2("join.decode", to);
      return to.split(separator);
    }
  };
}
function padding2(bits, chr = "=") {
  anumber3(bits);
  astr2("padding", chr);
  return {
    encode(data) {
      astrArr2("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr2("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize2(fn) {
  afn2(fn);
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix3(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr2(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d2) => {
    anumber3(d2);
    if (d2 < 0 || d2 >= from)
      throw new Error(`invalid integer: ${d2}`);
    return d2;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < dlen; i2++) {
      const digit = digits[i2];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i2] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd2 = (a2, b) => b === 0 ? a2 : gcd2(b, a2 % b);
var radix2carry2 = (from, to) => from + (to - gcd2(from, to));
var powers2 = (() => {
  let res = [];
  for (let i2 = 0; i2 < 40; i2++)
    res.push(2 ** i2);
  return res;
})();
function convertRadix22(data, from, to, padding3) {
  aArr2(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry2(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry2(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers2[from];
  const mask = powers2[to] - 1;
  const res = [];
  for (const n2 of data) {
    anumber3(n2);
    if (n2 >= max)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
    carry = carry << from | n2;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow = powers2[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding3 && pos >= from)
    throw new Error("Excess padding");
  if (!padding3 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding3 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix3(num) {
  anumber3(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes3(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix3(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr2("radix.decode", digits);
      return Uint8Array.from(convertRadix3(digits, num, _256));
    }
  };
}
function radix22(bits, revPadding = false) {
  anumber3(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry2(8, bits) > 32 || radix2carry2(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes3(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix22(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr2("radix2.decode", digits);
      return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper2(fn) {
  afn2(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e2) {
    }
  };
}
function checksum(len, fn) {
  anumber3(len);
  afn2(fn);
  return {
    encode(data) {
      if (!isBytes3(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes3(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn(payload).slice(0, len);
      for (let i2 = 0; i2 < len; i2++)
        if (newChecksum[i2] !== oldChecksum[i2])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var utils = {
  alphabet: alphabet3,
  chain: chain2,
  checksum,
  convertRadix: convertRadix3,
  convertRadix2: convertRadix22,
  radix: radix3,
  radix2: radix22,
  join: join2,
  padding: padding2
};
var base162 = chain2(radix22(4), alphabet3("0123456789ABCDEF"), join2(""));
var base322 = chain2(radix22(5), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding2(5), join2(""));
var base32nopad2 = chain2(radix22(5), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join2(""));
var base32hex2 = chain2(radix22(5), alphabet3("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding2(5), join2(""));
var base32hexnopad2 = chain2(radix22(5), alphabet3("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join2(""));
var base32crockford2 = chain2(radix22(5), alphabet3("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize2((s2) => s2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var base642 = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64();
  },
  decode(s2) {
    astr2("base64", s2);
    return Uint8Array.fromBase64(s2, { lastChunkHandling: "strict" });
  }
} : chain2(radix22(6), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding2(6), join2(""));
var base64nopad2 = chain2(radix22(6), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join2(""));
var base64url2 = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64({ alphabet: "base64url" });
  },
  decode(s2) {
    astr2("base64", s2);
    return Uint8Array.fromBase64(s2, { alphabet: "base64url" });
  }
} : chain2(radix22(6), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding2(6), join2(""));
var base64urlnopad2 = chain2(radix22(6), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join2(""));
var genBase582 = (abc) => chain2(radix3(58), alphabet3(abc), join2(""));
var base582 = genBase582("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr2 = genBase582("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp2 = genBase582("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET2 = chain2(alphabet3("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
var POLYMOD_GENERATORS2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod2(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS2.length; i2++) {
    if ((b >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS2[i2];
  }
  return chk;
}
function bechChecksum2(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c2 = prefix.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod2(chk) ^ c2 >> 5;
  }
  chk = bech32Polymod2(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod2(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v2 of words)
    chk = bech32Polymod2(chk) ^ v2;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod2(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET2.encode(convertRadix22([chk % powers2[30]], 30, 5, false));
}
function genBech322(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix22(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper2(fromWords);
  function encode(prefix, words, limit = 90) {
    astr2("bech32.encode prefix", prefix);
    if (isBytes3(words))
      words = Array.from(words);
    anumArr2("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum2(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET2.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    astr2("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET2.decode(data).slice(0, -6);
    const sum = bechChecksum2(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper2(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech322 = genBech322("bech32");
var bech32m2 = genBech322("bech32m");
var hasHexBuiltin2 = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes2(data);
    return data.toHex();
  },
  decode(s2) {
    astr2("hex", s2);
    return Uint8Array.fromHex(s2);
  }
};
var hex2 = hasHexBuiltin2 ? hexBuiltin : chain2(radix22(4), alphabet3("0123456789abcdef"), join2(""), normalize2((s2) => {
  if (typeof s2 !== "string" || s2.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s2} with length ${s2.length}`);
  return s2.toLowerCase();
}));

// node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/esm/index.js
var isJapanese = (wordlist) => wordlist[0] === "あいこくしん";
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize3(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
function aentropy(ent) {
  abytes(ent, 16, 20, 24, 28, 32);
}
var calcChecksum = (entropy) => {
  const bitsLeft = 8 - entropy.length / 4;
  return new Uint8Array([sha256(entropy)[0] >> bitsLeft << bitsLeft]);
};
function getCoder(wordlist) {
  if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
    throw new Error("Wordlist: expected array of 2048 strings");
  wordlist.forEach((i2) => {
    if (typeof i2 !== "string")
      throw new Error("wordlist: non-string element: " + i2);
  });
  return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist));
}
function mnemonicToEntropy(mnemonic, wordlist) {
  const { words } = normalize3(mnemonic);
  const entropy = getCoder(wordlist).decode(words);
  aentropy(entropy);
  return entropy;
}
function entropyToMnemonic(entropy, wordlist) {
  aentropy(entropy);
  const words = getCoder(wordlist).encode(entropy);
  return words.join(isJapanese(wordlist) ? "　" : " ");
}

// node_modules/.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/dist/chunk-PYBQOYML.js
var ActiveAccountContext = class {
  constructor() {
    this.activeAccount = null;
    this.guestMode = false;
  }
  set(account) {
    this.activeAccount = account;
    this.guestMode = false;
  }
  setGuestMode() {
    this.activeAccount = null;
    this.guestMode = true;
  }
  maybeGet() {
    return this.activeAccount;
  }
  get() {
    if (!this.activeAccount) {
      if (this.guestMode) {
        throw new Error(
          "Something that expects a full active account was called in guest mode."
        );
      }
      throw new Error("No active account");
    }
    return this.activeAccount;
  }
};
var activeAccountContext = new ActiveAccountContext();
var AnonymousJazzAgent = class {
  constructor(node) {
    this.node = node;
    this._type = "Anonymous";
  }
};
var inspect = Symbol.for("nodejs.util.inspect.custom");
var SchemaInit = "$SchemaInit$";
var ItemsSym = "$items$";
function hasRefValue(value, key) {
  var _a2;
  return Boolean(
    (_a2 = value._refs) == null ? void 0 : _a2[key]
  );
}
function hasReadAccess(value, key) {
  var _a2, _b2;
  return Boolean(
    (_b2 = (_a2 = value._refs) == null ? void 0 : _a2[key]) == null ? void 0 : _b2.hasReadAccess()
  );
}
function isOptionalField(value, key) {
  var _a2;
  return ((_a2 = value._schema[key]) == null ? void 0 : _a2.optional) ?? false;
}
function fulfillsDepth(depth, value) {
  var _a2, _b2;
  if (depth === true || depth === void 0) {
    return {
      status: "fulfilled"
    };
  }
  if (value._type === "CoMap" || value._type === "Group" || value._type === "Account") {
    const map = value;
    if ("$each" in depth) {
      const result = { status: "fulfilled" };
      for (const [key, item] of Object.entries(value)) {
        const rawValue = map._raw.get(key);
        if (rawValue !== void 0 && rawValue !== null) {
          if (!item) {
            if (hasReadAccess(map, key)) {
              result.status = "unfulfilled";
              continue;
            } else {
              return {
                status: "unauthorized",
                path: [key],
                id: rawValue
              };
            }
          }
          const innerResult = fulfillsDepth(depth.$each, item);
          if (innerResult.status === "unfulfilled") {
            result.status = "unfulfilled";
          } else if (innerResult.status === "unauthorized" && !isOptionalField(value, ItemsSym)) {
            innerResult.path.unshift(key);
            return innerResult;
          }
        } else if (!isOptionalField(value, ItemsSym)) {
          return {
            status: "unfulfilled"
          };
        }
      }
      return result;
    } else {
      const result = { status: "fulfilled" };
      for (const key of Object.keys(depth)) {
        const rawValue = map._raw.get(key);
        if (rawValue === void 0 || rawValue === null) {
          if (!((_a2 = map._schema) == null ? void 0 : _a2[key])) {
            if ((_b2 = map._schema) == null ? void 0 : _b2[ItemsSym]) {
              if (isOptionalField(map, ItemsSym)) {
                continue;
              } else {
                throw new Error(
                  `The ref ${key} requested on ${map.constructor.name} is missing`
                );
              }
            } else {
              throw new Error(
                `The ref ${key} requested on ${map.constructor.name} is not defined in the schema`
              );
            }
          } else if (isOptionalField(map, key)) {
            continue;
          } else {
            throw new Error(
              `The ref ${key} on ${map.constructor.name} is required but missing`
            );
          }
        } else {
          const item = value[key];
          if (!item) {
            if (hasReadAccess(map, key)) {
              result.status = "unfulfilled";
              continue;
            } else {
              return {
                status: "unauthorized",
                path: [key],
                id: rawValue
              };
            }
          }
          const innerResult = fulfillsDepth(depth[key], item);
          if (innerResult.status === "unfulfilled") {
            result.status = "unfulfilled";
          } else if (innerResult.status === "unauthorized" && !isOptionalField(value, key)) {
            innerResult.path.unshift(key);
            return innerResult;
          }
        }
      }
      return result;
    }
  } else if (value._type === "CoList") {
    if ("$each" in depth) {
      const result = { status: "fulfilled" };
      const list = value;
      for (const [key, item] of value.entries()) {
        const rawValue = list._raw.get(key);
        if (!rawValue) {
          if (isOptionalField(value, ItemsSym)) {
            continue;
          }
          throw new Error(
            `The ref ${key} on ${list.constructor.name} is required but missing`
          );
        }
        if (hasRefValue(value, key)) {
          if (!item) {
            if (hasReadAccess(value, key)) {
              result.status = "unfulfilled";
              continue;
            } else {
              return {
                status: "unauthorized",
                path: [key.toString()],
                id: value._raw.get(key) ?? "undefined"
              };
            }
          }
          const innerResult = fulfillsDepth(depth.$each, item);
          if (innerResult.status === "unfulfilled") {
            result.status = "unfulfilled";
          } else if (innerResult.status === "unauthorized" && !isOptionalField(value, ItemsSym)) {
            innerResult.path.unshift(key.toString());
            return innerResult;
          }
        } else if (!isOptionalField(value, ItemsSym)) {
          return {
            status: "unfulfilled"
          };
        }
      }
      return result;
    }
    return {
      status: "fulfilled"
    };
  } else if (value._type === "CoStream") {
    if ("$each" in depth) {
      const result = { status: "fulfilled" };
      for (const item of Object.values(value.perSession)) {
        if (item.ref) {
          if (!item.value) {
            if (item.ref.hasReadAccess()) {
              result.status = "unfulfilled";
              continue;
            } else {
              return {
                status: "unauthorized",
                path: [item.ref.id],
                id: item.ref.id
              };
            }
          }
          const innerResult = fulfillsDepth(depth.$each, item.value);
          if (innerResult.status === "unfulfilled") {
            result.status = "unfulfilled";
          } else if (innerResult.status === "unauthorized" && !isOptionalField(value, ItemsSym)) {
            innerResult.path.unshift(item.ref.id);
            return innerResult;
          }
        } else if (!isOptionalField(value, ItemsSym)) {
          return {
            status: "unfulfilled"
          };
        }
      }
      return result;
    }
    return {
      status: "fulfilled"
    };
  } else if (value._type === "BinaryCoStream" || value._type === "CoPlainText") {
    return {
      status: "fulfilled"
    };
  } else {
    console.error(value);
    throw new Error("Unexpected value type: " + value._type);
  }
}
var weakMap = /* @__PURE__ */ new WeakMap();
var coValuesCache = {
  get: (raw, compute) => {
    const cached = weakMap.get(raw);
    if (cached) {
      return cached;
    }
    const computed = compute();
    weakMap.set(raw, computed);
    return computed;
  }
};
var TRACE_ACCESSES = false;
var Ref = class _Ref {
  constructor(id, controlledAccount, schema) {
    this.id = id;
    this.controlledAccount = controlledAccount;
    this.schema = schema;
    if (!isRefEncoded(schema)) {
      throw new Error("Ref must be constructed with a ref schema");
    }
  }
  getNode() {
    return "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
  }
  hasReadAccess() {
    const node = this.getNode();
    const raw = node.getLoaded(this.id);
    if (!raw) {
      return true;
    }
    if (raw instanceof RawAccount || raw instanceof RawGroup) {
      return true;
    }
    const group = raw.core.getGroup();
    if (group instanceof RawAccount) {
      if (node.account.id !== group.id) {
        return false;
      }
    } else if (group.myRole() === void 0) {
      return false;
    }
    return true;
  }
  getValueWithoutAccessCheck() {
    const node = this.getNode();
    const raw = node.getLoaded(this.id);
    if (raw) {
      return coValuesCache.get(
        raw,
        () => instantiateRefEncoded(this.schema, raw)
      );
    } else {
      return null;
    }
  }
  get value() {
    if (!this.hasReadAccess()) {
      return null;
    }
    return this.getValueWithoutAccessCheck();
  }
  async loadHelper() {
    const node = "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
    const raw = await node.load(this.id);
    if (raw === "unavailable") {
      return "unavailable";
    } else {
      return new _Ref(this.id, this.controlledAccount, this.schema).value;
    }
  }
  syncLoad() {
    const node = "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
    const entry = node.coValuesStore.get(
      this.id
    );
    if (entry.highLevelState === "available") {
      return new _Ref(this.id, this.controlledAccount, this.schema).value;
    }
    return void 0;
  }
  async load() {
    const result = await this.loadHelper();
    if (result === "unavailable") {
      return void 0;
    } else {
      return result;
    }
  }
  accessFrom(fromScopeValue, key) {
    const subScope = subscriptionsScopes.get(fromScopeValue);
    subScope == null ? void 0 : subScope.onRefAccessedOrSet(fromScopeValue.id, this.id);
    TRACE_ACCESSES && console.log(subScope == null ? void 0 : subScope.scopeID, "accessing", fromScopeValue, key, this.id);
    if (this.value && subScope) {
      subscriptionsScopes.set(this.value, subScope);
    }
    if (subScope) {
      const cached = subScope.cachedValues[this.id];
      if (cached) {
        TRACE_ACCESSES && console.log("cached", cached);
        return cached;
      } else if (this.value !== null) {
        const freshValueInstance = instantiateRefEncoded(
          this.schema,
          this.value._raw
        );
        TRACE_ACCESSES && console.log("freshValueInstance", freshValueInstance);
        subScope.cachedValues[this.id] = freshValueInstance;
        subscriptionsScopes.set(freshValueInstance, subScope);
        return freshValueInstance;
      } else {
        return null;
      }
    } else {
      return this.value;
    }
  }
};
function makeRefs(getIdForKey, getKeysWithIds, controlledAccount, refSchemaForKey) {
  const refs = {};
  return new Proxy(refs, {
    get(_target, key) {
      if (key === Symbol.iterator) {
        return function* () {
          for (const key2 of getKeysWithIds()) {
            yield new Ref(
              getIdForKey(key2),
              controlledAccount,
              refSchemaForKey(key2)
            );
          }
        };
      }
      if (typeof key === "symbol") return void 0;
      if (key === "length") {
        return getKeysWithIds().length;
      }
      const id = getIdForKey(key);
      if (!id) return void 0;
      return new Ref(
        id,
        controlledAccount,
        refSchemaForKey(key)
      );
    },
    ownKeys() {
      return getKeysWithIds().map((key) => key.toString());
    },
    getOwnPropertyDescriptor(target, key) {
      const id = getIdForKey(key);
      if (id) {
        return {
          enumerable: true,
          configurable: true,
          writable: true
        };
      } else {
        return Reflect.getOwnPropertyDescriptor(target, key);
      }
    }
  });
}
var Encoders = {
  Date: {
    encode: (value) => value.toISOString(),
    decode: (value) => new Date(value)
  },
  OptionalDate: {
    encode: (value) => (value == null ? void 0 : value.toISOString()) || null,
    decode: (value) => value === null ? void 0 : new Date(value)
  }
};
var optional = {
  ref: optionalRef,
  json() {
    return { [SchemaInit]: "json" };
  },
  encoded(arg) {
    return { [SchemaInit]: { encoded: arg } };
  },
  string: {
    [SchemaInit]: "json"
  },
  number: {
    [SchemaInit]: "json"
  },
  boolean: {
    [SchemaInit]: "json"
  },
  null: {
    [SchemaInit]: "json"
  },
  Date: {
    [SchemaInit]: { encoded: Encoders.OptionalDate }
  },
  literal(..._lit) {
    return { [SchemaInit]: "json" };
  }
};
var co = {
  string: {
    [SchemaInit]: "json"
  },
  number: {
    [SchemaInit]: "json"
  },
  boolean: {
    [SchemaInit]: "json"
  },
  null: {
    [SchemaInit]: "json"
  },
  Date: {
    [SchemaInit]: { encoded: Encoders.Date }
  },
  literal(..._lit) {
    return { [SchemaInit]: "json" };
  },
  json() {
    return { [SchemaInit]: "json" };
  },
  encoded(arg) {
    return { [SchemaInit]: { encoded: arg } };
  },
  ref,
  items: ItemsSym,
  optional
};
function optionalRef(arg) {
  return ref(arg, { optional: true });
}
function ref(arg, options) {
  return {
    [SchemaInit]: {
      ref: arg,
      optional: (options == null ? void 0 : options.optional) || false
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  };
}
function isRefEncoded(schema) {
  return typeof schema === "object" && "ref" in schema && "optional" in schema && typeof schema.ref === "function";
}
function instantiateRefEncoded(schema, raw) {
  return isCoValueClass(schema.ref) ? schema.ref.fromRaw(raw) : schema.ref(
    raw
  ).fromRaw(raw);
}
var subscriptionsScopes = /* @__PURE__ */ new WeakMap();
var SubscriptionScope = class {
  constructor(root, rootSchema, onUpdate) {
    this.scopeID = `scope-${Math.random().toString(36).slice(2)}`;
    this.entries = /* @__PURE__ */ new Map();
    this.scheduledUpdate = false;
    this.cachedValues = {};
    this.parents = {};
    this.syncResolution = false;
    this.unsubscribeAll = () => {
      for (const entry of this.entries.values()) {
        if (entry.state === "loaded") {
          entry.rawUnsub();
        } else {
          entry.immediatelyUnsub = true;
        }
      }
      this.entries.clear();
    };
    this.rootEntry = {
      state: "loaded",
      value: root._raw,
      rawUnsub: () => {
      }
      // placeholder
    };
    this.entries.set(root.id, this.rootEntry);
    subscriptionsScopes.set(root, this);
    this.subscriber = root._loadedAs;
    this.scheduleUpdate = () => {
      const value = rootSchema.fromRaw(this.rootEntry.value);
      subscriptionsScopes.set(value, this);
      onUpdate(value, this);
    };
    this.rootEntry.rawUnsub = root._raw.core.subscribe(
      (rawUpdate) => {
        if (!rawUpdate) return;
        this.rootEntry.value = rawUpdate;
        this.scheduleUpdate();
      }
    );
  }
  onRefAccessedOrSet(fromId, accessedOrSetId) {
    if (!accessedOrSetId) {
      return;
    }
    this.parents[accessedOrSetId] = this.parents[accessedOrSetId] || /* @__PURE__ */ new Set();
    this.parents[accessedOrSetId].add(fromId);
    if (!this.entries.has(accessedOrSetId)) {
      const loadingEntry = {
        state: "loading",
        immediatelyUnsub: false
      };
      this.entries.set(accessedOrSetId, loadingEntry);
      const node = this.subscriber._type === "Account" ? this.subscriber._raw.core.node : this.subscriber.node;
      loadCoValue(
        node,
        accessedOrSetId,
        (core) => {
          if (loadingEntry.state === "loading" && loadingEntry.immediatelyUnsub) {
            return;
          }
          if (core !== "unavailable") {
            const entry = {
              state: "loaded",
              rawUnsub: () => {
              }
              // placeholder
            };
            this.entries.set(accessedOrSetId, entry);
            const rawUnsub = core.subscribe((rawUpdate) => {
              if (!rawUpdate) return;
              this.invalidate(accessedOrSetId);
              this.scheduleUpdate();
            });
            entry.rawUnsub = rawUnsub;
          }
        },
        this.syncResolution
      );
    }
  }
  invalidate(id, seen = /* @__PURE__ */ new Set()) {
    if (seen.has(id)) return;
    delete this.cachedValues[id];
    seen.add(id);
    for (const parent of this.parents[id] || []) {
      this.invalidate(parent, seen);
    }
  }
};
function loadCoValue(node, id, callback, syncResolution) {
  const entry = node.coValuesStore.get(id);
  if (entry.isAvailable() && syncResolution) {
    callback(entry.core);
  } else {
    void node.loadCoValueCore(id).then((core) => {
      callback(core);
    });
  }
}
var RegisteredSchemas = {};
async function randomSessionProvider(accountID, crypto3) {
  return {
    sessionID: crypto3.newRandomSessionID(accountID),
    sessionDone: () => {
    }
  };
}
async function createJazzContextFromExistingCredentials({
  credentials,
  peersToLoadFrom,
  crypto: crypto3,
  AccountSchema: PropsAccountSchema,
  sessionProvider,
  onLogOut
}) {
  const { sessionID, sessionDone } = await sessionProvider(
    credentials.accountID,
    crypto3
  );
  const CurrentAccountSchema = PropsAccountSchema ?? RegisteredSchemas["Account"];
  const node = await LocalNode.withLoadedAccount({
    accountID: credentials.accountID,
    accountSecret: credentials.secret,
    sessionID,
    peersToLoadFrom,
    crypto: crypto3,
    migration: async (rawAccount, _node, creationProps) => {
      const account2 = new CurrentAccountSchema({
        fromRaw: rawAccount
      });
      activeAccountContext.set(account2);
      await account2.applyMigration(creationProps);
    }
  });
  const account = CurrentAccountSchema.fromNode(node);
  activeAccountContext.set(account);
  return {
    node,
    account,
    done: () => {
      node.gracefulShutdown();
      sessionDone();
    },
    logOut: async () => {
      node.gracefulShutdown();
      sessionDone();
      await (onLogOut == null ? void 0 : onLogOut());
    }
  };
}
async function createJazzContextForNewAccount({
  creationProps,
  initialAgentSecret,
  peersToLoadFrom,
  crypto: crypto3,
  AccountSchema: PropsAccountSchema,
  onLogOut
}) {
  const CurrentAccountSchema = PropsAccountSchema ?? RegisteredSchemas["Account"];
  const { node } = await LocalNode.withNewlyCreatedAccount({
    creationProps,
    peersToLoadFrom,
    crypto: crypto3,
    initialAgentSecret,
    migration: async (rawAccount, _node, creationProps2) => {
      const account2 = new CurrentAccountSchema({
        fromRaw: rawAccount
      });
      activeAccountContext.set(account2);
      await account2.applyMigration(creationProps2);
    }
  });
  const account = CurrentAccountSchema.fromNode(node);
  activeAccountContext.set(account);
  return {
    node,
    account,
    done: () => {
      node.gracefulShutdown();
    },
    logOut: async () => {
      node.gracefulShutdown();
      await (onLogOut == null ? void 0 : onLogOut());
    }
  };
}
async function createJazzContext(options) {
  var _a2, _b2;
  const crypto3 = options.crypto;
  let context2;
  const authSecretStorage = options.authSecretStorage;
  await authSecretStorage.migrate();
  const credentials = options.credentials ?? await authSecretStorage.get();
  if (credentials && !options.newAccountProps) {
    context2 = await createJazzContextFromExistingCredentials({
      credentials: {
        accountID: credentials.accountID,
        secret: credentials.accountSecret
      },
      peersToLoadFrom: options.peersToLoadFrom,
      crypto: crypto3,
      AccountSchema: options.AccountSchema,
      sessionProvider: options.sessionProvider,
      onLogOut: () => {
        authSecretStorage.clearWithoutNotify();
      }
    });
  } else {
    const secretSeed = options.crypto.newRandomSecretSeed();
    const initialAgentSecret = ((_a2 = options.newAccountProps) == null ? void 0 : _a2.secret) ?? crypto3.agentSecretFromSecretSeed(secretSeed);
    const creationProps = ((_b2 = options.newAccountProps) == null ? void 0 : _b2.creationProps) ?? {
      name: options.defaultProfileName ?? "Anonymous user"
    };
    context2 = await createJazzContextForNewAccount({
      creationProps,
      initialAgentSecret,
      peersToLoadFrom: options.peersToLoadFrom,
      crypto: crypto3,
      AccountSchema: options.AccountSchema,
      onLogOut: async () => {
        await authSecretStorage.clearWithoutNotify();
      }
    });
    if (!options.newAccountProps) {
      await authSecretStorage.setWithoutNotify({
        accountID: context2.account.id,
        secretSeed,
        accountSecret: context2.node.account.agentSecret,
        provider: "anonymous"
      });
    }
  }
  return {
    ...context2,
    authSecretStorage
  };
}
async function createAnonymousJazzContext({
  peersToLoadFrom,
  crypto: crypto3
}) {
  const agentSecret = crypto3.newRandomAgentSecret();
  const rawAgent = new ControlledAgent(agentSecret, crypto3);
  const node = new LocalNode(
    rawAgent,
    crypto3.newRandomSessionID(rawAgent.id),
    crypto3
  );
  for (const peer of peersToLoadFrom) {
    node.syncManager.addPeer(peer);
  }
  activeAccountContext.setGuestMode();
  return {
    agent: new AnonymousJazzAgent(node),
    done: () => {
    },
    logOut: async () => {
    }
  };
}
globalThis.devtoolsFormatters = [
  {
    header: (object) => {
      var _a2;
      if (object._type === "CoMap") {
        return ["div", {}, ["span", {}, object.constructor.name]];
      } else if (object._type === "CoList") {
        return [
          "div",
          {},
          ["span", {}, object.constructor.name + "(" + object.length + ") "]
        ];
      } else if (object._type === "Account") {
        return [
          "div",
          {},
          [
            "span",
            {},
            object.constructor.name + "(" + ((_a2 = object._refs.profile.value) == null ? void 0 : _a2.name) + (object.isMe ? " ME" : "") + ")"
          ]
        ];
      } else {
        return null;
      }
    },
    hasBody: function() {
      return true;
    },
    body: function(object) {
      if (object._type === "CoMap" || object._type === "Account") {
        return [
          "div",
          { style: "margin-left: 15px" },
          ["div", "id: ", ["object", { object: object.id }]],
          ...Object.entries(object).map(([k, v2]) => [
            "div",
            { style: "white-space: nowrap;" },
            ["span", { style: "font-weight: bold; opacity: 0.6" }, k, ": "],
            ["object", { object: v2 }],
            ...typeof object._schema[k] === "function" ? v2 === null ? [
              [
                "span",
                { style: "opacity: 0.5" },
                ` (pending ${object._schema[k].name} `,
                ["object", { object: object._refs[k] }],
                ")"
              ]
            ] : [] : []
          ])
        ];
      } else if (object._type === "CoList") {
        return [
          "div",
          { style: "margin-left: 15px" },
          ["div", "id: ", ["object", { object: object.id }]],
          ...object.map((v2, i2) => [
            "div",
            { style: "white-space: nowrap;" },
            ["span", { style: "font-weight: bold; opacity: 0.6" }, i2, ": "],
            ["object", { object: v2 }],
            ...typeof object._schema[ItemsSym] === "function" ? v2 === null ? [
              [
                "span",
                { style: "opacity: 0.5" },
                ` (pending ${object._schema[ItemsSym].name} `,
                ["object", { object: object._refs[i2] }],
                ")"
              ]
            ] : [] : []
          ])
        ];
      }
    }
  }
];
function isCoValueClass(value) {
  return typeof value === "function" && value.fromRaw !== void 0;
}
var CoValueBase = class {
  get _owner() {
    const owner = this._raw.group instanceof RawAccount ? RegisteredSchemas["Account"].fromRaw(this._raw.group) : RegisteredSchemas["Group"].fromRaw(this._raw.group);
    const subScope = subscriptionsScopes.get(this);
    if (subScope) {
      subScope.onRefAccessedOrSet(this.id, owner.id);
      subscriptionsScopes.set(owner, subScope);
    }
    return owner;
  }
  /** @private */
  get _loadedAs() {
    const rawAccount = this._raw.core.node.account;
    if (rawAccount instanceof RawAccount) {
      return coValuesCache.get(
        rawAccount,
        () => RegisteredSchemas["Account"].fromRaw(rawAccount)
      );
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(..._args) {
    Object.defineProperty(this, "_instanceID", {
      value: `instance-${Math.random().toString(36).slice(2)}`,
      enumerable: false
    });
  }
  /** @category Internals */
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    return {
      id: this.id,
      type: this._type,
      error: "unknown CoValue class"
    };
  }
  [inspect]() {
    return this.toJSON();
  }
  /** @category Type Helpers */
  castAs(cl) {
    const casted = cl.fromRaw(this._raw);
    const subscriptionScope = subscriptionsScopes.get(this);
    if (subscriptionScope) {
      subscriptionsScopes.set(casted, subscriptionScope);
    }
    return casted;
  }
};
function loadCoValueWithoutMe(cls, id, options) {
  return loadCoValue2(cls, id, {
    ...options,
    loadAs: (options == null ? void 0 : options.loadAs) ?? activeAccountContext.get()
  });
}
function loadCoValue2(cls, id, options) {
  return new Promise((resolve) => {
    subscribeToCoValue(
      cls,
      id,
      {
        resolve: options.resolve,
        loadAs: options.loadAs,
        onUnavailable: () => {
          resolve(null);
        },
        onUnauthorized: () => {
          resolve(null);
        }
      },
      (value, unsubscribe) => {
        resolve(value);
        unsubscribe();
      }
    );
  });
}
async function ensureCoValueLoaded(existing, options) {
  const response = await loadCoValue2(
    existing.constructor,
    existing.id,
    {
      loadAs: existing._loadedAs,
      resolve: options == null ? void 0 : options.resolve
    }
  );
  if (!response) {
    throw new Error("Failed to deeply load CoValue " + existing.id);
  }
  return response;
}
function parseSubscribeRestArgs(args) {
  if (args.length === 2) {
    if (typeof args[0] === "object" && args[0] && typeof args[1] === "function") {
      return {
        options: {
          resolve: args[0].resolve,
          loadAs: args[0].loadAs,
          onUnauthorized: args[0].onUnauthorized,
          onUnavailable: args[0].onUnavailable
        },
        listener: args[1]
      };
    } else {
      throw new Error("Invalid arguments");
    }
  } else {
    if (typeof args[0] === "function") {
      return { options: {}, listener: args[0] };
    } else {
      throw new Error("Invalid arguments");
    }
  }
}
function subscribeToCoValueWithoutMe(cls, id, options, listener) {
  return subscribeToCoValue(
    cls,
    id,
    {
      ...options,
      loadAs: options.loadAs ?? activeAccountContext.get()
    },
    listener
  );
}
function subscribeToCoValue(cls, id, options, listener) {
  const ref2 = new Ref(id, options.loadAs, { ref: cls, optional: false });
  let unsubscribed = false;
  let unsubscribe;
  function subscribe() {
    var _a2;
    const value = ref2.getValueWithoutAccessCheck();
    if (!value) {
      (_a2 = options.onUnavailable) == null ? void 0 : _a2.call(options);
      return;
    }
    if (unsubscribed) return;
    const subscription = new SubscriptionScope(
      value,
      cls,
      (update, subscription2) => {
        var _a3, _b2, _c;
        if (subscription2.syncResolution) return;
        if (!ref2.hasReadAccess()) {
          console.error(
            "Not enough permissions to load / subscribe to CoValue",
            id
          );
          (_a3 = options.onUnauthorized) == null ? void 0 : _a3.call(options, []);
          return;
        }
        let result;
        try {
          subscription2.syncResolution = true;
          result = fulfillsDepth(options.resolve, update);
        } catch (e2) {
          console.error(
            "Failed to load / subscribe to CoValue",
            e2,
            e2 instanceof Error ? e2.stack : void 0
          );
          (_b2 = options.onUnavailable) == null ? void 0 : _b2.call(options);
          return;
        } finally {
          subscription2.syncResolution = false;
        }
        if (result.status === "unauthorized") {
          console.error(
            "Not enough permissions to load / subscribe to CoValue",
            id,
            "on path",
            result.path.join("."),
            "unaccessible value:",
            result.id
          );
          (_c = options.onUnauthorized) == null ? void 0 : _c.call(options, result.path);
          return;
        }
        if (result.status === "fulfilled") {
          listener(update, subscription2.unsubscribeAll);
        }
      }
    );
    unsubscribe = subscription.unsubscribeAll;
  }
  const sync = options.syncResolution ? ref2.syncLoad() : void 0;
  if (sync) {
    subscribe();
  } else {
    ref2.load().then(() => subscribe()).catch((e2) => {
      var _a2;
      console.error(
        "Failed to load / subscribe to CoValue",
        e2,
        e2 instanceof Error ? e2.stack : void 0
      );
      (_a2 = options.onUnavailable) == null ? void 0 : _a2.call(options);
    });
  }
  return function unsubscribeAtAnyPoint() {
    unsubscribed = true;
    unsubscribe && unsubscribe();
  };
}
function createCoValueObservable(initialValue = void 0) {
  let currentValue = initialValue;
  let subscriberCount = 0;
  function subscribe(cls, id, options, listener) {
    subscriberCount++;
    const unsubscribe = subscribeToCoValue(
      cls,
      id,
      {
        loadAs: options.loadAs,
        resolve: options.resolve,
        onUnavailable: () => {
          var _a2;
          currentValue = null;
          (_a2 = options.onUnavailable) == null ? void 0 : _a2.call(options);
        },
        onUnauthorized: () => {
          var _a2;
          currentValue = null;
          (_a2 = options.onUnauthorized) == null ? void 0 : _a2.call(options);
        },
        syncResolution: options.syncResolution
      },
      (value) => {
        currentValue = value;
        listener();
      }
    );
    return () => {
      unsubscribe();
      subscriberCount--;
      if (subscriberCount === 0) {
        currentValue = void 0;
      }
    };
  }
  const observable = {
    getCurrentValue: () => currentValue,
    subscribe
  };
  return observable;
}
function subscribeToExistingCoValue(existing, options, listener) {
  return subscribeToCoValue(
    existing.constructor,
    existing.id,
    {
      loadAs: existing._loadedAs,
      resolve: options == null ? void 0 : options.resolve,
      onUnavailable: options == null ? void 0 : options.onUnavailable,
      onUnauthorized: options == null ? void 0 : options.onUnauthorized
    },
    listener
  );
}
function isAccountInstance(instance) {
  if (typeof instance !== "object" || instance === null) {
    return false;
  }
  return "_type" in instance && instance._type === "Account";
}
function parseCoValueCreateOptions(options) {
  const Group2 = RegisteredSchemas["Group"];
  if (!options) {
    return { owner: Group2.create(), uniqueness: void 0 };
  }
  if ("_type" in options) {
    if (options._type === "Account" || options._type === "Group") {
      return { owner: options, uniqueness: void 0 };
    }
  }
  const uniqueness = options.unique ? { uniqueness: options.unique } : void 0;
  return {
    owner: options.owner ?? Group2.create(),
    uniqueness
  };
}
function parseGroupCreateOptions(options) {
  if (!options) {
    return { owner: activeAccountContext.get() };
  }
  return "_type" in options && isAccountInstance(options) ? { owner: options } : { owner: options.owner ?? activeAccountContext.get() };
}
function createInboxRoot(account) {
  if (!account.isLocalNodeOwner) {
    throw new Error("Account is not controlled");
  }
  const rawAccount = account._raw;
  const group = rawAccount.createGroup();
  const messagesFeed = group.createStream();
  const inboxRoot = rawAccount.createMap();
  const processedFeed = rawAccount.createStream();
  const failedFeed = rawAccount.createStream();
  const inviteLink = `${messagesFeed.id}/${group.createInvite("writeOnly")}`;
  inboxRoot.set("messages", messagesFeed.id);
  inboxRoot.set("processed", processedFeed.id);
  inboxRoot.set("failed", failedFeed.id);
  return {
    id: inboxRoot.id,
    inviteLink
  };
}
async function createInboxMessage(payload, inboxOwner) {
  const group = payload._raw.group;
  if (group instanceof RawAccount) {
    throw new Error("Inbox messages should be owned by a group");
  }
  group.addMember(inboxOwner, "writer");
  const message = group.createMap({
    payload: payload.id,
    result: void 0,
    processed: false,
    error: void 0
  });
  await payload._raw.core.waitForSync();
  await message.core.waitForSync();
  return message;
}
var Inbox = class _Inbox {
  constructor(account, root, messages, processed, failed) {
    this.processing = /* @__PURE__ */ new Set();
    this.account = account;
    this.root = root;
    this.messages = messages;
    this.processed = processed;
    this.failed = failed;
  }
  subscribe(Schema, callback, options = {}) {
    const processed = /* @__PURE__ */ new Set();
    const failed = /* @__PURE__ */ new Map();
    const node = this.account._raw.core.node;
    this.processed.subscribe((stream) => {
      for (const items of Object.values(stream.items)) {
        for (const item of items) {
          processed.add(item.value);
        }
      }
    });
    const { account } = this;
    const { retries = 3 } = options;
    let failTimer = void 0;
    const clearFailTimer = () => {
      clearTimeout(failTimer);
      failTimer = void 0;
    };
    const handleNewMessages = (stream) => {
      clearFailTimer();
      for (const [sessionID, items] of Object.entries(stream.items)) {
        const accountID = getAccountIDfromSessionID(sessionID);
        if (!accountID) {
          console.warn("Received message from unknown account", sessionID);
          continue;
        }
        for (const item of items) {
          const txKey = `${sessionID}/${item.tx.txIndex}`;
          if (!processed.has(txKey) && !this.processing.has(txKey)) {
            this.processing.add(txKey);
            const id = item.value;
            node.load(id).then((message) => {
              if (message === "unavailable") {
                return Promise.reject(
                  new Error("Unable to load inbox message " + id)
                );
              }
              return loadCoValue2(Schema, message.get("payload"), {
                loadAs: account
              });
            }).then((value) => {
              if (!value) {
                return Promise.reject(
                  new Error("Unable to load inbox message " + id)
                );
              }
              return callback(value, accountID);
            }).then((result) => {
              const inboxMessage = node.expectCoValueLoaded(item.value).getCurrentContent();
              if (result) {
                inboxMessage.set("result", result.id);
              }
              inboxMessage.set("processed", true);
              this.processed.push(txKey);
              this.processing.delete(txKey);
            }).catch((error) => {
              console.error("Error processing inbox message", error);
              this.processing.delete(txKey);
              const errors = failed.get(txKey) ?? [];
              const stringifiedError = String(error);
              errors.push(stringifiedError);
              let inboxMessage;
              try {
                inboxMessage = node.expectCoValueLoaded(item.value).getCurrentContent();
                inboxMessage.set("error", stringifiedError);
              } catch (error2) {
              }
              if (errors.length > retries) {
                inboxMessage == null ? void 0 : inboxMessage.set("processed", true);
                this.processed.push(txKey);
                this.failed.push({ errors, value: item.value });
              } else {
                failed.set(txKey, errors);
                if (!failTimer) {
                  failTimer = setTimeout(
                    () => handleNewMessages(stream),
                    100
                  );
                }
              }
            });
          }
        }
      }
    };
    const unsubscribe = this.messages.subscribe(handleNewMessages);
    return () => {
      unsubscribe();
      clearFailTimer();
    };
  }
  static async load(account) {
    const profile = account.profile;
    if (!profile) {
      throw new Error("Account profile should already be loaded");
    }
    if (!profile.inbox) {
      throw new Error("The account has not set up their inbox");
    }
    const node = account._raw.core.node;
    const root = await node.load(profile.inbox);
    if (root === "unavailable") {
      throw new Error("Inbox not found");
    }
    const [messages, processed, failed] = await Promise.all([
      node.load(root.get("messages")),
      node.load(root.get("processed")),
      node.load(root.get("failed"))
    ]);
    if (messages === "unavailable" || processed === "unavailable" || failed === "unavailable") {
      throw new Error("Inbox not found");
    }
    return new _Inbox(account, root, messages, processed, failed);
  }
};
var InboxSender = class _InboxSender {
  constructor(currentAccount, owner, messages) {
    this.currentAccount = currentAccount;
    this.owner = owner;
    this.messages = messages;
  }
  getOwnerAccount() {
    return this.owner;
  }
  async sendMessage(message) {
    const inboxMessage = await createInboxMessage(message, this.owner);
    this.messages.push(inboxMessage.id);
    return new Promise((resolve, reject) => {
      inboxMessage.subscribe((message2) => {
        if (message2.get("processed")) {
          const error = message2.get("error");
          if (error) {
            reject(new Error(error));
          } else {
            resolve(
              message2.get("result")
            );
          }
        }
      });
    });
  }
  static async load(inboxOwnerID, currentAccount) {
    currentAccount || (currentAccount = activeAccountContext.get());
    const node = currentAccount._raw.core.node;
    const inboxOwnerRaw = await node.load(
      inboxOwnerID
    );
    if (inboxOwnerRaw === "unavailable") {
      throw new Error("Failed to load the inbox owner");
    }
    const inboxOwnerProfileRaw = await node.load(inboxOwnerRaw.get("profile"));
    if (inboxOwnerProfileRaw === "unavailable") {
      throw new Error("Failed to load the inbox owner profile");
    }
    if (inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "reader" && inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "writer" && inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "admin") {
      throw new Error(
        "Insufficient permissions to access the inbox, make sure its user profile is publicly readable."
      );
    }
    const inboxInvite = inboxOwnerProfileRaw.get("inboxInvite");
    if (!inboxInvite) {
      throw new Error("The user has not set up their inbox");
    }
    const id = await acceptInvite(inboxInvite, currentAccount);
    const messages = await node.load(id);
    if (messages === "unavailable") {
      throw new Error("Inbox not found");
    }
    return new _InboxSender(currentAccount, inboxOwnerRaw, messages);
  }
};
async function acceptInvite(invite, account) {
  account || (account = activeAccountContext.get());
  const id = invite.slice(0, invite.indexOf("/"));
  const inviteSecret = invite.slice(invite.indexOf("/") + 1);
  if (!(id == null ? void 0 : id.startsWith("co_z")) || !inviteSecret.startsWith("inviteSecret_")) {
    throw new Error("Invalid inbox ticket");
  }
  if (!account.isLocalNodeOwner) {
    throw new Error("Account is not controlled");
  }
  await account._raw.acceptInvite(id, inviteSecret);
  return id;
}
function getAccountIDfromSessionID(sessionID) {
  const until = sessionID.indexOf("_session");
  const accountID = sessionID.slice(0, until);
  if (accountID.startsWith("co_z")) {
    return accountID;
  }
  return;
}
var _CoMap = class _CoMap2 extends CoValueBase {
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /**
   * If property `prop` is a `co.ref(...)`, you can use `coMaps._refs.prop` to access
   * the `Ref` instead of the potentially loaded/null value.
   *
   * This allows you to always get the ID or load the value manually.
   *
   * @example
   * ```ts
   * person._refs.pet.id; // => ID<Animal>
   * person._refs.pet.value;
   * // => Animal | null
   * const pet = await person._refs.pet.load();
   * ```
   *
   * @category Content
   **/
  get _refs() {
    return makeRefs(
      (key) => this._raw.get(key),
      () => {
        const keys = this._raw.keys().filter((key) => {
          const schema = this._schema[key] || this._schema[ItemsSym];
          return schema && schema !== "json" && isRefEncoded(schema);
        });
        return keys;
      },
      this._loadedAs,
      (key) => this._schema[key] || this._schema[ItemsSym]
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    );
  }
  /** @internal */
  getEditFromRaw(target, rawEdit, descriptor, key) {
    return {
      value: descriptor === "json" ? rawEdit.value : "encoded" in descriptor ? rawEdit.value === null || rawEdit.value === void 0 ? rawEdit.value : descriptor.encoded.decode(rawEdit.value) : new Ref(
        rawEdit.value,
        target._loadedAs,
        descriptor
      ).accessFrom(target, "_edits." + key + ".value"),
      ref: descriptor !== "json" && isRefEncoded(descriptor) ? new Ref(rawEdit.value, target._loadedAs, descriptor) : void 0,
      by: rawEdit.by && new Ref(rawEdit.by, target._loadedAs, {
        ref: RegisteredSchemas["Account"],
        optional: false
      }).accessFrom(target, "_edits." + key + ".by"),
      madeAt: rawEdit.at,
      key
    };
  }
  /** @category Collaboration */
  get _edits() {
    const map = this;
    return new Proxy(
      {},
      {
        get(_target, key) {
          const rawEdit = map._raw.lastEditAt(key);
          if (!rawEdit) return void 0;
          const descriptor = map._schema[key];
          return {
            ...map.getEditFromRaw(map, rawEdit, descriptor, key),
            get all() {
              return [...map._raw.editsAt(key)].map(
                (rawEdit2) => map.getEditFromRaw(map, rawEdit2, descriptor, key)
              );
            }
          };
        },
        ownKeys(_target) {
          return map._raw.keys();
        },
        getOwnPropertyDescriptor(target, key) {
          return {
            value: Reflect.get(target, key),
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    );
  }
  /** @internal */
  constructor(options) {
    super();
    if (options) {
      if ("fromRaw" in options) {
        Object.defineProperties(this, {
          id: {
            value: options.fromRaw.id,
            enumerable: false
          },
          _raw: { value: options.fromRaw, enumerable: false }
        });
      } else {
        throw new Error("Invalid CoMap constructor arguments");
      }
    }
    return new Proxy(this, CoMapProxyHandler);
  }
  /**
   * Create a new CoMap with the given initial values and owner.
   *
   * The owner (a Group or Account) determines access rights to the CoMap.
   *
   * The CoMap will immediately be persisted and synced to connected peers.
   *
   * @example
   * ```ts
   * const person = Person.create({
   *   name: "Alice",
   *   age: 42,
   *   pet: cat,
   * }, { owner: friendGroup });
   * ```
   *
   * @category Creation
   **/
  static create(init, options) {
    const instance = new this();
    const { owner, uniqueness } = parseCoValueCreateOptions(options);
    const raw = instance.rawFromInit(init, owner, uniqueness);
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return instance;
  }
  /**
   * Return a JSON representation of the `CoMap`
   * @category Content
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON(_key, processedValues) {
    const result = {
      id: this.id,
      _type: this._type
    };
    for (const key of this._raw.keys()) {
      const tKey = key;
      const descriptor = this._schema[tKey] || this._schema[ItemsSym];
      if (!descriptor) {
        continue;
      }
      if (descriptor == "json" || "encoded" in descriptor) {
        result[key] = this._raw.get(key);
      } else if (isRefEncoded(descriptor)) {
        const id = this._raw.get(key);
        if ((processedValues == null ? void 0 : processedValues.includes(id)) || id === this.id) {
          result[key] = { _circular: id };
          continue;
        }
        const ref2 = this[tKey];
        if (ref2 && typeof ref2 === "object" && "toJSON" in ref2 && typeof ref2.toJSON === "function") {
          const jsonedRef = ref2.toJSON(tKey, [
            ...processedValues || [],
            this.id
          ]);
          result[key] = jsonedRef;
        }
      } else {
        result[key] = void 0;
      }
    }
    return result;
  }
  [inspect]() {
    return this.toJSON();
  }
  /**
   * Create a new `RawCoMap` from an initialization object
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  rawFromInit(init, owner, uniqueness) {
    const rawOwner = owner._raw;
    const rawInit = {};
    if (init)
      for (const key of Object.keys(init)) {
        const initValue = init[key];
        const descriptor = this._schema[key] || this._schema[ItemsSym];
        if (!descriptor) {
          continue;
        }
        if (descriptor === "json") {
          rawInit[key] = initValue;
        } else if (isRefEncoded(descriptor)) {
          if (initValue) {
            rawInit[key] = initValue.id;
          }
        } else if ("encoded" in descriptor) {
          rawInit[key] = descriptor.encoded.encode(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            initValue
          );
        }
      }
    return rawOwner.createMap(rawInit, null, "private", uniqueness);
  }
  /**
   * Declare a Record-like CoMap schema, by extending `CoMap.Record(...)` and passing the value schema using `co`. Keys are always `string`.
   *
   * @example
   * ```ts
   * import { co, CoMap } from "jazz-tools";
   *
   * class ColorToFruitMap extends CoMap.Record(
   *  co.ref(Fruit)
   * ) {}
   *
   * // assume we have map: ColorToFruitMap
   * // and strawberry: Fruit
   * map["red"] = strawberry;
   * ```
   *
   * @category Declaration
   */
  static Record(value) {
    var _a2, _b2;
    class RecordLikeCoMap extends (_b2 = _CoMap2, _a2 = ItemsSym, _b2) {
      constructor() {
        super(...arguments);
        this[_a2] = value;
      }
    }
    return RecordLikeCoMap;
  }
  /**
   * Load a `CoMap` with a given ID, as a given account.
   *
   * `depth` specifies which (if any) fields that reference other CoValues to load as well before resolving.
   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.
   *
   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.
   *
   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.
   *
   * @example
   * ```ts
   * const person = await Person.load(
   *   "co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax",
   *   { pet: {} }
   * );
   * ```
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  static findUnique(unique, ownerID, as) {
    as || (as = activeAccountContext.get());
    const header = {
      type: "comap",
      ruleset: {
        type: "ownedByGroup",
        group: ownerID
      },
      meta: null,
      uniqueness: unique
    };
    const crypto3 = as._type === "Anonymous" ? as.node.crypto : as._raw.core.crypto;
    return cojsonInternals.idforHeader(header, crypto3);
  }
  /**
   * Given an already loaded `CoMap`, ensure that the specified fields are loaded to the specified depth.
   *
   * Works like `CoMap.load()`, but you don't need to pass the ID or the account to load as again.
   *
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  applyDiff(newValues) {
    for (const key in newValues) {
      if (Object.prototype.hasOwnProperty.call(newValues, key)) {
        const tKey = key;
        const descriptor = this._schema[tKey] || this._schema[ItemsSym];
        if (tKey in this._schema) {
          const newValue = newValues[tKey];
          const currentValue = this[tKey];
          if (descriptor === "json" || "encoded" in descriptor) {
            if (currentValue !== newValue) {
              this[tKey] = newValue;
            }
          } else if (isRefEncoded(descriptor)) {
            const currentId = currentValue == null ? void 0 : currentValue.id;
            const newId = newValue == null ? void 0 : newValue.id;
            if (currentId !== newId) {
              this[tKey] = newValue;
            }
          }
        }
      }
    }
    return this;
  }
  /**
   * Wait for the `CoMap` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoMap.prototype._type = "CoMap";
var CoMap = _CoMap;
var CoMapProxyHandler = {
  get(target, key, receiver) {
    if (key === "_schema") {
      return Reflect.get(target, key);
    } else if (key in target) {
      return Reflect.get(target, key, receiver);
    } else {
      const schema = target._schema;
      if (!schema) {
        return void 0;
      }
      const descriptor = schema[key] || schema[ItemsSym];
      if (descriptor && typeof key === "string") {
        const raw = target._raw.get(key);
        if (descriptor === "json") {
          return raw;
        } else if ("encoded" in descriptor) {
          return raw === void 0 ? void 0 : descriptor.encoded.decode(raw);
        } else if (isRefEncoded(descriptor)) {
          return raw === void 0 ? void 0 : new Ref(
            raw,
            target._loadedAs,
            descriptor
          ).accessFrom(receiver, key);
        }
      } else {
        return void 0;
      }
    }
  },
  set(target, key, value, receiver) {
    var _a2, _b2;
    if ((typeof key === "string" || ItemsSym) && typeof value === "object" && value !== null && SchemaInit in value) {
      (_a2 = target.constructor)._schema || (_a2._schema = {});
      target.constructor._schema[key] = value[SchemaInit];
      return true;
    }
    const descriptor = target._schema[key] || target._schema[ItemsSym];
    if (descriptor && typeof key === "string") {
      if (descriptor === "json") {
        target._raw.set(key, value);
      } else if ("encoded" in descriptor) {
        target._raw.set(key, descriptor.encoded.encode(value));
      } else if (isRefEncoded(descriptor)) {
        if (value === null) {
          if (descriptor.optional) {
            target._raw.set(key, null);
          } else {
            throw new Error(`Cannot set required reference ${key} to null`);
          }
        } else if (value == null ? void 0 : value.id) {
          target._raw.set(key, value.id);
          (_b2 = subscriptionsScopes.get(target)) == null ? void 0 : _b2.onRefAccessedOrSet(target.id, value.id);
        } else {
          throw new Error(
            `Cannot set reference ${key} to a non-CoValue. Got ${value}`
          );
        }
      }
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, attributes) {
    var _a2;
    if ("value" in attributes && typeof attributes.value === "object" && SchemaInit in attributes.value) {
      (_a2 = target.constructor)._schema || (_a2._schema = {});
      target.constructor._schema[key] = attributes.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, attributes);
    }
  },
  ownKeys(target) {
    const keys = Reflect.ownKeys(target).filter((k) => k !== ItemsSym);
    for (const key of target._raw.keys()) {
      if (!keys.includes(key)) {
        keys.push(key);
      }
    }
    return keys;
  },
  getOwnPropertyDescriptor(target, key) {
    if (key in target) {
      return Reflect.getOwnPropertyDescriptor(target, key);
    } else {
      const descriptor = target._schema[key] || target._schema[ItemsSym];
      if (descriptor || key in target._raw.latest) {
        return {
          enumerable: true,
          configurable: true,
          writable: true
        };
      }
    }
  },
  has(target, key) {
    var _a2, _b2;
    const descriptor = ((_a2 = target._schema) == null ? void 0 : _a2[key]) || ((_b2 = target._schema) == null ? void 0 : _b2[ItemsSym]);
    if (target._raw && typeof key === "string" && descriptor) {
      return target._raw.get(key) !== void 0;
    } else {
      return Reflect.has(target, key);
    }
  },
  deleteProperty(target, key) {
    const descriptor = target._schema[key] || target._schema[ItemsSym];
    if (typeof key === "string" && descriptor) {
      target._raw.delete(key);
      return true;
    } else {
      return Reflect.deleteProperty(target, key);
    }
  }
};
RegisteredSchemas["CoMap"] = CoMap;
var Profile = class extends CoMap {
  constructor() {
    super(...arguments);
    this.name = co.string;
    this.inbox = co.optional.json();
    this.inboxInvite = co.optional.json();
  }
  get _owner() {
    return super._owner;
  }
  /**
   * Creates a new profile with the given initial values and owner.
   *
   * The owner (a Group) determines access rights to the Profile.
   *
   * @category Creation
   */
  static create(init, options) {
    const owner = options !== void 0 && "owner" in options ? options.owner : options;
    if ((owner == null ? void 0 : owner._type) === "Account") {
      throw new Error("Profiles should be owned by a group");
    }
    return super.create(init, options);
  }
};
var _Account = class _Account2 extends CoValueBase {
  get _schema() {
    return this.constructor._schema;
  }
  get _owner() {
    return this;
  }
  get _loadedAs() {
    if (this.isLocalNodeOwner) return this;
    const rawAccount = this._raw.core.node.account;
    if (rawAccount instanceof RawAccount) {
      return coValuesCache.get(rawAccount, () => _Account2.fromRaw(rawAccount));
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  get _refs() {
    const profileID = this._raw.get("profile");
    const rootID = this._raw.get("root");
    return {
      profile: profileID && new Ref(
        profileID,
        this._loadedAs,
        this._schema.profile
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ),
      root: rootID && new Ref(
        rootID,
        this._loadedAs,
        this._schema.root
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      )
    };
  }
  /**
   * Whether this account is the currently active account.
   */
  get isMe() {
    return activeAccountContext.get().id === this.id;
  }
  constructor(options) {
    super();
    if (!("fromRaw" in options)) {
      throw new Error("Can only construct account from raw or with .create()");
    }
    this.isLocalNodeOwner = options.fromRaw.id == options.fromRaw.core.node.account.id;
    Object.defineProperties(this, {
      id: {
        value: options.fromRaw.id,
        enumerable: false
      },
      _raw: { value: options.fromRaw, enumerable: false },
      _type: { value: "Account", enumerable: false }
    });
    if (this.isLocalNodeOwner) {
      this.sessionID = options.fromRaw.core.node.currentSessionID;
    }
    return new Proxy(this, AccountAndGroupProxyHandler);
  }
  myRole() {
    if (this.isLocalNodeOwner) {
      return "admin";
    }
  }
  getRoleOf(member) {
    if (member === "me") {
      return this.isMe ? "admin" : void 0;
    }
    if (member === this.id) {
      return "admin";
    }
    return void 0;
  }
  getParentGroups() {
    return [];
  }
  get members() {
    const ref2 = new Ref(this.id, this._loadedAs, {
      ref: () => this.constructor,
      optional: false
    });
    return [{ id: this.id, role: "admin", ref: ref2, account: this }];
  }
  canRead(value) {
    const role = value._owner.getRoleOf(this.id);
    return role === "admin" || role === "writer" || role === "reader" || role === "writeOnly";
  }
  canWrite(value) {
    const role = value._owner.getRoleOf(this.id);
    return role === "admin" || role === "writer" || role === "writeOnly";
  }
  canAdmin(value) {
    return value._owner.getRoleOf(this.id) === "admin";
  }
  async acceptInvite(valueID, inviteSecret, coValueClass) {
    if (!this.isLocalNodeOwner) {
      throw new Error("Only a controlled account can accept invites");
    }
    await this._raw.acceptInvite(
      valueID,
      inviteSecret
    );
    return loadCoValue2(coValueClass, valueID, {
      loadAs: this
    });
  }
  /** @private */
  static async create(options) {
    const { node } = await LocalNode.withNewlyCreatedAccount({
      ...options,
      migration: async (rawAccount, _node, creationProps) => {
        var _a2;
        const account = new this({
          fromRaw: rawAccount
        });
        await ((_a2 = account.applyMigration) == null ? void 0 : _a2.call(account, creationProps));
      }
    });
    return this.fromNode(node);
  }
  static getMe() {
    return activeAccountContext.get();
  }
  static async createAs(as, options) {
    const connectedPeers2 = cojsonInternals.connectedPeers(
      "creatingAccount",
      "createdAccount",
      { peer1role: "server", peer2role: "client" }
    );
    as._raw.core.node.syncManager.addPeer(connectedPeers2[1]);
    const account = await this.create({
      creationProps: options.creationProps,
      crypto: as._raw.core.node.crypto,
      peersToLoadFrom: [connectedPeers2[0]]
    });
    await account.waitForAllCoValuesSync();
    return account;
  }
  static fromNode(node) {
    return new this({
      fromRaw: node.account
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    return {
      id: this.id,
      _type: this._type
    };
  }
  [inspect]() {
    return this.toJSON();
  }
  async applyMigration(creationProps) {
    await this.migrate(creationProps);
    if (this.profile === void 0 && creationProps) {
      const profileGroup = RegisteredSchemas["Group"].create({ owner: this });
      this.profile = Profile.create({ name: creationProps.name }, profileGroup);
      this.profile._owner.addMember("everyone", "reader");
    } else if (this.profile && creationProps) {
      if (this.profile._owner._type !== "Group") {
        throw new Error("Profile must be owned by a Group", {
          cause: `The profile of the account "${this.id}" was created with an Account as owner, which is not allowed.`
        });
      }
    }
    const node = this._raw.core.node;
    const profile = node.expectCoValueLoaded(this._raw.get("profile")).getCurrentContent();
    if (!profile.get("inbox")) {
      const inboxRoot = createInboxRoot(this);
      profile.set("inbox", inboxRoot.id);
      profile.set("inboxInvite", inboxRoot.inviteLink);
    }
  }
  // Placeholder method for subclasses to override
  migrate(creationProps) {
    creationProps;
  }
  /** @category Subscription & Loading */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /** @category Subscription & Loading */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `Account` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
  /**
   * Wait for all the available `CoValues` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForAllCoValuesSync(options) {
    return this._raw.core.node.syncManager.waitForAllCoValuesSync(
      options == null ? void 0 : options.timeout
    );
  }
};
_Account._schema = {
  profile: {
    ref: () => Profile,
    optional: false
  },
  root: {
    ref: () => RegisteredSchemas["CoMap"],
    optional: true
  }
};
var Account = _Account;
var AccountAndGroupProxyHandler = {
  get(target, key, receiver) {
    if (key === "profile") {
      const ref2 = target._refs.profile;
      return ref2 ? ref2.accessFrom(receiver, "profile") : (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        void 0
      );
    } else if (key === "root") {
      const ref2 = target._refs.root;
      return ref2 ? ref2.accessFrom(receiver, "root") : void 0;
    } else {
      return Reflect.get(target, key, receiver);
    }
  },
  set(target, key, value, receiver) {
    var _a2, _b2, _c;
    if ((key === "profile" || key === "root") && typeof value === "object" && SchemaInit in value) {
      (_a2 = target.constructor)._schema || (_a2._schema = {});
      target.constructor._schema[key] = value[SchemaInit];
      return true;
    } else if (key === "profile") {
      if (value) {
        target._raw.set(
          "profile",
          value.id,
          "trusting"
        );
      }
      (_b2 = subscriptionsScopes.get(receiver)) == null ? void 0 : _b2.onRefAccessedOrSet(target.id, value.id);
      return true;
    } else if (key === "root") {
      if (value) {
        target._raw.set("root", value.id);
      }
      (_c = subscriptionsScopes.get(receiver)) == null ? void 0 : _c.onRefAccessedOrSet(target.id, value.id);
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, descriptor) {
    var _a2;
    if ((key === "profile" || key === "root") && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
      (_a2 = target.constructor)._schema || (_a2._schema = {});
      target.constructor._schema[key] = descriptor.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, descriptor);
    }
  }
};
function isControlledAccount(account) {
  return account.isLocalNodeOwner;
}
RegisteredSchemas["Account"] = Account;
var _CoFeed = class _CoFeed2 extends CoValueBase {
  /**
   * Declare a `CoFeed` by subclassing `CoFeed.Of(...)` and passing the item schema using a `co` primitive or a `co.ref`.
   *
   * @example
   * ```ts
   * class ColorFeed extends CoFeed.Of(co.string) {}
   * class AnimalFeed extends CoFeed.Of(co.ref(Animal)) {}
   * ```
   *
   * @category Declaration
   */
  static Of(item) {
    var _a2, _b2;
    return class CoFeedOf extends (_b2 = _CoFeed2, _a2 = co.items, _b2) {
      constructor() {
        super(...arguments);
        this[_a2] = item;
      }
    };
  }
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /**
   * The current account's view of this `CoFeed`
   * @category Content
   */
  get byMe() {
    if (this._loadedAs._type === "Account") {
      return this[this._loadedAs.id];
    } else {
      return void 0;
    }
  }
  /**
   * The current session's view of this `CoFeed`
   *
   * This is a shortcut for `this.perSession` where the session ID is the current session ID.
   *
   * @category Content
   */
  get inCurrentSession() {
    if (this._loadedAs._type === "Account") {
      return this.perSession[this._loadedAs.sessionID];
    } else {
      return void 0;
    }
  }
  constructor(options) {
    super();
    if (options && "fromRaw" in options) {
      Object.defineProperties(this, {
        id: {
          value: options.fromRaw.id,
          enumerable: false
        },
        _raw: { value: options.fromRaw, enumerable: false }
      });
    }
    return new Proxy(this, CoStreamProxyHandler);
  }
  /**
   * Create a new `CoFeed`
   * @category Creation
   */
  static create(init, options) {
    const { owner } = parseCoValueCreateOptions(options);
    const instance = new this({ init, owner });
    const raw = owner._raw.createStream();
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    if (init) {
      instance.push(...init);
    }
    return instance;
  }
  /**
   * Push items to this `CoFeed`
   *
   * Items are appended to the current session's log. Each session (tab, device, app instance)
   * maintains its own append-only log, which is then aggregated into the per-account view.
   *
   * @example
   * ```ts
   * // Adds items to current session's log
   * feed.push("item1", "item2");
   *
   * // View items from current session
   * console.log(feed.inCurrentSession);
   *
   * // View aggregated items from all sessions for current account
   * console.log(feed.byMe);
   * ```
   *
   * @category Content
   */
  push(...items) {
    for (const item of items) {
      this.pushItem(item);
    }
  }
  pushItem(item) {
    const itemDescriptor = this._schema[ItemsSym];
    if (itemDescriptor === "json") {
      this._raw.push(item);
    } else if ("encoded" in itemDescriptor) {
      this._raw.push(itemDescriptor.encoded.encode(item));
    } else if (isRefEncoded(itemDescriptor)) {
      this._raw.push(item.id);
    }
  }
  /**
   * Get a JSON representation of the `CoFeed`
   * @category
   */
  toJSON() {
    const itemDescriptor = this._schema[ItemsSym];
    const mapper = itemDescriptor === "json" ? (v2) => v2 : "encoded" in itemDescriptor ? itemDescriptor.encoded.encode : (v2) => v2 && v2.id;
    return {
      id: this.id,
      _type: this._type,
      ...Object.fromEntries(
        Object.entries(this).map(([account, entry]) => [
          account,
          mapper(entry.value)
        ])
      ),
      in: Object.fromEntries(
        Object.entries(this.perSession).map(([session, entry]) => [
          session,
          mapper(entry.value)
        ])
      )
    };
  }
  /** @internal */
  [(ItemsSym, inspect)]() {
    return this.toJSON();
  }
  /** @internal */
  static schema(def) {
    this._schema || (this._schema = {});
    Object.assign(this._schema, def);
  }
  /**
   * Load a `CoFeed`
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Ensure a `CoFeed` is loaded to the specified depth
   *
   * @returns A new instance of the same CoFeed that's loaded to the specified depth
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `CoFeed` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoFeed.prototype._type = "CoStream";
var CoFeed = _CoFeed;
function entryFromRawEntry(accessFrom, rawEntry, loadedAs, accountID, itemField) {
  return {
    get value() {
      var _a2;
      if (itemField === "json") {
        return rawEntry.value;
      } else if ("encoded" in itemField) {
        return itemField.encoded.decode(rawEntry.value);
      } else if (isRefEncoded(itemField)) {
        return (_a2 = this.ref) == null ? void 0 : _a2.accessFrom(
          accessFrom,
          rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + ".value"
        );
      } else {
        throw new Error("Invalid item field schema");
      }
    },
    get ref() {
      if (itemField !== "json" && isRefEncoded(itemField)) {
        const rawId = rawEntry.value;
        return new Ref(
          rawId,
          loadedAs,
          itemField
        );
      } else {
        return void 0;
      }
    },
    get by() {
      var _a2;
      return accountID && ((_a2 = new Ref(accountID, loadedAs, {
        ref: RegisteredSchemas["Account"],
        optional: false
      })) == null ? void 0 : _a2.accessFrom(
        accessFrom,
        rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + ".by"
      ));
    },
    madeAt: rawEntry.at,
    tx: rawEntry.tx
  };
}
var CoStreamProxyHandler = {
  get(target, key, receiver) {
    if (typeof key === "string" && key.startsWith("co_")) {
      const rawEntry = target._raw.lastItemBy(key);
      if (!rawEntry) return;
      const entry = entryFromRawEntry(
        receiver,
        rawEntry,
        target._loadedAs,
        key,
        target._schema[ItemsSym]
      );
      Object.defineProperty(entry, "all", {
        get: () => {
          const allRawEntries = target._raw.itemsBy(key);
          return function* () {
            while (true) {
              const rawEntry2 = allRawEntries.next();
              if (rawEntry2.done) return;
              yield entryFromRawEntry(
                receiver,
                rawEntry2.value,
                target._loadedAs,
                key,
                target._schema[ItemsSym]
              );
            }
          }();
        }
      });
      return entry;
    } else if (key === "perSession") {
      return new Proxy({}, CoStreamPerSessionProxyHandler(target, receiver));
    } else {
      return Reflect.get(target, key, receiver);
    }
  },
  set(target, key, value, receiver) {
    var _a2;
    if (key === ItemsSym && typeof value === "object" && SchemaInit in value) {
      (_a2 = target.constructor)._schema || (_a2._schema = {});
      target.constructor._schema[ItemsSym] = value[SchemaInit];
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, descriptor) {
    var _a2;
    if (descriptor.value && key === ItemsSym && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
      (_a2 = target.constructor)._schema || (_a2._schema = {});
      target.constructor._schema[ItemsSym] = descriptor.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, descriptor);
    }
  },
  ownKeys(target) {
    const keys = Reflect.ownKeys(target);
    for (const accountID of target._raw.accounts()) {
      keys.push(accountID);
    }
    return keys;
  },
  getOwnPropertyDescriptor(target, key) {
    if (typeof key === "string" && key.startsWith("co_")) {
      return {
        configurable: true,
        enumerable: true,
        writable: false
      };
    } else {
      return Reflect.getOwnPropertyDescriptor(target, key);
    }
  }
};
var CoStreamPerSessionProxyHandler = (innerTarget, accessFrom) => ({
  get(_target, key, receiver) {
    if (typeof key === "string" && key.includes("session")) {
      const sessionID = key;
      const rawEntry = innerTarget._raw.lastItemIn(sessionID);
      if (!rawEntry) return;
      const by = cojsonInternals.accountOrAgentIDfromSessionID(sessionID);
      const entry = entryFromRawEntry(
        accessFrom,
        rawEntry,
        innerTarget._loadedAs,
        cojsonInternals.isAccountID(by) ? by : void 0,
        innerTarget._schema[ItemsSym]
      );
      Object.defineProperty(entry, "all", {
        get: () => {
          const allRawEntries = innerTarget._raw.itemsIn(sessionID);
          return function* () {
            while (true) {
              const rawEntry2 = allRawEntries.next();
              if (rawEntry2.done) return;
              yield entryFromRawEntry(
                accessFrom,
                rawEntry2.value,
                innerTarget._loadedAs,
                cojsonInternals.isAccountID(by) ? by : void 0,
                innerTarget._schema[ItemsSym]
              );
            }
          }();
        }
      });
      return entry;
    } else {
      return Reflect.get(innerTarget, key, receiver);
    }
  },
  ownKeys() {
    return innerTarget._raw.sessions();
  },
  getOwnPropertyDescriptor(target, key) {
    if (typeof key === "string" && key.startsWith("co_")) {
      return {
        configurable: true,
        enumerable: true,
        writable: false
      };
    } else {
      return Reflect.getOwnPropertyDescriptor(target, key);
    }
  }
});
var FileStream = class extends CoValueBase {
  constructor(options) {
    super();
    let raw;
    if ("fromRaw" in options) {
      raw = options.fromRaw;
    } else {
      const rawOwner = options.owner._raw;
      raw = rawOwner.createBinaryStream();
    }
    Object.defineProperties(this, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _type: { value: "BinaryCoStream", enumerable: false },
      _raw: { value: raw, enumerable: false }
    });
  }
  /**
   * Create a new empty `FileStream` instance.
   *
   * @param options - Configuration options for the new FileStream
   * @param options.owner - The Account or Group that will own this FileStream and control access rights
   *
   * @example
   * ```typescript
   * // Create owned by an account
   * const stream = FileStream.create({ owner: myAccount });
   *
   * // Create owned by a group
   * const stream = FileStream.create({ owner: teamGroup });
   *
   * // Create with implicit owner
   * const stream = FileStream.create(myAccount);
   * ```
   *
   * @remarks
   * For uploading an existing file or blob, use {@link FileStream.createFromBlob} instead.
   *
   * @category Creation
   */
  static create(options) {
    return new this(parseCoValueCreateOptions(options));
  }
  getChunks(options) {
    return this._raw.getBinaryChunks(options == null ? void 0 : options.allowUnfinished);
  }
  isBinaryStreamEnded() {
    return this._raw.isBinaryStreamEnded();
  }
  start(options) {
    this._raw.startBinaryStream(options);
  }
  push(data) {
    this._raw.pushBinaryStreamChunk(data);
  }
  end() {
    this._raw.endBinaryStream();
  }
  toBlob(options) {
    const chunks = this.getChunks({
      allowUnfinished: options == null ? void 0 : options.allowUnfinished
    });
    if (!chunks) {
      return void 0;
    }
    return new Blob(chunks.chunks, { type: chunks.mimeType });
  }
  /**
   * Load a `FileStream` as a `Blob`
   *
   * @category Content
   */
  static async loadAsBlob(id, options) {
    let stream = await this.load(id, options);
    if (!(options == null ? void 0 : options.allowUnfinished) && !(stream == null ? void 0 : stream.isBinaryStreamEnded())) {
      stream = await new Promise((resolve) => {
        subscribeToCoValueWithoutMe(
          this,
          id,
          options || {},
          (value, unsubscribe) => {
            if (value.isBinaryStreamEnded()) {
              unsubscribe();
              resolve(value);
            }
          }
        );
      });
    }
    return stream == null ? void 0 : stream.toBlob({
      allowUnfinished: options == null ? void 0 : options.allowUnfinished
    });
  }
  /**
   * Create a `FileStream` from a `Blob` or `File`
   *
   * @example
   * ```ts
   * import { co, FileStream } from "jazz-tools";
   *
   * const fileStream = await FileStream.createFromBlob(file, {owner: group})
   * ```
   * @category Content
   */
  static async createFromBlob(blob, options) {
    const stream = this.create(options);
    const onProgress = options && "onProgress" in options ? options.onProgress : void 0;
    const start = Date.now();
    const data = new Uint8Array(await blob.arrayBuffer());
    stream.start({
      mimeType: blob.type,
      totalSizeBytes: blob.size,
      fileName: blob instanceof File ? blob.name : void 0
    });
    const chunkSize = MAX_RECOMMENDED_TX_SIZE;
    let lastProgressUpdate = Date.now();
    for (let idx = 0; idx < data.length; idx += chunkSize) {
      stream.push(data.slice(idx, idx + chunkSize));
      if (Date.now() - lastProgressUpdate > 100) {
        onProgress == null ? void 0 : onProgress(idx / data.length);
        lastProgressUpdate = Date.now();
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    stream.end();
    const end = Date.now();
    console.debug(
      "Finished creating binary stream in",
      (end - start) / 1e3,
      "s - Throughput in MB/s",
      1e3 * (blob.size / (end - start)) / (1024 * 1024)
    );
    onProgress == null ? void 0 : onProgress(1);
    return stream;
  }
  /**
   * Get a JSON representation of the `FileStream`
   * @category Content
   */
  toJSON() {
    return {
      id: this.id,
      _type: this._type,
      ...this.getChunks()
    };
  }
  /** @internal */
  [inspect]() {
    return this.toJSON();
  }
  /**
   * Load a `FileStream`
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * An instance method to subscribe to an existing `FileStream`
   * @category Subscription & Loading
   */
  subscribe(listener) {
    return subscribeToExistingCoValue(this, {}, listener);
  }
  /**
   * Wait for the `FileStream` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
var _CoList = class _CoList2 extends Array {
  /**
   * Declare a `CoList` by subclassing `CoList.Of(...)` and passing the item schema using `co`.
   *
   * @example
   * ```ts
   * class ColorList extends CoList.Of(
   *   co.string
   * ) {}
   * class AnimalList extends CoList.Of(
   *   co.ref(Animal)
   * ) {}
   * ```
   *
   * @category Declaration
   */
  static Of(item) {
    var _a2, _b2;
    return class CoListOf extends (_b2 = _CoList2, _a2 = co.items, _b2) {
      constructor() {
        super(...arguments);
        this[_a2] = item;
      }
    };
  }
  /**
   * @ignore
   * @deprecated Use UPPERCASE `CoList.Of` instead! */
  static of(..._args) {
    throw new Error("Can't use Array.of with CoLists");
  }
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /** @category Collaboration */
  get _owner() {
    return this._raw.group instanceof RawAccount ? RegisteredSchemas["Account"].fromRaw(this._raw.group) : RegisteredSchemas["Group"].fromRaw(this._raw.group);
  }
  /**
   * If a `CoList`'s items are a `co.ref(...)`, you can use `coList._refs[i]` to access
   * the `Ref` instead of the potentially loaded/null value.
   *
   * This allows you to always get the ID or load the value manually.
   *
   * @example
   * ```ts
   * animals._refs[0].id; // => ID<Animal>
   * animals._refs[0].value;
   * // => Animal | null
   * const animal = await animals._refs[0].load();
   * ```
   *
   * @category Content
   **/
  get _refs() {
    return makeRefs(
      (idx) => this._raw.get(idx),
      () => Array.from({ length: this._raw.entries().length }, (_2, idx) => idx),
      this._loadedAs,
      (_idx) => this._schema[ItemsSym]
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    );
  }
  get _edits() {
    throw new Error("Not implemented");
  }
  get _loadedAs() {
    const rawAccount = this._raw.core.node.account;
    if (rawAccount instanceof RawAccount) {
      return coValuesCache.get(
        rawAccount,
        () => RegisteredSchemas["Account"].fromRaw(rawAccount)
      );
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  static get [(ItemsSym, Symbol.species)]() {
    return Array;
  }
  constructor(options) {
    super();
    Object.defineProperty(this, "_instanceID", {
      value: `instance-${Math.random().toString(36).slice(2)}`,
      enumerable: false
    });
    if (options && "fromRaw" in options) {
      Object.defineProperties(this, {
        id: {
          value: options.fromRaw.id,
          enumerable: false
        },
        _raw: { value: options.fromRaw, enumerable: false }
      });
    }
    return new Proxy(this, CoListProxyHandler);
  }
  /**
   * Create a new CoList with the given initial values and owner.
   *
   * The owner (a Group or Account) determines access rights to the CoMap.
   *
   * The CoList will immediately be persisted and synced to connected peers.
   *
   * @example
   * ```ts
   * const colours = ColorList.create(
   *   ["red", "green", "blue"],
   *   { owner: me }
   * );
   * const animals = AnimalList.create(
   *   [cat, dog, fish],
   *   { owner: me }
   * );
   * ```
   *
   * @category Creation
   **/
  static create(items, options) {
    const { owner } = parseCoValueCreateOptions(options);
    const instance = new this({ init: items, owner });
    const raw = owner._raw.createList(
      toRawItems(items, instance._schema[ItemsSym])
    );
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return instance;
  }
  push(...items) {
    this._raw.appendItems(
      toRawItems(items, this._schema[ItemsSym]),
      void 0,
      "private"
    );
    return this._raw.entries().length;
  }
  unshift(...items) {
    for (const item of toRawItems(items, this._schema[ItemsSym])) {
      this._raw.prepend(item);
    }
    return this._raw.entries().length;
  }
  pop() {
    const last = this[this.length - 1];
    this._raw.delete(this.length - 1);
    return last;
  }
  shift() {
    const first = this[0];
    this._raw.delete(0);
    return first;
  }
  /**
   * Splice the `CoList` at a given index.
   *
   * @param start - The index to start the splice.
   * @param deleteCount - The number of items to delete.
   * @param items - The items to insert.
   */
  splice(start, deleteCount, ...items) {
    const deleted = this.slice(start, start + deleteCount);
    for (let idxToDelete = start + deleteCount - 1; idxToDelete >= start; idxToDelete--) {
      this._raw.delete(idxToDelete);
    }
    const rawItems = toRawItems(items, this._schema[ItemsSym]);
    if (rawItems.length === 0) {
      return deleted;
    }
    if (rawItems.length === 1) {
      const item = rawItems[0];
      if (item === void 0) return deleted;
      if (start === 0) {
        this._raw.prepend(item);
      } else {
        this._raw.append(item, Math.max(start - 1, 0));
      }
      return deleted;
    }
    if (start === 0) {
      for (let i2 = rawItems.length - 1; i2 >= 0; i2--) {
        const item = rawItems[i2];
        if (item === void 0) continue;
        this._raw.prepend(item);
      }
    } else {
      let appendAfter = Math.max(start - 1, 0);
      for (const item of rawItems) {
        if (item === void 0) continue;
        this._raw.append(item, appendAfter);
        appendAfter++;
      }
    }
    return deleted;
  }
  /**
   * Modify the `CoList` to match another list, where the changes are managed internally.
   *
   * @param result - The resolved list of items.
   */
  applyDiff(result) {
    const current = this._raw.asArray();
    const comparator = isRefEncoded(this._schema[ItemsSym]) ? (aIdx, bIdx) => {
      var _a2, _b2;
      return ((_a2 = current[aIdx]) == null ? void 0 : _a2.id) === ((_b2 = result[bIdx]) == null ? void 0 : _b2.id);
    } : void 0;
    const patches = [...(0, import_fast_myers_diff.calcPatch)(current, result, comparator)];
    for (const [from, to, insert] of patches.reverse()) {
      this.splice(from, to - from, ...insert);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON(_key, seenAbove) {
    const itemDescriptor = this._schema[ItemsSym];
    if (itemDescriptor === "json") {
      return this._raw.asArray();
    } else if ("encoded" in itemDescriptor) {
      return this._raw.asArray().map((e2) => itemDescriptor.encoded.encode(e2));
    } else if (isRefEncoded(itemDescriptor)) {
      return this.map(
        (item, idx) => (seenAbove == null ? void 0 : seenAbove.includes(item == null ? void 0 : item.id)) ? { _circular: item.id } : item == null ? void 0 : item.toJSON(idx + "", [
          ...seenAbove || [],
          this.id
        ])
      );
    } else {
      return [];
    }
  }
  [inspect]() {
    return this.toJSON();
  }
  /** @category Internals */
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  /** @internal */
  static schema(def) {
    this._schema || (this._schema = {});
    Object.assign(this._schema, def);
  }
  /**
   * Load a `CoList` with a given ID, as a given account.
   *
   * `depth` specifies if item CoValue references should be loaded as well before resolving.
   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.
   *
   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.
   *
   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.
   *
   * @example
   * ```ts
   * const animalsWithVets =
   *   await ListOfAnimals.load(
   *     "co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax",
   *     me,
   *     [{ vet: {} }]
   *   );
   * ```
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Given an already loaded `CoList`, ensure that items are loaded to the specified depth.
   *
   * Works like `CoList.load()`, but you don't need to pass the ID or the account to load as again.
   *
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /** @category Type Helpers */
  castAs(cl) {
    const casted = cl.fromRaw(this._raw);
    const subscriptionScope = subscriptionsScopes.get(this);
    if (subscriptionScope) {
      subscriptionsScopes.set(casted, subscriptionScope);
    }
    return casted;
  }
  /**
   * Wait for the `CoList` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoList.prototype._type = "CoList";
var CoList = _CoList;
function toRawItems(items, itemDescriptor) {
  const rawItems = itemDescriptor === "json" ? items : "encoded" in itemDescriptor ? items == null ? void 0 : items.map((e2) => itemDescriptor.encoded.encode(e2)) : isRefEncoded(itemDescriptor) ? items == null ? void 0 : items.map((v2) => {
    if (!v2) return null;
    return v2.id;
  }) : (() => {
    throw new Error("Invalid element descriptor");
  })();
  return rawItems;
}
var CoListProxyHandler = {
  get(target, key, receiver) {
    if (typeof key === "string" && !isNaN(+key)) {
      const itemDescriptor = target._schema[ItemsSym];
      const rawValue = target._raw.get(Number(key));
      if (itemDescriptor === "json") {
        return rawValue;
      } else if ("encoded" in itemDescriptor) {
        return rawValue === void 0 ? void 0 : itemDescriptor.encoded.decode(rawValue);
      } else if (isRefEncoded(itemDescriptor)) {
        return rawValue === void 0 ? void 0 : new Ref(
          rawValue,
          target._loadedAs,
          itemDescriptor
        ).accessFrom(receiver, Number(key));
      }
    } else if (key === "length") {
      return target._raw.entries().length;
    } else {
      return Reflect.get(target, key, receiver);
    }
  },
  set(target, key, value, receiver) {
    var _a2;
    if (key === ItemsSym && typeof value === "object" && SchemaInit in value) {
      (_a2 = target.constructor)._schema || (_a2._schema = {});
      target.constructor._schema[ItemsSym] = value[SchemaInit];
      return true;
    }
    if (typeof key === "string" && !isNaN(+key)) {
      const itemDescriptor = target._schema[ItemsSym];
      let rawValue;
      if (itemDescriptor === "json") {
        rawValue = value;
      } else if ("encoded" in itemDescriptor) {
        rawValue = itemDescriptor.encoded.encode(value);
      } else if (isRefEncoded(itemDescriptor)) {
        if (value === null) {
          if (itemDescriptor.optional) {
            rawValue = null;
          } else {
            throw new Error(`Cannot set required reference ${key} to null`);
          }
        } else if (value == null ? void 0 : value.id) {
          rawValue = value.id;
        } else {
          throw new Error(
            `Cannot set reference ${key} to a non-CoValue. Got ${value}`
          );
        }
      }
      target._raw.replace(Number(key), rawValue);
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, descriptor) {
    var _a2;
    if (descriptor.value && key === ItemsSym && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
      (_a2 = target.constructor)._schema || (_a2._schema = {});
      target.constructor._schema[ItemsSym] = descriptor.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, descriptor);
    }
  },
  has(target, key) {
    if (typeof key === "string" && !isNaN(+key)) {
      return Number(key) < target._raw.entries().length;
    } else {
      return Reflect.has(target, key);
    }
  }
};
var _Group = class _Group2 extends CoValueBase {
  get _schema() {
    return this.constructor._schema;
  }
  get _refs() {
    const profileID = this._raw.get("profile");
    const rootID = this._raw.get("root");
    return {
      profile: profileID && new Ref(
        profileID,
        this._loadedAs,
        this._schema.profile
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ),
      root: rootID && new Ref(
        rootID,
        this._loadedAs,
        this._schema.root
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      )
    };
  }
  /** @deprecated Don't use constructor directly, use .create */
  constructor(options) {
    super();
    let raw;
    if (options && "fromRaw" in options) {
      raw = options.fromRaw;
    } else {
      const initOwner = options.owner;
      if (!initOwner) throw new Error("No owner provided");
      if (initOwner._type === "Account" && isControlledAccount(initOwner)) {
        const rawOwner = initOwner._raw;
        raw = rawOwner.createGroup();
      } else {
        throw new Error("Can only construct group as a controlled account");
      }
    }
    Object.defineProperties(this, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return new Proxy(this, AccountAndGroupProxyHandler);
  }
  static create(options) {
    return new this(parseGroupCreateOptions(options));
  }
  myRole() {
    return this._raw.myRole();
  }
  addMember(member, role) {
    this._raw.addMember(member === "everyone" ? member : member._raw, role);
  }
  removeMember(member) {
    return this._raw.removeMember(member === "everyone" ? member : member._raw);
  }
  get members() {
    var _a2;
    const members = [];
    const BaseAccountSchema = ((_a2 = activeAccountContext.maybeGet()) == null ? void 0 : _a2.constructor) || RegisteredSchemas["Account"];
    const refEncodedAccountSchema = {
      ref: () => BaseAccountSchema,
      optional: false
    };
    for (const accountID of this._raw.getAllMemberKeysSet()) {
      if (!isAccountID2(accountID)) continue;
      const role = this._raw.roleOf(accountID);
      if (role === "admin" || role === "writer" || role === "reader" || role === "writeOnly") {
        const ref2 = new Ref(
          accountID,
          this._loadedAs,
          refEncodedAccountSchema
        );
        const accessRef = () => ref2.accessFrom(this, "members." + accountID);
        if (!ref2.syncLoad()) {
          console.warn("Account not loaded", accountID);
        }
        members.push({
          id: accountID,
          role,
          ref: ref2,
          get account() {
            return accessRef();
          }
        });
      }
    }
    return members;
  }
  getRoleOf(member) {
    if (member === "me") {
      return this._raw.roleOf(
        activeAccountContext.get().id
      );
    }
    return this._raw.roleOf(
      member === "everyone" ? member : member
    );
  }
  getParentGroups() {
    return this._raw.getParentGroups().map((group) => _Group2.fromRaw(group));
  }
  extend(parent, roleMapping) {
    this._raw.extend(parent._raw, roleMapping);
    return this;
  }
  async revokeExtend(parent) {
    await this._raw.revokeExtend(parent._raw);
    return this;
  }
  /** @category Subscription & Loading */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /** @category Subscription & Loading */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `Group` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_Group.prototype._type = "Group";
_Group._schema = {
  profile: "json",
  root: "json"
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
};
Object.defineProperty(_Group.prototype, "_schema", {
  get: () => _Group._schema
});
var Group = _Group;
RegisteredSchemas["Group"] = Group;
function isAccountID2(id) {
  return id.startsWith("co_");
}
var CoPlainText = class extends String {
  get _owner() {
    return this._raw.group instanceof RawAccount ? Account.fromRaw(this._raw.group) : Group.fromRaw(this._raw.group);
  }
  get _loadedAs() {
    return Account.fromNode(this._raw.core.node);
  }
  constructor(options) {
    super("fromRaw" in options ? options.fromRaw.toString() : options.text);
    let raw;
    if ("fromRaw" in options) {
      raw = options.fromRaw;
    } else {
      raw = options.owner._raw.createPlainText(options.text);
    }
    Object.defineProperties(this, {
      id: { value: raw.id, enumerable: false },
      _type: { value: "CoPlainText", enumerable: false },
      _raw: { value: raw, enumerable: false }
    });
  }
  static create(text, options) {
    return new this({ text, owner: options.owner });
  }
  get length() {
    return this._raw.toString().length;
  }
  toString() {
    return this._raw.toString();
  }
  valueOf() {
    return this._raw.toString();
  }
  toJSON() {
    return this._raw.toString();
  }
  [inspect]() {
    return this.toJSON();
  }
  insertBefore(idx, text) {
    this._raw.insertBefore(idx, text);
  }
  insertAfter(idx, text) {
    this._raw.insertAfter(idx, text);
  }
  deleteRange(range) {
    this._raw.deleteRange(range);
  }
  posBefore(idx) {
    return this._raw.mapping.opIDbeforeIdx[idx];
  }
  posAfter(idx) {
    return this._raw.mapping.opIDafterIdx[idx];
  }
  idxBefore(pos) {
    return this._raw.mapping.idxBeforeOpID[stringifyOpID(pos)];
  }
  idxAfter(pos) {
    return this._raw.mapping.idxAfterOpID[stringifyOpID(pos)];
  }
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  /**
   * Apply text, modifying the text in place. Calculates the diff and applies it to the CoValue.
   *
   * @category Mutation
   */
  applyDiff(other) {
    const current = this._raw.toString();
    for (const [from, to, insert] of [...(0, import_fast_myers_diff2.calcPatch)(current, other)].reverse()) {
      if (to > from) {
        this.deleteRange({ from, to });
      }
      if (insert.length > 0) {
        this.insertBefore(from, insert);
      }
    }
  }
  /**
   * Load a `CoPlainText` with a given ID, as a given account.
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Given an already loaded `CoPlainText`, subscribe to updates to the `CoPlainText` and ensure that the specified fields are loaded to the specified depth.
   *
   * Works like `CoPlainText.subscribe()`, but you don't need to pass the ID or the account to load as again.
   *
   * Returns an unsubscribe function that you should call when you no longer need updates.
   *
   * @category Subscription & Loading
   **/
  subscribe(listener) {
    return subscribeToExistingCoValue(this, {}, listener);
  }
};
var CoRichText = class extends CoPlainText {
};
var _a;
var _b;
var ImageDefinition = class extends (_b = CoMap, _a = co.items, _b) {
  constructor() {
    super(...arguments);
    this.originalSize = co.json();
    this.placeholderDataURL = co.string;
    this[_a] = co.ref(FileStream);
  }
  highestResAvailable(options) {
    var _a2;
    if (!subscriptionsScopes.get(this)) {
      console.warn(
        "highestResAvailable() only makes sense when used within a subscription."
      );
    }
    const resolutions = Object.keys(this).filter(
      (key) => key.match(/^\d+x\d+$/)
    );
    let maxWidth = options == null ? void 0 : options.maxWidth;
    if (options == null ? void 0 : options.targetWidth) {
      const targetWidth = options.targetWidth;
      const widths = resolutions.map((res) => Number(res.split("x")[0]));
      maxWidth = Math.min(...widths.filter((w2) => w2 >= targetWidth));
    }
    const validResolutions = resolutions.filter(
      (key) => maxWidth === void 0 || Number(key.split("x")[0]) <= maxWidth
    );
    validResolutions.sort((a2, b) => {
      const aWidth = Number(a2.split("x")[0]);
      const bWidth = Number(b.split("x")[0]);
      return aWidth - bWidth;
    });
    let highestAvailableResolution;
    for (const resolution of validResolutions) {
      if (this[resolution] && ((_a2 = this[resolution]) == null ? void 0 : _a2.getChunks())) {
        highestAvailableResolution = resolution;
      }
    }
    return highestAvailableResolution && {
      res: highestAvailableResolution,
      stream: this[highestAvailableResolution]
    };
  }
};
var SchemaUnion = class _SchemaUnion extends CoValueBase {
  /**
   * Create a new union type from a discriminator function.
   *
   * The discriminator function receives the raw data and should return the appropriate concrete class to use for that data.
   *
   * When loading a SchemaUnion, the correct subclass will be instantiated based on the discriminator.
   *
   * @param discriminator - Function that determines which concrete type to use
   * @returns A new class that can create/load instances of the union type
   *
   * @example
   * ```ts
   * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {
   *   switch (raw.get("type")) {
   *     case "button": return ButtonWidget;
   *     case "slider": return SliderWidget;
   *     default: throw new Error("Unknown widget type");
   *   }
   * });
   *
   * const widget = await loadCoValue(WidgetUnion, id, me, {});
   *
   * // You can narrow the returned instance to a subclass by using `instanceof`
   * if (widget instanceof ButtonWidget) {
   *   console.log(widget.label);
   * } else if (widget instanceof SliderWidget) {
   *   console.log(widget.min, widget.max);
   * }
   * ```
   *
   * @category Declaration
   **/
  static Of(discriminator) {
    return class SchemaUnionClass extends _SchemaUnion {
      static fromRaw(raw) {
        const ResolvedClass = discriminator(
          raw
        );
        return ResolvedClass.fromRaw(raw);
      }
    };
  }
  /**
   * Create an instance from raw data. This is called internally and should not be used directly.
   * Use {@link SchemaUnion.Of} to create a union type instead.
   *
   * @internal
   */
  // @ts-ignore
  static fromRaw(raw) {
    throw new Error("Not implemented");
  }
};
var KvStoreContext = class _KvStoreContext {
  constructor() {
    this.storageInstance = null;
  }
  static getInstance() {
    if (!_KvStoreContext.instance) {
      _KvStoreContext.instance = new _KvStoreContext();
    }
    return _KvStoreContext.instance;
  }
  isInitialized() {
    return this.storageInstance !== null;
  }
  initialize(store) {
    if (!this.storageInstance) {
      this.storageInstance = store;
    }
  }
  getStorage() {
    if (!this.storageInstance) {
      throw new Error("Storage instance is not initialized.");
    }
    return this.storageInstance;
  }
};
var KvStoreContext_default = KvStoreContext;
var STORAGE_KEY = "jazz-logged-in-secret";
var AuthSecretStorage = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.isAuthenticated = false;
  }
  async migrate() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    if (!await kvStore.get(STORAGE_KEY)) {
      const demoAuthSecret = await kvStore.get("demo-auth-logged-in-secret");
      if (demoAuthSecret) {
        const parsed = JSON.parse(demoAuthSecret);
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            accountSecret: parsed.accountSecret,
            provider: "demo"
          })
        );
        await kvStore.delete("demo-auth-logged-in-secret");
      }
      const clerkAuthSecret = await kvStore.get("jazz-clerk-auth");
      if (clerkAuthSecret) {
        const parsed = JSON.parse(clerkAuthSecret);
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            accountSecret: parsed.secret,
            provider: "clerk"
          })
        );
        await kvStore.delete("jazz-clerk-auth");
      }
    }
    const value = await kvStore.get(STORAGE_KEY);
    if (value) {
      const parsed = JSON.parse(value);
      if ("secret" in parsed) {
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            secretSeed: parsed.secretSeed,
            accountSecret: parsed.secret,
            provider: parsed.provider
          })
        );
      }
    }
  }
  async get() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    const data = await kvStore.get(STORAGE_KEY);
    if (!data) return null;
    const parsed = JSON.parse(data);
    if (!parsed.accountID || !parsed.accountSecret) {
      throw new Error("Invalid auth secret storage data");
    }
    return {
      accountID: parsed.accountID,
      secretSeed: parsed.secretSeed ? new Uint8Array(parsed.secretSeed) : void 0,
      accountSecret: parsed.accountSecret,
      provider: parsed.provider
    };
  }
  async setWithoutNotify(payload) {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    await kvStore.set(
      STORAGE_KEY,
      JSON.stringify({
        accountID: payload.accountID,
        secretSeed: payload.secretSeed ? Array.from(payload.secretSeed) : void 0,
        accountSecret: payload.accountSecret,
        provider: payload.provider
      })
    );
  }
  async set(payload) {
    this.setWithoutNotify(payload);
    this.emitUpdate(payload);
  }
  getIsAuthenticated(data) {
    if (!data) return false;
    return data.provider !== "anonymous";
  }
  onUpdate(handler) {
    this.listeners.add(handler);
    return () => {
      this.listeners.delete(handler);
    };
  }
  emitUpdate(data) {
    const isAuthenticated = this.getIsAuthenticated(data);
    if (this.isAuthenticated === isAuthenticated) return;
    this.isAuthenticated = isAuthenticated;
    for (const listener of this.listeners) {
      listener(this.isAuthenticated);
    }
  }
  async clearWithoutNotify() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    await kvStore.delete(STORAGE_KEY);
  }
  async clear() {
    await this.clearWithoutNotify();
    this.emitUpdate(null);
  }
};
var InMemoryKVStore = class {
  constructor() {
    this.store = {};
  }
  async get(key) {
    const data = this.store[key];
    if (!data) return null;
    return data;
  }
  async set(key, value) {
    this.store[key] = value;
  }
  async delete(key) {
    delete this.store[key];
  }
  async clearAll() {
    this.store = {};
  }
};
var JazzContextManager = class {
  constructor() {
    this.authSecretStorage = new AuthSecretStorage();
    this.keepContextOpen = false;
    this.logOut = async () => {
      var _a2, _b2;
      if (!this.context || !this.props) {
        return;
      }
      await ((_b2 = (_a2 = this.props).onLogOut) == null ? void 0 : _b2.call(_a2));
      if (this.props.logOutReplacement) {
        await this.props.logOutReplacement();
      } else {
        await this.context.logOut();
        return this.createContext(this.props);
      }
    };
    this.done = () => {
      if (!this.context) {
        return;
      }
      this.context.done();
    };
    this.shouldMigrateAnonymousAccount = async () => {
      var _a2;
      if (!((_a2 = this.props) == null ? void 0 : _a2.onAnonymousAccountDiscarded)) {
        return false;
      }
      const prevCredentials = await this.authSecretStorage.get();
      const wasAnonymous = this.authSecretStorage.getIsAuthenticated(prevCredentials) === false;
      return wasAnonymous;
    };
    this.authenticate = async (credentials) => {
      if (!this.props) {
        throw new Error("Props required");
      }
      const prevContext = this.context;
      const migratingAnonymousAccount = await this.shouldMigrateAnonymousAccount();
      this.keepContextOpen = migratingAnonymousAccount;
      await this.createContext(this.props, { credentials }).finally(() => {
        this.keepContextOpen = false;
      });
      if (migratingAnonymousAccount) {
        await this.handleAnonymousAccountMigration(prevContext);
      }
    };
    this.register = async (accountSecret, creationProps) => {
      if (!this.props) {
        throw new Error("Props required");
      }
      const prevContext = this.context;
      const migratingAnonymousAccount = await this.shouldMigrateAnonymousAccount();
      this.keepContextOpen = migratingAnonymousAccount;
      await this.createContext(this.props, {
        newAccountProps: {
          secret: accountSecret,
          creationProps
        }
      }).finally(() => {
        this.keepContextOpen = false;
      });
      if (migratingAnonymousAccount) {
        await this.handleAnonymousAccountMigration(prevContext);
      }
      if (this.context && "me" in this.context) {
        return this.context.me.id;
      }
      throw new Error("The registration hasn't created a new account");
    };
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = (callback) => {
      this.listeners.add(callback);
      return () => {
        this.listeners.delete(callback);
      };
    };
    KvStoreContext.getInstance().initialize(this.getKvStore());
  }
  getKvStore() {
    return new InMemoryKVStore();
  }
  async createContext(props, authProps) {
    this.props = props;
    const { promise, resolve } = createResolvablePromise();
    const prevPromise = this.contextPromise;
    this.contextPromise = promise;
    await prevPromise;
    try {
      const result = await this.getNewContext(props, authProps);
      await this.updateContext(props, result, authProps);
      resolve();
    } catch (error) {
      resolve();
      throw error;
    }
  }
  async getNewContext(props, authProps) {
    props;
    authProps;
    throw new Error("Not implemented");
  }
  async updateContext(props, context2, authProps) {
    var _a2;
    if (!this.keepContextOpen) {
      (_a2 = this.context) == null ? void 0 : _a2.done();
    }
    this.context = context2;
    this.props = props;
    this.value = {
      ...context2,
      node: context2.node,
      authenticate: this.authenticate,
      register: this.register,
      logOut: this.logOut
    };
    if (authProps == null ? void 0 : authProps.credentials) {
      this.authSecretStorage.emitUpdate(authProps.credentials);
    } else {
      this.authSecretStorage.emitUpdate(await this.authSecretStorage.get());
    }
    this.notify();
  }
  propsChanged(props) {
    props;
    throw new Error("Not implemented");
  }
  getCurrentValue() {
    return this.value;
  }
  getAuthSecretStorage() {
    return this.authSecretStorage;
  }
  async handleAnonymousAccountMigration(prevContext) {
    var _a2, _b2;
    if (!this.props) {
      throw new Error("Props required");
    }
    const currentContext = this.context;
    if (prevContext && currentContext && "me" in prevContext && "me" in currentContext) {
      const [prevAccountAsPeer, currentAccountAsPeer] = cojsonInternals.connectedPeers(
        prevContext.me.id,
        currentContext.me.id,
        {
          peer1role: "client",
          peer2role: "server"
        }
      );
      prevContext.node.syncManager.addPeer(currentAccountAsPeer);
      currentContext.node.syncManager.addPeer(prevAccountAsPeer);
      try {
        await ((_b2 = (_a2 = this.props).onAnonymousAccountDiscarded) == null ? void 0 : _b2.call(_a2, prevContext.me));
        await prevContext.me.waitForAllCoValuesSync();
      } catch (error) {
        console.error("Error onAnonymousAccountDiscarded", error);
      }
      prevAccountAsPeer.outgoing.close();
      currentAccountAsPeer.outgoing.close();
    }
    prevContext == null ? void 0 : prevContext.done();
  }
  notify() {
    for (const listener of this.listeners) {
      listener();
    }
  }
};
function createResolvablePromise() {
  let resolve;
  const promise = new Promise((res) => {
    resolve = res;
  });
  return { promise, resolve };
}
var DemoAuth = class {
  constructor(authenticate, authSecretStorage) {
    this.authenticate = authenticate;
    this.authSecretStorage = authSecretStorage;
    this.logIn = async (username) => {
      const existingUsers = await this.getExisitingUsersWithData();
      const storageData = existingUsers[username];
      if (!(storageData == null ? void 0 : storageData.accountID)) {
        throw new Error("User not found");
      }
      await this.authenticate({
        accountID: storageData.accountID,
        accountSecret: storageData.accountSecret
      });
      await this.authSecretStorage.set({
        accountID: storageData.accountID,
        accountSecret: storageData.accountSecret,
        secretSeed: storageData.secretSeed ? new Uint8Array(storageData.secretSeed) : void 0,
        provider: "demo"
      });
    };
    this.signUp = async (username) => {
      const existingUsers = await this.getExistingUsers();
      if (existingUsers.includes(username)) {
        throw new Error("User already registered");
      }
      const credentials = await this.authSecretStorage.get();
      if (!credentials) {
        throw new Error("No credentials found");
      }
      const currentAccount = await Account.getMe().ensureLoaded({
        resolve: {
          profile: true
        }
      });
      currentAccount.profile.name = username;
      await this.authSecretStorage.set({
        accountID: credentials.accountID,
        accountSecret: credentials.accountSecret,
        secretSeed: credentials.secretSeed ? new Uint8Array(credentials.secretSeed) : void 0,
        provider: "demo"
      });
      await this.addToExistingUsers(username, {
        accountID: credentials.accountID,
        accountSecret: credentials.accountSecret,
        secretSeed: credentials.secretSeed ? Array.from(credentials.secretSeed) : void 0
      });
    };
    this.getExistingUsers = async () => {
      return Object.keys(await this.getExisitingUsersWithData());
    };
  }
  async addToExistingUsers(username, data) {
    const existingUsers = await this.getExisitingUsersWithData();
    if (existingUsers[username]) {
      return;
    }
    existingUsers[username] = data;
    const kvStore = KvStoreContext.getInstance().getStorage();
    await kvStore.set("demo-auth-users", JSON.stringify(existingUsers));
  }
  async getExisitingUsersWithData() {
    const kvStore = KvStoreContext.getInstance().getStorage();
    await migrateExistingUsers(kvStore);
    const existingUsers = await kvStore.get("demo-auth-users");
    return existingUsers ? JSON.parse(existingUsers) : {};
  }
};
function encodeUsername(username) {
  return btoa(username).replace(/=/g, "-").replace(/\+/g, "_").replace(/\//g, ".");
}
async function getStorageVersion(kvStore) {
  try {
    const version = await kvStore.get("demo-auth-storage-version");
    return version ? parseInt(version) : 1;
  } catch (error) {
    return 1;
  }
}
async function setStorageVersion(kvStore, version) {
  await kvStore.set("demo-auth-storage-version", version.toString());
}
async function getExistingUsersList(kvStore) {
  const existingUsers = await kvStore.get("demo-auth-existing-users");
  return existingUsers ? existingUsers.split(",") : [];
}
async function migrateExistingUsers(kvStore) {
  if (await getStorageVersion(kvStore) < 2) {
    const existingUsers = await getExistingUsersList(kvStore);
    for (const username of existingUsers) {
      const legacyKey = `demo-auth-existing-users-${username}`;
      const storageData = await kvStore.get(legacyKey);
      if (storageData) {
        await kvStore.set(
          `demo-auth-existing-users-${encodeUsername(username)}`,
          storageData
        );
        await kvStore.delete(legacyKey);
      }
    }
    await setStorageVersion(kvStore, 2);
  }
  if (await getStorageVersion(kvStore) < 3) {
    const existingUsersList = await getExistingUsersList(kvStore);
    const existingUsers = {};
    const keysToDelete = ["demo-auth-existing-users"];
    for (const username of existingUsersList) {
      const key = `demo-auth-existing-users-${encodeUsername(username)}`;
      const storageData = await kvStore.get(key);
      if (storageData) {
        existingUsers[username] = JSON.parse(storageData);
        keysToDelete.push(key);
      }
    }
    await kvStore.set("demo-auth-users", JSON.stringify(existingUsers));
    for (const key of keysToDelete) {
      await kvStore.delete(key);
    }
    await setStorageVersion(kvStore, 3);
  }
}
var PassphraseAuth = class {
  constructor(crypto3, authenticate, register, authSecretStorage, wordlist) {
    this.crypto = crypto3;
    this.authenticate = authenticate;
    this.register = register;
    this.authSecretStorage = authSecretStorage;
    this.wordlist = wordlist;
    this.passphrase = "";
    this.logIn = async (passphrase) => {
      const { crypto: crypto4, authenticate: authenticate2 } = this;
      let secretSeed;
      try {
        secretSeed = mnemonicToEntropy(passphrase, this.wordlist);
      } catch (e2) {
        throw new Error("Invalid passphrase");
      }
      const accountSecret = crypto4.agentSecretFromSecretSeed(secretSeed);
      const accountID = cojsonInternals.idforHeader(
        cojsonInternals.accountHeaderForInitialAgentSecret(accountSecret, crypto4),
        crypto4
      );
      await authenticate2({
        accountID,
        accountSecret
      });
      await this.authSecretStorage.set({
        accountID,
        secretSeed,
        accountSecret,
        provider: "passphrase"
      });
      this.passphrase = passphrase;
      this.notify();
    };
    this.signUp = async (name) => {
      const credentials = await this.authSecretStorage.get();
      if (!credentials || !credentials.secretSeed) {
        throw new Error("No credentials found");
      }
      const passphrase = entropyToMnemonic(credentials.secretSeed, this.wordlist);
      await this.authSecretStorage.set({
        accountID: credentials.accountID,
        secretSeed: credentials.secretSeed,
        accountSecret: credentials.accountSecret,
        provider: "passphrase"
      });
      if (name == null ? void 0 : name.trim()) {
        const currentAccount = await Account.getMe().ensureLoaded({
          resolve: {
            profile: true
          }
        });
        currentAccount.profile.name = name;
      }
      return passphrase;
    };
    this.registerNewAccount = async (passphrase, name) => {
      const secretSeed = mnemonicToEntropy(passphrase, this.wordlist);
      const accountSecret = this.crypto.agentSecretFromSecretSeed(secretSeed);
      const accountID = await this.register(accountSecret, { name });
      await this.authSecretStorage.set({
        accountID,
        secretSeed,
        accountSecret,
        provider: "passphrase"
      });
      return accountID;
    };
    this.getCurrentAccountPassphrase = async () => {
      const credentials = await this.authSecretStorage.get();
      if (!credentials || !credentials.secretSeed) {
        throw new Error("No credentials found");
      }
      return entropyToMnemonic(credentials.secretSeed, this.wordlist);
    };
    this.generateRandomPassphrase = () => {
      return entropyToMnemonic(this.crypto.newRandomSecretSeed(), this.wordlist);
    };
    this.loadCurrentAccountPassphrase = async () => {
      const passphrase = await this.getCurrentAccountPassphrase();
      this.passphrase = passphrase;
      this.notify();
    };
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = (callback) => {
      this.listeners.add(callback);
      return () => {
        this.listeners.delete(callback);
      };
    };
  }
  notify() {
    for (const listener of this.listeners) {
      listener();
    }
  }
};
function createInviteLink(value, role, baseURL, valueHint) {
  const coValueCore = value._raw.core;
  let currentCoValue = coValueCore;
  while (currentCoValue.header.ruleset.type === "ownedByGroup") {
    currentCoValue = currentCoValue.getGroup().core;
  }
  const { ruleset, meta } = currentCoValue.header;
  if (ruleset.type !== "group" || (meta == null ? void 0 : meta.type) === "account") {
    throw new Error("Can't create invite link for object without group");
  }
  const group = cojsonInternals.expectGroup(currentCoValue.getCurrentContent());
  const inviteSecret = group.createInvite(role);
  return `${baseURL}#/invite/${valueHint ? valueHint + "/" : ""}${value.id}/${inviteSecret}`;
}
function parseInviteLink(inviteURL) {
  const url = new URL(inviteURL);
  const parts = url.hash.split("/");
  let valueHint;
  let valueID;
  let inviteSecret;
  if (parts[0] === "#" && parts[1] === "invite") {
    if (parts.length === 5) {
      valueHint = parts[2];
      valueID = parts[3];
      inviteSecret = parts[4];
    } else if (parts.length === 4) {
      valueID = parts[2];
      inviteSecret = parts[3];
    }
    if (!valueID || !inviteSecret) {
      return void 0;
    }
    return { valueID, inviteSecret, valueHint };
  }
}
function consumeInviteLink({
  inviteURL,
  as = Account.getMe(),
  forValueHint,
  invitedObjectSchema
}) {
  return new Promise((resolve, reject) => {
    const result = parseInviteLink(inviteURL);
    if (result && result.valueHint === forValueHint) {
      as.acceptInvite(result.valueID, result.inviteSecret, invitedObjectSchema).then(() => {
        resolve(result);
      }).catch(reject);
    } else {
      resolve(void 0);
    }
  });
}

export {
  base64URLtoBytes,
  bytesToBase64url,
  logger,
  base58,
  stableStringify,
  textEncoder,
  textDecoder,
  CryptoProvider,
  MAX_RECOMMENDED_TX_SIZE,
  emptyKnownState,
  cojsonInternals,
  anumber2 as anumber,
  abytes,
  aexists,
  aoutput,
  u8,
  u32,
  clean,
  rotr,
  swap8IfBE,
  swap32IfBE,
  utf8ToBytes,
  toBytes,
  concatBytes,
  Hash,
  createOptHasher,
  createXOFer,
  randomBytes2 as randomBytes,
  SHA256_IV,
  fromBig,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  add,
  add3L,
  add3H,
  sha512,
  AnonymousJazzAgent,
  Encoders,
  co,
  randomSessionProvider,
  createJazzContextFromExistingCredentials,
  createJazzContextForNewAccount,
  createJazzContext,
  createAnonymousJazzContext,
  CoValueBase,
  loadCoValue2,
  subscribeToCoValue,
  createCoValueObservable,
  Inbox,
  InboxSender,
  CoMap,
  Profile,
  Account,
  isControlledAccount,
  CoFeed,
  FileStream,
  CoList,
  Group,
  CoPlainText,
  CoRichText,
  ImageDefinition,
  SchemaUnion,
  KvStoreContext,
  AuthSecretStorage,
  InMemoryKVStore,
  JazzContextManager,
  DemoAuth,
  PassphraseAuth,
  createInviteLink,
  parseInviteLink,
  consumeInviteLink
};
/*! Bundled license information:

@scure/base/lib/esm/index.js:
@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

jazz-tools/dist/chunk-PYBQOYML.js:
  (* istanbul ignore file -- @preserve *)
*/
//# sourceMappingURL=chunk-2DGAZFSV.js.map
