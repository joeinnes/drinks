import {
  require_jsx_runtime
} from "./chunk-GPSOZ4ZP.js";
import {
  require_react
} from "./chunk-WWYT3PKD.js";
import {
  Account,
  AuthSecretStorage,
  CryptoProvider,
  DemoAuth,
  FileStream,
  Hash,
  ImageDefinition,
  InMemoryKVStore,
  InboxSender,
  JazzContextManager,
  MAX_RECOMMENDED_TX_SIZE,
  PassphraseAuth,
  SHA256_IV,
  abytes,
  add,
  add3H,
  add3L,
  aexists,
  anumber,
  aoutput,
  base58,
  base64URLtoBytes,
  bytesToBase64url,
  clean,
  cojsonInternals,
  concatBytes,
  consumeInviteLink,
  createAnonymousJazzContext,
  createCoValueObservable,
  createInviteLink,
  createJazzContext,
  createOptHasher,
  createXOFer,
  emptyKnownState,
  fromBig,
  logger,
  parseInviteLink,
  randomBytes,
  rotr,
  rotr32H,
  rotr32L,
  rotrBH,
  rotrBL,
  rotrSH,
  rotrSL,
  sha512,
  stableStringify,
  swap32IfBE,
  swap8IfBE,
  textDecoder,
  textEncoder,
  toBytes,
  u32,
  u8,
  utf8ToBytes
} from "./chunk-2DGAZFSV.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/.pnpm/pica@9.0.1/node_modules/pica/dist/pica.js
var require_pica = __commonJS({
  "node_modules/.pnpm/pica@9.0.1/node_modules/pica/dist/pica.js"(exports, module2) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.pica = f();
      }
    })(function() {
      var define2, module3, exports2;
      return (/* @__PURE__ */ function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof __require && __require;
                if (!f && c) return c(i2, true);
                if (u) return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof __require && __require, i = 0; i < t.length; i++) o(t[i]);
          return o;
        }
        return r;
      }())({ 1: [function(_dereq_, module4, exports3) {
        "use strict";
        var Multimath = _dereq_("multimath");
        var mm_unsharp_mask = _dereq_("./mm_unsharp_mask");
        var mm_resize = _dereq_("./mm_resize");
        function MathLib(requested_features) {
          var __requested_features = requested_features || [];
          var features = {
            js: __requested_features.indexOf("js") >= 0,
            wasm: __requested_features.indexOf("wasm") >= 0
          };
          Multimath.call(this, features);
          this.features = {
            js: features.js,
            wasm: features.wasm && this.has_wasm()
          };
          this.use(mm_unsharp_mask);
          this.use(mm_resize);
        }
        MathLib.prototype = Object.create(Multimath.prototype);
        MathLib.prototype.constructor = MathLib;
        MathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {
          var result = this.resize(options, cache);
          if (options.unsharpAmount) {
            this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);
          }
          return result;
        };
        module4.exports = MathLib;
      }, { "./mm_resize": 4, "./mm_unsharp_mask": 9, "multimath": 19 }], 2: [function(_dereq_, module4, exports3) {
        "use strict";
        function clampTo8(i) {
          return i < 0 ? 0 : i > 255 ? 255 : i;
        }
        function clampNegative(i) {
          return i >= 0 ? i : 0;
        }
        function convolveHor(src, dest, srcW, srcH, destW, filters) {
          var r, g, b, a;
          var filterPtr, filterShift, filterSize;
          var srcPtr, srcY, destX, filterVal;
          var srcOffset = 0, destOffset = 0;
          for (srcY = 0; srcY < srcH; srcY++) {
            filterPtr = 0;
            for (destX = 0; destX < destW; destX++) {
              filterShift = filters[filterPtr++];
              filterSize = filters[filterPtr++];
              srcPtr = srcOffset + filterShift * 4 | 0;
              r = g = b = a = 0;
              for (; filterSize > 0; filterSize--) {
                filterVal = filters[filterPtr++];
                a = a + filterVal * src[srcPtr + 3] | 0;
                b = b + filterVal * src[srcPtr + 2] | 0;
                g = g + filterVal * src[srcPtr + 1] | 0;
                r = r + filterVal * src[srcPtr] | 0;
                srcPtr = srcPtr + 4 | 0;
              }
              dest[destOffset + 3] = clampNegative(a >> 7);
              dest[destOffset + 2] = clampNegative(b >> 7);
              dest[destOffset + 1] = clampNegative(g >> 7);
              dest[destOffset] = clampNegative(r >> 7);
              destOffset = destOffset + srcH * 4 | 0;
            }
            destOffset = (srcY + 1) * 4 | 0;
            srcOffset = (srcY + 1) * srcW * 4 | 0;
          }
        }
        function convolveVert(src, dest, srcW, srcH, destW, filters) {
          var r, g, b, a;
          var filterPtr, filterShift, filterSize;
          var srcPtr, srcY, destX, filterVal;
          var srcOffset = 0, destOffset = 0;
          for (srcY = 0; srcY < srcH; srcY++) {
            filterPtr = 0;
            for (destX = 0; destX < destW; destX++) {
              filterShift = filters[filterPtr++];
              filterSize = filters[filterPtr++];
              srcPtr = srcOffset + filterShift * 4 | 0;
              r = g = b = a = 0;
              for (; filterSize > 0; filterSize--) {
                filterVal = filters[filterPtr++];
                a = a + filterVal * src[srcPtr + 3] | 0;
                b = b + filterVal * src[srcPtr + 2] | 0;
                g = g + filterVal * src[srcPtr + 1] | 0;
                r = r + filterVal * src[srcPtr] | 0;
                srcPtr = srcPtr + 4 | 0;
              }
              r >>= 7;
              g >>= 7;
              b >>= 7;
              a >>= 7;
              dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14);
              dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);
              dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);
              dest[destOffset] = clampTo8(r + (1 << 13) >> 14);
              destOffset = destOffset + srcH * 4 | 0;
            }
            destOffset = (srcY + 1) * 4 | 0;
            srcOffset = (srcY + 1) * srcW * 4 | 0;
          }
        }
        function convolveHorWithPre(src, dest, srcW, srcH, destW, filters) {
          var r, g, b, a, alpha;
          var filterPtr, filterShift, filterSize;
          var srcPtr, srcY, destX, filterVal;
          var srcOffset = 0, destOffset = 0;
          for (srcY = 0; srcY < srcH; srcY++) {
            filterPtr = 0;
            for (destX = 0; destX < destW; destX++) {
              filterShift = filters[filterPtr++];
              filterSize = filters[filterPtr++];
              srcPtr = srcOffset + filterShift * 4 | 0;
              r = g = b = a = 0;
              for (; filterSize > 0; filterSize--) {
                filterVal = filters[filterPtr++];
                alpha = src[srcPtr + 3];
                a = a + filterVal * alpha | 0;
                b = b + filterVal * src[srcPtr + 2] * alpha | 0;
                g = g + filterVal * src[srcPtr + 1] * alpha | 0;
                r = r + filterVal * src[srcPtr] * alpha | 0;
                srcPtr = srcPtr + 4 | 0;
              }
              b = b / 255 | 0;
              g = g / 255 | 0;
              r = r / 255 | 0;
              dest[destOffset + 3] = clampNegative(a >> 7);
              dest[destOffset + 2] = clampNegative(b >> 7);
              dest[destOffset + 1] = clampNegative(g >> 7);
              dest[destOffset] = clampNegative(r >> 7);
              destOffset = destOffset + srcH * 4 | 0;
            }
            destOffset = (srcY + 1) * 4 | 0;
            srcOffset = (srcY + 1) * srcW * 4 | 0;
          }
        }
        function convolveVertWithPre(src, dest, srcW, srcH, destW, filters) {
          var r, g, b, a;
          var filterPtr, filterShift, filterSize;
          var srcPtr, srcY, destX, filterVal;
          var srcOffset = 0, destOffset = 0;
          for (srcY = 0; srcY < srcH; srcY++) {
            filterPtr = 0;
            for (destX = 0; destX < destW; destX++) {
              filterShift = filters[filterPtr++];
              filterSize = filters[filterPtr++];
              srcPtr = srcOffset + filterShift * 4 | 0;
              r = g = b = a = 0;
              for (; filterSize > 0; filterSize--) {
                filterVal = filters[filterPtr++];
                a = a + filterVal * src[srcPtr + 3] | 0;
                b = b + filterVal * src[srcPtr + 2] | 0;
                g = g + filterVal * src[srcPtr + 1] | 0;
                r = r + filterVal * src[srcPtr] | 0;
                srcPtr = srcPtr + 4 | 0;
              }
              r >>= 7;
              g >>= 7;
              b >>= 7;
              a >>= 7;
              a = clampTo8(a + (1 << 13) >> 14);
              if (a > 0) {
                r = r * 255 / a | 0;
                g = g * 255 / a | 0;
                b = b * 255 / a | 0;
              }
              dest[destOffset + 3] = a;
              dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);
              dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);
              dest[destOffset] = clampTo8(r + (1 << 13) >> 14);
              destOffset = destOffset + srcH * 4 | 0;
            }
            destOffset = (srcY + 1) * 4 | 0;
            srcOffset = (srcY + 1) * srcW * 4 | 0;
          }
        }
        module4.exports = {
          convolveHor,
          convolveVert,
          convolveHorWithPre,
          convolveVertWithPre
        };
      }, {}], 3: [function(_dereq_, module4, exports3) {
        "use strict";
        module4.exports = "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEYA2AGf39/f39/AGAAAGAIf39/f39/f38AAg8BA2VudgZtZW1vcnkCAAADBwYBAAAAAAIGBgF/AEEACweUAQgRX193YXNtX2NhbGxfY3RvcnMAAAtjb252b2x2ZUhvcgABDGNvbnZvbHZlVmVydAACEmNvbnZvbHZlSG9yV2l0aFByZQADE2NvbnZvbHZlVmVydFdpdGhQcmUABApjb252b2x2ZUhWAAUMX19kc29faGFuZGxlAwAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAAKyA4GAwABC4wDARB/AkAgA0UNACAERQ0AIANBAnQhFQNAQQAhE0EAIQsDQCALQQJqIQcCfyALQQF0IAVqIgYuAQIiC0UEQEEAIQhBACEGQQAhCUEAIQogBwwBCyASIAYuAQBqIQhBACEJQQAhCiALIRRBACEOIAchBkEAIQ8DQCAFIAZBAXRqLgEAIhAgACAIQQJ0aigCACIRQRh2bCAPaiEPIBFB/wFxIBBsIAlqIQkgEUEQdkH/AXEgEGwgDmohDiARQQh2Qf8BcSAQbCAKaiEKIAhBAWohCCAGQQFqIQYgFEEBayIUDQALIAlBB3UhCCAKQQd1IQYgDkEHdSEJIA9BB3UhCiAHIAtqCyELIAEgDEEBdCIHaiAIQQAgCEEAShs7AQAgASAHQQJyaiAGQQAgBkEAShs7AQAgASAHQQRyaiAJQQAgCUEAShs7AQAgASAHQQZyaiAKQQAgCkEAShs7AQAgDCAVaiEMIBNBAWoiEyAERw0ACyANQQFqIg0gAmwhEiANQQJ0IQwgAyANRw0ACwsL2gMBD38CQCADRQ0AIARFDQAgAkECdCEUA0AgCyEMQQAhE0EAIQIDQCACQQJqIQYCfyACQQF0IAVqIgcuAQIiAkUEQEEAIQhBACEHQQAhCkEAIQkgBgwBCyAHLgEAQQJ0IBJqIQhBACEJIAIhCkEAIQ0gBiEHQQAhDkEAIQ8DQCAFIAdBAXRqLgEAIhAgACAIQQF0IhFqLwEAbCAJaiEJIAAgEUEGcmovAQAgEGwgDmohDiAAIBFBBHJqLwEAIBBsIA9qIQ8gACARQQJyai8BACAQbCANaiENIAhBBGohCCAHQQFqIQcgCkEBayIKDQALIAlBB3UhCCANQQd1IQcgDkEHdSEKIA9BB3UhCSACIAZqCyECIAEgDEECdGogB0GAQGtBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobQQh0QYD+A3EgCUGAQGtBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobQRB0QYCA/AdxIApBgEBrQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EYdHJyIAhBgEBrQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG3I2AgAgAyAMaiEMIBNBAWoiEyAERw0ACyAUIAtBAWoiC2whEiADIAtHDQALCwuSAwEQfwJAIANFDQAgBEUNACADQQJ0IRUDQEEAIRNBACEGA0AgBkECaiEIAn8gBkEBdCAFaiIGLgECIgdFBEBBACEJQQAhDEEAIQ1BACEOIAgMAQsgEiAGLgEAaiEJQQAhDkEAIQ1BACEMIAchFEEAIQ8gCCEGA0AgBSAGQQF0ai4BACAAIAlBAnRqKAIAIhBBGHZsIhEgD2ohDyARIBBBEHZB/wFxbCAMaiEMIBEgEEEIdkH/AXFsIA1qIQ0gESAQQf8BcWwgDmohDiAJQQFqIQkgBkEBaiEGIBRBAWsiFA0ACyAPQQd1IQkgByAIagshBiABIApBAXQiCGogDkH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEECcmogDUH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEEEcmogDEH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEEGcmogCUEAIAlBAEobOwEAIAogFWohCiATQQFqIhMgBEcNAAsgC0EBaiILIAJsIRIgC0ECdCEKIAMgC0cNAAsLC4IEAQ9/AkAgA0UNACAERQ0AIAJBAnQhFANAIAshDEEAIRJBACEHA0AgB0ECaiEKAn8gB0EBdCAFaiICLgECIhNFBEBBACEIQQAhCUEAIQYgCiEHQQAMAQsgAi4BAEECdCARaiEJQQAhByATIQJBACENIAohBkEAIQ5BACEPA0AgBSAGQQF0ai4BACIIIAAgCUEBdCIQai8BAGwgB2ohByAAIBBBBnJqLwEAIAhsIA5qIQ4gACAQQQRyai8BACAIbCAPaiEPIAAgEEECcmovAQAgCGwgDWohDSAJQQRqIQkgBkEBaiEGIAJBAWsiAg0ACyAHQQd1IQggDUEHdSEJIA9BB3UhBiAKIBNqIQcgDkEHdQtBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKGyIKQf8BcQRAIAlB/wFsIAJtIQkgCEH/AWwgAm0hCCAGQf8BbCACbSEGCyABIAxBAnRqIAlBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKG0EIdEGA/gNxIAZBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKG0EQdEGAgPwHcSAKQRh0ciAIQYBAa0EOdSICQf8BIAJB/wFIGyICQQAgAkEAShtycjYCACADIAxqIQwgEkEBaiISIARHDQALIBQgC0EBaiILbCERIAMgC0cNAAsLC0AAIAcEQEEAIAIgAyAEIAUgABADIAJBACAEIAUgBiABEAQPC0EAIAIgAyAEIAUgABABIAJBACAEIAUgBiABEAIL";
      }, {}], 4: [function(_dereq_, module4, exports3) {
        "use strict";
        module4.exports = {
          name: "resize",
          fn: _dereq_("./resize"),
          wasm_fn: _dereq_("./resize_wasm"),
          wasm_src: _dereq_("./convolve_wasm_base64")
        };
      }, { "./convolve_wasm_base64": 3, "./resize": 5, "./resize_wasm": 8 }], 5: [function(_dereq_, module4, exports3) {
        "use strict";
        var createFilters = _dereq_("./resize_filter_gen");
        var _require = _dereq_("./convolve"), convolveHor = _require.convolveHor, convolveVert = _require.convolveVert, convolveHorWithPre = _require.convolveHorWithPre, convolveVertWithPre = _require.convolveVertWithPre;
        function hasAlpha(src, width, height) {
          var ptr = 3, len = width * height * 4 | 0;
          while (ptr < len) {
            if (src[ptr] !== 255) return true;
            ptr = ptr + 4 | 0;
          }
          return false;
        }
        function resetAlpha(dst, width, height) {
          var ptr = 3, len = width * height * 4 | 0;
          while (ptr < len) {
            dst[ptr] = 255;
            ptr = ptr + 4 | 0;
          }
        }
        module4.exports = function resize(options) {
          var src = options.src;
          var srcW = options.width;
          var srcH = options.height;
          var destW = options.toWidth;
          var destH = options.toHeight;
          var scaleX = options.scaleX || options.toWidth / options.width;
          var scaleY = options.scaleY || options.toHeight / options.height;
          var offsetX = options.offsetX || 0;
          var offsetY = options.offsetY || 0;
          var dest = options.dest || new Uint8Array(destW * destH * 4);
          var filter = typeof options.filter === "undefined" ? "mks2013" : options.filter;
          var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);
          var tmp = new Uint16Array(destW * srcH * 4);
          if (hasAlpha(src, srcW, srcH)) {
            convolveHorWithPre(src, tmp, srcW, srcH, destW, filtersX);
            convolveVertWithPre(tmp, dest, srcH, destW, destH, filtersY);
          } else {
            convolveHor(src, tmp, srcW, srcH, destW, filtersX);
            convolveVert(tmp, dest, srcH, destW, destH, filtersY);
            resetAlpha(dest, destW, destH);
          }
          return dest;
        };
      }, { "./convolve": 2, "./resize_filter_gen": 6 }], 6: [function(_dereq_, module4, exports3) {
        "use strict";
        var FILTER_INFO = _dereq_("./resize_filter_info");
        var FIXED_FRAC_BITS = 14;
        function toFixedPoint(num) {
          return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));
        }
        module4.exports = function resizeFilterGen(filter, srcSize, destSize, scale, offset) {
          var filterFunction = FILTER_INFO.filter[filter].fn;
          var scaleInverted = 1 / scale;
          var scaleClamped = Math.min(1, scale);
          var srcWindow = FILTER_INFO.filter[filter].win / scaleClamped;
          var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;
          var leftNotEmpty, rightNotEmpty, filterShift, filterSize;
          var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);
          var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);
          var packedFilterPtr = 0;
          var slowCopy = !packedFilter.subarray || !packedFilter.set;
          for (destPixel = 0; destPixel < destSize; destPixel++) {
            srcPixel = (destPixel + 0.5) * scaleInverted + offset;
            srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));
            srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));
            filterElementSize = srcLast - srcFirst + 1;
            floatFilter = new Float32Array(filterElementSize);
            fxpFilter = new Int16Array(filterElementSize);
            total = 0;
            for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {
              floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);
              total += floatVal;
              floatFilter[idx] = floatVal;
            }
            filterTotal = 0;
            for (idx = 0; idx < floatFilter.length; idx++) {
              filterVal = floatFilter[idx] / total;
              filterTotal += filterVal;
              fxpFilter[idx] = toFixedPoint(filterVal);
            }
            fxpFilter[destSize >> 1] += toFixedPoint(1 - filterTotal);
            leftNotEmpty = 0;
            while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {
              leftNotEmpty++;
            }
            if (leftNotEmpty < fxpFilter.length) {
              rightNotEmpty = fxpFilter.length - 1;
              while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {
                rightNotEmpty--;
              }
              filterShift = srcFirst + leftNotEmpty;
              filterSize = rightNotEmpty - leftNotEmpty + 1;
              packedFilter[packedFilterPtr++] = filterShift;
              packedFilter[packedFilterPtr++] = filterSize;
              if (!slowCopy) {
                packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);
                packedFilterPtr += filterSize;
              } else {
                for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {
                  packedFilter[packedFilterPtr++] = fxpFilter[idx];
                }
              }
            } else {
              packedFilter[packedFilterPtr++] = 0;
              packedFilter[packedFilterPtr++] = 0;
            }
          }
          return packedFilter;
        };
      }, { "./resize_filter_info": 7 }], 7: [function(_dereq_, module4, exports3) {
        "use strict";
        var filter = {
          // Nearest neibor
          box: {
            win: 0.5,
            fn: function fn(x) {
              if (x < 0) x = -x;
              return x < 0.5 ? 1 : 0;
            }
          },
          // // Hamming
          hamming: {
            win: 1,
            fn: function fn(x) {
              if (x < 0) x = -x;
              if (x >= 1) {
                return 0;
              }
              if (x < 11920929e-14) {
                return 1;
              }
              var xpi = x * Math.PI;
              return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1));
            }
          },
          // Lanczos, win = 2
          lanczos2: {
            win: 2,
            fn: function fn(x) {
              if (x < 0) x = -x;
              if (x >= 2) {
                return 0;
              }
              if (x < 11920929e-14) {
                return 1;
              }
              var xpi = x * Math.PI;
              return Math.sin(xpi) / xpi * Math.sin(xpi / 2) / (xpi / 2);
            }
          },
          // Lanczos, win = 3
          lanczos3: {
            win: 3,
            fn: function fn(x) {
              if (x < 0) x = -x;
              if (x >= 3) {
                return 0;
              }
              if (x < 11920929e-14) {
                return 1;
              }
              var xpi = x * Math.PI;
              return Math.sin(xpi) / xpi * Math.sin(xpi / 3) / (xpi / 3);
            }
          },
          // Magic Kernel Sharp 2013, win = 2.5
          // http://johncostella.com/magic/
          mks2013: {
            win: 2.5,
            fn: function fn(x) {
              if (x < 0) x = -x;
              if (x >= 2.5) {
                return 0;
              }
              if (x >= 1.5) {
                return -0.125 * (x - 2.5) * (x - 2.5);
              }
              if (x >= 0.5) {
                return 0.25 * (4 * x * x - 11 * x + 7);
              }
              return 1.0625 - 1.75 * x * x;
            }
          }
        };
        module4.exports = {
          filter,
          // Legacy mapping
          f2q: {
            box: 0,
            hamming: 1,
            lanczos2: 2,
            lanczos3: 3
          },
          q2f: ["box", "hamming", "lanczos2", "lanczos3"]
        };
      }, {}], 8: [function(_dereq_, module4, exports3) {
        "use strict";
        var createFilters = _dereq_("./resize_filter_gen");
        function hasAlpha(src, width, height) {
          var ptr = 3, len = width * height * 4 | 0;
          while (ptr < len) {
            if (src[ptr] !== 255) return true;
            ptr = ptr + 4 | 0;
          }
          return false;
        }
        function resetAlpha(dst, width, height) {
          var ptr = 3, len = width * height * 4 | 0;
          while (ptr < len) {
            dst[ptr] = 255;
            ptr = ptr + 4 | 0;
          }
        }
        function asUint8Array(src) {
          return new Uint8Array(src.buffer, 0, src.byteLength);
        }
        var IS_LE = true;
        try {
          IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
        } catch (__) {
        }
        function copyInt16asLE(src, target, target_offset) {
          if (IS_LE) {
            target.set(asUint8Array(src), target_offset);
            return;
          }
          for (var ptr = target_offset, i = 0; i < src.length; i++) {
            var data2 = src[i];
            target[ptr++] = data2 & 255;
            target[ptr++] = data2 >> 8 & 255;
          }
        }
        module4.exports = function resize_wasm(options) {
          var src = options.src;
          var srcW = options.width;
          var srcH = options.height;
          var destW = options.toWidth;
          var destH = options.toHeight;
          var scaleX = options.scaleX || options.toWidth / options.width;
          var scaleY = options.scaleY || options.toHeight / options.height;
          var offsetX = options.offsetX || 0;
          var offsetY = options.offsetY || 0;
          var dest = options.dest || new Uint8Array(destW * destH * 4);
          var filter = typeof options.filter === "undefined" ? "mks2013" : options.filter;
          var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);
          var src_offset = 0;
          var src_size = Math.max(src.byteLength, dest.byteLength);
          var tmp_offset = this.__align(src_offset + src_size);
          var tmp_size = srcH * destW * 4 * 2;
          var filtersX_offset = this.__align(tmp_offset + tmp_size);
          var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);
          var alloc_bytes = filtersY_offset + filtersY.byteLength;
          var instance = this.__instance("resize", alloc_bytes);
          var mem = new Uint8Array(this.__memory.buffer);
          var mem32 = new Uint32Array(this.__memory.buffer);
          var src32 = new Uint32Array(src.buffer);
          mem32.set(src32);
          copyInt16asLE(filtersX, mem, filtersX_offset);
          copyInt16asLE(filtersY, mem, filtersY_offset);
          var fn = instance.exports.convolveHV || instance.exports._convolveHV;
          if (hasAlpha(src, srcW, srcH)) {
            fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 1);
          } else {
            fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 0);
            resetAlpha(dest, destW, destH);
          }
          var dest32 = new Uint32Array(dest.buffer);
          dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW));
          return dest;
        };
      }, { "./resize_filter_gen": 6 }], 9: [function(_dereq_, module4, exports3) {
        "use strict";
        module4.exports = {
          name: "unsharp_mask",
          fn: _dereq_("./unsharp_mask"),
          wasm_fn: _dereq_("./unsharp_mask_wasm"),
          wasm_src: _dereq_("./unsharp_mask_wasm_base64")
        };
      }, { "./unsharp_mask": 10, "./unsharp_mask_wasm": 11, "./unsharp_mask_wasm_base64": 12 }], 10: [function(_dereq_, module4, exports3) {
        "use strict";
        var glur_mono16 = _dereq_("glur/mono16");
        function hsv_v16(img, width, height) {
          var size = width * height;
          var out = new Uint16Array(size);
          var r, g, b, max;
          for (var i = 0; i < size; i++) {
            r = img[4 * i];
            g = img[4 * i + 1];
            b = img[4 * i + 2];
            max = r >= g && r >= b ? r : g >= b && g >= r ? g : b;
            out[i] = max << 8;
          }
          return out;
        }
        module4.exports = function unsharp(img, width, height, amount, radius, threshold) {
          var v1, v2, vmul;
          var diff, iTimes4;
          if (amount === 0 || radius < 0.5) {
            return;
          }
          if (radius > 2) {
            radius = 2;
          }
          var brightness = hsv_v16(img, width, height);
          var blured = new Uint16Array(brightness);
          glur_mono16(blured, width, height, radius);
          var amountFp = amount / 100 * 4096 + 0.5 | 0;
          var thresholdFp = threshold << 8;
          var size = width * height;
          for (var i = 0; i < size; i++) {
            v1 = brightness[i];
            diff = v1 - blured[i];
            if (Math.abs(diff) >= thresholdFp) {
              v2 = v1 + (amountFp * diff + 2048 >> 12);
              v2 = v2 > 65280 ? 65280 : v2;
              v2 = v2 < 0 ? 0 : v2;
              v1 = v1 !== 0 ? v1 : 1;
              vmul = (v2 << 12) / v1 | 0;
              iTimes4 = i * 4;
              img[iTimes4] = img[iTimes4] * vmul + 2048 >> 12;
              img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 2048 >> 12;
              img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 2048 >> 12;
            }
          }
        };
      }, { "glur/mono16": 18 }], 11: [function(_dereq_, module4, exports3) {
        "use strict";
        module4.exports = function unsharp(img, width, height, amount, radius, threshold) {
          if (amount === 0 || radius < 0.5) {
            return;
          }
          if (radius > 2) {
            radius = 2;
          }
          var pixels = width * height;
          var img_bytes_cnt = pixels * 4;
          var hsv_bytes_cnt = pixels * 2;
          var blur_bytes_cnt = pixels * 2;
          var blur_line_byte_cnt = Math.max(width, height) * 4;
          var blur_coeffs_byte_cnt = 8 * 4;
          var img_offset = 0;
          var hsv_offset = img_bytes_cnt;
          var blur_offset = hsv_offset + hsv_bytes_cnt;
          var blur_tmp_offset = blur_offset + blur_bytes_cnt;
          var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;
          var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;
          var instance = this.__instance("unsharp_mask", img_bytes_cnt + hsv_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {
            exp: Math.exp
          });
          var img32 = new Uint32Array(img.buffer);
          var mem32 = new Uint32Array(this.__memory.buffer);
          mem32.set(img32);
          var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;
          fn(img_offset, hsv_offset, width, height);
          fn = instance.exports.blurMono16 || instance.exports._blurMono16;
          fn(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius);
          fn = instance.exports.unsharp || instance.exports._unsharp;
          fn(img_offset, img_offset, hsv_offset, blur_offset, width, height, amount, threshold);
          img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));
        };
      }, {}], 12: [function(_dereq_, module4, exports3) {
        "use strict";
        module4.exports = "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";
      }, {}], 13: [function(_dereq_, module4, exports3) {
        "use strict";
        var GC_INTERVAL = 100;
        function Pool(create, idle) {
          this.create = create;
          this.available = [];
          this.acquired = {};
          this.lastId = 1;
          this.timeoutId = 0;
          this.idle = idle || 2e3;
        }
        Pool.prototype.acquire = function() {
          var _this = this;
          var resource;
          if (this.available.length !== 0) {
            resource = this.available.pop();
          } else {
            resource = this.create();
            resource.id = this.lastId++;
            resource.release = function() {
              return _this.release(resource);
            };
          }
          this.acquired[resource.id] = resource;
          return resource;
        };
        Pool.prototype.release = function(resource) {
          var _this2 = this;
          delete this.acquired[resource.id];
          resource.lastUsed = Date.now();
          this.available.push(resource);
          if (this.timeoutId === 0) {
            this.timeoutId = setTimeout(function() {
              return _this2.gc();
            }, GC_INTERVAL);
          }
        };
        Pool.prototype.gc = function() {
          var _this3 = this;
          var now = Date.now();
          this.available = this.available.filter(function(resource) {
            if (now - resource.lastUsed > _this3.idle) {
              resource.destroy();
              return false;
            }
            return true;
          });
          if (this.available.length !== 0) {
            this.timeoutId = setTimeout(function() {
              return _this3.gc();
            }, GC_INTERVAL);
          } else {
            this.timeoutId = 0;
          }
        };
        module4.exports = Pool;
      }, {}], 14: [function(_dereq_, module4, exports3) {
        "use strict";
        var MIN_INNER_TILE_SIZE = 2;
        module4.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {
          var scaleX = toWidth / fromWidth;
          var scaleY = toHeight / fromHeight;
          var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize;
          if (minScale > 0.5) return [[toWidth, toHeight]];
          var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale));
          if (stageCount <= 1) return [[toWidth, toHeight]];
          var result = [];
          for (var i = 0; i < stageCount; i++) {
            var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));
            var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));
            result.push([width, height]);
          }
          return result;
        };
      }, {}], 15: [function(_dereq_, module4, exports3) {
        "use strict";
        var PIXEL_EPSILON = 1e-5;
        function pixelFloor(x) {
          var nearest = Math.round(x);
          if (Math.abs(x - nearest) < PIXEL_EPSILON) {
            return nearest;
          }
          return Math.floor(x);
        }
        function pixelCeil(x) {
          var nearest = Math.round(x);
          if (Math.abs(x - nearest) < PIXEL_EPSILON) {
            return nearest;
          }
          return Math.ceil(x);
        }
        module4.exports = function createRegions(options) {
          var scaleX = options.toWidth / options.width;
          var scaleY = options.toHeight / options.height;
          var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;
          var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder;
          if (innerTileWidth < 1 || innerTileHeight < 1) {
            throw new Error("Internal error in pica: target tile width/height is too small.");
          }
          var x, y;
          var innerX, innerY, toTileWidth, toTileHeight;
          var tiles = [];
          var tile;
          for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {
            for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {
              x = innerX - options.destTileBorder;
              if (x < 0) {
                x = 0;
              }
              toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;
              if (x + toTileWidth >= options.toWidth) {
                toTileWidth = options.toWidth - x;
              }
              y = innerY - options.destTileBorder;
              if (y < 0) {
                y = 0;
              }
              toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;
              if (y + toTileHeight >= options.toHeight) {
                toTileHeight = options.toHeight - y;
              }
              tile = {
                toX: x,
                toY: y,
                toWidth: toTileWidth,
                toHeight: toTileHeight,
                toInnerX: innerX,
                toInnerY: innerY,
                toInnerWidth: innerTileWidth,
                toInnerHeight: innerTileHeight,
                offsetX: x / scaleX - pixelFloor(x / scaleX),
                offsetY: y / scaleY - pixelFloor(y / scaleY),
                scaleX,
                scaleY,
                x: pixelFloor(x / scaleX),
                y: pixelFloor(y / scaleY),
                width: pixelCeil(toTileWidth / scaleX),
                height: pixelCeil(toTileHeight / scaleY)
              };
              tiles.push(tile);
            }
          }
          return tiles;
        };
      }, {}], 16: [function(_dereq_, module4, exports3) {
        "use strict";
        function objClass(obj) {
          return Object.prototype.toString.call(obj);
        }
        module4.exports.isCanvas = function isCanvas(element) {
          var cname = objClass(element);
          return cname === "[object HTMLCanvasElement]" || cname === "[object OffscreenCanvas]" || cname === "[object Canvas]";
        };
        module4.exports.isImage = function isImage(element) {
          return objClass(element) === "[object HTMLImageElement]";
        };
        module4.exports.isImageBitmap = function isImageBitmap(element) {
          return objClass(element) === "[object ImageBitmap]";
        };
        module4.exports.limiter = function limiter(concurrency) {
          var active = 0, queue = [];
          function roll() {
            if (active < concurrency && queue.length) {
              active++;
              queue.shift()();
            }
          }
          return function limit(fn) {
            return new Promise(function(resolve, reject) {
              queue.push(function() {
                fn().then(function(result) {
                  resolve(result);
                  active--;
                  roll();
                }, function(err) {
                  reject(err);
                  active--;
                  roll();
                });
              });
              roll();
            });
          };
        };
        module4.exports.cib_quality_name = function cib_quality_name(num) {
          switch (num) {
            case 0:
              return "pixelated";
            case 1:
              return "low";
            case 2:
              return "medium";
          }
          return "high";
        };
        module4.exports.cib_support = function cib_support(createCanvas) {
          return Promise.resolve().then(function() {
            if (typeof createImageBitmap === "undefined") {
              return false;
            }
            var c = createCanvas(100, 100);
            return createImageBitmap(c, 0, 0, 100, 100, {
              resizeWidth: 10,
              resizeHeight: 10,
              resizeQuality: "high"
            }).then(function(bitmap) {
              var status = bitmap.width === 10;
              bitmap.close();
              c = null;
              return status;
            });
          })["catch"](function() {
            return false;
          });
        };
        module4.exports.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {
          return new Promise(function(resolve, reject) {
            if (typeof OffscreenCanvas === "undefined") {
              resolve(false);
              return;
            }
            function workerPayload(self2) {
              if (typeof createImageBitmap === "undefined") {
                self2.postMessage(false);
                return;
              }
              Promise.resolve().then(function() {
                var canvas = new OffscreenCanvas(10, 10);
                var ctx = canvas.getContext("2d");
                ctx.rect(0, 0, 1, 1);
                return createImageBitmap(canvas, 0, 0, 1, 1);
              }).then(function() {
                return self2.postMessage(true);
              }, function() {
                return self2.postMessage(false);
              });
            }
            var code = btoa("(".concat(workerPayload.toString(), ")(self);"));
            var w = new Worker("data:text/javascript;base64,".concat(code));
            w.onmessage = function(ev) {
              return resolve(ev.data);
            };
            w.onerror = reject;
          }).then(function(result) {
            return result;
          }, function() {
            return false;
          });
        };
        module4.exports.can_use_canvas = function can_use_canvas(createCanvas) {
          var usable = false;
          try {
            var canvas = createCanvas(2, 1);
            var ctx = canvas.getContext("2d");
            var d = ctx.createImageData(2, 1);
            d.data[0] = 12;
            d.data[1] = 23;
            d.data[2] = 34;
            d.data[3] = 255;
            d.data[4] = 45;
            d.data[5] = 56;
            d.data[6] = 67;
            d.data[7] = 255;
            ctx.putImageData(d, 0, 0);
            d = null;
            d = ctx.getImageData(0, 0, 2, 1);
            if (d.data[0] === 12 && d.data[1] === 23 && d.data[2] === 34 && d.data[3] === 255 && d.data[4] === 45 && d.data[5] === 56 && d.data[6] === 67 && d.data[7] === 255) {
              usable = true;
            }
          } catch (err) {
          }
          return usable;
        };
        module4.exports.cib_can_use_region = function cib_can_use_region() {
          return new Promise(function(resolve) {
            if (typeof Image === "undefined" || typeof createImageBitmap === "undefined") {
              resolve(false);
              return;
            }
            var image = new Image();
            image.src = "data:image/jpeg;base64,/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRcZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRAf/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z";
            image.onload = function() {
              createImageBitmap(image, 0, 0, image.width, image.height).then(function(bitmap) {
                if (bitmap.width === image.width && bitmap.height === image.height) {
                  resolve(true);
                } else {
                  resolve(false);
                }
              }, function() {
                return resolve(false);
              });
            };
            image.onerror = function() {
              return resolve(false);
            };
          });
        };
      }, {}], 17: [function(_dereq_, module4, exports3) {
        "use strict";
        module4.exports = function() {
          var MathLib = _dereq_("./mathlib");
          var mathLib;
          onmessage = function onmessage2(ev) {
            var tileOpts = ev.data.opts;
            var returnBitmap = false;
            if (!tileOpts.src && tileOpts.srcBitmap) {
              var canvas = new OffscreenCanvas(tileOpts.width, tileOpts.height);
              var ctx = canvas.getContext("2d");
              ctx.drawImage(tileOpts.srcBitmap, 0, 0);
              tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data;
              canvas.width = canvas.height = 0;
              canvas = null;
              tileOpts.srcBitmap.close();
              tileOpts.srcBitmap = null;
            }
            if (!mathLib) mathLib = new MathLib(ev.data.features);
            var data2 = mathLib.resizeAndUnsharp(tileOpts);
            if (returnBitmap) {
              var toImageData = new ImageData(new Uint8ClampedArray(data2), tileOpts.toWidth, tileOpts.toHeight);
              var _canvas = new OffscreenCanvas(tileOpts.toWidth, tileOpts.toHeight);
              var _ctx = _canvas.getContext("2d");
              _ctx.putImageData(toImageData, 0, 0);
              createImageBitmap(_canvas).then(function(bitmap) {
                postMessage({
                  bitmap
                }, [bitmap]);
              });
            } else {
              postMessage({
                data: data2
              }, [data2.buffer]);
            }
          };
        };
      }, { "./mathlib": 1 }], 18: [function(_dereq_, module4, exports3) {
        var a0, a1, a2, a3, b1, b2, left_corner, right_corner;
        function gaussCoef(sigma) {
          if (sigma < 0.5) {
            sigma = 0.5;
          }
          var a = Math.exp(0.726 * 0.726) / sigma, g1 = Math.exp(-a), g2 = Math.exp(-2 * a), k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);
          a0 = k;
          a1 = k * (a - 1) * g1;
          a2 = k * (a + 1) * g1;
          a3 = -k * g2;
          b1 = 2 * g1;
          b2 = -g2;
          left_corner = (a0 + a1) / (1 - b1 - b2);
          right_corner = (a2 + a3) / (1 - b1 - b2);
          return new Float32Array([a0, a1, a2, a3, b1, b2, left_corner, right_corner]);
        }
        function convolveMono16(src, out, line, coeff, width, height) {
          var prev_src, curr_src, curr_out, prev_out, prev_prev_out;
          var src_index, out_index, line_index;
          var i, j;
          var coeff_a0, coeff_a1, coeff_b1, coeff_b2;
          for (i = 0; i < height; i++) {
            src_index = i * width;
            out_index = i;
            line_index = 0;
            prev_src = src[src_index];
            prev_prev_out = prev_src * coeff[6];
            prev_out = prev_prev_out;
            coeff_a0 = coeff[0];
            coeff_a1 = coeff[1];
            coeff_b1 = coeff[4];
            coeff_b2 = coeff[5];
            for (j = 0; j < width; j++) {
              curr_src = src[src_index];
              curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
              prev_prev_out = prev_out;
              prev_out = curr_out;
              prev_src = curr_src;
              line[line_index] = prev_out;
              line_index++;
              src_index++;
            }
            src_index--;
            line_index--;
            out_index += height * (width - 1);
            prev_src = src[src_index];
            prev_prev_out = prev_src * coeff[7];
            prev_out = prev_prev_out;
            curr_src = prev_src;
            coeff_a0 = coeff[2];
            coeff_a1 = coeff[3];
            for (j = width - 1; j >= 0; j--) {
              curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
              prev_prev_out = prev_out;
              prev_out = curr_out;
              prev_src = curr_src;
              curr_src = src[src_index];
              out[out_index] = line[line_index] + prev_out;
              src_index--;
              line_index--;
              out_index -= height;
            }
          }
        }
        function blurMono16(src, width, height, radius) {
          if (!radius) {
            return;
          }
          var out = new Uint16Array(src.length), tmp_line = new Float32Array(Math.max(width, height));
          var coeff = gaussCoef(radius);
          convolveMono16(src, out, tmp_line, coeff, width, height, radius);
          convolveMono16(out, src, tmp_line, coeff, height, width, radius);
        }
        module4.exports = blurMono16;
      }, {}], 19: [function(_dereq_, module4, exports3) {
        "use strict";
        var assign3 = _dereq_("object-assign");
        var base64decode = _dereq_("./lib/base64decode");
        var hasWebAssembly = _dereq_("./lib/wa_detect");
        var DEFAULT_OPTIONS = {
          js: true,
          wasm: true
        };
        function MultiMath(options) {
          if (!(this instanceof MultiMath)) return new MultiMath(options);
          var opts = assign3({}, DEFAULT_OPTIONS, options || {});
          this.options = opts;
          this.__cache = {};
          this.__init_promise = null;
          this.__modules = opts.modules || {};
          this.__memory = null;
          this.__wasm = {};
          this.__isLE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
          if (!this.options.js && !this.options.wasm) {
            throw new Error('mathlib: at least "js" or "wasm" should be enabled');
          }
        }
        MultiMath.prototype.has_wasm = hasWebAssembly;
        MultiMath.prototype.use = function(module5) {
          this.__modules[module5.name] = module5;
          if (this.options.wasm && this.has_wasm() && module5.wasm_fn) {
            this[module5.name] = module5.wasm_fn;
          } else {
            this[module5.name] = module5.fn;
          }
          return this;
        };
        MultiMath.prototype.init = function() {
          if (this.__init_promise) return this.__init_promise;
          if (!this.options.js && this.options.wasm && !this.has_wasm()) {
            return Promise.reject(new Error(`mathlib: only "wasm" was enabled, but it's not supported`));
          }
          var self2 = this;
          this.__init_promise = Promise.all(Object.keys(self2.__modules).map(function(name) {
            var module5 = self2.__modules[name];
            if (!self2.options.wasm || !self2.has_wasm() || !module5.wasm_fn) return null;
            if (self2.__wasm[name]) return null;
            return WebAssembly.compile(self2.__base64decode(module5.wasm_src)).then(function(m) {
              self2.__wasm[name] = m;
            });
          })).then(function() {
            return self2;
          });
          return this.__init_promise;
        };
        MultiMath.prototype.__base64decode = base64decode;
        MultiMath.prototype.__reallocate = function mem_grow_to(bytes2) {
          if (!this.__memory) {
            this.__memory = new WebAssembly.Memory({
              initial: Math.ceil(bytes2 / (64 * 1024))
            });
            return this.__memory;
          }
          var mem_size = this.__memory.buffer.byteLength;
          if (mem_size < bytes2) {
            this.__memory.grow(Math.ceil((bytes2 - mem_size) / (64 * 1024)));
          }
          return this.__memory;
        };
        MultiMath.prototype.__instance = function instance(name, memsize, env_extra) {
          if (memsize) this.__reallocate(memsize);
          if (!this.__wasm[name]) {
            var module5 = this.__modules[name];
            this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module5.wasm_src));
          }
          if (!this.__cache[name]) {
            var env_base = {
              memoryBase: 0,
              memory: this.__memory,
              tableBase: 0,
              table: new WebAssembly.Table({ initial: 0, element: "anyfunc" })
            };
            this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {
              env: assign3(env_base, env_extra || {})
            });
          }
          return this.__cache[name];
        };
        MultiMath.prototype.__align = function align(number2, base) {
          base = base || 8;
          var reminder = number2 % base;
          return number2 + (reminder ? base - reminder : 0);
        };
        module4.exports = MultiMath;
      }, { "./lib/base64decode": 20, "./lib/wa_detect": 21, "object-assign": 22 }], 20: [function(_dereq_, module4, exports3) {
        "use strict";
        var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        module4.exports = function base64decode(str) {
          var input = str.replace(/[\r\n=]/g, ""), max = input.length;
          var out = new Uint8Array(max * 3 >> 2);
          var bits = 0;
          var ptr = 0;
          for (var idx = 0; idx < max; idx++) {
            if (idx % 4 === 0 && idx) {
              out[ptr++] = bits >> 16 & 255;
              out[ptr++] = bits >> 8 & 255;
              out[ptr++] = bits & 255;
            }
            bits = bits << 6 | BASE64_MAP.indexOf(input.charAt(idx));
          }
          var tailbits = max % 4 * 6;
          if (tailbits === 0) {
            out[ptr++] = bits >> 16 & 255;
            out[ptr++] = bits >> 8 & 255;
            out[ptr++] = bits & 255;
          } else if (tailbits === 18) {
            out[ptr++] = bits >> 10 & 255;
            out[ptr++] = bits >> 2 & 255;
          } else if (tailbits === 12) {
            out[ptr++] = bits >> 4 & 255;
          }
          return out;
        };
      }, {}], 21: [function(_dereq_, module4, exports3) {
        "use strict";
        var wa;
        module4.exports = function hasWebAssembly() {
          if (typeof wa !== "undefined") return wa;
          wa = false;
          if (typeof WebAssembly === "undefined") return wa;
          try {
            var bin = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]);
            var module5 = new WebAssembly.Module(bin);
            var instance = new WebAssembly.Instance(module5, {});
            if (instance.exports.test(4) !== 0) wa = true;
            return wa;
          } catch (__) {
          }
          return wa;
        };
      }, {}], 22: [function(_dereq_, module4, exports3) {
        "use strict";
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
          if (val === null || val === void 0) {
            throw new TypeError("Object.assign cannot be called with null or undefined");
          }
          return Object(val);
        }
        function shouldUseNative() {
          try {
            if (!Object.assign) {
              return false;
            }
            var test1 = new String("abc");
            test1[5] = "de";
            if (Object.getOwnPropertyNames(test1)[0] === "5") {
              return false;
            }
            var test2 = {};
            for (var i = 0; i < 10; i++) {
              test2["_" + String.fromCharCode(i)] = i;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
              return test2[n];
            });
            if (order2.join("") !== "0123456789") {
              return false;
            }
            var test3 = {};
            "abcdefghijklmnopqrst".split("").forEach(function(letter) {
              test3[letter] = letter;
            });
            if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
              return false;
            }
            return true;
          } catch (err) {
            return false;
          }
        }
        module4.exports = shouldUseNative() ? Object.assign : function(target, source) {
          var from;
          var to = toObject(target);
          var symbols;
          for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) {
              if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
              }
            }
            if (getOwnPropertySymbols) {
              symbols = getOwnPropertySymbols(from);
              for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                  to[symbols[i]] = from[symbols[i]];
                }
              }
            }
          }
          return to;
        };
      }, {}], 23: [function(_dereq_, module4, exports3) {
        var bundleFn = arguments[3];
        var sources = arguments[4];
        var cache = arguments[5];
        var stringify = JSON.stringify;
        module4.exports = function(fn, options) {
          var wkey;
          var cacheKeys = Object.keys(cache);
          for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            var exp = cache[key].exports;
            if (exp === fn || exp && exp.default === fn) {
              wkey = key;
              break;
            }
          }
          if (!wkey) {
            wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
            var wcache = {};
            for (var i = 0, l = cacheKeys.length; i < l; i++) {
              var key = cacheKeys[i];
              wcache[key] = key;
            }
            sources[wkey] = [
              "function(require,module,exports){" + fn + "(self); }",
              wcache
            ];
          }
          var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
          var scache = {};
          scache[wkey] = wkey;
          sources[skey] = [
            "function(require,module,exports){var f = require(" + stringify(wkey) + ");(f.default ? f.default : f)(self);}",
            scache
          ];
          var workerSources = {};
          resolveSources(skey);
          function resolveSources(key2) {
            workerSources[key2] = true;
            for (var depPath in sources[key2][1]) {
              var depKey = sources[key2][1][depPath];
              if (!workerSources[depKey]) {
                resolveSources(depKey);
              }
            }
          }
          var src = "(" + bundleFn + ")({" + Object.keys(workerSources).map(function(key2) {
            return stringify(key2) + ":[" + sources[key2][0] + "," + stringify(sources[key2][1]) + "]";
          }).join(",") + "},{},[" + stringify(skey) + "])";
          var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
          var blob = new Blob([src], { type: "text/javascript" });
          if (options && options.bare) {
            return blob;
          }
          var workerUrl = URL2.createObjectURL(blob);
          var worker = new Worker(workerUrl);
          worker.objectURL = workerUrl;
          return worker;
        };
      }, {}], "/index.js": [function(_dereq_, module4, exports3) {
        "use strict";
        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _iterableToArrayLimit(arr, i) {
          var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
          if (_i == null) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _s, _e;
          try {
            for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }
        var assign3 = _dereq_("object-assign");
        var webworkify = _dereq_("webworkify");
        var MathLib = _dereq_("./lib/mathlib");
        var Pool = _dereq_("./lib/pool");
        var utils2 = _dereq_("./lib/utils");
        var worker = _dereq_("./lib/worker");
        var createStages = _dereq_("./lib/stepper");
        var createRegions = _dereq_("./lib/tiler");
        var filter_info = _dereq_("./lib/mm_resize/resize_filter_info");
        var singletones = {};
        var NEED_SAFARI_FIX = false;
        try {
          if (typeof navigator !== "undefined" && navigator.userAgent) {
            NEED_SAFARI_FIX = navigator.userAgent.indexOf("Safari") >= 0;
          }
        } catch (e) {
        }
        var concurrency = 1;
        if (typeof navigator !== "undefined") {
          concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);
        }
        var DEFAULT_PICA_OPTS = {
          tile: 1024,
          concurrency,
          features: ["js", "wasm", "ww"],
          idle: 2e3,
          createCanvas: function createCanvas(width, height) {
            var tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = width;
            tmpCanvas.height = height;
            return tmpCanvas;
          }
        };
        var DEFAULT_RESIZE_OPTS = {
          filter: "mks2013",
          unsharpAmount: 0,
          unsharpRadius: 0,
          unsharpThreshold: 0
        };
        var CAN_NEW_IMAGE_DATA = false;
        var CAN_CREATE_IMAGE_BITMAP = false;
        var CAN_USE_CANVAS_GET_IMAGE_DATA = false;
        var CAN_USE_OFFSCREEN_CANVAS = false;
        var CAN_USE_CIB_REGION_FOR_IMAGE = false;
        function workerFabric() {
          return {
            value: webworkify(worker),
            destroy: function destroy() {
              this.value.terminate();
              if (typeof window !== "undefined") {
                var url = window.URL || window.webkitURL || window.mozURL || window.msURL;
                if (url && url.revokeObjectURL && this.value.objectURL) {
                  url.revokeObjectURL(this.value.objectURL);
                }
              }
            }
          };
        }
        function Pica2(options) {
          if (!(this instanceof Pica2)) return new Pica2(options);
          this.options = assign3({}, DEFAULT_PICA_OPTS, options || {});
          var limiter_key = "lk_".concat(this.options.concurrency);
          this.__limit = singletones[limiter_key] || utils2.limiter(this.options.concurrency);
          if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit;
          this.features = {
            js: false,
            // pure JS implementation, can be disabled for testing
            wasm: false,
            // webassembly implementation for heavy functions
            cib: false,
            // resize via createImageBitmap (only FF at this moment)
            ww: false
            // webworkers
          };
          this.__workersPool = null;
          this.__requested_features = [];
          this.__mathlib = null;
        }
        Pica2.prototype.init = function() {
          var _this = this;
          if (this.__initPromise) return this.__initPromise;
          if (typeof ImageData !== "undefined" && typeof Uint8ClampedArray !== "undefined") {
            try {
              new ImageData(new Uint8ClampedArray(400), 10, 10);
              CAN_NEW_IMAGE_DATA = true;
            } catch (__) {
            }
          }
          if (typeof ImageBitmap !== "undefined") {
            if (ImageBitmap.prototype && ImageBitmap.prototype.close) {
              CAN_CREATE_IMAGE_BITMAP = true;
            } else {
              this.debug("ImageBitmap does not support .close(), disabled");
            }
          }
          var features = this.options.features.slice();
          if (features.indexOf("all") >= 0) {
            features = ["cib", "wasm", "js", "ww"];
          }
          this.__requested_features = features;
          this.__mathlib = new MathLib(features);
          if (features.indexOf("ww") >= 0) {
            if (typeof window !== "undefined" && "Worker" in window) {
              try {
                var wkr = _dereq_("webworkify")(function() {
                });
                wkr.terminate();
                this.features.ww = true;
                var wpool_key = "wp_".concat(JSON.stringify(this.options));
                if (singletones[wpool_key]) {
                  this.__workersPool = singletones[wpool_key];
                } else {
                  this.__workersPool = new Pool(workerFabric, this.options.idle);
                  singletones[wpool_key] = this.__workersPool;
                }
              } catch (__) {
              }
            }
          }
          var initMath = this.__mathlib.init().then(function(mathlib) {
            assign3(_this.features, mathlib.features);
          });
          var checkCibResize;
          if (!CAN_CREATE_IMAGE_BITMAP) {
            checkCibResize = Promise.resolve(false);
          } else {
            checkCibResize = utils2.cib_support(this.options.createCanvas).then(function(status) {
              if (_this.features.cib && features.indexOf("cib") < 0) {
                _this.debug("createImageBitmap() resize supported, but disabled by config");
                return;
              }
              if (features.indexOf("cib") >= 0) _this.features.cib = status;
            });
          }
          CAN_USE_CANVAS_GET_IMAGE_DATA = utils2.can_use_canvas(this.options.createCanvas);
          var checkOffscreenCanvas;
          if (CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && features.indexOf("ww") !== -1) {
            checkOffscreenCanvas = utils2.worker_offscreen_canvas_support();
          } else {
            checkOffscreenCanvas = Promise.resolve(false);
          }
          checkOffscreenCanvas = checkOffscreenCanvas.then(function(result) {
            CAN_USE_OFFSCREEN_CANVAS = result;
          });
          var checkCibRegion = utils2.cib_can_use_region().then(function(result) {
            CAN_USE_CIB_REGION_FOR_IMAGE = result;
          });
          this.__initPromise = Promise.all([initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion]).then(function() {
            return _this;
          });
          return this.__initPromise;
        };
        Pica2.prototype.__invokeResize = function(tileOpts, opts) {
          var _this2 = this;
          opts.__mathCache = opts.__mathCache || {};
          return Promise.resolve().then(function() {
            if (!_this2.features.ww) {
              return {
                data: _this2.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)
              };
            }
            return new Promise(function(resolve, reject) {
              var w = _this2.__workersPool.acquire();
              if (opts.cancelToken) opts.cancelToken["catch"](function(err) {
                return reject(err);
              });
              w.value.onmessage = function(ev) {
                w.release();
                if (ev.data.err) reject(ev.data.err);
                else resolve(ev.data);
              };
              var transfer = [];
              if (tileOpts.src) transfer.push(tileOpts.src.buffer);
              if (tileOpts.srcBitmap) transfer.push(tileOpts.srcBitmap);
              w.value.postMessage({
                opts: tileOpts,
                features: _this2.__requested_features,
                preload: {
                  wasm_nodule: _this2.__mathlib.__
                }
              }, transfer);
            });
          });
        };
        Pica2.prototype.__extractTileData = function(tile, from, opts, stageEnv, extractTo) {
          if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,
          // can use canvas because canvas doesn't have orientation;
          // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671
          (utils2.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) {
            this.debug("Create tile for OffscreenCanvas");
            return createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then(function(bitmap) {
              extractTo.srcBitmap = bitmap;
              return extractTo;
            });
          }
          if (utils2.isCanvas(from)) {
            if (!stageEnv.srcCtx) stageEnv.srcCtx = from.getContext("2d");
            this.debug("Get tile pixel data");
            extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data;
            return extractTo;
          }
          this.debug("Draw tile imageBitmap/image to temporary canvas");
          var tmpCanvas = this.options.createCanvas(tile.width, tile.height);
          var tmpCtx = tmpCanvas.getContext("2d");
          tmpCtx.globalCompositeOperation = "copy";
          tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);
          this.debug("Get tile pixel data");
          extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data;
          tmpCanvas.width = tmpCanvas.height = 0;
          return extractTo;
        };
        Pica2.prototype.__landTileData = function(tile, result, stageEnv) {
          var toImageData;
          this.debug("Convert raw rgba tile result to ImageData");
          if (result.bitmap) {
            stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY);
            return null;
          }
          if (CAN_NEW_IMAGE_DATA) {
            toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight);
          } else {
            toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight);
            if (toImageData.data.set) {
              toImageData.data.set(result.data);
            } else {
              for (var i = toImageData.data.length - 1; i >= 0; i--) {
                toImageData.data[i] = result.data[i];
              }
            }
          }
          this.debug("Draw tile");
          if (NEED_SAFARI_FIX) {
            stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);
          } else {
            stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);
          }
          return null;
        };
        Pica2.prototype.__tileAndResize = function(from, to, opts) {
          var _this3 = this;
          var stageEnv = {
            srcCtx: null,
            srcImageBitmap: null,
            isImageBitmapReused: false,
            toCtx: null
          };
          var processTile = function processTile2(tile) {
            return _this3.__limit(function() {
              if (opts.canceled) return opts.cancelToken;
              var tileOpts = {
                width: tile.width,
                height: tile.height,
                toWidth: tile.toWidth,
                toHeight: tile.toHeight,
                scaleX: tile.scaleX,
                scaleY: tile.scaleY,
                offsetX: tile.offsetX,
                offsetY: tile.offsetY,
                filter: opts.filter,
                unsharpAmount: opts.unsharpAmount,
                unsharpRadius: opts.unsharpRadius,
                unsharpThreshold: opts.unsharpThreshold
              };
              _this3.debug("Invoke resize math");
              return Promise.resolve(tileOpts).then(function(tileOpts2) {
                return _this3.__extractTileData(tile, from, opts, stageEnv, tileOpts2);
              }).then(function(tileOpts2) {
                _this3.debug("Invoke resize math");
                return _this3.__invokeResize(tileOpts2, opts);
              }).then(function(result) {
                if (opts.canceled) return opts.cancelToken;
                stageEnv.srcImageData = null;
                return _this3.__landTileData(tile, result, stageEnv);
              });
            });
          };
          return Promise.resolve().then(function() {
            stageEnv.toCtx = to.getContext("2d");
            if (utils2.isCanvas(from)) return null;
            if (utils2.isImageBitmap(from)) {
              stageEnv.srcImageBitmap = from;
              stageEnv.isImageBitmapReused = true;
              return null;
            }
            if (utils2.isImage(from)) {
              if (!CAN_CREATE_IMAGE_BITMAP) return null;
              _this3.debug("Decode image via createImageBitmap");
              return createImageBitmap(from).then(function(imageBitmap) {
                stageEnv.srcImageBitmap = imageBitmap;
              })["catch"](function(e) {
                return null;
              });
            }
            throw new Error('Pica: ".from" should be Image, Canvas or ImageBitmap');
          }).then(function() {
            if (opts.canceled) return opts.cancelToken;
            _this3.debug("Calculate tiles");
            var regions = createRegions({
              width: opts.width,
              height: opts.height,
              srcTileSize: _this3.options.tile,
              toWidth: opts.toWidth,
              toHeight: opts.toHeight,
              destTileBorder: opts.__destTileBorder
            });
            var jobs = regions.map(function(tile) {
              return processTile(tile);
            });
            function cleanup(stageEnv2) {
              if (stageEnv2.srcImageBitmap) {
                if (!stageEnv2.isImageBitmapReused) stageEnv2.srcImageBitmap.close();
                stageEnv2.srcImageBitmap = null;
              }
            }
            _this3.debug("Process tiles");
            return Promise.all(jobs).then(function() {
              _this3.debug("Finished!");
              cleanup(stageEnv);
              return to;
            }, function(err) {
              cleanup(stageEnv);
              throw err;
            });
          });
        };
        Pica2.prototype.__processStages = function(stages, from, to, opts) {
          var _this4 = this;
          if (opts.canceled) return opts.cancelToken;
          var _stages$shift = stages.shift(), _stages$shift2 = _slicedToArray(_stages$shift, 2), toWidth = _stages$shift2[0], toHeight = _stages$shift2[1];
          var isLastStage = stages.length === 0;
          var filter;
          if (isLastStage || filter_info.q2f.indexOf(opts.filter) < 0) filter = opts.filter;
          else if (opts.filter === "box") filter = "box";
          else filter = "hamming";
          opts = assign3({}, opts, {
            toWidth,
            toHeight,
            filter
          });
          var tmpCanvas;
          if (!isLastStage) {
            tmpCanvas = this.options.createCanvas(toWidth, toHeight);
          }
          return this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function() {
            if (isLastStage) return to;
            opts.width = toWidth;
            opts.height = toHeight;
            return _this4.__processStages(stages, tmpCanvas, to, opts);
          }).then(function(res) {
            if (tmpCanvas) {
              tmpCanvas.width = tmpCanvas.height = 0;
            }
            return res;
          });
        };
        Pica2.prototype.__resizeViaCreateImageBitmap = function(from, to, opts) {
          var _this5 = this;
          var toCtx = to.getContext("2d");
          this.debug("Resize via createImageBitmap()");
          return createImageBitmap(from, {
            resizeWidth: opts.toWidth,
            resizeHeight: opts.toHeight,
            resizeQuality: utils2.cib_quality_name(filter_info.f2q[opts.filter])
          }).then(function(imageBitmap) {
            if (opts.canceled) return opts.cancelToken;
            if (!opts.unsharpAmount) {
              toCtx.drawImage(imageBitmap, 0, 0);
              imageBitmap.close();
              toCtx = null;
              _this5.debug("Finished!");
              return to;
            }
            _this5.debug("Unsharp result");
            var tmpCanvas = _this5.options.createCanvas(opts.toWidth, opts.toHeight);
            var tmpCtx = tmpCanvas.getContext("2d");
            tmpCtx.drawImage(imageBitmap, 0, 0);
            imageBitmap.close();
            var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);
            _this5.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);
            toCtx.putImageData(iData, 0, 0);
            tmpCanvas.width = tmpCanvas.height = 0;
            iData = tmpCtx = tmpCanvas = toCtx = null;
            _this5.debug("Finished!");
            return to;
          });
        };
        Pica2.prototype.resize = function(from, to, options) {
          var _this6 = this;
          this.debug("Start resize...");
          var opts = assign3({}, DEFAULT_RESIZE_OPTS);
          if (!isNaN(options)) {
            opts = assign3(opts, {
              quality: options
            });
          } else if (options) {
            opts = assign3(opts, options);
          }
          opts.toWidth = to.width;
          opts.toHeight = to.height;
          opts.width = from.naturalWidth || from.width;
          opts.height = from.naturalHeight || from.height;
          if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
            if (opts.quality < 0 || opts.quality > 3) {
              throw new Error("Pica: .quality should be [0..3], got ".concat(opts.quality));
            }
            opts.filter = filter_info.q2f[opts.quality];
          }
          if (to.width === 0 || to.height === 0) {
            return Promise.reject(new Error("Invalid output size: ".concat(to.width, "x").concat(to.height)));
          }
          if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;
          opts.canceled = false;
          if (opts.cancelToken) {
            opts.cancelToken = opts.cancelToken.then(function(data2) {
              opts.canceled = true;
              throw data2;
            }, function(err) {
              opts.canceled = true;
              throw err;
            });
          }
          var DEST_TILE_BORDER = 3;
          opts.__destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));
          return this.init().then(function() {
            if (opts.canceled) return opts.cancelToken;
            if (_this6.features.cib) {
              if (filter_info.q2f.indexOf(opts.filter) >= 0) {
                return _this6.__resizeViaCreateImageBitmap(from, to, opts);
              }
              _this6.debug("cib is enabled, but not supports provided filter, fallback to manual math");
            }
            if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {
              var err = new Error("Pica: cannot use getImageData on canvas, make sure fingerprinting protection isn't enabled");
              err.code = "ERR_GET_IMAGE_DATA";
              throw err;
            }
            var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this6.options.tile, opts.__destTileBorder);
            return _this6.__processStages(stages, from, to, opts);
          });
        };
        Pica2.prototype.resizeBuffer = function(options) {
          var _this7 = this;
          var opts = assign3({}, DEFAULT_RESIZE_OPTS, options);
          if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
            if (opts.quality < 0 || opts.quality > 3) {
              throw new Error("Pica: .quality should be [0..3], got ".concat(opts.quality));
            }
            opts.filter = filter_info.q2f[opts.quality];
          }
          return this.init().then(function() {
            return _this7.__mathlib.resizeAndUnsharp(opts);
          });
        };
        Pica2.prototype.toBlob = function(canvas, mimeType, quality) {
          mimeType = mimeType || "image/png";
          return new Promise(function(resolve) {
            if (canvas.toBlob) {
              canvas.toBlob(function(blob) {
                return resolve(blob);
              }, mimeType, quality);
              return;
            }
            if (canvas.convertToBlob) {
              resolve(canvas.convertToBlob({
                type: mimeType,
                quality
              }));
              return;
            }
            var asString = atob(canvas.toDataURL(mimeType, quality).split(",")[1]);
            var len = asString.length;
            var asBuffer = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
              asBuffer[i] = asString.charCodeAt(i);
            }
            resolve(new Blob([asBuffer], {
              type: mimeType
            }));
          });
        };
        Pica2.prototype.debug = function() {
        };
        module4.exports = Pica2;
      }, { "./lib/mathlib": 1, "./lib/mm_resize/resize_filter_info": 7, "./lib/pool": 13, "./lib/stepper": 14, "./lib/tiler": 15, "./lib/utils": 16, "./lib/worker": 17, "object-assign": 22, "webworkify": 23 }] }, {}, [])("/index.js");
    });
  }
});

// node_modules/.pnpm/jazz-react@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react/dist/provider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/.pnpm/jazz-browser@0.13.17/node_modules/jazz-browser/dist/utils/export-account-inspector.js
async function exportAccountToInspector() {
  const authSecretStorage = new AuthSecretStorage();
  const localStorageData = await authSecretStorage.get();
  if (!localStorageData) {
    console.error("No account data found in localStorage");
    return;
  }
  const encodedAccountSecret = btoa(localStorageData.accountSecret);
  window.open(new URL(`#/import/${localStorageData == null ? void 0 : localStorageData.accountID}/${encodedAccountSecret}`, "https://inspector.jazz.tools").toString(), "_blank");
}
function listenForCmdJ() {
  if (typeof window === "undefined")
    return;
  const cb = (e) => {
    if (e.metaKey && e.key === "j") {
      if (confirm("Are you sure you want to inspect your account using inspector.jazz.tools? This lets anyone with the secret inspector URL read your data and impersonate you.")) {
        exportAccountToInspector();
      }
    }
  };
  window.addEventListener("keydown", cb);
  return () => {
    window.removeEventListener("keydown", cb);
  };
}
function setupInspector() {
  if (typeof window === "undefined")
    return;
  const url = new URL(window.location.href);
  if (url.hash.includes("allowJazzInspector") || true) {
    return listenForCmdJ();
  }
}

// node_modules/.pnpm/jazz-browser@0.13.17/node_modules/jazz-browser/dist/auth/PasskeyAuth.js
var BrowserPasskeyAuth = class {
  constructor(crypto, authenticate, authSecretStorage, appName, appHostname = window.location.hostname) {
    this.crypto = crypto;
    this.authenticate = authenticate;
    this.authSecretStorage = authSecretStorage;
    this.appName = appName;
    this.appHostname = appHostname;
    this.logIn = async () => {
      const { crypto: crypto2, authenticate: authenticate2 } = this;
      const webAuthNCredential = await this.getPasskeyCredentials();
      if (!webAuthNCredential) {
        return;
      }
      const webAuthNCredentialPayload = new Uint8Array(webAuthNCredential.response.userHandle);
      const accountSecretSeed = webAuthNCredentialPayload.slice(0, cojsonInternals.secretSeedLength);
      const secret = crypto2.agentSecretFromSecretSeed(accountSecretSeed);
      const accountID = cojsonInternals.rawCoIDfromBytes(webAuthNCredentialPayload.slice(cojsonInternals.secretSeedLength, cojsonInternals.secretSeedLength + cojsonInternals.shortHashLength));
      await authenticate2({
        accountID,
        accountSecret: secret
      });
      await this.authSecretStorage.set({
        accountID,
        secretSeed: accountSecretSeed,
        accountSecret: secret,
        provider: "passkey"
      });
    };
    this.signUp = async (username) => {
      const credentials = await this.authSecretStorage.get();
      if (!(credentials == null ? void 0 : credentials.secretSeed)) {
        throw new Error("Not enough credentials to register the account with passkey");
      }
      await this.createPasskeyCredentials({
        accountID: credentials.accountID,
        secretSeed: credentials.secretSeed,
        username
      });
      const currentAccount = await Account.getMe().ensureLoaded({
        resolve: {
          profile: true
        }
      });
      if (username.trim().length !== 0) {
        currentAccount.profile.name = username;
      }
      await this.authSecretStorage.set({
        accountID: credentials.accountID,
        secretSeed: credentials.secretSeed,
        accountSecret: credentials.accountSecret,
        provider: "passkey"
      });
    };
  }
  async createPasskeyCredentials({ accountID, secretSeed, username }) {
    const webAuthNCredentialPayload = new Uint8Array(cojsonInternals.secretSeedLength + cojsonInternals.shortHashLength);
    webAuthNCredentialPayload.set(secretSeed);
    webAuthNCredentialPayload.set(cojsonInternals.rawCoIDtoBytes(accountID), cojsonInternals.secretSeedLength);
    try {
      await navigator.credentials.create({
        publicKey: {
          challenge: Uint8Array.from([0, 1, 2]),
          rp: {
            name: this.appName,
            id: this.appHostname
          },
          user: {
            id: webAuthNCredentialPayload,
            name: username + ` (${(/* @__PURE__ */ new Date()).toLocaleString()})`,
            displayName: username
          },
          pubKeyCredParams: [
            { alg: -7, type: "public-key" },
            { alg: -8, type: "public-key" },
            { alg: -37, type: "public-key" },
            { alg: -257, type: "public-key" }
          ],
          authenticatorSelection: {
            requireResidentKey: true,
            residentKey: "required",
            userVerification: "preferred"
          },
          timeout: 6e4,
          attestation: "direct"
        }
      });
    } catch (error) {
      throw new Error("Passkey creation aborted", { cause: error });
    }
  }
  async getPasskeyCredentials() {
    try {
      const value = await navigator.credentials.get({
        publicKey: {
          challenge: Uint8Array.from([0, 1, 2]),
          rpId: this.appHostname,
          allowCredentials: [],
          timeout: 6e4,
          userVerification: "preferred"
        },
        mediation: "optional"
      });
      return value;
    } catch (error) {
      throw new Error("Passkey creation aborted", { cause: error });
    }
  }
};
BrowserPasskeyAuth.id = "passkey";

// node_modules/.pnpm/cojson-storage@0.13.17/node_modules/cojson-storage/dist/syncUtils.js
function collectNewTxs({ newTxsInSession, newContentMessages, sessionRow, firstNewTxIdx }) {
  for (const tx of newTxsInSession) {
    const lastMessage = newContentMessages[newContentMessages.length - 1];
    if (!lastMessage)
      return;
    let sessionEntry = lastMessage.new[sessionRow.sessionID];
    if (!sessionEntry) {
      sessionEntry = {
        after: firstNewTxIdx,
        lastSignature: "WILL_BE_REPLACED",
        newTransactions: []
      };
      lastMessage.new[sessionRow.sessionID] = sessionEntry;
    }
    sessionEntry.newTransactions.push(tx.tx);
    sessionEntry.lastSignature = sessionRow.lastSignature;
  }
}
function getDependedOnCoValues({ coValueRow, newContentMessages }) {
  return coValueRow.header.ruleset.type === "group" ? getGroupDependedOnCoValues(newContentMessages) : coValueRow.header.ruleset.type === "ownedByGroup" ? getOwnedByGroupDependedOnCoValues(coValueRow, newContentMessages) : [];
}
function getGroupDependedOnCoValues(newContentMessages) {
  const keys = [];
  for (const piece of newContentMessages) {
    for (const sessionEntry of Object.values(piece.new)) {
      for (const tx of sessionEntry.newTransactions) {
        if (tx.privacy !== "trusting")
          continue;
        const changes = safeParseChanges(tx.changes);
        for (const change of changes) {
          if (change && typeof change === "object" && "op" in change && change.op === "set" && "key" in change && change.key) {
            const key = cojsonInternals.getGroupDependentKey(change.key);
            if (key) {
              keys.push(key);
            }
          }
        }
      }
    }
  }
  return keys;
}
function getOwnedByGroupDependedOnCoValues(coValueRow, newContentMessages) {
  if (coValueRow.header.ruleset.type !== "ownedByGroup")
    return [];
  const keys = [coValueRow.header.ruleset.group];
  for (const piece of newContentMessages) {
    for (const sessionID of Object.keys(piece.new)) {
      const accountId = cojsonInternals.accountOrAgentIDfromSessionID(sessionID);
      if (cojsonInternals.isAccountID(accountId) && accountId !== coValueRow.id) {
        keys.push(accountId);
      }
    }
  }
  return keys;
}
function safeParseChanges(changes) {
  try {
    return cojsonInternals.parseJSON(changes);
  } catch (e) {
    return [];
  }
}

// node_modules/.pnpm/cojson-storage@0.13.17/node_modules/cojson-storage/dist/syncManager.js
var SyncManager = class {
  constructor(dbClient, toLocalNode) {
    this.toLocalNode = toLocalNode;
    this.dbClient = dbClient;
  }
  async handleSyncMessage(msg) {
    switch (msg.action) {
      case "load":
        await this.handleLoad(msg);
        break;
      case "content":
        await this.handleContent(msg);
        break;
      case "known":
        await this.handleKnown(msg);
        break;
      case "done":
        await this.handleDone(msg);
        break;
    }
  }
  async handleSessionUpdate({ sessionRow, peerKnownState, newContentMessages }) {
    if (sessionRow.lastIdx <= (peerKnownState.sessions[sessionRow.sessionID] || 0))
      return;
    const firstNewTxIdx = peerKnownState.sessions[sessionRow.sessionID] || 0;
    const newTxsInSession = await this.dbClient.getNewTransactionInSession(sessionRow.rowID, firstNewTxIdx);
    collectNewTxs({
      newTxsInSession,
      newContentMessages,
      sessionRow,
      firstNewTxIdx
    });
  }
  async sendNewContent(coValueKnownState) {
    const outputMessages = await this.collectCoValueData(coValueKnownState);
    const collectedMessages = Object.values(outputMessages).reverse();
    for (const { knownMessage, contentMessages } of collectedMessages) {
      this.sendStateMessage(knownMessage);
      if (contentMessages == null ? void 0 : contentMessages.length) {
        for (const msg of contentMessages) {
          this.sendStateMessage(msg);
        }
      }
    }
  }
  async collectCoValueData(peerKnownState, messageMap = {}, asDependencyOf) {
    if (messageMap[peerKnownState.id]) {
      return messageMap;
    }
    const coValueRow = await this.dbClient.getCoValue(peerKnownState.id);
    if (!coValueRow) {
      const emptyKnownMessage = {
        action: "known",
        ...emptyKnownState(peerKnownState.id)
      };
      if (asDependencyOf) {
        emptyKnownMessage.asDependencyOf = asDependencyOf;
      }
      messageMap[peerKnownState.id] = { knownMessage: emptyKnownMessage };
      return messageMap;
    }
    const allCoValueSessions = await this.dbClient.getCoValueSessions(coValueRow.rowID);
    const newCoValueKnownState = {
      id: coValueRow.id,
      header: true,
      sessions: {}
    };
    const newContentMessages = [
      {
        action: "content",
        id: coValueRow.id,
        header: coValueRow.header,
        new: {},
        priority: cojsonInternals.getPriorityFromHeader(coValueRow.header)
      }
    ];
    await Promise.all(allCoValueSessions.map((sessionRow) => {
      newCoValueKnownState.sessions[sessionRow.sessionID] = sessionRow.lastIdx;
      return this.handleSessionUpdate({
        sessionRow,
        peerKnownState,
        newContentMessages
      });
    }));
    const dependedOnCoValuesList = getDependedOnCoValues({
      coValueRow,
      newContentMessages
    });
    const knownMessage = {
      action: "known",
      ...newCoValueKnownState
    };
    if (asDependencyOf) {
      knownMessage.asDependencyOf = asDependencyOf;
    }
    messageMap[newCoValueKnownState.id] = {
      knownMessage,
      contentMessages: newContentMessages
    };
    await Promise.all(dependedOnCoValuesList.map((dependedOnCoValue) => this.collectCoValueData({
      id: dependedOnCoValue,
      header: false,
      sessions: {}
    }, messageMap, asDependencyOf || coValueRow.id)));
    return messageMap;
  }
  handleLoad(msg) {
    return this.sendNewContent(msg);
  }
  async handleContent(msg) {
    const coValueRow = await this.dbClient.getCoValue(msg.id);
    const invalidAssumptionOnHeaderPresence = !msg.header && !coValueRow;
    if (invalidAssumptionOnHeaderPresence) {
      return this.sendStateMessage({
        action: "known",
        id: msg.id,
        header: false,
        sessions: {},
        isCorrection: true
      });
    }
    const storedCoValueRowID = coValueRow ? coValueRow.rowID : await this.dbClient.addCoValue(msg);
    const ourKnown = {
      id: msg.id,
      header: true,
      sessions: {}
    };
    let invalidAssumptions = false;
    for (const sessionID of Object.keys(msg.new)) {
      await this.dbClient.transaction(async () => {
        var _a;
        const sessionRow = await this.dbClient.getSingleCoValueSession(storedCoValueRowID, sessionID);
        if (sessionRow) {
          ourKnown.sessions[sessionRow.sessionID] = sessionRow.lastIdx;
        }
        if (((sessionRow == null ? void 0 : sessionRow.lastIdx) || 0) < (((_a = msg.new[sessionID]) == null ? void 0 : _a.after) || 0)) {
          invalidAssumptions = true;
        } else {
          return this.putNewTxs(msg, sessionID, sessionRow, storedCoValueRowID);
        }
      });
    }
    if (invalidAssumptions) {
      this.sendStateMessage({
        action: "known",
        ...ourKnown,
        isCorrection: invalidAssumptions
      });
    }
  }
  async putNewTxs(msg, sessionID, sessionRow, storedCoValueRowID) {
    var _a, _b;
    const newTransactions = ((_a = msg.new[sessionID]) == null ? void 0 : _a.newTransactions) || [];
    const actuallyNewOffset = ((sessionRow == null ? void 0 : sessionRow.lastIdx) || 0) - (((_b = msg.new[sessionID]) == null ? void 0 : _b.after) || 0);
    const actuallyNewTransactions = newTransactions.slice(actuallyNewOffset);
    let newBytesSinceLastSignature = ((sessionRow == null ? void 0 : sessionRow.bytesSinceLastSignature) || 0) + actuallyNewTransactions.reduce((sum, tx) => sum + (tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length), 0);
    const newLastIdx = ((sessionRow == null ? void 0 : sessionRow.lastIdx) || 0) + actuallyNewTransactions.length;
    let shouldWriteSignature = false;
    if (newBytesSinceLastSignature > MAX_RECOMMENDED_TX_SIZE) {
      shouldWriteSignature = true;
      newBytesSinceLastSignature = 0;
    }
    const nextIdx = (sessionRow == null ? void 0 : sessionRow.lastIdx) || 0;
    if (!msg.new[sessionID])
      throw new Error("Session ID not found");
    const sessionUpdate = {
      coValue: storedCoValueRowID,
      sessionID,
      lastIdx: newLastIdx,
      lastSignature: msg.new[sessionID].lastSignature,
      bytesSinceLastSignature: newBytesSinceLastSignature
    };
    const sessionRowID = await this.dbClient.addSessionUpdate({
      sessionUpdate,
      sessionRow
    });
    if (shouldWriteSignature) {
      await this.dbClient.addSignatureAfter({
        sessionRowID,
        idx: newLastIdx - 1,
        signature: msg.new[sessionID].lastSignature
      });
    }
    return Promise.all(actuallyNewTransactions.map((newTransaction, i) => this.dbClient.addTransaction(sessionRowID, nextIdx + i, newTransaction)));
  }
  handleKnown(_msg) {
  }
  handleDone(_msg) {
  }
  async sendStateMessage(msg) {
    return this.toLocalNode.push(msg).catch((e) => logger.error(`Error sending ${msg.action} state, id ${msg.id}`, {
      err: e
    }));
  }
};

// node_modules/.pnpm/cojson-storage-indexeddb@0.13.17/node_modules/cojson-storage-indexeddb/dist/CoJsonIDBTransaction.js
var CoJsonIDBTransaction = class {
  constructor(db) {
    this.pendingRequests = [];
    this.rejectHandlers = [];
    this.id = Math.random();
    this.running = false;
    this.failed = false;
    this.done = false;
    this.startedAt = performance.now();
    this.db = db;
    this.tx = this.db.transaction(["coValues", "sessions", "transactions", "signatureAfter"], "readwrite");
    this.tx.oncomplete = () => {
      this.done = true;
    };
    this.tx.onabort = () => {
      this.done = true;
    };
  }
  isReusable() {
    const delta = performance.now() - this.startedAt;
    return !this.done && delta <= 20;
  }
  getObjectStore(name) {
    return this.tx.objectStore(name);
  }
  pushRequest(handler) {
    const next = () => {
      const next2 = this.pendingRequests.shift();
      if (next2) {
        next2(this);
      } else {
        this.running = false;
        this.done = true;
      }
    };
    if (this.running) {
      return new Promise((resolve, reject) => {
        this.rejectHandlers.push(reject);
        this.pendingRequests.push(async () => {
          try {
            const result = await handler(this, next);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        });
      });
    }
    this.running = true;
    return handler(this, next);
  }
  handleRequest(handler) {
    return this.pushRequest((txEntry, next) => {
      return new Promise((resolve, reject) => {
        const request = handler(txEntry);
        request.onerror = () => {
          this.failed = true;
          this.tx.abort();
          console.error(request.error);
          reject(request.error);
          for (const handler2 of this.rejectHandlers) {
            handler2();
          }
        };
        request.onsuccess = () => {
          resolve(request.result);
          next();
        };
      });
    });
  }
  commit() {
    if (!this.done) {
      this.tx.commit();
    }
  }
};

// node_modules/.pnpm/cojson-storage-indexeddb@0.13.17/node_modules/cojson-storage-indexeddb/dist/idbClient.js
var IDBClient = class {
  constructor(db) {
    this.db = db;
  }
  makeRequest(handler) {
    var _a;
    if (this.activeTransaction) {
      return this.activeTransaction.handleRequest(handler);
    }
    if ((_a = this.autoBatchingTransaction) == null ? void 0 : _a.isReusable()) {
      return this.autoBatchingTransaction.handleRequest(handler);
    }
    const tx = new CoJsonIDBTransaction(this.db);
    this.autoBatchingTransaction = tx;
    return tx.handleRequest(handler);
  }
  async getCoValue(coValueId) {
    return this.makeRequest((tx) => tx.getObjectStore("coValues").index("coValuesById").get(coValueId));
  }
  async getCoValueSessions(coValueRowId) {
    return this.makeRequest((tx) => tx.getObjectStore("sessions").index("sessionsByCoValue").getAll(coValueRowId));
  }
  async getSingleCoValueSession(coValueRowId, sessionID) {
    return this.makeRequest((tx) => tx.getObjectStore("sessions").index("uniqueSessions").get([coValueRowId, sessionID]));
  }
  async getNewTransactionInSession(sessionRowId, firstNewTxIdx) {
    return this.makeRequest((tx) => tx.getObjectStore("transactions").getAll(IDBKeyRange.bound([sessionRowId, firstNewTxIdx], [sessionRowId, Number.POSITIVE_INFINITY])));
  }
  async getSignatures(sessionRowId, firstNewTxIdx) {
    return this.makeRequest((tx) => tx.getObjectStore("signatureAfter").getAll(IDBKeyRange.bound([sessionRowId, firstNewTxIdx], [sessionRowId, Number.POSITIVE_INFINITY])));
  }
  async addCoValue(msg) {
    if (!msg.header) {
      throw new Error(`Header is required, coId: ${msg.id}`);
    }
    return await this.makeRequest((tx) => tx.getObjectStore("coValues").put({
      id: msg.id,
      // biome-ignore lint/style/noNonNullAssertion: TODO(JAZZ-561): Review
      header: msg.header
    }));
  }
  async addSessionUpdate({ sessionUpdate, sessionRow }) {
    return this.makeRequest((tx) => tx.getObjectStore("sessions").put((sessionRow == null ? void 0 : sessionRow.rowID) ? {
      rowID: sessionRow.rowID,
      ...sessionUpdate
    } : sessionUpdate));
  }
  async addTransaction(sessionRowID, idx, newTransaction) {
    await this.makeRequest((tx) => tx.getObjectStore("transactions").add({
      ses: sessionRowID,
      idx,
      tx: newTransaction
    }));
  }
  async addSignatureAfter({ sessionRowID, idx, signature }) {
    return this.makeRequest((tx) => tx.getObjectStore("signatureAfter").put({
      ses: sessionRowID,
      idx,
      signature
    }));
  }
  closeTransaction(tx) {
    tx.commit();
    if (tx === this.activeTransaction) {
      this.activeTransaction = void 0;
    }
  }
  async transaction(operationsCallback) {
    const tx = new CoJsonIDBTransaction(this.db);
    this.activeTransaction = tx;
    try {
      await operationsCallback();
      tx.commit();
    } finally {
      this.activeTransaction = void 0;
    }
  }
};

// node_modules/.pnpm/cojson-storage-indexeddb@0.13.17/node_modules/cojson-storage-indexeddb/dist/idbNode.js
var DATABASE_NAME = "jazz-storage";
var IDBNode = class _IDBNode {
  constructor(db, fromLocalNode, toLocalNode) {
    this.dbClient = new IDBClient(db);
    this.syncManager = new SyncManager(this.dbClient, toLocalNode);
    const processMessages = async () => {
      for await (const msg of fromLocalNode) {
        try {
          if (msg === "Disconnected" || msg === "PingTimeout") {
            throw new Error("Unexpected Disconnected message");
          }
          await this.syncManager.handleSyncMessage(msg);
        } catch (e) {
          console.error(e);
        }
      }
    };
    processMessages().catch((e) => console.error("Error in processMessages in IndexedDB", e));
  }
  static async asPeer({ trace, localNodeName = "local" } = {
    localNodeName: "local"
  }) {
    const [localNodeAsPeer, storageAsPeer] = cojsonInternals.connectedPeers(localNodeName, "indexedDB", {
      peer1role: "client",
      peer2role: "storage",
      trace,
      crashOnClose: true
    });
    await _IDBNode.open(localNodeAsPeer.incoming, localNodeAsPeer.outgoing);
    return { ...storageAsPeer, priority: 100 };
  }
  static async open(fromLocalNode, toLocalNode) {
    const dbPromise = new Promise((resolve, reject) => {
      const request = indexedDB.open(DATABASE_NAME, 4);
      request.onerror = () => {
        reject(request.error);
      };
      request.onsuccess = () => {
        resolve(request.result);
      };
      request.onupgradeneeded = async (ev) => {
        const db = request.result;
        if (ev.oldVersion === 0) {
          const coValues = db.createObjectStore("coValues", {
            autoIncrement: true,
            keyPath: "rowID"
          });
          coValues.createIndex("coValuesById", "id", {
            unique: true
          });
          const sessions = db.createObjectStore("sessions", {
            autoIncrement: true,
            keyPath: "rowID"
          });
          sessions.createIndex("sessionsByCoValue", "coValue");
          sessions.createIndex("uniqueSessions", ["coValue", "sessionID"], {
            unique: true
          });
          db.createObjectStore("transactions", {
            keyPath: ["ses", "idx"]
          });
        }
        if (ev.oldVersion <= 1) {
          db.createObjectStore("signatureAfter", {
            keyPath: ["ses", "idx"]
          });
        }
      };
    });
    return new _IDBNode(await dbPromise, fromLocalNode, toLocalNode);
  }
};

// node_modules/.pnpm/cojson-transport-ws@0.13.17/node_modules/cojson-transport-ws/dist/serialization.js
function addMessageToBacklog(backlog, message) {
  if (!backlog) {
    return JSON.stringify(message);
  }
  return `${backlog}
${JSON.stringify(message)}`;
}
function deserializeMessages(messages) {
  if (typeof messages !== "string") {
    return {
      ok: false,
      error: new Error("Expected a string")
    };
  }
  try {
    return {
      ok: true,
      messages: messages.split("\n").map((msg) => JSON.parse(msg))
    };
  } catch (e) {
    logger.error("Error while deserializing messages", { err: e });
    return {
      ok: false,
      error: e
    };
  }
}

// node_modules/.pnpm/cojson-transport-ws@0.13.17/node_modules/cojson-transport-ws/dist/BatchedOutgoingMessages.js
var MAX_OUTGOING_MESSAGES_CHUNK_BYTES = 25e3;
var BatchedOutgoingMessages = class {
  constructor(send) {
    this.send = send;
    this.backlog = "";
    this.timeout = null;
  }
  push(msg) {
    const payload = addMessageToBacklog(this.backlog, msg);
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    const maxChunkSizeReached = payload.length >= MAX_OUTGOING_MESSAGES_CHUNK_BYTES;
    const backlogExists = this.backlog.length > 0;
    if (maxChunkSizeReached && backlogExists) {
      this.sendMessagesInBulk();
      this.backlog = addMessageToBacklog("", msg);
      this.timeout = setTimeout(() => {
        this.sendMessagesInBulk();
      }, 0);
    } else if (maxChunkSizeReached) {
      this.backlog = payload;
      this.sendMessagesInBulk();
    } else {
      this.backlog = payload;
      this.timeout = setTimeout(() => {
        this.sendMessagesInBulk();
      }, 0);
    }
  }
  sendMessagesInBulk() {
    this.send(this.backlog);
    this.backlog = "";
  }
  close() {
    this.sendMessagesInBulk();
  }
};

// node_modules/.pnpm/cojson-transport-ws@0.13.17/node_modules/cojson-transport-ws/dist/createWebSocketPeer.js
var BUFFER_LIMIT = 1e5;
var BUFFER_LIMIT_POLLING_INTERVAL = 10;
function createPingTimeoutListener(enabled, timeout, callback) {
  if (!enabled) {
    return {
      reset() {
      },
      clear() {
      }
    };
  }
  let pingTimeout = null;
  return {
    reset() {
      pingTimeout && clearTimeout(pingTimeout);
      pingTimeout = setTimeout(() => {
        callback();
      }, timeout);
    },
    clear() {
      pingTimeout && clearTimeout(pingTimeout);
    }
  };
}
function waitForWebSocketOpen(websocket) {
  return new Promise((resolve) => {
    if (websocket.readyState === 1) {
      resolve();
    } else {
      websocket.addEventListener("open", () => resolve(), { once: true });
    }
  });
}
function createOutgoingMessagesManager(websocket, batchingByDefault) {
  let closed = false;
  const outgoingMessages = new BatchedOutgoingMessages((messages) => {
    if (websocket.readyState === 1) {
      websocket.send(messages);
    }
  });
  let batchingEnabled = batchingByDefault;
  async function sendMessage(msg) {
    if (closed) {
      return Promise.reject(new Error("WebSocket closed"));
    }
    if (websocket.readyState !== 1) {
      await waitForWebSocketOpen(websocket);
    }
    while (websocket.bufferedAmount > BUFFER_LIMIT && websocket.readyState === 1) {
      await new Promise((resolve) => setTimeout(resolve, BUFFER_LIMIT_POLLING_INTERVAL));
    }
    if (websocket.readyState !== 1) {
      return;
    }
    if (!batchingEnabled) {
      websocket.send(JSON.stringify(msg));
    } else {
      outgoingMessages.push(msg);
    }
  }
  return {
    sendMessage,
    setBatchingEnabled(enabled) {
      batchingEnabled = enabled;
    },
    close() {
      closed = true;
      outgoingMessages.close();
    }
  };
}
function createClosedEventEmitter(callback = () => {
}) {
  let disconnected = false;
  return () => {
    if (disconnected)
      return;
    disconnected = true;
    callback();
  };
}
function createWebSocketPeer({ id, websocket, role, expectPings = true, batchingByDefault = true, deletePeerStateOnClose = false, pingTimeout = 1e4, onSuccess, onClose }) {
  const incoming = new cojsonInternals.Channel();
  const emitClosedEvent = createClosedEventEmitter(onClose);
  function handleClose() {
    incoming.push("Disconnected").catch((e) => logger.error("Error while pushing disconnect msg", { err: e }));
    emitClosedEvent();
  }
  websocket.addEventListener("close", handleClose);
  websocket.addEventListener("error", (err) => {
    if (err.message) {
      logger.warn("WebSocket error", { err });
    }
    handleClose();
  });
  const pingTimeoutListener = createPingTimeoutListener(expectPings, pingTimeout, () => {
    incoming.push("PingTimeout").catch((e) => logger.error("Error while pushing ping timeout", { err: e }));
    emitClosedEvent();
  });
  const outgoingMessages = createOutgoingMessagesManager(websocket, batchingByDefault);
  let isFirstMessage = true;
  function handleIncomingMsg(event) {
    pingTimeoutListener.reset();
    if (event.data === "") {
      return;
    }
    const result = deserializeMessages(event.data);
    if (!result.ok) {
      logger.warn("Error while deserializing messages", { err: result.error });
      return;
    }
    if (isFirstMessage) {
      onSuccess == null ? void 0 : onSuccess();
      isFirstMessage = false;
    }
    const { messages } = result;
    if (messages.length > 1) {
      outgoingMessages.setBatchingEnabled(true);
    }
    for (const msg of messages) {
      if (msg && "action" in msg) {
        incoming.push(msg).catch((e) => logger.error("Error while pushing incoming msg", { err: e }));
      }
    }
  }
  websocket.addEventListener("message", handleIncomingMsg);
  return {
    id,
    incoming,
    outgoing: {
      push: outgoingMessages.sendMessage,
      close() {
        outgoingMessages.close();
        websocket.removeEventListener("message", handleIncomingMsg);
        websocket.removeEventListener("close", handleClose);
        pingTimeoutListener.clear();
        emitClosedEvent();
        if (websocket.readyState === 0) {
          websocket.addEventListener("open", function handleClose2() {
            websocket.close();
          }, { once: true });
        } else if (websocket.readyState === 1) {
          websocket.close();
        }
      }
    },
    role,
    crashOnClose: false,
    deletePeerStateOnClose
  };
}

// node_modules/.pnpm/cojson-transport-ws@0.13.17/node_modules/cojson-transport-ws/dist/WebSocketPeerWithReconnection.js
var WebSocketPeerWithReconnection = class {
  constructor(opts) {
    this.state = "disabled";
    this.currentPeer = void 0;
    this.unsubscribeNetworkChange = void 0;
    this.reconnectionAttempts = 0;
    this.startConnection = async () => {
      if (this.state !== "enabled")
        return;
      if (this.currentPeer) {
        this.removePeer(this.currentPeer);
        this.reconnectionAttempts++;
        const timeout = this.reconnectionTimeout * this.reconnectionAttempts;
        logger.debug(`Websocket disconnected, trying to reconnect in ${timeout}ms`);
        await this.waitForOnline(timeout);
      }
      if (this.state !== "enabled")
        return;
      this.currentPeer = createWebSocketPeer({
        websocket: new WebSocket(this.peer),
        id: this.peer,
        role: "server",
        onClose: this.startConnection,
        onSuccess: () => {
          logger.debug("Websocket connection successful");
          this.reconnectionAttempts = 0;
        }
      });
      this.addPeer(this.currentPeer);
    };
    this.enable = () => {
      if (this.state === "enabled")
        return;
      this.state = "enabled";
      this.startConnection();
    };
    this.disable = () => {
      var _a;
      if (this.state === "disabled")
        return;
      this.state = "disabled";
      this.reconnectionAttempts = 0;
      (_a = this.unsubscribeNetworkChange) == null ? void 0 : _a.call(this);
      this.unsubscribeNetworkChange = void 0;
      if (this.currentPeer) {
        this.removePeer(this.currentPeer);
        this.currentPeer = void 0;
      }
    };
    this.peer = opts.peer;
    this.reconnectionTimeout = opts.reconnectionTimeout || 500;
    this.addPeer = opts.addPeer;
    this.removePeer = opts.removePeer;
  }
  // Basic implementation for environments that don't support network change events (e.g. Node.js)
  // Needs to be extended to handle platform specific APIs
  onNetworkChange(callback) {
    callback;
    return () => {
    };
  }
  waitForOnline(timeout) {
    return new Promise((resolve) => {
      const unsubscribeNetworkChange = this.onNetworkChange((connected) => {
        if (connected) {
          handleTimeoutOrOnline();
        }
      });
      function handleTimeoutOrOnline() {
        clearTimeout(timer);
        unsubscribeNetworkChange();
        resolve();
      }
      const timer = setTimeout(handleTimeoutOrOnline, timeout);
    });
  }
};

// node_modules/.pnpm/jazz-crypto-rs@0.0.7/node_modules/jazz-crypto-rs/dist/esm/wasm/pkg/jazz_crypto_rs.mjs
var wasm;
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length) heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_export_0(addHeapObject(e));
  }
}
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function dropObject(idx) {
  if (idx < 132) return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127) break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8ArrayMemory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function blake3_hash_once(data2) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(data2, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.blake3_hash_once(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var v2 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export_1(r0, r1 * 1, 1);
    return v2;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function blake3_hash_once_with_context(data2, context) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(data2, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArray8ToWasm0(context, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    wasm.blake3_hash_once_with_context(retptr, ptr0, len0, ptr1, len1);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var v3 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export_1(r0, r1 * 1, 1);
    return v3;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function blake3_empty_state() {
  const ret = wasm.blake3_empty_state();
  return Blake3Hasher.__wrap(ret);
}
function new_ed25519_signing_key() {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.new_ed25519_signing_key(retptr);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var v1 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export_1(r0, r1 * 1, 1);
    return v1;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function encrypt(value, key_secret, nonce_material) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(value, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(key_secret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_export_2);
    const len2 = WASM_VECTOR_LEN;
    wasm.decrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    if (r3) {
      throw takeObject(r2);
    }
    var v4 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export_1(r0, r1 * 1, 1);
    return v4;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function decrypt(ciphertext, key_secret, nonce_material) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(ciphertext, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(key_secret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_export_2);
    const len2 = WASM_VECTOR_LEN;
    wasm.decrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    if (r3) {
      throw takeObject(r2);
    }
    var v4 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export_1(r0, r1 * 1, 1);
    return v4;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function seal(message, sender_secret, recipient_id, nonce_material) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(sender_secret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passStringToWasm0(recipient_id, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
    const len2 = WASM_VECTOR_LEN;
    const ptr3 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_export_2);
    const len3 = WASM_VECTOR_LEN;
    wasm.seal(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    if (r3) {
      throw takeObject(r2);
    }
    var v5 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export_1(r0, r1 * 1, 1);
    return v5;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function unseal(sealed_message, recipient_secret, sender_id, nonce_material) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(sealed_message, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(recipient_secret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passStringToWasm0(sender_id, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
    const len2 = WASM_VECTOR_LEN;
    const ptr3 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_export_2);
    const len3 = WASM_VECTOR_LEN;
    wasm.unseal(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    if (r3) {
      throw takeObject(r2);
    }
    var v5 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export_1(r0, r1 * 1, 1);
    return v5;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function sign(message, secret) {
  let deferred4_0;
  let deferred4_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArray8ToWasm0(secret, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    wasm.sign(retptr, ptr0, len0, ptr1, len1);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr3 = r0;
    var len3 = r1;
    if (r3) {
      ptr3 = 0;
      len3 = 0;
      throw takeObject(r2);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm0(ptr3, len3);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_1(deferred4_0, deferred4_1, 1);
  }
}
function verify(signature, message, id) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArray8ToWasm0(message, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passArray8ToWasm0(id, wasm.__wbindgen_export_2);
    const len2 = WASM_VECTOR_LEN;
    wasm.verify(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return r0 !== 0;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function get_signer_id(secret) {
  let deferred3_0;
  let deferred3_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(secret, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.get_signer_id(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr2 = r0;
    var len2 = r1;
    if (r3) {
      ptr2 = 0;
      len2 = 0;
      throw takeObject(r2);
    }
    deferred3_0 = ptr2;
    deferred3_1 = len2;
    return getStringFromWasm0(ptr2, len2);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_1(deferred3_0, deferred3_1, 1);
  }
}
function new_x25519_private_key() {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.new_x25519_private_key(retptr);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var v1 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export_1(r0, r1 * 1, 1);
    return v1;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function get_sealer_id(secret) {
  let deferred3_0;
  let deferred3_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(secret, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.get_sealer_id(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr2 = r0;
    var len2 = r1;
    if (r3) {
      ptr2 = 0;
      len2 = 0;
      throw takeObject(r2);
    }
    deferred3_0 = ptr2;
    deferred3_1 = len2;
    return getStringFromWasm0(ptr2, len2);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_1(deferred3_0, deferred3_1, 1);
  }
}
var Blake3HasherFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_blake3hasher_free(ptr >>> 0, 1));
var Blake3Hasher = class _Blake3Hasher {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Blake3Hasher.prototype);
    obj.__wbg_ptr = ptr;
    Blake3HasherFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    Blake3HasherFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_blake3hasher_free(ptr, 0);
  }
  constructor() {
    const ret = wasm.blake3_empty_state();
    this.__wbg_ptr = ret >>> 0;
    Blake3HasherFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * @param {Uint8Array} data
   */
  update(data2) {
    const ptr0 = passArray8ToWasm0(data2, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.blake3_update_state(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {Uint8Array}
   */
  finalize() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.blake3hasher_finalize(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var v1 = getArrayU8FromWasm0(r0, r1).slice();
      wasm.__wbindgen_export_1(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Blake3Hasher}
   */
  clone() {
    const ret = wasm.blake3hasher_clone(this.__wbg_ptr);
    return _Blake3Hasher.__wrap(ret);
  }
};
async function __wbg_load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes2 = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes2, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_export_1(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).randomFillSync(takeObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_require_79b1e9274cde3c87 = function() {
    return handleError(function() {
      const ret = module.require;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const ret = typeof global === "undefined" ? null : global;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const ret = typeof self === "undefined" ? null : self;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const ret = typeof window === "undefined" ? null : window;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    throw new Error();
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  const { instance, module: module2 } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance, module2);
}

// node_modules/.pnpm/jazz-crypto-rs@0.0.7/node_modules/jazz-crypto-rs/dist/esm/wasm/pkg/jazz_crypto_rs.wasm.mjs
var data = "data:application/wasm;base64,AGFzbQEAAAAByQEbYAN/f38Bf2ACf38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAABf2AFf39/f38AYAd/f39/f39/AGAEf39/fwBgBX9/f39/AX9gAABgBn9/f39/fwBgBH9/f38Bf2AJf39/f39/f39/AGAGf39/f39/AX9gBX9/f35/AGAHf39/fn9/fwF/YAJ/fgBgB39/f39/f38Bf2ADfn9/AX9gBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf35/fwAC5AkiA3diZxRfX3diaW5kZ2VuX2Vycm9yX25ldwABA3diZxpfX3diZ19uZXdfOGE2ZjIzOGE2ZWNlODZlYQAGA3diZxxfX3diZ19zdGFja18wZWQ3NWQ2ODU3NWIwZjNjAAIDd2JnHF9fd2JnX2Vycm9yXzc1MzRiOGU5YTM2ZjFhYjQAAgN3YmcaX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYABAN3YmcbX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmAAUDd2JnHV9fd2JnX2NyeXB0b19lZDU4YjhlMTBhMjkyODM5AAUDd2JnFF9fd2JpbmRnZW5faXNfb2JqZWN0AAUDd2JnHl9fd2JnX3Byb2Nlc3NfNWMxZDY3MGJjNTM2MTRiOAAFA3diZx9fX3diZ192ZXJzaW9uc19jNzFhYTE2MjZhOTNlMGExAAUDd2JnG19fd2JnX25vZGVfMDI5OTk1MzNjNGVhMDJlMwAFA3diZxRfX3diaW5kZ2VuX2lzX3N0cmluZwAFA3diZx5fX3diZ19yZXF1aXJlXzc5YjFlOTI3NGNkZTNjODcABgN3YmcWX193YmluZGdlbl9pc19mdW5jdGlvbgAFA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAAQN3YmcbX193YmdfY2FsbF83Y2NjZGQ2OWUwNzkxYWUyAAADd2JnH19fd2JnX21zQ3J5cHRvXzBhMzZlMmVjM2EzNDNkMjYABQN3YmckX193YmdfbmV3d2l0aGxlbmd0aF9hMzgxNjM0ZTkwYzI3NmQ0AAUDd2JnF19fd2JpbmRnZW5faXNfdW5kZWZpbmVkAAUDd2JnIF9fd2JnX25ld25vYXJnc18xMDVlZDQ3MTQ3NWFhZjUwAAEDd2JnG19fd2JnX2NhbGxfNjcyYTRkMjE2MzRkNGEyNAABA3diZy1fX3diZ19zdGF0aWNfYWNjZXNzb3JfR0xPQkFMXzg4YTkwMmQxM2E1NTdkMDcABgN3YmcyX193Ymdfc3RhdGljX2FjY2Vzc29yX0dMT0JBTF9USElTXzU2NTc4YmU3ZTlmODMyYjAABgN3YmctX193Ymdfc3RhdGljX2FjY2Vzc29yX1dJTkRPV181ZGUzNzA0M2E5MWE5YzQwAAYDd2JnK19fd2JnX3N0YXRpY19hY2Nlc3Nvcl9TRUxGXzM3YzVkNDE4ZTRiZjU4MTkABgN3YmcRX193YmluZGdlbl9tZW1vcnkABgN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgABQN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZDk3ZTYzN2ViZTE0NWE5YQAAA3diZyVfX3diZ19yYW5kb21GaWxsU3luY19hYjJjZmU3OWViYmYyNzQwAAIDd2JnH19fd2JnX3N1YmFycmF5X2FhOTA2NWZhOWRjNWRmOTYAAAN3YmcmX193YmdfZ2V0UmFuZG9tVmFsdWVzX2JjYjQ5MTJmMTYwMDBkYzQAAgN3YmcaX193YmdfbmV3X2ExMjAwMmE3ZjkxYzc1YmUABQN3YmcaX193Ymdfc2V0XzY1NTk1YmRkODY4YjMwMDkAAwN3YmcQX193YmluZGdlbl90aHJvdwACA8IBwAEIAwMHEAUMDgMOAgACAwcRAgMIAgMCAAcDAgMDAggDAwgDAgQCAwcCDRICBQQDBwIDCAMDAg8AAAcDBAECCQMDAwMDAgQAAQQCAgMDAgoTAQIBBhQBAQEBAwEBAgEBAQECAgAGDAECAQEBBAMDDAkJAQIHBAQDAwMDAwIBAQEBAAADCgICCwELDQEPCgcVFxkJAAEBAQQEBAQEAQEBBQEBAQcBAgEBAgECAgICAgIEBAEBBQELAgsBAQEAAAEAAgMEBQFwAVdXBQMBABEGCQF/AUGAgMAACwfPBikGbWVtb3J5AgAOZ2VuZXJhdGVfbm9uY2UAYxBibGFrZTNfaGFzaF9vbmNlAGIdYmxha2UzX2hhc2hfb25jZV93aXRoX2NvbnRleHQAWhdfX3diZ19ibGFrZTNoYXNoZXJfZnJlZQCCARVibGFrZTNoYXNoZXJfZmluYWxpemUAchJibGFrZTNoYXNoZXJfY2xvbmUATRJibGFrZTNfZW1wdHlfc3RhdGUAdBNibGFrZTNfdXBkYXRlX3N0YXRlAHoXYmxha2UzX2RpZ2VzdF9mb3Jfc3RhdGUAahduZXdfZWQyNTUxOV9zaWduaW5nX2tleQBcDGVkMjU1MTlfc2lnbgBIDmVkMjU1MTlfdmVyaWZ5AFMeZWQyNTUxOV9zaWduaW5nX2tleV9mcm9tX2J5dGVzAGwdZWQyNTUxOV9zaWduaW5nX2tleV90b19wdWJsaWMAWyBlZDI1NTE5X3ZlcmlmeWluZ19rZXlfZnJvbV9ieXRlcwBtHGVkMjU1MTlfc2lnbmF0dXJlX2Zyb21fYnl0ZXMAZAdkZWNyeXB0AD8Ec2VhbAApBnVuc2VhbAArBHNpZ24AMAZ2ZXJpZnkANA1nZXRfc2lnbmVyX2lkADYWbmV3X3gyNTUxOV9wcml2YXRlX2tleQBOEXgyNTUxOV9wdWJsaWNfa2V5AEMVeDI1NTE5X2RpZmZpZV9oZWxsbWFuADkNZ2V0X3NlYWxlcl9pZAAvEGRlY3J5cHRfeHNhbHNhMjAAQgVzdGFydACpARhlZDI1NTE5X3NpZ25pbmdfa2V5X3NpZ24ASBBlbmNyeXB0X3hzYWxzYTIwAEIVZWQyNTUxOV92ZXJpZnlpbmdfa2V5AFsTYmxha2UzaGFzaGVyX3VwZGF0ZQB6B2VuY3J5cHQAPxBibGFrZTNoYXNoZXJfbmV3AHQTX193YmluZGdlbl9leHBvcnRfMADQARNfX3diaW5kZ2VuX2V4cG9ydF8xAJsBE19fd2JpbmRnZW5fZXhwb3J0XzIAnwETX193YmluZGdlbl9leHBvcnRfMwCqAR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyANQBEF9fd2JpbmRnZW5fc3RhcnQAqQEJpgEBAEEBC1bSAXyAAbwBtQHCAccBXYkBtAHTAZ4BigHGAZIByQHHAagBtgF5casBrQGGAa4BrQGsAbMBsgGuAa4BrwGwAbEBxAGWAaEBdtUBvQG+AZYBiwHAAZYBoQF22QG9AXidAZ0BlgGiAXfBAcgBWaAB2gGHAX/gAcoBzAHhAYUBuAG6AbkBtwGBAXPLAZYBogF32wHPAc4BpQHNAZUBiAGTAbsBCp6BCcABhH0CLH8QfiMAQbAgayIHJAACQAJAAkACQAJAAkACQCACQSBGBEAgAUEGai0AACEIIAFBAmotAAAhCSABLwAEIQ0gAS0AByECIAEvAAAhCiABLQADIREgASkACCEzIAEtABUhFiABKAAQIRkgAS0AFCEXIAEtABghGCABLQAXIRogAS0AFiEdIAEtABshGyABLQAaIRwgAS0AGSEjIAcgAS0AHyIfQRJ0rUKAgPAPgyABLQAdIimtQv8Bg0IChiABLQAcIiGtQsABg0IGiIQgAS0AHiIqrUL/AYNCCoaEhD4ChCAgByAhQRR0rUKAgMAfgyAcrUL/AYNCBIYgI61C8AGDQgSIhCAbrUL/AYNCDIaEhD4CgCAgByAjQRV0rUKAgIAPgyAarUL/AYNCBYYgHa1C+AGDQgOIhCAYrUL/AYNCDYaEhD4C/B8gByAdQRd0rUKAgIAcgyAZQRl2rSAXrUL/AYNCB4aEIBatQv8Bg0IPhoSEPgL4HyAHIBlB////D3E2AvQfIAcgM0ImiEKAgPAfgyAzQiiIQv8BgyI1QgKGIDNCIIhC/wGDIjdCBoiEIDNCMIhC/wGDIjxCCoaEhD4C8B8gByAzQg2IQoCA4A+DIDNCEIhC/wGDIj1CA4YgM0IIiEL/AYMiOEIFiIQgM0IYiEL/AYMiP0ILhoSEPgLsHyAHIAogCUEQdHIgEUEYdHIiK0H///8fcTYC4B8gByAzQg2GQoCAgB+DIAhBEHQiAUETdq0gAq1C/wGDQgWGhCAzQv8BgyJAQg2GhIQ+AugfIAcgASANciIIQQZ0IgFBgICADnEgAUGAgP8BcSABQcD/AHEgEUECdnJycjYC5B8gB0GIEWoiCyAHQeAfahBWIAcgBykDqBEiNEL///8fgyAHKQOgESAHKQOYESAHKQOQESAHKQOIESI5QhqIfCI2QhmIfCI6QhqIfCI+QhmIfCI7p0H///8fcSIBNgKYICAHIAcpA7ARIDRCGoh8IjRC////D4MgO0IaiHwiOz4CnCAgByAHKQO4ESA0QhmIfCI0p0H///8fcSIRNgKgICAHIDZC////D4MgBykD0BEgBykDyBEgBykDwBEgNEIaiHwiNEIZiHwiNkIaiHwiQUIZiEITfiA5Qv///x+DfCI5QhqIfCJCPgKMICAHIDmnQf///x9xIgk2AoggIAcgPqdB////D3EiDTYClCAgByBBp0H///8PcSIKNgKsICAHIDqnQf///x9xIgw2ApAgIAcgNqdB////H3EiDjYCqCAgByA0p0H///8PcSIPNgKkICAHIBFB8P///wNqrSA7IAFB8P///wNqrSI0QhqIfELw////AXwiOUIZiHwiNqdB////H3E2AkAgByAPQfD///8Baq0gNkIaiHwiNqdB////D3E2AkQgByAOQfD///8Daq0gNkIZiHwiNqdB////H3E2AkggByAMQfD///8Daq0gQiAJQc/9//8Daq0iOkIaiHxC8P///wF8Ij5CGYh8IjunQf///x9xNgIwIAcgCkHw////AWqtIDZCGoh8IjanQf///w9xNgJMIAcgDUHw////AWqtIDtCGoh8IjunQf///w9xNgI0IAcgOUL///8PgyA0Qv///x+DIDtCGYh8IjRCGoh8PgI8IAcgNKdB////H3E2AjggByA+Qv///w+DIDZCGYhCE34gOkL///8fg3wiNEIaiHw+AiwgByA0p0H///8fcTYCKCALIAdBiCBqQdy6wAAQQSAHIAcoAqwRNgJ8IAcgBykCpBE3AnQgByAHKQKcETcCbCAHIAcpApQRNwJkIAcgBykCjBE3AlwgByAHKAKIEUEBajYCWCALIAdB2ABqIgkQViAHIAcpA7gRIAcpA7ARIAcpA6gRIjRCGoh8IjlCGYh8IjanQf///x9xNgKgAyAHIAcpA5gRIAcpA5ARIAcpA4gRIjpCGoh8Ij5CGYh8IjunQf///x9xNgKQAyAHIAcpA8ARIDZCGoh8IjanQf///w9xNgKkAyAHIAcpA6ARIDtCGoh8IjunQf///w9xNgKUAyAHIAcpA8gRIDZCGYh8IjanQf///x9xNgKoAyAHIDlC////D4MgNEL///8fgyA7QhmIfCI0QhqIfD4CnAMgByA0p0H///8fcTYCmAMgByAHKQPQESA2QhqIfCI0p0H///8PcTYCrAMgByA+Qv///w+DIDRCGYhCE34gOkL///8fg3wiNEIaiHw+AowDIAcgNKdB////H3E2AogDIAdB6AFqIgogB0GIA2oiASAJEEEgCyAKEFYgByAHKQO4ESAHKQOwESAHKQOoESI0QhqIfCI5QhmIfCI2p0H///8fcTYCoAMgByAHKQOYESAHKQOQESAHKQOIESI6QhqIfCI+QhmIfCI7p0H///8fcTYCkAMgByAHKQPAESA2QhqIfCI2p0H///8PcTYCpAMgByAHKQOgESA7QhqIfCI7p0H///8PcTYClAMgByAHKQPIESA2QhmIfCI2p0H///8fcTYCqAMgByA5Qv///w+DIDRC////H4MgO0IZiHwiNEIaiHw+ApwDIAcgNKdB////H3E2ApgDIAcgBykD0BEgNkIaiHwiNKdB////D3E2AqwDIAcgPkL///8PgyA0QhmIQhN+IDpC////H4N8IjRCGoh8PgKMAyAHIDSnQf///x9xNgKIAyAHQYgbaiIOIAEgCRBBIAdByB1qIg8gB0EoaiINIAoQQSAHQYgPaiIMIA0gDhBBIAsgDBA7IAdBqANqIAdBqBFqKQIANwMAIAdBoANqIAdBoBFqKQIANwMAIAdBmANqIAdBmBFqKQIANwMAIAdBkANqIAdBkBFqKQIANwMAIAcgBykCiBE3A4gDIAsgAUECEFUgB0GIDWoiCiAMIAsQQSAHQagcaiIMIA8gChBBIAsgDBBWIAcgBykDuBEgBykDsBEgBykDqBEiNEIaiHwiOUIZiHwiNqdB////H3E2AqADIAcgBykDmBEgBykDkBEgBykDiBEiOkIaiHwiPkIZiHwiO6dB////H3E2ApADIAcgBykDwBEgNkIaiHwiNqdB////D3E2AqQDIAcgBykDoBEgO0IaiHwiO6dB////D3E2ApQDIAcgBykDyBEgNkIZiHwiNqdB////H3E2AqgDIAcgOUL///8PgyA0Qv///x+DIDtCGYh8IjRCGoh8PgKcAyAHIDSnQf///x9xNgKYAyAHIAcpA9ARIDZCGoh8IjSnQf///w9xNgKsAyAHID5C////D4MgNEIZiEITfiA6Qv///x+DfCI0QhqIfD4CjAMgByA0p0H///8fcTYCiAMgAkEYdCAIciEsIAogCSABEEEgASAKEEwgCyANEExBACEBQQEhAgNAIAdBiANqIhAgAWotAAAgB0GIEWoiEiABai0AAEYQvwEgAnEhAiABQQFqIgFBIEcNAAsgAhC/ASEiIAdB8P///wMgBygCQGutQfD///8BIAcoAjxrrUHw////AyAHKAI4a60iNEIaiHwiOUIZiHwiNqdB////H3EiETYCoBEgB0Hw////AyAHKAIwa61B8P///wEgBygCLGutQdD9//8DIAcoAihrrSI6QhqIfCI+QhmIfCI7p0H///8fcSIINgKQESAHQfD///8BIAcoAkRrrSA2QhqIfCI2p0H///8PcSIJNgKkESAHQfD///8BIAcoAjRrrSA7QhqIfCI7p0H///8PcSINNgKUESAHQfD///8DIAcoAkhrrSA2QhmIfCI2p0H///8fcSIKNgKoESAHIDRC////H4MgO0IZiHwiNKdB////H3EiDDYCmBEgByA5Qv///w+DIDRCGoh8pyIONgKcESAHQfD///8BIAcoAkxrrSA2QhqIfCI0p0H///8PcSIPNgKsESAHIDRCGYhCE34gOkL///8fg3wiNKdB////H3EiCzYCiBEgByA+Qv///w+DIDRCGoh8pyITNgKMESAHQYgPaiAHQYgNahBMIBAgEhBMQQAhAUEBIQIDQCAHQYgPaiISIAFqLQAAIAdBiANqIhAgAWotAABGEL8BIAJxIQIgAUEBaiIBQSBHDQALIAIQvwEhICAHIA82AqwRIAcgCjYCqBEgByAJNgKkESAHIBE2AqARIAcgDjYCnBEgByAMNgKYESAHIA02ApQRIAcgCDYCkBEgByATNgKMESAHIAs2AogRIBAgB0GIEWpBhLvAABBBIAdByB1qIAdBiA1qEEwgEiAQEExBACEBQQEhAgNAIAdByB1qIAFqLQAAIAdBiA9qIgggAWotAABGEL8BIAJxIQIgAUEBaiIBQSBHDQALIAIQvwEhASAIQYS7wAAgB0GoHGoiFRBBIAdBsBxqIgJBACABICByEL8BQf8BcWsiASACKAIAIhEgBygCkA9zcSARcyIRNgIAIAdBuBxqIgggCCgCACIJIAcoApgPcyABcSAJcyIJNgIAIAdBwBxqIg0gDSgCACIKIAcoAqAPcyABcSAKcyIKNgIAIAcgBygCtBwiDCAHKAKUD3MgAXEgDHMiDDYCtBwgByAHKAKsHCIOIAcoAowPcyABcSAOcyIONgKsHCAHIAcoAqgcIg8gBygCiA9zIAFxIA9zIg82AqgcIAcgBygCvBwiCyAHKAKcD3MgAXEgC3MiCzYCvBwgByAHKALEHCITIAcoAqQPcyABcSATcyITNgLEHCAHQcgcaiISIBIoAgAiECAHKAKoD3MgAXEgEHMiEDYCACAHIAEgBygCzBwiASAHKAKsD3NxIAFzIhQ2AswcIAdBiBFqIBUQTCASQQAgBy0AiBFBAXEQvwFB/wFxayIBQfD///8DIBBrrUHw////ASATa61B8P///wMgCmutQfD///8BIAtrrUHw////AyAJa60iNEIaiHwiOUIZiHwiNkIaiHwiOkIZiHwiPqdB////H3EgEHNxIBBzNgIAIA0gNqdB////H3EgCnMgAXEgCnM2AgAgCCA0Qv///x+DQfD///8BIAxrrUHw////AyARa61B8P///wEgDmutQdD9//8DIA9rrSI0QhqIfCI2QhmIfCI7QhqIfCJBQhmIfCJCp0H///8fcSAJcyABcSAJczYCACACIDunQf///x9xIBFzIAFxIBFzNgIAIAdB8P///wEgFGutID5CGoh8Ij6nQf///w9xIBRzIAFxIBRzNgLMHCAHIDqnQf///w9xIBNzIAFxIBNzNgLEHCAHIAsgOUL///8PgyBCQhqIfKdzIAFxIAtzNgK8HCAHIEGnQf///w9xIAxzIAFxIAxzNgK0HCAHID5CGYhCE34gNEL///8fg3wiNKdB////H3EgD3MgAXEgD3M2AqgcIAcgDiA2Qv///w+DIDRCGoh8p3MgAXEgDnM2AqwcICAgInIQvwEhASAHQasDaiASKQIAIjQ3AAAgB0GjA2ogDSkCACI5NwAAIAdBmwNqIAgpAgAiNjcAACAHQZMDaiACKQIAIjo3AAAgB0GQEWoiAiA6NwMAIAdBmBFqIhEgNjcDACAHQaARaiIIIDk3AwAgB0GoEWoiLSIJIDQ3AwAgByAHKQKoHCI0NwCLAyAHIDQ3A4gRIAdB0BFqIg8gB0GAIGopAgA3AwAgB0HIEWoiCyAHQfgfaikCADcDACAHQcARaiIuIhMgB0HwH2opAgA3AwAgB0G4EWoiLyISIAdB6B9qKQIANwMAIAcgBykC4B83A7ARIAdBsB9qIg0gCSkDADcDACAHQagfaiIKIAgpAwA3AwAgB0GgH2oiDCARKQMANwMAIAdBmB9qIg4gAikDADcDACAHIAcpA4gRNwOQHyAHQdgfaiIQIA8pAwA3AwAgB0HQH2oiFCALKQMANwMAIAdByB9qIiAgEykDADcDACAHQcAfaiIiIBIpAwA3AwAgByAHKQOwETcDuB8CQAJAAkACQCABQf8BcQRAIA1BACAfQYABcUEHdhC/AUH/AXFrIgFB8P///wMgDSgCACIVa61B8P///wEgBygCrB8iJmutQfD///8DIAooAgAiJGutQfD///8BIAcoAqQfIidrrUHw////AyAMKAIAIihrrSI0QhqIfCI5QhmIfCI2QhqIfCI6QhmIfCI+p0H///8fcSAVc3EgFXM2AgAgDkHw////AyAOKAIAIhVrrUHw////ASAHKAKUHyIla61B0P3//wMgBygCkB8iHmutIjtCGoh8IkFCGYh8IkKnQf///x9xIBVzIAFxIBVzNgIAIAogJCAkIDanQf///x9xcyABcXM2AgAgDCAoICggNEL///8fg0Hw////ASAHKAKcHyIVa60gQkIaiHwiNEIZiHwiNqdB////H3FzIAFxczYCACAHQfD///8BIAcoArQfIiRrrSA+QhqIfCI+p0H///8PcSAkcyABcSAkczYCtB8gByAVIBUgNKdB////D3FzIAFxczYCnB8gByAmICYgOqdB////D3FzIAFxczYCrB8gByAnICcgOUL///8PgyA2QhqIfKdzIAFxczYCpB8gByAeIB4gPkIZiEITfiA7Qv///x+DfCI0p0H///8fcXMgAXFzNgKQHyAHICUgJSBBQv///w+DIDRCGoh8p3MgAXFzNgKUHyAJIA0pAwA3AwAgCCAKKQMANwMAIBEgDCkDADcDACACIA4pAwA3AwAgByAHKQOQHzcDiBEgB0GAEmogB0GQH2ogB0G4H2oQQSAPIBApAwA3AwAgCyAUKQMANwMAIBMgICkDADcDACASICIpAwA3AwAgB0HgEWpBlLrAACkCADcDACAHQegRakGcusAAKQIANwMAIAdB8BFqQaS6wAApAgA3AwAgB0H4EWpBrLrAACkCADcDACAHIAcpA7gfNwOwESAHQYy6wAApAgA3A9gRIAdBCGogIikDADcDACAHQRBqICApAwA3AwAgB0EYaiAUKQMANwMAIAdBIGogECkDADcDACAHIAcpA7gfNwMAIAZBwABHDQYgM0KAgICAgICAgH+DIDxCMIaEIDVCKIaEIDdCIIaEID9CGIaEID1CEIaEIDhCCIaEIECEITMgCSgCACEJIAgoAgAhCCARKAIAIQ0gAigCACEKIAcoAqwRIQwgBygCpBEhDiAHKAKcESEPIAcoApQRIQsgBygCjBEhEyAHKAKIESESIAcoAqQSIRAgBygCoBIh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AmogB0EQaikDADcCACAHQZgCaiAHQQhqKQMANwIAIAdBwAJqQZS6wAApAgA3AgAgB0HIAmpBnLrAACkCADcCACAHQdACakGkusAAKQIANwIAIAdB2AJqQay6wAApAgA3AgAgByAHKQMANwKQAiAHQYy6wAApAgA3ArgCIAdB8P///wMgImutQfD///8BIBVrrUHw////AyAma60iM0IaiHwiNUIZiHwiN6dB////H3E2AvgCIAdB8P///wMgJ2utQfD///8BIChrrUHQ/f//AyAla60iPEIaiHwiPUIZiHwiOKdB////H3E2AugCIAdB8P///wMgCGutQfD///8BIA9rrUHw////AyANa60iP0IaiHwiQEIZiHwiNKdB////H3EiBDYCgAIgB0Hw////AyAKa61B8P///wEgE2utQdD9//8DIBJrrSI5QhqIfCI2QhmIfCI6p0H///8fcSIZNgLwASAHQfD///8BICBrrSA3QhqIfCI3p0H///8PcTYC/AIgB0Hw////ASAka60gOEIaiHwiOKdB////D3E2AuwCIAdB8P///wEgDmutIDRCGoh8IjSnQf///w9xIh02AoQCIAdB8P///wEgC2utIDpCGoh8IjqnQf///w9xIiM2AvQBIAdB8P///wMgFGutIDdCGYh8IjenQf///x9xNgKAAyAHIDVC////D4MgM0L///8fgyA4QhmIfCIzQhqIfD4C9AIgByAzp0H///8fcTYC8AIgB0Hw////AyAJa60gNEIZiHwiM6dB////H3EiETYCiAIgByA/Qv///x+DIDpCGYh8IjWnQf///x9xIgg2AvgBIAcgQEL///8PgyA1QhqIfKciCTYC/AEgB0Hw////ASAQa60gN0IaiHwiNadB////D3E2AoQDIAdB8P///wEgDGutIDNCGoh8IjOnQf///w9xIg02AowCIAcgPUL///8PgyA1QhmIQhN+IDxC////H4N8IjVCGoh8PgLkAiAHIDWnQf///x9xNgLgAiAHIDNCGYhCE34gOUL///8fg3wiM6dB////H3EiCjYC6AEgByA2Qv///w+DIDNCGoh8pyIMNgLsASAHQYgNakGAAhDeARpCACEzIAdCADcDqA8gB0H4AGohAyAHQeACaiEOQQAhAQNAQQAgAWshAgJAA0AgAUEGdiEFAn4gAUE/cSIGQTtPBEAgB0GID2ogBUEDdGoiBUEIaikDACACQT9xrYYgBSkDACAGrYiEDAELIAdBiA9qIAVBA3RqKQMAIAatiAtCH4MgM3wiNUIBg1AEQCACQQFrIQIgAUEBaiIBQYACRw0BDAILCyAHQYgNaiABaiA1p0FgQQAgNUIPViICG2o6AAAgAUH7AUkgAq0hMyABQQVqIQENAQsLIAdBiA9qQYACEN4BGiAHQZARaiADQQhqKQAANwMAIAdBmBFqIANBEGopAAA3AwAgB0GgEWogA0EYaikAADcDAEIAITMgB0IANwOoESAHIAMpAAA3A4gRQQAhAQNAQQAgAWshAgJAA0AgAUEGdiEDAn4gAUE/cSIFQThPBEAgB0GIEWogA0EDdGoiA0EIaikDACACQT9xrYYgAykDACAFrYiEDAELIAdBiBFqIANBA3RqKQMAIAWtiAtC/wGDIDN8IjVCAYNQBEAgAkEBayECIAFBAWoiAUGAAkcNAQwCCwsgB0GID2ogAWogNTwAACABQfgBSSA1Qv8AVq0hMyABQQhqIQENAQsLQf8BIQEDQCABIgIgB0GIDWpqLQAAIgMNBkEAIQMgAUUNBiABQQFrIQEgB0GID2ogAmotAABFDQALDAULQez1wgBBLkGc9sIAEKMBAAtBrfXCAEEuQdz1wgAQowEAC0GEmsAAQTcgB0GIEWpBvIPAAEGYm8AAEJQBAAsgAEEANgIADAMLIABBAzYCAAwCCyAHIAcoAqgCIgEgBGtB8P///wNqrSAHKAKkAiIPIAlrQfD///8Baq0gBygCoAIiCyAIa0Hw////A2qtIjNCGoh8IjVCGYh8IjenQf///x9xNgLIAyAHIAcoApgCIhMgGWtB8P///wNqrSAHKAKUAiISIAxrQfD///8Baq0gBygCkAIiECAKa0HQ/f//A2qtIjxCGoh8Ij1CGYh8IjinQf///x9xNgK4AyAHIAcoAqwCIhQgHWtB8P///wFqrSA3QhqIfCI3p0H///8PcTYCzAMgByAHKAKcAiIWICNrQfD///8Baq0gOEIaiHwiOKdB////D3E2ArwDIAcgBygCsAIiFyARa0Hw////A2qtIDdCGYh8IjenQf///x9xNgLQAyAHIDVC////D4MgM0L///8fgyA4QhmIfCIzQhqIfD4CxAMgByAzp0H///8fcTYCwAMgByAHKAK0AiIYIA1rQfD///8Baq0gN0IaiHwiM6dB////D3E2AtQDIAcgPUL///8PgyAzQhmIQhN+IDxC////H4N8IjNCGoh8PgK0AyAHIDOnQf///x9xNgKwA0EAIQYgB0H4A2pBrLrAACkCACIzNwIAIAdB8ANqQaS6wAApAgAiNTcCACAHQegDakGcusAAKQIAIjc3AgAgB0HgA2pBlLrAACkCACI8NwIAIAdBjLrAACkCACI9NwLYAyAHQYAEaiIFIA5BtLrAABBBIAcgDSAYajYCrAMgByARIBdqNgKoAyAHIBQgHWo2AqQDIAcgASAEajYCoAMgByAJIA9qNgKcAyAHIAggC2o2ApgDIAcgFiAjajYClAMgByATIBlqNgKQAyAHIAwgEmo2AowDIAcgCiAQajYCiAMgB0GIEWogB0GIA2oiAUGgARDfARogB0GoEmogAUGgARDfARogB0HIE2ogAUGgARDfARogB0HoFGogAUGgARDfARogB0GIFmogAUGgARDfARogB0GoF2ogAUGgARDfARogB0HIGGogAUGgARDfARogB0HoGWogAUGgARDfARogB0GQHmogB0EgaikDADcDACAHQYgeaiAHQRhqKQMANwMAIAdBgB5qIAdBEGopAwA3AwAgB0H4HWogB0EIaikDADcDACAHQaAeaiA8NwMAIAdBqB5qIDc3AwAgB0GwHmogNTcDACAHQbgeaiAzNwMAIAcgBykDADcD8B0gByA9NwOYHiAHQegdaiAHQYgCaikCADcDACAHQeAdaiAHQYACaikCADcDACAHQdgdaiAHQfgBaikCADcDACAHQdAdaiAHQfABaikCADcDACAHIAcpAugBNwPIHSABIAdByB1qEC4gB0GIG2ogASAFEEEgB0GwG2ogB0GwA2oiGSAHQdgDaiIdEEEgB0HYG2ogHSAFEEEgB0GAHGogASAZEEEgB0GgHWohISAHQfgcaiEEIAdBwB5qISMgB0GYHmohASAHQfAdaiEgA0AgB0GIA2oiFSAHQYgbaiAHQYgRaiIeIAZqIiIQPCAHQcgdaiAVIAUQQSAgIBkgHRBBIAEgHSAFEEEgIyAVIBkQQSAHKALsHSERIAcoApQeIQggBygC6B0hCSAHKAKQHiENIAcoAtQdIQogBygC/B0hDCAHKALkHSEOIAcoAoweIQ8gBygC0B0hCyAHKAL4HSETIAcoAswdIRIgBygC9B0hECAHKALIHSEUIAcoAvAdIRYgBygC4B0hFyAHKAKIHiEYIAcoAtwdIRogBygChB4hGyAHKALYHSEcIAcoAoAeIR8gBCABKQIANwIAIARBCGogAUEIaikCADcCACAEQRBqIAFBEGopAgA3AgAgBEEYaiABQRhqKQIANwIAIARBIGogAUEgaikCADcCACAHIBggF2tB8P///wNqrSAbIBprQfD///8Baq0gHyAca0Hw////A2qtIjNCGoh8IjVCGYh8IjenQf///x9xNgLoHCAHIBMgC2tB8P///wNqrSAQIBJrQfD///8Baq0gFiAUa0HQ/f//A2qtIjxCGoh8Ij1CGYh8IjinQf///x9xNgLYHCAHIA8gDmtB8P///wFqrSA3QhqIfCI3p0H///8PcTYC7BwgByAMIAprQfD///8Baq0gOEIaiHwiOKdB////D3E2AtwcIAcgDSAJa0Hw////A2qtIDdCGYh8IjenQf///x9xNgLwHCAHIDVC////D4MgM0L///8fgyA4QhmIfCIzQhqIfD4C5BwgByAzp0H///8fcTYC4BwgByAIIBFrQfD///8Baq0gN0IaiHwiM6dB////D3E2AvQcIAcgPUL///8PgyAzQhmIQhN+IDxC////H4N8IjNCGoh8PgLUHCAHIDOnQf///x9xNgLQHCAhICNBtLrAABBBIAcgCCARajYCzBwgByAJIA1qNgLIHCAHIA4gD2o2AsQcIAcgFyAYajYCwBwgByAaIBtqNgK8HCAHIBwgH2o2ArgcIAcgCiAMajYCtBwgByALIBNqNgKwHCAHIBAgEmo2AqwcIAcgFCAWajYCqBwgIkGgAWogB0GoHGpBoAEQ3wEaIAZBoAFqIgZB4AhHDQALIBUgHkGAChDfARogB0HIHGpCADcDACAHQcAcakIANwMAIAdBuBxqQgA3AwAgB0GwHGpCADcDACAHQdgcakGUusAAKQIAIjM3AwAgB0HgHGpBnLrAACkCACI1NwMAIAdB6BxqQaS6wAApAgAiNzcDACAHQfAcakGsusAAKQIAIjw3AwAgB0GAHWogMzcDACAHQYgdaiA1NwMAIAdBkB1qIDc3AwAgB0GYHWogPDcDACAHQgA3A6gcIAdBjLrAACkCACIzNwPQHCAHIDM3A/gcIAdB2BFqIQYg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Goh8IjZCGYh8IjqnQf///x9xNgKgHiAHICQgJmtB8P///wFqrSA3QhqIfCI3p0H///8PcTYC5B0gByAbIBprQfD///8Baq0gOEIaiHwiOKdB////D3E2AtQdIAcgLiAPa0Hw////AWqtIDRCGoh8IjSnQf///w9xNgK0HiAHICogDWtB8P///wFqrSA6QhqIfCI6p0H///8PcTYCpB4gByAoICdrQfD///8Daq0gN0IZiHwiN6dB////H3E2AugdIAcgNUL///8PgyAzQv///x+DIDhCGYh8IjNCGoh8PgLcHSAHIDOnQf///x9xNgLYHSAHIC8gC2tB8P///wNqrSA0QhmIfCIzp0H///8fcTYCuB4gByBAQv///w+DID9C////H4MgOkIZiHwiNUIaiHw+AqweIAcgNadB////H3E2AqgeIAcgMiAxa0Hw////AWqtIDdCGoh8IjWnQf///w9xNgLsHSAHIDAgE2tB8P///wFqrSAzQhqIfCIzp0H///8PcTYCvB4gByA9Qv///w+DIDVCGYhCE34gPEL///8fg3wiNUIaiHw+AswdIAcgNadB////H3E2AsgdIAcgNkL///8PgyAzQhmIQhN+IDlC////H4N8IjNCGoh8PgKcHiAHIDOnQf///x9xNgKYHgwBCyAHQcgdaiAHQYgRaiAHQYgDaiAIQaABbGoQPAsCQAJAAkACQCAHQYgPaiACaiwAACIDQQBHQX8gA0EATiIIG0H/AXEOAgMBAAsgB0GIEWogB0HIHWoiCCAEEEEgHSAFIAEQQSAGIAEgBBBBIBkgCCAFEEFBACADa8AiCEEBdiEDIAhBAE4NASADQcAAQaT4wAAQmQEACyAHQYgRaiAHQcgdaiIJIAQQQSAdIAUgARBBIAYgASAEEEEgGSAJIAUQQSADQQF2IQMgCEUEQCADQcAAQaT4wAAQmQEACyAHQcgdaiAHQYgRaiADQfgAbEGsu8AAahA9DAELIAcoArARIQggBygCiBEhCSAHKAK0ESENIAcoAowRIQogBygCuBEhDCAHKAKQESEOIAcoArwRIQ8gBygClBEhCyAHKALAESETIAcoApgRIRIgBygCxBEhECAHKAKcESEUIAcoAsgRIRYgBygCoBEhFyAHKALMESEYIAcoAqQRIRogBygC0BEhGyAHKAKoESEcIAcgBygCrBEiHyAHKALUESIhajYCtB8gByAbIBxqNgKwHyAHIBggGmo2AqwfIAcgFiAXajYCqB8gByAQIBRqNgKkHyAHIBIgE2o2AqAfIAcgCyAPajYCnB8gByAMIA5qNgKYHyAHIAogDWo2ApQfIAcgCCAJajYCkB8gByAWIBdrQfD///8Daq0gECAUa0Hw////AWqtIBMgEmtB8P///wNqrSIzQhqIfCI1QhmIfCI3p0H///8fcTYC0B8gByAMIA5rQfD///8Daq0gDSAKa0Hw////AWqtIAggCWtB0P3//wNqrSI8QhqIfCI9QhmIfCI4p0H///8fcTYCwB8gByAYIBprQfD///8Baq0gN0IaiHwiN6dB////D3E2AtQfIAcgDyALa0Hw////AWqtIDhCGoh8IjinQf///w9xNgLEHyAHIBsgHGtB8P///wNqrSA3QhmIfCI3p0H///8fcTYC2B8gByA1Qv///w+DIDNC////H4MgOEIZiHwiM0IaiHw+AswfIAcgM6dB////H3E2AsgfIAcgISAfa0Hw////AWqtIDdCGoh8IjOnQf///w9xNgLcHyAHID1C////D4MgM0IZiEITfiA8Qv///x+DfCIzQhqIfD4CvB8gByAzp0H///8fcTYCuB8gB0HgH2ogB0GQH2ogA0H4AGwiA0HUu8AAahBBIAdBiCBqIAdBuB9qIANBrLvAAGoQQSAHQYgbaiAZIANB/LvAAGoQQSAHKAKIGyEDIAcoAtgRISUgBygCjBshCCAHKALcESEeIAcoApAbIQkgBygC4BEhKSAHKAKUGyENIAcoAuQRISogBygCmBshCiAHKALoESErIAcoApwbIQwgBygC7BEhLCAHKAKgGyEOIAcoAvARIS0gBygCpBshDyAHKAL0ESEuIAcoAqgbIQsgBygC+BEhLyAHKAKsGyETIAcoAvwRITAgBygCiCAhEiAHKALgHyEQIAcoAowgIRQgBygC5B8hFiAHKAKQICEXIAcoAugfIRggBygClCAhGiAHKALsHyEbIAcoApggIRwgBygC8B8hHyAHKAKcICEhIAcoAvQfISAgBygCoCAhIiAHKAL4HyEVIAcoAqQgISYgBygC/B8hJCAHKAKoICEnIAcoAoAgISggByAHKAKsICIxIAcoAoQgIjJqNgKUHiAHICcgKGo2ApAeIAcgJCAmajYCjB4gByAVICJqNgKIHiAHICAgIWo2AoQeIAcgHCAfajYCgB4gByAaIBtqNgL8HSAHIBcgGGo2AvgdIAcgFCAWajYC9B0gByAQIBJqNgLwHSAHIBMgMEEBdCIwajYC5B4gByALIC9BAXQiL2o2AuAeIAcgDyAuQQF0Ii5qNgLcHiAHIA4gLUEBdCItajYC2B4gByAMICxBAXQiLGo2AtQeIAcgCiArQQF0IitqNgLQHiAHIA0gKkEBdCIqajYCzB4gByAJIClBAXQiKWo2AsgeIAcgCCAeQQF0Ih5qNgLEHiAHIAMgJUEBdCIlajYCwB4gByAVICJrQfD///8Daq0gICAha0Hw////AWqtIB8gHGtB8P///wNqrSIzQhqIfCI1QhmIfCI3p0H///8fcTYC4B0gByAYIBdrQfD///8Daq0gFiAUa0Hw////AWqtIBAgEmtB0P3//wNqrSI8QhqIfCI9QhmIfCI4p0H///8fcTYC0B0gByAtIA5rQfD///8Daq0gLCAMa0Hw////AWqtICsgCmtB8P///wNqrSI/QhqIfCJAQhmIfCI0p0H///8fcTYCsB4gByApIAlrQfD///8Daq0gHiAIa0Hw////AWqtICUgA2tB0P3//wNqrSI5QhqIfCI2QhmIfCI6p0H///8fcTYCoB4gByAkICZrQfD///8Baq0gN0IaiHwiN6dB////D3E2AuQdIAcgGyAaa0Hw////AWqtIDhCGoh8IjinQf///w9xNgLUHSAHIC4gD2tB8P///wFqrSA0QhqIfCI0p0H///8PcTYCtB4gByAqIA1rQfD///8Baq0gOkIaiHwiOqdB////D3E2AqQeIAcgKCAna0Hw////A2qtIDdCGYh8IjenQf///x9xNgLoHSAHIDVC////D4MgM0L///8fgyA4QhmIfCIzQhqIfD4C3B0gByAzp0H///8fcTYC2B0gByAvIAtrQfD///8Daq0gNEIZiHwiM6dB////H3E2ArgeIAcgQEL///8PgyA/Qv///x+DIDpCGYh8IjVCGoh8PgKsHiAHIDWnQf///x9xNgKoHiAHIDIgMWtB8P///wFqrSA3QhqIfCI1p0H///8PcTYC7B0gByAwIBNrQfD///8Baq0gM0IaiHwiM6dB////D3E2ArweIAcgPUL///8PgyA1QhmIQhN+IDxC////H4N8IjVCGoh8PgLMHSAHIDWnQf///x9xNgLIHSAHIDZC////D4MgM0IZiEITfiA5Qv///x+DfCIzQhqIfD4CnB4gByAzp0H///8fcTYCmB4LIAdBiBFqIgMgB0HIHWogBBBBIB0gBSABEEEgBiABIAQQQSAHQagcaiADQfgAEN8BGiACBEAgAkEBayICIAdBiA1qai0AACEDDAELCyAHQYgRaiIBIAdBqBxqIgIgIxBBIAdBsBFqIBEgIxBBIAdByB1qICMQViAHKQOQHiE3IAcpA4geITwgBykD4B0hPSAHKQOAHiE4IAcpA9gdIT8gBykD0B0hQCAHKQPIHSEzIAcpA/gdITQgBykD8B0hOSAHKQPoHSE1IAdBgBJqIAIgERBBIAcgNCA5IDVCGoh8IjlCGYh8IjSnQf///x9xNgLwESAHID8gQCAzQhqIfCJAQhmIfCI/p0H///8fcTYC4BEgByA4IDRCGoh8IjinQf///w9xNgL0ESAHID0gP0IaiHwiPadB////D3E2AuQRIAcgPCA4QhmIfCI8p0H///8fcTYC+BEgByA5Qv///w+DIDVC////H4MgPUIZiHwiNUIaiHw+AuwRIAcgNadB////H3E2AugRIAcgNyA8QhqIfCI1p0H///8PcTYC/BEgByBAQv///w+DIDVCGYhCE34gM0L///8fg3wiM0IaiHw+AtwRIAcgM6dB////H3E2AtgRIAdBsAFqIgIgARBlIAIgB0HYAGpBIBDcAUUEQCAAQQo2AgAgAEEBOgAEDAILQdGAwwAtAAAaQRAQJyIBRQ0CIAFBAzYCAAsgAEEKNgIAIABBADoABCABQQRrKAIAIgBBeHEiAkEUQRggAEEDcSIAG0kNAiAAQQAgAkE4TxsNAyABEEULIAdBsCBqJAAPCwALQa31wgBBLkHc9cIAEKMBAAtB7PXCAEEuQZz2wgAQowEAC4ZXASF+IAEgAkEHdGohAiAAKQM4ISIgACkDMCEgIAApAyghHyAAKQMgIR0gACkDGCEjIAApAxAhISAAKQMIIR4gACkDACEHA0AgByABKQAAIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQiEiAiIB1CMokgHUIuiYUgHUIXiYV8IB8gIIUgHYMgIIV8fEKi3KK5jfOLxcIAfCIDIB4gIYUgB4MgHiAhg4UgB0IkiSAHQh6JhSAHQhmJhXx8IgRCJIkgBEIeiYUgBEIZiYUgBCAHIB6FgyAHIB6DhXwgICABKQAIIgVCOIYgBUKA/gODQiiGhCAFQoCA/AeDQhiGIAVCgICA+A+DQgiGhIQgBUIIiEKAgID4D4MgBUIYiEKAgPwHg4QgBUIoiEKA/gODIAVCOIiEhIQiE3wgAyAjfCILIB0gH4WDIB+FfCALQjKJIAtCLomFIAtCF4mFfELNy72fkpLRm/EAfCIGfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IB8gASkAECIDQjiGIANCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISEIhV8IAYgIXwiDCALIB2FgyAdhXwgDEIyiSAMQi6JhSAMQheJhXxC0YnLnYGGwZ/KAH0iDnwiA0IkiSADQh6JhSADQhmJhSADIAQgBYWDIAQgBYOFfCAdIAEpABgiBkI4hiAGQoD+A4NCKIaEIAZCgID8B4NCGIYgBkKAgID4D4NCCIaEhCAGQgiIQoCAgPgPgyAGQhiIQoCA/AeDhCAGQiiIQoD+A4MgBkI4iISEhCIWfCAOIB58Ig4gCyAMhYMgC4V8IA5CMokgDkIuiYUgDkIXiYV8QsTI2POni4mlFn0iEHwiBkIkiSAGQh6JhSAGQhmJhSAGIAMgBYWDIAMgBYOFfCALIAEpACAiDUI4hiANQoD+A4NCKIaEIA1CgID8B4NCGIYgDUKAgID4D4NCCIaEhCANQgiIQoCAgPgPgyANQhiIQoCA/AeDhCANQiiIQoD+A4MgDUI4iISEhCIXfCAHIBB8IgsgDCAOhYMgDIV8IAtCMokgC0IuiYUgC0IXiYV8Qrjqopq/y7CrOXwiDXwiB0IkiSAHQh6JhSAHQhmJhSAHIAMgBoWDIAMgBoOFfCAMIAEpACgiDEI4hiAMQoD+A4NCKIaEIAxCgID8B4NCGIYgDEKAgID4D4NCCIaEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIUfCAEIA18IgwgCyAOhYMgDoV8IAxCMokgDEIuiYUgDEIXiYV8Qpmgl7CbvsT42QB8Ig18IgRCJIkgBEIeiYUgBEIZiYUgBCAGIAeFgyAGIAeDhXwgDiABKQAwIg5COIYgDkKA/gODQiiGhCAOQoCA/AeDQhiGIA5CgICA+A+DQgiGhIQgDkIIiEKAgID4D4MgDkIYiEKAgPwHg4QgDkIoiEKA/gODIA5COIiEhIQiGHwgBSANfCIOIAsgDIWDIAuFfCAOQjKJIA5CLomFIA5CF4mFfELl4JqHtauf4O0AfSINfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IAsgASkAOCILQjiGIAtCgP4Dg0IohoQgC0KAgPwHg0IYhiALQoCAgPgPg0IIhoSEIAtCCIhCgICA+A+DIAtCGIhCgID8B4OEIAtCKIhCgP4DgyALQjiIhISEIhp8IAMgDXwiCyAMIA6FgyAMhXwgC0IyiSALQi6JhSALQheJhXxC6P3JrKKl6PHUAH0iDXwiA0IkiSADQh6JhSADQhmJhSADIAQgBYWDIAQgBYOFfCAMIAEpAEAiDEI4hiAMQoD+A4NCKIaEIAxCgID8B4NCGIYgDEKAgID4D4NCCIaEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIbfCAGIA18IgwgCyAOhYMgDoV8IAxCMokgDEIuiYUgDEIXiYV8Qr778+f1rJX8J30iDXwiBkIkiSAGQh6JhSAGQhmJhSAGIAMgBYWDIAMgBYOFfCAOIAEpAEgiDkI4hiAOQoD+A4NCKIaEIA5CgID8B4NCGIYgDkKAgID4D4NCCIaEhCAOQgiIQoCAgPgPgyAOQhiIQoCA/AeDhCAOQiiIQoD+A4MgDkI4iISEhCIZfCAHIA18Ig4gCyAMhYMgC4V8IA5CMokgDkIuiYUgDkIXiYV8Qr7fwauU4NbBEnwiDXwiB0IkiSAHQh6JhSAHQhmJhSAHIAMgBoWDIAMgBoOFfCALIAEpAFAiC0I4hiALQoD+A4NCKIaEIAtCgID8B4NCGIYgC0KAgID4D4NCCIaEhCALQgiIQoCAgPgPgyALQhiIQoCA/AeDhCALQiiIQoD+A4MgC0I4iISEhCIIfCAEIA18IgsgDCAOhYMgDIV8IAtCMokgC0IuiYUgC0IXiYV8Qozlkvfkt+GYJHwiDXwiBEIkiSAEQh6JhSAEQhmJhSAEIAYgB4WDIAYgB4OFfCAMIAEpAFgiDEI4hiAMQoD+A4NCKIaEIAxCgID8B4NCGIYgDEKAgID4D4NCCIaEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIJfCAFIA18IgwgCyAOhYMgDoV8IAxCMokgDEIuiYUgDEIXiYV8QuLp/q+9uJ+G1QB8Ig18IgVCJIkgBUIeiYUgBUIZiYUgBSAEIAeFgyAEIAeDhXwgDiABKQBgIg5COIYgDkKA/gODQiiGhCAOQoCA/AeDQhiGIA5CgICA+A+DQgiGhIQgDkIIiEKAgID4D4MgDkIYiEKAgPwHg4QgDkIoiEKA/gODIA5COIiEhIQiCnwgAyANfCIOIAsgDIWDIAuFfCAOQjKJIA5CLomFIA5CF4mFfELvku6Tz66X3/IAfCINfCIDQiSJIANCHomFIANCGYmFIAMgBCAFhYMgBCAFg4V8IAsgASkAaCILQjiGIAtCgP4Dg0IohoQgC0KAgPwHg0IYhiALQoCAgPgPg0IIhoSEIAtCCIhCgICA+A+DIAtCGIhCgID8B4OEIAtCKIhCgP4DgyALQjiIhISEIg98IAYgDXwiDSAMIA6FgyAMhXwgDUIyiSANQi6JhSANQheJhXxCz9Klp5zA05D/AH0iEHwiBkIkiSAGQh6JhSAGQhmJhSAGIAMgBYWDIAMgBYOFfCABKQBwIgtCOIYgC0KA/gODQiiGhCALQoCA/AeDQhiGIAtCgICA+A+DQgiGhIQgC0IIiEKAgID4D4MgC0IYiEKAgPwHg4QgC0IoiEKA/gODIAtCOIiEhIQiCyAMfCAHIBB8IhAgDSAOhYMgDoV8IBBCMokgEEIuiYUgEEIXiYV8Qsvb49GNq/6R5AB9IhF8IgdCJIkgB0IeiYUgB0IZiYUgByADIAaFgyADIAaDhXwgASkAeCIMQjiGIAxCgP4Dg0IohoQgDEKAgPwHg0IYhiAMQoCAgPgPg0IIhoSEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISEIgwgDnwgBCARfCIRIA0gEIWDIA2FfCARQjKJIBFCLomFIBFCF4mFfELsstuEs9GDsj59Ihx8IgRCJIkgBEIeiYUgBEIZiYUgBCAGIAeFgyAGIAeDhXwgE0I/iSATQjiJhSATQgeIhSASfCAZfCALQi2JIAtCA4mFIAtCBoiFfCIOIA18IAUgHHwiEiAQIBGFgyAQhXwgEkIyiSASQi6JhSASQheJhXxCruq6iObHpbIbfSIcfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IBVCP4kgFUI4iYUgFUIHiIUgE3wgCHwgDEItiSAMQgOJhSAMQgaIhXwiDSAQfCADIBx8IhMgESAShYMgEYV8IBNCMokgE0IuiYUgE0IXiYV8Qp20w72cj+6gEH0iHHwiA0IkiSADQh6JhSADQhmJhSADIAQgBYWDIAQgBYOFfCAWQj+JIBZCOImFIBZCB4iFIBV8IAl8IA5CLYkgDkIDiYUgDkIGiIV8IhAgEXwgBiAcfCIVIBIgE4WDIBKFfCAVQjKJIBVCLomFIBVCF4mFfEK1q7Pc6Ljn4A98Ihx8IgZCJIkgBkIeiYUgBkIZiYUgBiADIAWFgyADIAWDhXwgF0I/iSAXQjiJhSAXQgeIhSAWfCAKfCANQi2JIA1CA4mFIA1CBoiFfCIRIBJ8IAcgHHwiFiATIBWFgyAThXwgFkIyiSAWQi6JhSAWQheJhXxC5biyvce5qIYkfCIcfCIHQiSJIAdCHomFIAdCGYmFIAcgAyAGhYMgAyAGg4V8IBRCP4kgFEI4iYUgFEIHiIUgF3wgD3wgEEItiSAQQgOJhSAQQgaIhXwiEiATfCAEIBx8IhcgFSAWhYMgFYV8IBdCMokgF0IuiYUgF0IXiYV8QvWErMn1jcv0LXwiHHwiBEIkiSAEQh6JhSAEQhmJhSAEIAYgB4WDIAYgB4OFfCAYQj+JIBhCOImFIBhCB4iFIBR8IAt8IBFCLYkgEUIDiYUgEUIGiIV8IhMgFXwgBSAcfCIUIBYgF4WDIBaFfCAUQjKJIBRCLomFIBRCF4mFfEKDyZv1ppWhusoAfCIcfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IBpCP4kgGkI4iYUgGkIHiIUgGHwgDHwgEkItiSASQgOJhSASQgaIhXwiFSAWfCADIBx8IhggFCAXhYMgF4V8IBhCMokgGEIuiYUgGEIXiYV8QtT3h+rLu6rY3AB8Ihx8IgNCJIkgA0IeiYUgA0IZiYUgAyAEIAWFgyAEIAWDhXwgG0I/iSAbQjiJhSAbQgeIhSAafCAOfCATQi2JIBNCA4mFIBNCBoiFfCIWIBd8IAYgHHwiGiAUIBiFgyAUhXwgGkIyiSAaQi6JhSAaQheJhXxCtafFmKib4vz2AHwiHHwiBkIkiSAGQh6JhSAGQhmJhSAGIAMgBYWDIAMgBYOFfCAZQj+JIBlCOImFIBlCB4iFIBt8IA18IBVCLYkgFUIDiYUgFUIGiIV8IhcgFHwgByAcfCIbIBggGoWDIBiFfCAbQjKJIBtCLomFIBtCF4mFfELVwOSM0dXr4OcAfSIcfCIHQiSJIAdCHomFIAdCGYmFIAcgAyAGhYMgAyAGg4V8IAhCP4kgCEI4iYUgCEIHiIUgGXwgEHwgFkItiSAWQgOJhSAWQgaIhXwiFCAYfCAEIBx8IhkgGiAbhYMgGoV8IBlCMokgGUIuiYUgGUIXiYV8QvCbr5Ktso7n1wB9Ihx8IgRCJIkgBEIeiYUgBEIZiYUgBCAGIAeFgyAGIAeDhXwgCUI/iSAJQjiJhSAJQgeIhSAIfCARfCAXQi2JIBdCA4mFIBdCBoiFfCIYIBp8IAUgHHwiCCAZIBuFgyAbhXwgCEIyiSAIQi6JhSAIQheJhXxCwb2TuPaGtv7PAH0iHHwiBUIkiSAFQh6JhSAFQhmJhSAFIAQgB4WDIAQgB4OFfCAKQj+JIApCOImFIApCB4iFIAl8IBJ8IBRCLYkgFEIDiYUgFEIGiIV8IhogG3wgAyAcfCIJIAggGYWDIBmFfCAJQjKJIAlCLomFIAlCF4mFfEKc4sOIhIeg08AAfSIcfCIDQiSJIANCHomFIANCGYmFIAMgBCAFhYMgBCAFg4V8IA9CP4kgD0I4iYUgD0IHiIUgCnwgE3wgGEItiSAYQgOJhSAYQgaIhXwiGyAZfCAGIBx8IgogCCAJhYMgCIV8IApCMokgCkIuiYUgCkIXiYV8Qr7g3ZLMgf2POX0iHHwiBkIkiSAGQh6JhSAGQhmJhSAGIAMgBYWDIAMgBYOFfCALQj+JIAtCOImFIAtCB4iFIA98IBV8IBpCLYkgGkIDiYUgGkIGiIV8IhkgCHwgByAcfCIIIAkgCoWDIAmFfCAIQjKJIAhCLomFIAhCF4mFfELbsdXnhtebrCp9Ig98IgdCJIkgB0IeiYUgB0IZiYUgByADIAaFgyADIAaDhXwgDEI/iSAMQjiJhSAMQgeIhSALfCAWfCAbQi2JIBtCA4mFIBtCBoiFfCILIAl8IAQgD3wiCSAIIAqFgyAKhXwgCUIyiSAJQi6JhSAJQheJhXxC74SOgJ7qmOUGfCIPfCIEQiSJIARCHomFIARCGYmFIAQgBiAHhYMgBiAHg4V8IA5CP4kgDkI4iYUgDkIHiIUgDHwgF3wgGUItiSAZQgOJhSAZQgaIhXwiDCAKfCAFIA98IgogCCAJhYMgCIV8IApCMokgCkIuiYUgCkIXiYV8QvDcudDwrMqUFHwiD3wiBUIkiSAFQh6JhSAFQhmJhSAFIAQgB4WDIAQgB4OFfCANQj+JIA1COImFIA1CB4iFIA58IBR8IAtCLYkgC0IDiYUgC0IGiIV8Ig4gCHwgAyAPfCIIIAkgCoWDIAmFfCAIQjKJIAhCLomFIAhCF4mFfEL838i21NDC2yd8Ig98IgNCJIkgA0IeiYUgA0IZiYUgAyAEIAWFgyAEIAWDhXwgEEI/iSAQQjiJhSAQQgeIhSANfCAYfCAMQi2JIAxCA4mFIAxCBoiFfCINIAl8IAYgD3wiCSAIIAqFgyAKhXwgCUIyiSAJQi6JhSAJQheJhXxCppKb4YWnyI0ufCIPfCIGQiSJIAZCHomFIAZCGYmFIAYgAyAFhYMgAyAFg4V8IBFCP4kgEUI4iYUgEUIHiIUgEHwgGnwgDkItiSAOQgOJhSAOQgaIhXwiECAKfCAHIA98IgogCCAJhYMgCIV8IApCMokgCkIuiYUgCkIXiYV8Qu3VkNbFv5uWzQB8Ig98IgdCJIkgB0IeiYUgB0IZiYUgByADIAaFgyADIAaDhXwgEkI/iSASQjiJhSASQgeIhSARfCAbfCANQi2JIA1CA4mFIA1CBoiFfCIRIAh8IAQgD3wiCCAJIAqFgyAJhXwgCEIyiSAIQi6JhSAIQheJhXxC3+fW7Lmig5zTAHwiD3wiBEIkiSAEQh6JhSAEQhmJhSAEIAYgB4WDIAYgB4OFfCATQj+JIBNCOImFIBNCB4iFIBJ8IBl8IBBCLYkgEEIDiYUgEEIGiIV8IhIgCXwgBSAPfCIJIAggCoWDIAqFfCAJQjKJIAlCLomFIAlCF4mFfELex73dyOqcheUAfCIPfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IBVCP4kgFUI4iYUgFUIHiIUgE3wgC3wgEUItiSARQgOJhSARQgaIhXwiEyAKfCADIA98IgogCCAJhYMgCIV8IApCMokgCkIuiYUgCkIXiYV8Qqjl3uOz14K19gB8Ig98IgNCJIkgA0IeiYUgA0IZiYUgAyAEIAWFgyAEIAWDhXwgFkI/iSAWQjiJhSAWQgeIhSAVfCAMfCASQi2JIBJCA4mFIBJCBoiFfCIVIAh8IAYgD3wiCCAJIAqFgyAJhXwgCEIyiSAIQi6JhSAIQheJhXxCmqLJwJvazZ7+AH0iD3wiBkIkiSAGQh6JhSAGQhmJhSAGIAMgBYWDIAMgBYOFfCAXQj+JIBdCOImFIBdCB4iFIBZ8IA58IBNCLYkgE0IDiYUgE0IGiIV8IhYgCXwgByAPfCIJIAggCoWDIAqFfCAJQjKJIAlCLomFIAlCF4mFfELFlffbru/0xu0AfSIPfCIHQiSJIAdCHomFIAdCGYmFIAcgAyAGhYMgAyAGg4V8IBRCP4kgFEI4iYUgFEIHiIUgF3wgDXwgFUItiSAVQgOJhSAVQgaIhXwiFyAKfCAEIA98IgogCCAJhYMgCIV8IApCMokgCkIuiYUgCkIXiYV8Qpz5u5jr64Wg3QB9Ig98IgRCJIkgBEIeiYUgBEIZiYUgBCAGIAeFgyAGIAeDhXwgGEI/iSAYQjiJhSAYQgeIhSAUfCAQfCAWQi2JIBZCA4mFIBZCBoiFfCIUIAh8IAUgD3wiCCAJIAqFgyAJhXwgCEIyiSAIQi6JhSAIQheJhXxC/5/3ncS25vLXAH0iD3wiBUIkiSAFQh6JhSAFQhmJhSAFIAQgB4WDIAQgB4OFfCAaQj+JIBpCOImFIBpCB4iFIBh8IBF8IBdCLYkgF0IDiYUgF0IGiIV8IhggCXwgAyAPfCIJIAggCoWDIAqFfCAJQjKJIAlCLomFIAlCF4mFfELv0J348pGd2j19Ig98IgNCJIkgA0IeiYUgA0IZiYUgAyAEIAWFgyAEIAWDhXwgG0I/iSAbQjiJhSAbQgeIhSAafCASfCAUQi2JIBRCA4mFIBRCBoiFfCIaIAp8IAYgD3wiCiAIIAmFgyAIhXwgCkIyiSAKQi6JhSAKQheJhXxC0IOtzc/L68k4fSIPfCIGQiSJIAZCHomFIAZCGYmFIAYgAyAFhYMgAyAFg4V8IBlCP4kgGUI4iYUgGUIHiIUgG3wgE3wgGEItiSAYQgOJhSAYQgaIhXwiGyAIfCAHIA98IgggCSAKhYMgCYV8IAhCMokgCEIuiYUgCEIXiYV8Qujbwsji/MW2Ln0iD3wiB0IkiSAHQh6JhSAHQhmJhSAHIAMgBoWDIAMgBoOFfCALQj+JIAtCOImFIAtCB4iFIBl8IBV8IBpCLYkgGkIDiYUgGkIGiIV8IhkgCXwgBCAPfCIJIAggCoWDIAqFfCAJQjKJIAlCLomFIAlCF4mFfELwrenUuru+syl9Ig98IgRCJIkgBEIeiYUgBEIZiYUgBCAGIAeFgyAGIAeDhXwgDEI/iSAMQjiJhSAMQgeIhSALfCAWfCAbQi2JIBtCA4mFIBtCBoiFfCILIAp8IAUgD3wiCiAIIAmFgyAIhXwgCkIyiSAKQi6JhSAKQheJhXxC1r+7xKrP8vgLfSIPfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IA5CP4kgDkI4iYUgDkIHiIUgDHwgF3wgGUItiSAZQgOJhSAZQgaIhXwiDCAIfCADIA98IgggCSAKhYMgCYV8IAhCMokgCEIuiYUgCEIXiYV8Qrij75WDjqi1EHwiD3wiA0IkiSADQh6JhSADQhmJhSADIAQgBYWDIAQgBYOFfCANQj+JIA1COImFIA1CB4iFIA58IBR8IAtCLYkgC0IDiYUgC0IGiIV8Ig4gCXwgBiAPfCIJIAggCoWDIAqFfCAJQjKJIAlCLomFIAlCF4mFfELIocvG66Kw0hl8Ig98IgZCJIkgBkIeiYUgBkIZiYUgBiADIAWFgyADIAWDhXwgEEI/iSAQQjiJhSAQQgeIhSANfCAYfCAMQi2JIAxCA4mFIAxCBoiFfCINIAp8IAcgD3wiCiAIIAmFgyAIhXwgCkIyiSAKQi6JhSAKQheJhXxC09aGioWB25sefCIPfCIHQiSJIAdCHomFIAdCGYmFIAcgAyAGhYMgAyAGg4V8IBFCP4kgEUI4iYUgEUIHiIUgEHwgGnwgDkItiSAOQgOJhSAOQgaIhXwiECAIfCAEIA98IgggCSAKhYMgCYV8IAhCMokgCEIuiYUgCEIXiYV8QpnXu/zN6Z2kJ3wiD3wiBEIkiSAEQh6JhSAEQhmJhSAEIAYgB4WDIAYgB4OFfCASQj+JIBJCOImFIBJCB4iFIBF8IBt8IA1CLYkgDUIDiYUgDUIGiIV8IhEgCXwgBSAPfCIJIAggCoWDIAqFfCAJQjKJIAlCLomFIAlCF4mFfEKoke2M3pav2DR8Ig98IgVCJIkgBUIeiYUgBUIZiYUgBSAEIAeFgyAEIAeDhXwgE0I/iSATQjiJhSATQgeIhSASfCAZfCAQQi2JIBBCA4mFIBBCBoiFfCISIAp8IAMgD3wiCiAIIAmFgyAIhXwgCkIyiSAKQi6JhSAKQheJhXxC47SlrryWg445fCIPfCIDQiSJIANCHomFIANCGYmFIAMgBCAFhYMgBCAFg4V8IBVCP4kgFUI4iYUgFUIHiIUgE3wgC3wgEUItiSARQgOJhSARQgaIhXwiEyAIfCAGIA98IgggCSAKhYMgCYV8IAhCMokgCEIuiYUgCEIXiYV8QsuVhpquyarszgB8Ig98IgZCJIkgBkIeiYUgBkIZiYUgBiADIAWFgyADIAWDhXwgFkI/iSAWQjiJhSAWQgeIhSAVfCAMfCASQi2JIBJCA4mFIBJCBoiFfCIVIAl8IAcgD3wiCSAIIAqFgyAKhXwgCUIyiSAJQi6JhSAJQheJhXxC88aPu/fJss7bAHwiD3wiB0IkiSAHQh6JhSAHQhmJhSAHIAMgBoWDIAMgBoOFfCAXQj+JIBdCOImFIBdCB4iFIBZ8IA58IBNCLYkgE0IDiYUgE0IGiIV8IhYgCnwgBCAPfCIKIAggCYWDIAiFfCAKQjKJIApCLomFIApCF4mFfEKj8cq1vf6bl+gAfCIPfCIEQiSJIARCHomFIARCGYmFIAQgBiAHhYMgBiAHg4V8IBRCP4kgFEI4iYUgFEIHiIUgF3wgDXwgFUItiSAVQgOJhSAVQgaIhXwiFyAIfCAFIA98IgggCSAKhYMgCYV8IAhCMokgCEIuiYUgCEIXiYV8Qvzlvu/l3eDH9AB8Ig98IgVCJIkgBUIeiYUgBUIZiYUgBSAEIAeFgyAEIAeDhXwgGEI/iSAYQjiJhSAYQgeIhSAUfCAQfCAWQi2JIBZCA4mFIBZCBoiFfCIUIAl8IAMgD3wiCSAIIAqFgyAKhXwgCUIyiSAJQi6JhSAJQheJhXxC4N7cmPTt2NL4AHwiD3wiA0IkiSADQh6JhSADQhmJhSADIAQgBYWDIAQgBYOFfCAaQj+JIBpCOImFIBpCB4iFIBh8IBF8IBdCLYkgF0IDiYUgF0IGiIV8IhggCnwgBiAPfCIKIAggCYWDIAiFfCAKQjKJIApCLomFIApCF4mFfEKOqb3wtf3hm/sAfSIPfCIGQiSJIAZCHomFIAZCGYmFIAYgAyAFhYMgAyAFg4V8IBtCP4kgG0I4iYUgG0IHiIUgGnwgEnwgFEItiSAUQgOJhSAUQgaIhXwiGiAIfCAHIA98IgggCSAKhYMgCYV8IAhCMokgCEIuiYUgCEIXiYV8QpSM76z+vr+c8wB9Ig98IgdCJIkgB0IeiYUgB0IZiYUgByADIAaFgyADIAaDhXwgGUI/iSAZQjiJhSAZQgeIhSAbfCATfCAYQi2JIBhCA4mFIBhCBoiFfCIbIAl8IAQgD3wiCSAIIAqFgyAKhXwgCUIyiSAJQi6JhSAJQheJhXxC2MPz5N2AwKDvAH0iD3wiBEIkiSAEQh6JhSAEQhmJhSAEIAYgB4WDIAYgB4OFfCALQj+JIAtCOImFIAtCB4iFIBl8IBV8IBpCLYkgGkIDiYUgGkIGiIV8IhkgCnwgBSAPfCIKIAggCYWDIAiFfCAKQjKJIApCLomFIApCF4mFfEKXhPWLwuLk19sAfSIPfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IAxCP4kgDEI4iYUgDEIHiIUgC3wgFnwgG0ItiSAbQgOJhSAbQgaIhXwiCyAIfCADIA98IgggCSAKhYMgCYV8IAhCMokgCEIuiYUgCEIXiYV8QuuN5umEgZeDwQB9Ig98IgNCJIkgA0IeiYUgA0IZiYUgAyAEIAWFgyAEIAWDhXwgDkI/iSAOQjiJhSAOQgeIhSAMfCAXfCAZQi2JIBlCA4mFIBlCBoiFfCIMIAl8IAYgD3wiCSAIIAqFgyAKhXwgCUIyiSAJQi6JhSAJQheJhXxC1dm25NHhocc5fSIPfCIGQiSJIAZCHomFIAZCGYmFIAYgAyAFhYMgAyAFg4V8IA1CP4kgDUI4iYUgDUIHiIUgDnwgFHwgC0ItiSALQgOJhSALQgaIhXwiDiAKfCAHIA98IgogCCAJhYMgCIV8IApCMokgCkIuiYUgCkIXiYV8QuS85q6RprDsNX0iD3wiB0IkiSAHQh6JhSAHQhmJhSAHIAMgBoWDIAMgBoOFfCAIIBBCP4kgEEI4iYUgEEIHiIUgDXwgGHwgDEItiSAMQgOJhSAMQgaIhXwiCHwgBCAPfCINIAkgCoWDIAmFfCANQjKJIA1CLomFIA1CF4mFfEL5+/zxjefRvC59Ig98IgRCJIkgBEIeiYUgBEIZiYUgBCAGIAeFgyAGIAeDhXwgCSARQj+JIBFCOImFIBFCB4iFIBB8IBp8IA5CLYkgDkIDiYUgDkIGiIV8Igl8IAUgD3wiECAKIA2FgyAKhXwgEEIyiSAQQi6JhSAQQheJhXxC4qn8kJPF4JIVfSIPfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IAogEkI/iSASQjiJhSASQgeIhSARfCAbfCAIQi2JIAhCA4mFIAhCBoiFfCIKfCADIA98IhEgDSAQhYMgDYV8IBFCMokgEUIuiYUgEUIXiYV8QojdxIyBkKzBCn0iD3wiA0IkiSADQh6JhSADQhmJhSADIAQgBYWDIAQgBYOFfCATQj+JIBNCOImFIBNCB4iFIBJ8IBl8IAlCLYkgCUIDiYUgCUIGiIV8IhIgDXwgBiAPfCINIBAgEYWDIBCFfCANQjKJIA1CLomFIA1CF4mFfEK6392Qp/WZ+AZ8Ig98IgZCJIkgBkIeiYUgBkIZiYUgBiADIAWFgyADIAWDhXwgFUI/iSAVQjiJhSAVQgeIhSATfCALfCAKQi2JIApCA4mFIApCBoiFfCITIBB8IAcgD3wiECANIBGFgyARhXwgEEIyiSAQQi6JhSAQQheJhXxCprGiltq437EKfCIPfCIHQiSJIAdCHomFIAdCGYmFIAcgAyAGhYMgAyAGg4V8IBZCP4kgFkI4iYUgFkIHiIUgFXwgDHwgEkItiSASQgOJhSASQgaIhXwiFSARfCAEIA98IhEgDSAQhYMgDYV8IBFCMokgEUIuiYUgEUIXiYV8Qq6b5PfLgOafEXwiD3wiBEIkiSAEQh6JhSAEQhmJhSAEIAYgB4WDIAYgB4OFfCAXQj+JIBdCOImFIBdCB4iFIBZ8IA58IBNCLYkgE0IDiYUgE0IGiIV8IhYgDXwgBSAPfCINIBAgEYWDIBCFfCANQjKJIA1CLomFIA1CF4mFfEKbjvGY0ebCuBt8Ig98IgVCJIkgBUIeiYUgBUIZiYUgBSAEIAeFgyAEIAeDhXwgFEI/iSAUQjiJhSAUQgeIhSAXfCAIfCAVQi2JIBVCA4mFIBVCBoiFfCIXIBB8IAMgD3wiECANIBGFgyARhXwgEEIyiSAQQi6JhSAQQheJhXxChPuRmNL+3e0ofCIIfCIDQiSJIANCHomFIANCGYmFIAMgBCAFhYMgBCAFg4V8IBhCP4kgGEI4iYUgGEIHiIUgFHwgCXwgFkItiSAWQgOJhSAWQgaIhXwiFCARfCAGIAh8IhEgDSAQhYMgDYV8IBFCMokgEUIuiYUgEUIXiYV8QpPJnIa076rlMnwiCHwiBkIkiSAGQh6JhSAGQhmJhSAGIAMgBYWDIAMgBYOFfCAaQj+JIBpCOImFIBpCB4iFIBh8IAp8IBdCLYkgF0IDiYUgF0IGiIV8IhggDXwgByAIfCINIBAgEYWDIBCFfCANQjKJIA1CLomFIA1CF4mFfEK8/aauocGvzzx8Igh8IgdCJIkgB0IeiYUgB0IZiYUgByADIAaFgyADIAaDhXwgG0I/iSAbQjiJhSAbQgeIhSAafCASfCAUQi2JIBRCA4mFIBRCBoiFfCISIBB8IAQgCHwiECANIBGFgyARhXwgEEIyiSAQQi6JhSAQQheJhXxCzJrA4Mn42Y7DAHwiFHwiBEIkiSAEQh6JhSAEQhmJhSAEIAYgB4WDIAYgB4OFfCAZQj+JIBlCOImFIBlCB4iFIBt8IBN8IBhCLYkgGEIDiYUgGEIGiIV8IhMgEXwgBSAUfCIRIA0gEIWDIA2FfCARQjKJIBFCLomFIBFCF4mFfEK2hfnZ7Jf14swAfCIUfCIFQiSJIAVCHomFIAVCGYmFIAUgBCAHhYMgBCAHg4V8IAtCP4kgC0I4iYUgC0IHiIUgGXwgFXwgEkItiSASQgOJhSASQgaIhXwiEiANfCADIBR8IgMgECARhYMgEIV8IANCMokgA0IuiYUgA0IXiYV8Qqr8lePPs8q/2QB8IhV8Ig1CJIkgDUIeiYUgDUIZiYUgDSAEIAWFgyAEIAWDhXwgCyAMQj+JIAxCOImFIAxCB4iFfCAWfCATQi2JIBNCA4mFIBNCBoiFfCAQfCAGIBV8IgYgAyARhYMgEYV8IAZCMokgBkIuiYUgBkIXiYV8Quz129az9dvl3wB8IhB8IgsgBSANhYMgBSANg4V8IAtCJIkgC0IeiYUgC0IZiYV8IAwgDkI/iSAOQjiJhSAOQgeIhXwgF3wgEkItiSASQgOJhSASQgaIhXwgEXwgByAQfCIMIAMgBoWDIAOFfCAMQjKJIAxCLomFIAxCF4mFfEKXsJ3SxLGGouwAfCIOfCEHIAsgHnwhHiAEIB18IA58IR0gDSAhfCEhIAwgH3whHyAFICN8ISMgBiAgfCEgIAMgInwhIiABQYABaiIBIAJHDQALIAAgIjcDOCAAICA3AzAgACAfNwMoIAAgHTcDICAAICM3AxggACAhNwMQIAAgHjcDCCAAIAc3AwALlC4CQX8YfiMAQaAGayIDJAAgA0EJaiABQQlqKQAANwAAIANBEWogAUERaikAADcAACADQRdqIAFBF2opAAA3AAAgAyABKQABNwABIAMgAS0AAEH4AXE6AAAgAyABLQAfQT9xQcAAcjoAHyACMQAFIUsgAjEABCFMIAIxABUhTSACMQAUIU4gAjEACCFKIAIxAAchUSACMQAGIUQgAjEACyFPIAIxAAohUiACMQAJIUkgAjEADyFTIAIxAA4hUCACMQANIVQgAjEADCFFIAIxABghVSACMQAXIVYgAjEAFiFHIAIxABshVyACMQAaIVggAjEAGSFIIAIxAB8hWSACMQAeIVogAjEAHSFbIAIxABwhRiACKAAAIQEgAyACKAAQIgJB////D3EiFjYCNCADIAFB////H3EiFzYCICADIFlCEoZCgIDwD4MgW0IChiBGQgaIhCBaQgqGhISnIhg2AkQgAyBGQhSGQoCAwB+DIFhCBIYgSEIEiIQgV0IMhoSEpyIZNgJAIAMgSEIVhkKAgIAPgyBWQgWGIEdCA4iEIFVCDYaEhKciGjYCPCADIFRCAoYgRUIGiIQgUEIKhoQgU0IShoSnIhs2AjAgAyBFQhOGQoCA4A+DIFJCA4YgSUIFiIQgT0ILhoSEpyIcNgIsIAMgSUIVhkKAgIAfgyBRQgWGIERCA4iEIEpCDYaEhKciBzYCKCADIEdCF4ZCgICAHIMgAkEZdq0gTkIHhoQgTUIPhoSEpyIINgI4IAMgREIWhkKAgIAOgyABQRp2rSBMQgaGhCBLQg6GhISnIgk2AiQgA0HoAGpBrLrAACkCADcDACADQeAAakGkusAAKQIANwMAIANB2ABqQZy6wAApAgA3AwAgA0HQAGpBlLrAACkCADcDACADQfgAakIANwMAIANBgAFqQgA3AwAgA0GIAWpCADcDACADQZABakIANwMAIANBjLrAACkCADcDSCADQgA3A3AgA0EAOgCfASADQfAAaiEuQQEhKEEAIQJBgAIhAUEBISECQANAAkACQCAqBEAgAUUNAiABQQFrIgFBA3YhBAwBCyABRQ0BAkAgAUGAAksEf0F/BSAhDQEgAUEBRg0DQX4LIAFqQQN2QSBB/LnAABCZAQALIAEgIUYNASABICFrIiFBAWsiAUEDdiEEICFBgQJPDQMLQQAhIUEBISogAyAEai0AACABQQdxdiIvIAJB/wFxQQBHc0EBcRC/ASECIAMoAmghBCADKAKQASEFIAMoAmQhDyADKAKMASEQIAMoAmAhESADKAKIASESIAMoAlwhEyADKAKEASEUIAMoAlghFSADKAKAASEGIAMoAlQhIiADKAJ8ISMgAygCUCEkIAMoAnghJSADKAJMISYgAygCdCEnIAMoAkghKSADKAJwISsgAygClAEhLCADQQAgAkH/AXFrIgIgGCADKAJsIi1zcSIwIC1zIi02AmwgAyAsIAogLHMgAnEiMXMiLDYClAEgAyArICggK3MgAnEiMnMiKzYCcCADICkgFyApcyACcSIzcyIpNgJIIAMgJyAgICdzIAJxIjRzIic2AnQgAyAmIAkgJnMgAnEiNXMiJjYCTCADICUgHyAlcyACcSI2cyIlNgJ4IAMgJCAHICRzIAJxIjdzIiQ2AlAgAyAjIB4gI3MgAnEiOHMiIzYCfCADICIgHCAicyACcSI5cyIiNgJUIAMgBiAGIB1zIAJxIjpzIgY2AoABIAMgFSAVIBtzIAJxIjtzIhU2AlggAyAUIA4gFHMgAnEiPHMiFDYChAEgAyATIBMgFnMgAnEiPXMiEzYCXCADIBIgDSAScyACcSI+cyISNgKIASADIBEgCCARcyACcSI/cyIRNgJgIAMgECAMIBBzIAJxIkBzIhA2AowBIAMgDyAPIBpzIAJxIkFzIg82AmQgAyAFIAUgC3MgAnEiQnMiBTYCkAEgAyAEIAQgGXMgAnEiQ3MiAjYCaCADICwgLWo2AsQBIAMgAiAFajYCwAEgAyAPIBBqNgK8ASADIBEgEmo2ArgBIAMgEyAUajYCtAEgAyAGIBVqNgKwASADICIgI2o2AqwBIAMgJCAlajYCqAEgAyAmICdqNgKkASADICkgK2o2AqABIAMgESASa0Hw////A2qtIBMgFGtB8P///wFqrSAVIAZrQfD///8Daq0iREIaiHwiSUIZiHwiRadB////H3E2AuABIAMgJCAla0Hw////A2qtICYgJ2tB8P///wFqrSApICtrQdD9//8Daq0iR0IaiHwiSEIZiHwiRqdB////H3E2AtABIAMgDyAQa0Hw////AWqtIEVCGoh8IkWnQf///w9xNgLkASADICIgI2tB8P///wFqrSBGQhqIfCJGp0H///8PcTYC1AEgAyACIAVrQfD///8Daq0gRUIZiHwiRadB////H3E2AugBIAMgSUL///8PgyBEQv///x+DIEZCGYh8IkRCGoh8PgLcASADIESnQf///x9xNgLYASADIC0gLGtB8P///wFqrSBFQhqIfCJEp0H///8PcTYC7AEgAyBIQv///w+DIERCGYhCE34gR0L///8fg3wiREIaiHw+AswBIAMgRKdB////H3E2AsgBIAMgCiAxcyICIBggMHMiGGo2ApQCIAMgCyBCcyIKIBkgQ3MiGWo2ApACIAMgDCBAcyILIBogQXMiGmo2AowCIAMgDSA+cyIMIAggP3MiCGo2AogCIAMgDiA8cyINIBYgPXMiFmo2AoQCIAMgHSA6cyIOIBsgO3MiG2o2AoACIAMgHiA4cyIdIBwgOXMiHGo2AvwBIAMgHyA2cyIeIAcgN3MiB2o2AvgBIAMgICA0cyIfIAkgNXMiCWo2AvQBIAMgKCAycyIgIBcgM3MiF2o2AvABIAMgGCACa0Hw////AWqtIBkgCmtB8P///wNqrSAaIAtrQfD///8Baq0gCCAMa0Hw////A2qtIBYgDWtB8P///wFqrSAbIA5rQfD///8Daq0iREIaiHwiSUIZiHwiRUIaiHwiR0IZiHwiSEIaiHwiRqdB////D3E2ArwCIAMgSKdB////H3E2ArgCIAMgR6dB////D3E2ArQCIAMgRadB////H3E2ArACIAMgSUL///8PgyBEQv///x+DIBwgHWtB8P///wFqrSAHIB5rQfD///8Daq0gCSAfa0Hw////AWqtIBcgIGtB0P3//wNqrSJEQhqIfCJJQhmIfCJFQhqIfCJHQhmIfCJIQhqIfD4CrAIgAyBIp0H///8fcTYCqAIgAyBHp0H///8PcTYCpAIgAyBFp0H///8fcTYCoAIgAyBJQv///w+DIEZCGYhCE34gREL///8fg3wiREIaiHw+ApwCIAMgRKdB////H3E2ApgCIANB0AVqIgYgA0GgAWoiBBBWIAMgAykDmAYgAykDkAYgAykDiAYgAykDgAYgAykD+AUgAykD8AUiREIaiHwiSUIZiHwiRUIaiHwiR0IZiHwiSEIaiHwiRkIZiEITfiADKQPQBSJLQv///x+DfCJMp0H///8fcSIHNgLAAiADIAMpA9gFIEtCGoh8IktC////D4MgTEIaiHwiTD4CxAIgAyBEQv///x+DIAMpA+gFIAMpA+AFIEtCGYh8IkRCGoh8IktCGYh8Ik2nQf///x9xIgg2AtACIAMgSUL///8PgyBNQhqIfCJJPgLUAiADIEunQf///w9xIgk2AswCIAMgRqdB////D3EiCjYC5AIgAyBEp0H///8fcSILNgLIAiADIEinQf///x9xIgw2AuACIAMgR6dB////D3EiDTYC3AIgAyBFp0H///8fcSIONgLYAiAGIANByAFqIgUQViADKQP4BSFEIAMgAykD8AUiRUL///8fgyADKQPoBSADKQPgBSADKQPYBSADKQPQBSJHQhqIfCJIQhmIfCJGQhqIfCJLQhmIfCJNp0H///8fcSICNgL4AiADIAMpA4AGIEQgRUIaiHwiREIZiHwiRadB////H3EiFjYCgAMgAyBIQv///w+DIAMpA5gGIAMpA5AGIAMpA4gGIEVCGoh8IkVCGYh8IkhCGoh8Ik5CGYhCE34gR0L///8fg3wiR0IaiHwiSqciEjYC7AIgAyBEQv///w+DIE1CGoh8IkSnIhM2AvwCIAMgR6dB////H3EiFzYC6AIgAyBLp0H///8PcSIYNgL0AiADIE6nQf///w9xIhk2AowDIAMgRqdB////H3EiGjYC8AIgAyBIp0H///8fcSIbNgKIAyADIEWnQf///w9xIhw2AoQDIAMgDiAWa0Hw////A2qtIEkgRH0gCCACa0Hw////A2qtIkRCGoh8QvD///8BfCJJQhmIfCJFp0H///8fcTYCqAMgAyANIBxrQfD///8Baq0gRUIaiHwiRadB////D3E2AqwDIAMgDCAba0Hw////A2qtIEVCGYh8IkWnQf///x9xNgKwAyADIAsgGmtB8P///wNqrSBMIEp9IAcgF2tB0P3//wNqrSJHQhqIfELw////AXwiSEIZiHwiRqdB////H3E2ApgDIAMgCiAZa0Hw////AWqtIEVCGoh8IkWnQf///w9xNgK0AyADIAkgGGtB8P///wFqrSBGQhqIfCJGp0H///8PcTYCnAMgAyBJQv///w+DIERC////H4MgRkIZiHwiREIaiHw+AqQDIAMgRKdB////H3E2AqADIAMgSEL///8PgyBFQhmIQhN+IEdC////H4N8IkRCGoh8PgKUAyADIESnQf///x9xNgKQAyADQbgDaiAEIANBmAJqEEEgA0HgA2ogBSADQfABahBBIAMoArgDIQcgAygC4AMhCCADKAK8AyEJIAMoAuQDIQogAygCwAMhCyADKALoAyEMIAMoAsQDIQ0gAygC7AMhDiADKALIAyEdIAMoAvADIR4gAygCzAMhHyADKAL0AyEgIAMoAtADISggAygC+AMhBCADKALUAyEFIAMoAvwDIQ8gAygC2AMhECADKAKABCERIAMgAygChAQiFCADKALcAyIVajYCrAQgAyAQIBFqNgKoBCADIAUgD2o2AqQEIAMgBCAoajYCoAQgAyAfICBqNgKcBCADIB0gHmo2ApgEIAMgDSAOajYClAQgAyALIAxqNgKQBCADIAkgCmo2AowEIAMgByAIajYCiAQgAyAoIARrQfD///8Daq0gHyAga0Hw////AWqtIB0gHmtB8P///wNqrSJEQhqIfCJJQhmIfCJFp0H///8fcTYCyAQgAyALIAxrQfD///8Daq0gCSAKa0Hw////AWqtIAcgCGtB0P3//wNqrSJHQhqIfCJIQhmIfCJGp0H///8fcTYCuAQgAyAFIA9rQfD///8Baq0gRUIaiHwiRadB////D3E2AswEIAMgDSAOa0Hw////AWqtIEZCGoh8IkanQf///w9xNgK8BCADIBAgEWtB8P///wNqrSBFQhmIfCJFp0H///8fcTYC0AQgAyBJQv///w+DIERC////H4MgRkIZiHwiREIaiHw+AsQEIAMgRKdB////H3E2AsAEIAMgFSAUa0Hw////AWqtIEVCGoh8IkSnQf///w9xNgLUBCADIEhC////D4MgREIZiEITfiBHQv///x+DfCJEQhqIfD4CtAQgAyBEp0H///8fcTYCsAQgBiADQYgEahBWIAMpA5gGIAMpA5AGIAMpA4gGIAMpA4AGIAMpA/gFIAMpA+gFIUwgAykD4AUhTSADKQPYBSFOIAMpA9AFIUQgAykD8AUhSSAGIANBsARqEFYgAyADKQOABiADKQP4BSADKQPwBSJKQhqIfCJRQhmIfCJPp0H///8fcTYC8AQgAyADKQPgBSADKQPYBSADKQPQBSJSQhqIfCJTQhmIfCJQp0H///8fcTYC4AQgAyADKQOIBiBPQhqIfCJPp0H///8PcTYC9AQgAyADKQPoBSBQQhqIfCJQp0H///8PcTYC5AQgAyADKQOQBiBPQhmIfCJPp0H///8fcTYC+AQgAyBRQv///w+DIEpC////H4MgUEIZiHwiSkIaiHw+AuwEIAMgSqdB////H3E2AugEIAMgAykDmAYgT0IaiHwiSqdB////D3E2AvwEIAMgU0L///8PgyBKQhmIQhN+IFJC////H4N8IkpCGoh8PgLcBCADIEqnQf///x9xNgLYBCADQYAFakG0+MAAIANBkANqIgQQQSADQcgAaiADQcACaiADQegCahBBIAMgAygCpAUgGWo2AswFIAMgAygCoAUgG2o2AsgFIAMgAygCnAUgHGo2AsQFIAMgAygCmAUgFmo2AsAFIAMgAygClAUgE2o2ArwFIAMgAygCkAUgAmo2ArgFIAMgAygCjAUgGGo2ArQFIAMgAygCiAUgGmo2ArAFIAMgAygChAUgEmo2AqwFIAMgAygCgAUgF2o2AqgFIC4gBCADQagFahBBIElC////H4MgTCBNIE4gREIaiHwiTkIZiHwiTUIaiHwiTEIZiHwiSqdB////H3EhGyBJQhqIfCJJQhmIfCJGQhqIfCJIQhmIfCJHQhqIfCJFQhmIQhN+IERC////H4N8IkSnQf///x9xIRcgSUL///8PgyBKQhqIfKchFiBOQv///w+DIERCGoh8pyEJIC9BAXEhAiBGp0H///8fcSEIIE2nQf///x9xIQcgSKdB////D3EhGiBMp0H///8PcSEcIEenQf///x9xIRkgRadB////D3EhGCAGIANBIGogA0HYBGoQQSADKAL0BSEKIAMoAvAFIQsgAygC7AUhDCADKALoBSENIAMoAuQFIQ4gAygC4AUhHSADKALcBSEeIAMoAtgFIR8gAygC1AUhICADKALQBSEoDAELCyACEL8BIQEgAygCSCECIAMoAkwhISADKAJQIQQgAygCVCEqIAMoAlghBSADKAJcIQ8gAygCYCEQIAMoAmQhESADKAJoIRIgAygCbCETIAMoAnAhFCADKAJ0IRUgAygCeCEGIAMoAnwhIiADKAKAASEjIAMoAoQBISQgAygCiAEhJSADKAKMASEmIAMoApABIScgA0EAIAFB/wFxayIBIAogAygClAEiKXNxIClzNgKUASADICcgCyAncyABcXM2ApABIAMgJiAMICZzIAFxczYCjAEgAyAlIA0gJXMgAXFzNgKIASADICQgDiAkcyABcXM2AoQBIAMgIyAdICNzIAFxczYCgAEgAyAiIB4gInMgAXFzNgJ8IAMgBiAGIB9zIAFxczYCeCADIBUgFSAgcyABcXM2AnQgAyAUIBQgKHMgAXFzNgJwIAMgEyATIBhzIAFxczYCbCADIBIgEiAZcyABcXM2AmggAyARIBEgGnMgAXFzNgJkIAMgECAIIBBzIAFxczYCYCADIA8gDyAWcyABcXM2AlwgAyAFIAUgG3MgAXFzNgJYIAMgKiAcICpzIAFxczYCVCADIAQgBCAHcyABcXM2AlAgAyAhIAkgIXMgAXFzNgJMIAMgAiACIBdzIAFxczYCSCADQQA6AJ8BIANB0AVqIgEgLhA7IANBoAVqIANB8AVqKQIANwMAIANBmAVqIANB6AVqKQIANwMAIANBkAVqIANB4AVqKQIANwMAIANBiAVqIANB2AVqKQIANwMAIAMgAykC0AU3A4AFIANByAVqIANBmAZqKQIANwMAIANBwAVqIANBkAZqKQIANwMAIANBuAVqIANBiAZqKQIANwMAIANBsAVqIANBgAZqKQIANwMAIAMgAykC+AU3A6gFIAEgA0GABWpBBRBVIANB2ARqIgIgASADQagFahBBIAEgA0HIAGogAhBBIAAgARBMIANBoAZqJAAPCyAEQSBB/LnAABCZAQALkD4CIX8kfiMAQaAHayIFJAACQCACQSBGBEAgBUEGaiABQQJqIgctAAA6AAAgBUETaiABQQ9qIggpAAA3AAAgBUEjaiABQR9qIgktAAA6AAAgBSABLwAAOwEEIAUgASgAAyIKNgAHIAUgASkABzcACyAFIAEpABc3ABsgBUHIAmoiBiAFQQRqED4gBUEkaiICIAYQNyAFQYAFaiILIAIQZSAFQaAFaiACQaABEN8BGiAGEGkgBUHmAWogBy0AADoAACAFQfMBaiAIKQAANwAAIAVBgwJqIAktAAA6AAAgBSAKNgDnASAFIAEvAAA7AeQBIAUgASkABzcA6wEgBSABKQAXNwD7ASACIAtBwAEQ3wEaIAVBiAJqIAVB5AFqED4gBUGQA2oiBkIANwMAIAVBgANqQbDqwgApAwA3AwAgBUH4AmpBqOrCACkDADcDACAFQfACakGg6sIAKQMANwMAIAVB6AJqQZjqwgApAwA3AwAgBUHgAmpBkOrCACkDADcDACAFQdgCakGI6sIAKQMANwMAIAVB0AJqQYDqwgApAwA3AwAgBUIANwOIAyAFQfjpwgApAwA3A8gCIAVBoANqIAVBsAJqKQAANwMAIAVBqANqIAVBuAJqKQAANwMAIAVBsANqIAVBwAJqKQAANwMAIAUgBSkAqAI3A5gDIAVBuANqQeAAEN4BIQIgBUEgOgCYBCAFQZgDaiEBAkAgBEHfAE0EQCACIAMgBBDfARogBEEgaiECDAELIAIgA0HgABDfARogBkIANwMAIAVCATcDiAMgBUHIAmoiByABQQEQIyADQeAAaiIIIARB4ABrIgZBgH9xaiEJIAZB/wBxIQIgBkGAAU8EQCAFIAUpA4gDIiYgBkEHdiIGrXwiJzcDiAMgBUGQA2oiCiAKKQMAICYgJ1atfDcDACAHIAggBhAjCyABIAkgAhDfARoLIAUgAjoAmAQgBUGABWoiAiAFQcgCakHYARDfARogBUGgBGoiBiACECwgAiAGEDcgBUHABGogAhBlIAFBgQEQ3gEhASAFQZADaiICQgA3AwAgBUGAA2pBsOrCACkDADcDACAFQfgCakGo6sIAKQMANwMAIAVB8AJqQaDqwgApAwA3AwAgBUHoAmpBmOrCACkDADcDACAFQeACakGQ6sIAKQMANwMAIAVB2AJqQYjqwgApAwA3AwAgBUHQAmpBgOrCACkDADcDACABIAUpAMAENwAAIAFBCGogBUHIBGopAAA3AAAgAUEQaiAFQdAEaikAADcAACABQRhqIAVB2ARqKQAANwAAIAVCADcDiAMgBUH46cIAKQMANwPIAiAFQcADaiAFQSxqKQIANwMAIAVByANqIAVBNGopAgA3AwAgBUHQA2ogBUE8aikCADcDACAFQcAAOgCYBCAFIAUpAiQ3A7gDAkAgBEE/TQRAIAVB2ANqIAMgBBDfARogBEHAAHIhAwwBCyACQgA3AwAgBUGQBGogA0E4aikAADcDACAFQYgEaiADQTBqKQAANwMAIAVBgARqIANBKGopAAA3AwAgBUH4A2ogA0EgaikAADcDACAFQfADaiADQRhqKQAANwMAIAVB6ANqIANBEGopAAA3AwAgBUHgA2ogA0EIaikAADcDACAFQgE3A4gDIAUgAykAADcD2AMgBUHIAmoiBiABQQEQIyADQUBrIgcgBEFAaiICQYB/cWohBCACQf8AcSEDIAJBgAFPBEAgBSAFKQOIAyImIAJBB3YiAq18Iic3A4gDIAVBkANqIgggCCkDACAmICdWrXw3AwAgBiAHIAIQIwsgASAEIAMQ3wEaCyAFIAM6AJgEIAVBgAVqIgEgBUHIAmpB2AEQ3wEaIAVB4ARqIAEQLCAFLwDkBCECIAUtAOYEIQMgBS0A+AQhBCAFLQD2BCEGIAUtAPcEIQcgBS8A6AQhCCAFLQDnBCEJIAUvAOwEIQogBS0A6wQhCyAFLQDqBCENIAUvAPAEIQwgBS0A7wQhECAFLQDuBCEXIAUtAPQEIQ4gBS0A9QQhESAFLQDzBCEYIAUtAPIEIRIgBS0A/AQhDyAFLQD5BCEZIAUtAPoEIRogBS0A+wQhEyAFLwDgBCEUIAUtAOIEIRUgBS0A4wQhFiAFIAUvAP0EIAUtAP8EQRB0cjYCnAcgBSAWQRh0IhZBgICA+AFxIBQgFUEQdHJyNgL8BiAFIA9BFXQgGUEIdCIPIBpBEHQgE0EYdHJyQQt2cjYCmAcgBSAOIBFBCHQiEXJBD3QgEkEQdCIOIBhBGHRyQRF2ckH/////AXE2ApAHIAUgDCAOckEMdCAXQRB0IgwgEEEYdHJBFHZyQf////8BcTYCjAcgBSAKIAxyQQl0IA1BEHQiCiALQRh0ckEXdnJB/////wFxNgKIByAFIAggCnJBBnQgCUEYdCIIQRp2ckH/////AXE2AoQHIAUgBCAPckESdCAGQRB0IAdBGHRyIBFyQQ52ckH/////AXE2ApQHIAUgAiADQRB0ciAIckEDdCAWQR12ckH/////AXE2AoAHIAUvAIwCIQIgBS0AjgIhAyAFLQCgAiEEIAUtAJ4CIQYgBS0AnwIhByAFLwCIAiEIIAUtAIoCIQkgBS0AiwIhCiAFLwCQAiELIAUtAI8CIQ0gBS8AlAIhDCAFLQCTAiEQIAUtAJICIRcgBS8AmAIhDiAFLQCXAiERIAUtAJYCIRggBS0AnAIhEiAFLQCdAiEPIAUtAJsCIRkgBS0AmgIhGiAFLQCkAiETIAUtAKECIRQgBS0AogIhFSAFLQCjAiEWIAUgBS8ApQIgBS0ApwJBEHRyNgKgBSAFIBNBFXQgFEEIdCITIBVBEHQgFkEYdHJyQQt2cjYCnAUgBSASIA9BCHQiD3JBD3QgGkEQdCISIBlBGHRyQRF2ckH/////AXE2ApQFIAUgDiASckEMdCAYQRB0Ig4gEUEYdHJBFHZyQf////8BcTYCkAUgBSAMIA5yQQl0IBdBEHQiDCAQQRh0ckEXdnJB/////wFxNgKMBSAFIAsgDHJBBnQgDUEYdCILQRp2ckH/////AXE2AogFIAUgCkEYdCIKQYCAgPgBcSAIIAlBEHRycjYCgAUgBSAEIBNyQRJ0IAZBEHQgB0EYdHIgD3JBDnZyQf////8BcTYCmAUgBSACIANBEHRyIAtyQQN0IApBHXZyQf////8BcTYChAUjAEHQAGsiAiQAIAIgASgCACIErSIoIAVB/AZqIgoiAygCACIGrSIpfiItQpv80ZIBfkL/////AYMiKkLSscwEfiADKAIEIgetIisgKH4gASgCBCIIrSIuICl+fCJEfCAqQu2n1+cBfiAtfEIdiHwiPUKb/NGSAX5C/////wGDIixCFIYgBiADKAIUIglqrSIxIAE1AhAiJn58IAQgASgCFCIGaq0iLyADNQIQIid+fCABKAIMIgStIjMgK34gAygCCCILrSI0IAEoAggiDa0iMH58IAMoAgwiDK0iNiAufnwgJiApfnwgJyAofnwiRX0gCyADKAIcIhBqrSI3IA0gASgCHCILaq0iMn58IAQgASgCICINaq0iOSAHIAMoAhgiBGqtIjh+fCADKAIgIgMgDGqtIjUgASgCGCIHIAhqrSI6fnwgDa0iOyAErSI8fiAQrSI+IAutIj9+fCADrSJAIAetIkF+fCJGfSAwIDZ+IDMgNH58ICYgK358ICcgLn58IAatIkIgCa0iQ359IkcgLELNAn4gLX18IC8gMX58ICkgMH4gKyAufnwgKCA0fnwiSCAqQpbrnO8BfnwgLELSscwEfnwgLELtp9fnAX4gPXxCHYh8Ij1Cm/zRkgF+Qv////8BgyItQsX6zu8BfnwgLiA0fiArIDB+fCApIDN+fCAoIDZ+fCJJICpCxfrO7wF+fCAsQpbrnO8BfnwgLULSscwEfnwgLULtp9fnAX4gPXxCHYh8IilCm/zRkgF+Qv////8BgyIoQpbrnO8BfnwgLELF+s7vAX4gKkLNAn58IEV8IC1Cluuc7wF+fCAoQtKxzAR+fCAoQu2n1+cBfiApfEIdiHwiKUKb/NGSAX5C/////wGDIixC0rHMBH58ICxC7afX5wF+ICl8Qh2IfCIrQpv80ZIBfkL/////AYMiKULNAn58ICYgNH4gMyA2fnwgJyAwfnwgPCBCfiBBIEN+fH0iNCAxIDp+IER9IC8gOH58fCAtQs0CfnwgKELF+s7vAX58ICxCluuc7wF+fCApQtKxzAR+fCApQu2n1+cBfiArfEIdiHwiLkKb/NGSAX5C/////wGDIitCxfrO7wF+fCAnIDN+ICYgNn58ID8gQ34gPCBBfnwgPiBCfnx9IjMgOCA6fiBIfSAxIDJ+fCAvIDd+fHwgKELNAn58ICxCxfrO7wF+fCApQpbrnO8BfnwgK0LSscwEfnwgK0Ltp9fnAX4gLnxCHYh8IjBCm/zRkgF+Qv////8BgyIuQpbrnO8BfnwgKkIUhiBJfSAmICd+fCAyIDh+fCA3IDp+fCAxIDl+fCAvIDV+fCA+IEF+IDwgP358IDsgQ358IEAgQn58IjF9ICxCzQJ+fCApQsX6zu8BfnwgK0KW65zvAX58IC5C0rHMBH58IC5C7afX5wF+IDB8Qh2IfCIvQpv80ZIBfkL/////AYMiKkLSscwEfnwgKkLtp9fnAX4gL3xCHYh8Ii+nQf////8BcTYCLCACICcgOn4gR30gJiA4fnwgNyA5fnwgMiA1fnwgPyBAfiA7ID5+fCIwfSAtQhSGfCArQs0CfnwgLkLF+s7vAX58ICpCluuc7wF+fCAvQh2IfCItp0H/////AXE2AjAgAiAnIDJ+ICYgN358IDQgOyBAfiIvfH0gNSA5fnwgKEIUhnwgLkLNAn58ICpCxfrO7wF+fCAtQh2IfCItp0H/////AXE2AjQgAiAmIDV+ICcgOX58IDN9ICxCFIZ8ICpCzQJ+fCAtQh2IfCImp0H/////AXE2AjggAiApQhSGIDF8ICZCHYh8IianQf////8BcTYCPCACICtCFIYgRnwgJkIdiHwiJqdB/////wFxNgJAIAIgLkIUhiAwfCAmQh2IfCImp0H/////AXE2AkQgAiAqQhSGIC98ICZCHYh8IiZCHYg+AkwgAiAmp0H/////AXE2AkggAkEIaiACQSxqIgMQXiACIAI1AhgiJkKOkb78AH4gAigCDCIErSIoQtfu/KEBfiACKAIIIgatIidCga/LywF+fCACKAIQIgetIilCvf61rAF+fCACKAIUIgitIitCl7bQ8AF+fCAmQpK6/toAfnwiMn0gBiACKAIcIglqrSIuQoGvy8sBfnwgBCACKAIgIgZqrSIxQsT3kKIBfnwgByACKAIkIgRqrSIvQtuYl50DfnwgCCACKAIoIgdqrSIzQtTEi9gDfnwgBK0iNEKemuHwAX4gBq0iMELtiBR+fCAHrSI2Qr2Ou+cBfnwiOX0gKEKSuv7aAH4gJ0KXttDwAX58IjggJ0Lm2bGCAX5C/v///wGDIipC0rHMBH58ICdCkrr+2gB+Ii0gKkLtp9fnAX58Qh2IfCI1Qpv80ZIBfkL/////AYMiLEIUhnwgKULX7vyhAX4gKEKBr8vLAX58ICtCvf61rAF+fCAmQpe20PABfnwgCa0iN0KEqcBefnwiOiAtfSAuQo6RvvwAfnwgLELNAn58IChCl7bQ8AF+ICdCvf61rAF+fCApQpK6/toAfnwiOyAqQpbrnO8BfnwgLELSscwEfnwgLELtp9fnAX4gNXxCHYh8IjVCm/zRkgF+Qv////8BgyItQsX6zu8BfnwgKEK9/rWsAX4gJ0LX7vyhAX58IClCl7bQ8AF+fCArQpK6/toAfnwiPCAqQsX6zu8BfnwgLEKW65zvAX58IC1C0rHMBH58IC1C7afX5wF+IDV8Qh2IfCIoQpv80ZIBfkL/////AYMiJ0KW65zvAX58IDIgKkLNAn58ICxCxfrO7wF+fCAtQpbrnO8BfnwgJ0LSscwEfnwgJ0Ltp9fnAX4gKHxCHYh8IihCm/zRkgF+Qv////8BgyIsQtKxzAR+fCAsQu2n1+cBfiAofEIdiHwiMkKb/NGSAX5C/////wGDIihCzQJ+fCArQtfu/KEBfiApQoGvy8sBfnwgJkK9/rWsAX58IDdCw/HEmH5+fCAwQoSpwF5+fCI1IC5C1MSL2AN+IDh9IDFCjpG+/AB+fHwgLULNAn58ICdCxfrO7wF+fCAsQpbrnO8BfnwgKELSscwEfnwgKELtp9fnAX4gMnxCHYh8IjJCm/zRkgF+Qv////8BgyIpQsX6zu8BfnwgJkLX7vyhAX4gK0KBr8vLAX58IDdC4uWej35+fCAwQsPxxJh+fnwgNEKEqcBefnwiOCAuQtuYl50DfiA7fSAxQtTEi9gDfnwgL0KOkb78AH58fCAnQs0CfnwgLELF+s7vAX58IChCluuc7wF+fCApQtKxzAR+fCApQu2n1+cBfiAyfEIdiHwiMkKb/NGSAX5C/////wGDIitCluuc7wF+fCAqQhSGIDx9ICZCga/LywF+fCAuQsT3kKIBfnwgMULbmJedA358IC9C1MSL2AN+fCAzQo6RvvwAfnwgMEKemuHwAX4gN0LtiBR+fCA0Qr2Ou+cBfnwgNkL81r8hfnwiLn0gLELNAn58IChCxfrO7wF+fCApQpbrnO8BfnwgK0LSscwEfnwgK0Ltp9fnAX4gMnxCHYh8IjBCm/zRkgF+Qv////8BgyIqQtKxzAR+fCAqQu2n1+cBfiAwfEIdiHwiMKdB/////wFxNgIsIAIgJkLUxIvYA34gOn0gMUKBr8vLAX58IC9CxPeQogF+fCAzQtuYl50DfnwgNkKemuHwAX4gNELtiBR+fCIxfSAtQhSGfCApQs0CfnwgK0LF+s7vAX58ICpCluuc7wF+fCAwQh2IfCItp0H/////AXE2AjAgAiAmQtuYl50DfiAvQoGvy8sBfnwgNSA2Qu2IFH4iL3x9IDNCxPeQogF+fCAnQhSGfCArQs0CfnwgKkLF+s7vAX58IC1CHYh8IienQf////8BcTYCNCACICZCxPeQogF+IDh9IDNCga/LywF+fCAsQhSGfCAqQs0CfnwgJ0IdiHwiJqdB/////wFxNgI4IAIgKEIUhiAufCAmQh2IfCImp0H/////AXE2AjwgAiApQhSGIDl8ICZCHYh8IianQf////8BcTYCQCACICtCFIYgMXwgJkIdiHwiJqdB/////wFxNgJEIAIgKkIUhiAvfCAmQh2IfCImQh2IPgJMIAIgJqdB/////wFxNgJIIAVB2AZqIAMQXiACQdAAaiQAIAUoAvgGIQsgBSgC9AYhAyAFKALwBiEEIAUoAuwGIQYgBSgC6AYhAiAFKALkBiEHIAUoAuAGIQkgBSgC3AYhCCAFLwC9BCENIAUtAL8EIQwgBS0AvAQhECAFLQC6BCEXIAUtALsEIQ4gBS0AuAQhESAFLQC5BCEYIAUtALYEIRIgBS0AtwQhDyAFLQC0BCEZIAUtALUEIRogBS0AswQhEyAFLwCwBCEUIAUtALIEIRUgBS0ArwQhFiAFLwCsBCEfIAUtAK4EISAgBS0AqwQhISAFLwCoBCEcIAUtAKoEIR0gBS8ApAQhGyAFLQCmBCEiIAUtAKcEIR4gBSAFKALYBiIjQf////8BcSAFLQCjBEEYdCIkQYCAgPgBcSAFLwCgBCAFLQCiBEEQdHJyaiIlQf////8BcTYCgAUgBSAIQfj///8BcSAjIAhBHXRyQR12ciAlQR12aiAeQRh0Ih4gGyAiQRB0cnJBA3QgJEEddnJB/////wFxaiIbQf////8BcTYChAUgBSAJQT9xIAhBHXZyIAlBBnYiCEH//wNxIAggB0EXdCIJckGAgPwHcSIIckEGdHJB/////wFxIBtBHXZqIBwgHUEQdCIdckEGdCAeQRp2ckH/////AXFqIhxB/////wFxNgKIBSAFIAJBBHRB8AFxIAdBGXZyQRB0IhsgB0EJdkH//wNxckEJdCAJQYCAgHhxIAhyQRd2ckH/////AXEgHEEddmogHyAgQRB0IgdyQQl0ICFBGHQgHXJBF3ZyQf////8BcWoiCEH/////AXE2AowFIAUgBkEBdEH+AXEgAkEcdnJBEHQiCSACQQx2Qf//A3FyQQx0IAJBFHRBgICAeHEgG3JBFHZyQf////8BcSAIQR12aiAUIBVBEHQiAnJBDHQgFkEYdCAHckEUdnJB/////wFxaiIHQf////8BcTYCkAUgBSAEQQ50IgggBkEPdiIUckGA/gNxIhUgFEH/AXFyQQ90IAZBEXRBgICAeHEgCXJBEXZyQf////8BcSAHQR12aiAZIBpBCHQiBnJBD3QgE0EYdCACckERdnJB/////wFxaiICQf////8BcTYClAUgBSADQQN0QfgBcSAEQRp2ckEIdCIHIARBEnZB/wFxckESdCAIQYCAfHEgFXJBDnZyQf////8BcSACQR12aiARIBhBCHQiAnJBEnQgEkEQdCAPQRh0ciAGckEOdnJB/////wFxaiIEQf////8BcTYCmAUgBSADQYCAgP8BcSADQQt0QYCAfHEgB3JBC3ZyIARBHXZqIBBBFXQgF0EQdCAOQRh0ciACckELdnJqIgJB/////wFxNgKcBSAFIAtB////B3EgAkEddmogDSAMQRB0cmo2AqAFIAogARBeIAVBhgJqIgsgBUHCBGotAAA6AAAgBUHgBmoiDSAFQdMEaikAADcDACAFQeUGaiIMIAVB2ARqKQAANwAAIAUgBS8AwAQ7AYQCIAUgBSkAywQ3A9gGIAUoAvwGIQYgBSgCgAchASAFKAKEByEHIAUoAogHIQIgBSgCjAchAyAFKAKQByEIIAUoApQHIQQgBSgCmAchCSAFKAKcByEKIAUpAMMEISYgBUEAOgCIAiAFQQA6AIkCIAVBADoAigIgBUEAOgCLAiAFQQA6AIwCIAVBADoAjQIgBUEAOgCOAiAFQQA6AI8CIAVBADoAkAIgBUEAOgCRAiAFQQA6AJICIAVBADoAkwIgBUEAOgCUAiAFQQA6AJUCIAVBADoAlgIgBUEAOgCXAiAFQQA6AJgCIAVBADoAmQIgBUEAOgCaAiAFQQA6AJsCIAVBADoAnAIgBUEAOgCdAiAFQQA6AJ4CIAVBADoAnwIgBUEAOgCgAiAFQQA6AKECIAVBADoAogIgBUEAOgCjAiAFQQA6AKQCIAVBADoApQIgBUEAOgCmAiAFQQA6AKcCIAVBADoAqAIgBUEAOgCpAiAFQQA6AKoCIAVBADoAqwIgBUEAOgCsAiAFQQA6AK0CIAVBADoArgIgBUEAOgCvAiAFQQA6ALACIAVBADoAsQIgBUEAOgCyAiAFQQA6ALMCIAVBADoAtAIgBUEAOgC1AiAFQQA6ALYCIAVBADoAtwIgBUEAOgC4AiAFQQA6ALkCIAVBADoAugIgBUEAOgC7AiAFQQA6ALwCIAVBADoAvQIgBUEAOgC+AiAFQQA6AL8CIAVBADoAwAIgBUEAOgDBAiAFQQA6AMICIAVBADoAwwIgBUEAOgDEAiAFQQA6AMUCIAVBADoAxgIgBUEAOgDHAiAAQQNqIAstAAA6AAAgACAFLwGEAjsAASAAIAUpA9gGNwIMIABBFGogDSkDADcCACAAQRlqIAwpAAA3AAAgACAKQRB2OgBAIAAgCkEIdjoAPyAAIAo6AD4gACAJQRV2OgA9IAAgCUENdjoAPCAAIAlBBXY6ADsgACAJQQN0IARBGnZyOgA6IAAgBEESdjoAOSAAIARBCnY6ADggACAEQQJ2OgA3IAAgBEEGdCAIQRd2cjoANiAAIAhBD3Y6ADUgACAIQQd2OgA0IAAgCEEBdCADQRx2cjoAMyAAIANBFHY6ADIgACADQQx2OgAxIAAgA0EEdjoAMCAAIANBBHQgAkEZdnI6AC8gACACQRF2OgAuIAAgAkEJdjoALSAAIAJBAXY6ACwgACACQQd0IAdBFnZyOgArIAAgB0EOdjoAKiAAIAdBBnY6ACkgACAHQQJ0IAFBG3ZyOgAoIAAgAUETdjoAJyAAIAFBC3Y6ACYgACABQQN2OgAlIAAgAUEFdCAGQRh2cjoAJCAAIAZBEHY6ACMgACAGQQh2OgAiIAAgBjoAISAAICY3AgQgAEEAOgAAIAVBADoA5AEgBUEAOgDlASAFQQA6AOYBIAVBADoA5wEgBUEAOgDoASAFQQA6AOkBIAVBADoA6gEgBUEAOgDrASAFQQA6AOwBIAVBADoA7QEgBUEAOgDuASAFQQA6AO8BIAVBADoA8AEgBUEAOgDxASAFQQA6APIBIAVBADoA8wEgBUEAOgD0ASAFQQA6APUBIAVBADoA9gEgBUEAOgD3ASAFQQA6APgBIAVBADoA+QEgBUEAOgD6ASAFQQA6APsBIAVBADoA/AEgBUEAOgD9ASAFQQA6AP4BIAVBADoA/wEgBUEAOgCAAiAFQQA6AIECIAVBADoAggIgBUEAOgCDAgwBCyAAQQE6AAAgAEEANgIECyAFQaAHaiQAC4kbASB/IAAgACgCGCIdIAEoABAiJCAAKAIIamoiGyABKAAUIhVqIB0gGyACQf8BcXNBEHciAkHy5rvjA2oiHXNBFHciG2oiIiACc0EYdyIJIB1qIhwgG3NBGXciDyAAKAIUIhsgASgACCICIAAoAgRqaiIZIAEoAAwiHWogGSADQiCIp3NBEHciHkH7ouGkBGsiICAbc0EUdyIGaiIKIAEoACgiG2pqIiMgASgALCIZaiAPICMgACgCECIhIAEoAAAiDyAAKAIAamoiCCABKAAEIh9qICEgCCADp3NBEHciIUHnzKfQBmoiCHNBFHciB2oiDiAhc0EYdyINc0EQdyILIAAoAhwiBSABKAAYIiMgACgCDGpqIgwgASgAHCIhaiAFIAwgBEH/AXFzQRB3IgRBxpXA1QVrIgVzQRR3IgxqIhEgBHNBGHciECAFaiIFaiISc0EUdyIUaiITIB1qIAYgICAKIB5zQRh3IiBqIgZzQRl3IgogDiABKAAgIgRqaiIOIAEoACQiHmogCiAcIA4gEHNBEHciHGoiCnNBFHciDmoiECAcc0EYdyIWIApqIgogDnNBGXciHGoiDiAbaiAcIA4gBSAMc0EZdyIFICIgASgAMCIcamoiDCABKAA0IiJqIAwgIHNBEHciICAIIA1qIghqIg0gBXNBFHciBWoiDCAgc0EYdyIXc0EQdyIOIAcgCHNBGXciCCARIAEoADgiIGpqIgcgASgAPCIBaiAHIAlzQRB3IgkgBmoiBiAIc0EUdyIIaiIHIAlzQRh3IgkgBmoiBmoiEXNBFHciGGoiGiAcaiALIBNzQRh3IgsgEmoiEiAUc0EZdyIUIAwgIWpqIgwgD2ogCSAMc0EQdyIJIApqIgogFHNBFHciDGoiFCAJc0EYdyIJIApqIgogDHNBGXciDGoiEyAVaiAMIBMgBiAIc0EZdyIGIAIgEGpqIgggI2ogBiAIIAtzQRB3IgYgDSAXaiIIaiINc0EUdyILaiIMIAZzQRh3IgZzQRB3IhAgBSAIc0EZdyIIIAcgJGpqIgcgImogCCAHIBZzQRB3IgggEmoiB3NBFHciBWoiEiAIc0EYdyIIIAdqIgdqIhNzQRR3IhZqIhcgG2ogDiAac0EYdyIOIBFqIhEgGHNBGXciGCAMIB9qaiIMIBlqIAogCCAMc0EQdyIKaiIIIBhzQRR3IgxqIhggCnNBGHciCiAIaiIIIAxzQRl3IgxqIhogHGogDCAaIAUgB3NBGXciByAUIB5qaiIFICBqIAcgBSAOc0EQdyIHIAYgDWoiBmoiDnNBFHciDWoiBSAHc0EYdyIHc0EQdyIMIAYgC3NBGXciBiABIBJqaiILIARqIAYgCSALc0EQdyIJIBFqIgZzQRR3IgtqIhEgCXNBGHciCSAGaiIGaiISc0EUdyIUaiIaIB5qIBAgF3NBGHciECATaiITIBZzQRl3IhYgBSAiamoiBSACaiAFIAlzQRB3IgkgCGoiCCAWc0EUdyIFaiIWIAlzQRh3IgkgCGoiCCAFc0EZdyIFaiIXIA9qIAUgFyAGIAtzQRl3IgYgGCAdamoiCyAkaiAGIAsgEHNBEHciBiAHIA5qIgdqIg5zQRR3IgtqIgUgBnNBGHciBnNBEHciECAHIA1zQRl3IgcgESAhamoiDSAgaiAHIAogDXNBEHciCiATaiIHc0EUdyINaiIRIApzQRh3IgogB2oiB2oiE3NBFHciF2oiGCAcaiAMIBpzQRh3IgwgEmoiEiAUc0EZdyIUIAUgI2pqIgUgFWogBSAKc0EQdyIKIAhqIgggFHNBFHciBWoiFCAKc0EYdyIKIAhqIgggBXNBGXciBWoiGiAeaiAFIBogByANc0EZdyIHIBYgGWpqIg0gAWogByAMIA1zQRB3IgcgBiAOaiIGaiIOc0EUdyINaiIFIAdzQRh3IgdzQRB3IgwgBiALc0EZdyIGIAQgEWpqIgsgH2ogBiAJIAtzQRB3IgkgEmoiBnNBFHciC2oiESAJc0EYdyIJIAZqIgZqIhJzQRR3IhZqIhogGWogECAYc0EYdyIQIBNqIhMgF3NBGXciFyAFICBqaiIFIB1qIAUgCXNBEHciCSAIaiIIIBdzQRR3IgVqIhcgCXNBGHciCSAIaiIIIAVzQRl3IgVqIhggAmogBSAYIAYgC3NBGXciBiAUIBtqaiILICFqIAYgCyAQc0EQdyIGIAcgDmoiB2oiDnNBFHciC2oiBSAGc0EYdyIGc0EQdyIQIAcgDXNBGXciByARICJqaiINIAFqIAcgCiANc0EQdyIKIBNqIgdzQRR3Ig1qIhEgCnNBGHciCiAHaiIHaiIUc0EUdyITaiIYIB5qIAwgGnNBGHciDCASaiISIBZzQRl3IhYgBSAkamoiBSAPaiAFIApzQRB3IgogCGoiCCAWc0EUdyIFaiIWIApzQRh3IgogCGoiCCAFc0EZdyIFaiIaIBlqIAUgGiAHIA1zQRl3IgcgFSAXamoiDSAEaiAHIAwgDXNBEHciByAGIA5qIgZqIg5zQRR3Ig1qIgUgB3NBGHciB3NBEHciDCAGIAtzQRl3IgYgESAfamoiCyAjaiAGIAkgC3NBEHciCSASaiIGc0EUdyILaiIRIAlzQRh3IgkgBmoiBmoiEnNBFHciF2oiGiAVaiAQIBhzQRh3IhAgFGoiFCATc0EZdyITIAEgBWpqIgUgG2ogBSAJc0EQdyIJIAhqIgggE3NBFHciBWoiEyAJc0EYdyIJIAhqIgggBXNBGXciBWoiGCAdaiAFIBggBiALc0EZdyIGIBYgHGpqIgsgImogBiALIBBzQRB3IgYgByAOaiIHaiIOc0EUdyILaiIFIAZzQRh3IgZzQRB3IhAgByANc0EZdyIHIBEgIGpqIg0gBGogByAKIA1zQRB3IgogFGoiB3NBFHciDWoiESAKc0EYdyIKIAdqIgdqIhRzQRR3IhZqIhggGWogDCAac0EYdyIMIBJqIhIgF3NBGXciFyAFICFqaiIFIAJqIAUgCnNBEHciCiAIaiIIIBdzQRR3IgVqIhcgCnNBGHciCiAIaiIIIAVzQRl3IgVqIhogFWogBSAaIAcgDXNBGXciByAPIBNqaiINIB9qIAcgDCANc0EQdyIHIAYgDmoiBmoiDnNBFHciDWoiBSAHc0EYdyIHc0EQdyIMIAYgC3NBGXciBiARICNqaiILICRqIAYgCSALc0EQdyIJIBJqIgZzQRR3IgtqIhEgCXNBGHciCSAGaiIGaiISc0EUdyITaiIaIA9qIBAgGHNBGHciECAUaiIUIBZzQRl3IhYgBCAFamoiBSAcaiAFIAlzQRB3IgkgCGoiCCAWc0EUdyIFaiIWIAlzQRh3IgkgCGoiCCAFc0EZdyIFaiIYIBtqIAUgGCAGIAtzQRl3IgYgFyAeamoiCyAgaiAGIAsgEHNBEHciBiAHIA5qIgdqIg5zQRR3IgtqIgUgBnNBGHciBnNBEHciECAHIA1zQRl3IgcgASARamoiDSAfaiAHIAogDXNBEHciCiAUaiIHc0EUdyINaiIRIApzQRh3IgogB2oiB2oiFHNBFHciF2oiGCAVaiAMIBpzQRh3IhUgEmoiDCATc0EZdyISIAUgImpqIgUgHWogBSAKc0EQdyIKIAhqIgggEnNBFHciBWoiEiAKc0EYdyIKIAhqIgggBXNBGXciBWoiEyAPaiAFIBMgByANc0EZdyIPIAIgFmpqIgcgI2ogDyAHIBVzQRB3IhUgBiAOaiIPaiIGc0EUdyIHaiIOIBVzQRh3IhVzQRB3Ig0gCyAPc0EZdyIPIBEgJGpqIgsgIWogDyAJIAtzQRB3Ig8gDGoiCXNBFHciC2oiBSAPc0EYdyIPIAlqIglqIgxzQRR3IhFqIhMgAmogHiAQIBhzQRh3IgIgFGoiHiAXc0EZdyIQIA4gH2pqIh9qIA8gH3NBEHciDyAIaiIfIBBzQRR3IghqIg4gD3NBGHciDyAfaiIfIAhzQRl3IghqIhAgHGogECABIAkgC3NBGXciASASIBlqaiIZaiABIAIgGXNBEHciASAGIBVqIgJqIhVzQRR3IhlqIhwgAXNBGHciAXNBEHciCSACIAdzQRl3IgIgBCAFamoiBCAjaiACIAQgCnNBEHciAiAeaiIEc0EUdyIjaiIeIAJzQRh3IgIgBGoiBGoiBiAIc0EUdyIKaiIIIAlzQRh3IgkgBmoiBiABIBVqIgEgGXNBGXciFSAeICFqaiIZICJqIBUgDyAZc0EQdyIVIA0gE3NBGHciGSAMaiIPaiIhc0EUdyIeaiIiczYCDCAAIBsgDyARc0EZdyIPIBwgIGpqIhxqIAIgHHNBEHciAiAfaiIbIA9zQRR3Ig9qIh8gAnNBGHciAiAbaiIbICQgBCAjc0EZdyIEIA4gHWpqIh1qIAQgASAZIB1zQRB3IgFqIgRzQRR3IiRqIh1zNgIIIAAgFSAic0EYdyIVICFqIhkgCHM2AgQgACABIB1zQRh3IgEgBGoiBCAfczYCACAAIAQgJHNBGXcgAnM2AhwgACAGIApzQRl3IBVzNgIYIAAgDyAbc0EZdyABczYCFCAAIBkgHnNBGXcgCXM2AhAL7SICCH8BfgJAAkACQAJAAkACQAJAAkAgAEH1AU8EQCAAQc3/e08NBSAAQQtqIgBBeHEhBUGkgMMAKAIAIghFDQRBACAFayEDAn9BACAFQYACSQ0AGkEfIAVB////B0sNABogBUEGIABBCHZnIgBrdkEBcSAAQQF0a0E+agsiB0ECdEGI/cIAaigCACIBRQRAQQAhAAwCC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQQDQAJAIAEoAgRBeHEiBiAFSQ0AIAYgBWsiBiADTw0AIAEhAiAGIgMNAEEAIQMgASEADAQLIAEoAhQiBiAAIAYgASAEQR12QQRxakEQaigCACIBRxsgACAGGyEAIARBAXQhBCABDQALDAELQaCAwwAoAgAiBEEQIABBC2pB+ANxIABBC0kbIgVBA3YiAHYiAUEDcQRAAkAgAUF/c0EBcSAAaiIBQQN0IgBBmP7CAGoiAiAAQaD+wgBqKAIAIgAoAggiA0cEQCADIAI2AgwgAiADNgIIDAELQaCAwwAgBEF+IAF3cTYCAAsgACABQQN0IgFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMCAsgBUGogMMAKAIATQ0DAkACQCABRQRAQaSAwwAoAgAiAEUNBiAAaEECdEGI/cIAaigCACICKAIEQXhxIAVrIQMgAiEBA0ACQCACKAIQIgANACACKAIUIgANACABKAIYIQcCQAJAIAEgASgCDCIARgRAIAFBFEEQIAEoAhQiABtqKAIAIgINAUEAIQAMAgsgASgCCCICIAA2AgwgACACNgIIDAELIAFBFGogAUEQaiAAGyEEA0AgBCEGIAIiAEEUaiAAQRBqIAAoAhQiAhshBCAAQRRBECACG2ooAgAiAg0ACyAGQQA2AgALIAdFDQQgASABKAIcQQJ0QYj9wgBqIgIoAgBHBEAgB0EQQRQgBygCECABRhtqIAA2AgAgAEUNBQwECyACIAA2AgAgAA0DQaSAwwBBpIDDACgCAEF+IAEoAhx3cTYCAAwECyAAKAIEQXhxIAVrIgIgAyACIANJIgIbIQMgACABIAIbIQEgACECDAALAAsCQEECIAB0IgJBACACa3IgASAAdHFoIgBBA3QiAkGY/sIAaiIBIAJBoP7CAGooAgAiAigCCCIDRwRAIAMgATYCDCABIAM2AggMAQtBoIDDACAEQX4gAHdxNgIACyACIAVBA3I2AgQgAiAFaiIGIABBA3QiACAFayIDQQFyNgIEIAAgAmogAzYCAEGogMMAKAIAIgEEQCABQXhxQZj+wgBqIQBBsIDDACgCACEEAn9BoIDDACgCACIFQQEgAUEDdnQiAXFFBEBBoIDDACABIAVyNgIAIAAMAQsgACgCCAshASAAIAQ2AgggASAENgIMIAQgADYCDCAEIAE2AggLQbCAwwAgBjYCAEGogMMAIAM2AgAgAkEIag8LIAAgBzYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABKAIUIgJFDQAgACACNgIUIAIgADYCGAsCQAJAIANBEE8EQCABIAVBA3I2AgQgASAFaiIFIANBAXI2AgQgAyAFaiADNgIAQaiAwwAoAgAiBEUNASAEQXhxQZj+wgBqIQBBsIDDACgCACECAn9BoIDDACgCACIGQQEgBEEDdnQiBHFFBEBBoIDDACAEIAZyNgIAIAAMAQsgACgCCAshBCAAIAI2AgggBCACNgIMIAIgADYCDCACIAQ2AggMAQsgASADIAVqIgBBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQMAQtBsIDDACAFNgIAQaiAwwAgAzYCAAsgAUEIag8LIAAgAnJFBEBBACECQQIgB3QiAEEAIABrciAIcSIARQ0DIABoQQJ0QYj9wgBqKAIAIQALIABFDQELA0AgACACIAAoAgRBeHEiBCAFayIGIANJIgcbIQggACgCECIBRQRAIAAoAhQhAQsgAiAIIAQgBUkiABshAiADIAYgAyAHGyAAGyEDIAEiAA0ACwsgAkUNACAFQaiAwwAoAgAiAE0gAyAAIAVrT3ENACACKAIYIQcCQAJAIAIgAigCDCIARgRAIAJBFEEQIAIoAhQiABtqKAIAIgENAUEAIQAMAgsgAigCCCIBIAA2AgwgACABNgIIDAELIAJBFGogAkEQaiAAGyEEA0AgBCEGIAEiAEEUaiAAQRBqIAAoAhQiARshBCAAQRRBECABG2ooAgAiAQ0ACyAGQQA2AgALIAdFDQMgAiACKAIcQQJ0QYj9wgBqIgEoAgBHBEAgB0EQQRQgBygCECACRhtqIAA2AgAgAEUNBAwDCyABIAA2AgAgAA0CQaSAwwBBpIDDACgCAEF+IAIoAhx3cTYCAAwDCwJAAkACQAJAAkAgBUGogMMAKAIAIgFLBEAgBUGsgMMAKAIAIgBPBEBBACEDIAVBr4AEaiIAQRB2QAAiAUF/RiICDQcgAUEQdCIBRQ0HQbiAwwBBACAAQYCAfHEgAhsiA0G4gMMAKAIAaiIANgIAQbyAwwBBvIDDACgCACICIAAgACACSRs2AgACQAJAQbSAwwAoAgAiBARAQYj+wgAhAANAIAAoAgAiAiAAKAIEIgZqIAFGDQIgACgCCCIADQALDAILQcSAwwAoAgAiAEEAIAAgAU0bRQRAQcSAwwAgATYCAAtByIDDAEH/HzYCAEGM/sIAIAM2AgBBiP7CACABNgIAQaT+wgBBmP7CADYCAEGs/sIAQaD+wgA2AgBBoP7CAEGY/sIANgIAQbT+wgBBqP7CADYCAEGo/sIAQaD+wgA2AgBBvP7CAEGw/sIANgIAQbD+wgBBqP7CADYCAEHE/sIAQbj+wgA2AgBBuP7CAEGw/sIANgIAQcz+wgBBwP7CADYCAEHA/sIAQbj+wgA2AgBB1P7CAEHI/sIANgIAQcj+wgBBwP7CADYCAEHc/sIAQdD+wgA2AgBB0P7CAEHI/sIANgIAQZT+wgBBADYCAEHk/sIAQdj+wgA2AgBB2P7CAEHQ/sIANgIAQeD+wgBB2P7CADYCAEHs/sIAQeD+wgA2AgBB6P7CAEHg/sIANgIAQfT+wgBB6P7CADYCAEHw/sIAQej+wgA2AgBB/P7CAEHw/sIANgIAQfj+wgBB8P7CADYCAEGE/8IAQfj+wgA2AgBBgP/CAEH4/sIANgIAQYz/wgBBgP/CADYCAEGI/8IAQYD/wgA2AgBBlP/CAEGI/8IANgIAQZD/wgBBiP/CADYCAEGc/8IAQZD/wgA2AgBBmP/CAEGQ/8IANgIAQaT/wgBBmP/CADYCAEGs/8IAQaD/wgA2AgBBoP/CAEGY/8IANgIAQbT/wgBBqP/CADYCAEGo/8IAQaD/wgA2AgBBvP/CAEGw/8IANgIAQbD/wgBBqP/CADYCAEHE/8IAQbj/wgA2AgBBuP/CAEGw/8IANgIAQcz/wgBBwP/CADYCAEHA/8IAQbj/wgA2AgBB1P/CAEHI/8IANgIAQcj/wgBBwP/CADYCAEHc/8IAQdD/wgA2AgBB0P/CAEHI/8IANgIAQeT/wgBB2P/CADYCAEHY/8IAQdD/wgA2AgBB7P/CAEHg/8IANgIAQeD/wgBB2P/CADYCAEH0/8IAQej/wgA2AgBB6P/CAEHg/8IANgIAQfz/wgBB8P/CADYCAEHw/8IAQej/wgA2AgBBhIDDAEH4/8IANgIAQfj/wgBB8P/CADYCAEGMgMMAQYCAwwA2AgBBgIDDAEH4/8IANgIAQZSAwwBBiIDDADYCAEGIgMMAQYCAwwA2AgBBnIDDAEGQgMMANgIAQZCAwwBBiIDDADYCAEG0gMMAIAE2AgBBmIDDAEGQgMMANgIAQayAwwAgA0EoayIANgIAIAEgAEEBcjYCBCAAIAFqQSg2AgRBwIDDAEGAgIABNgIADAgLIAEgBE0gAiAES3INACAAKAIMRQ0DC0HEgMMAQcSAwwAoAgAiACABIAAgAUkbNgIAIAEgA2ohAkGI/sIAIQACQAJAA0AgAiAAKAIARwRAIAAoAggiAA0BDAILCyAAKAIMRQ0BC0GI/sIAIQADQAJAIAQgACgCACICTwRAIAIgACgCBGoiBiAESw0BCyAAKAIIIQAMAQsLQbSAwwAgATYCAEGsgMMAIANBKGsiADYCACABIABBAXI2AgQgACABakEoNgIEQcCAwwBBgICAATYCACAEIAZBIGtBeHFBCGsiACAAIARBEGpJGyICQRs2AgRBiP7CACkCACEJIAJBEGpBkP7CACkCADcCACACIAk3AghBjP7CACADNgIAQYj+wgAgATYCAEGQ/sIAIAJBCGo2AgBBlP7CAEEANgIAIAJBHGohAANAIABBBzYCACAAQQRqIgAgBkkNAAsgAiAERg0HIAIgAigCBEF+cTYCBCAEIAIgBGsiAEEBcjYCBCACIAA2AgAgAEGAAk8EQCAEIAAQfQwICyAAQXhxQZj+wgBqIQECf0GggMMAKAIAIgJBASAAQQN2dCIAcUUEQEGggMMAIAAgAnI2AgAgAQwBCyABKAIICyEAIAEgBDYCCCAAIAQ2AgwgBCABNgIMIAQgADYCCAwHCyAAIAE2AgAgACAAKAIEIANqNgIEIAEgBUEDcjYCBCACIAEgBWoiBGshBSACQbSAwwAoAgBGDQMgAkGwgMMAKAIARg0EIAIoAgQiA0EDcUEBRgRAIAIgA0F4cSIAEG4gACAFaiEFIAAgAmoiAigCBCEDCyACIANBfnE2AgQgBCAFQQFyNgIEIAQgBWogBTYCACAFQYACTwRAIAQgBRB9DAYLIAVBeHFBmP7CAGohAAJ/QaCAwwAoAgAiAkEBIAVBA3Z0IgNxRQRAQaCAwwAgAiADcjYCACAADAELIAAoAggLIQUgACAENgIIIAUgBDYCDCAEIAA2AgwgBCAFNgIIDAULQayAwwAgACAFayIBNgIAQbSAwwBBtIDDACgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqIQMMBgtBsIDDACgCACEAAkAgASAFayICQQ9NBEBBsIDDAEEANgIAQaiAwwBBADYCACAAIAFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMAQtBqIDDACACNgIAQbCAwwAgACAFaiIENgIAIAQgAkEBcjYCBCAAIAFqIAI2AgAgACAFQQNyNgIECwwICyAAIAMgBmo2AgRBtIDDAEG0gMMAKAIAIgBBD2pBeHEiAUEIayICNgIAQayAwwBBrIDDACgCACADaiIEIAAgAWtqQQhqIgE2AgAgAiABQQFyNgIEIAAgBGpBKDYCBEHAgMMAQYCAgAE2AgAMAwtBtIDDACAENgIAQayAwwBBrIDDACgCACAFaiIANgIAIAQgAEEBcjYCBAwBC0GwgMMAIAQ2AgBBqIDDAEGogMMAKAIAIAVqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAsgAUEIag8LQQAhA0GsgMMAKAIAIgAgBU0NAEGsgMMAIAAgBWsiATYCAEG0gMMAQbSAwwAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQMAwsgAw8LIAAgBzYCGCACKAIQIgEEQCAAIAE2AhAgASAANgIYCyACKAIUIgFFDQAgACABNgIUIAEgADYCGAsCQCADQRBPBEAgAiAFQQNyNgIEIAIgBWoiASADQQFyNgIEIAEgA2ogAzYCACADQYACTwRAIAEgAxB9DAILIANBeHFBmP7CAGohAAJ/QaCAwwAoAgAiBEEBIANBA3Z0IgNxRQRAQaCAwwAgAyAEcjYCACAADAELIAAoAggLIQMgACABNgIIIAMgATYCDCABIAA2AgwgASADNgIIDAELIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqDwsgAEEIagvNFwInfwF+IwBB4AJrIgYkAAJAAkACQAJAAkAgAkEgRgRAIAYgAS8AADsBCCAGIAEtAAc6AA8gBiABKAADNgALIAYgAUECai0AADoACiABKAAYIQ0gASgAHCEQIAEoABQhAiABKAAIIQogASgADCEIIAEoABAhASAGIANBAmotAAA6ABIgBiADLwAAOwEQIAYgAy0ABzoAFyAGIAMoAAM2ABMgAy8AFCADQRZqLQAAQRB0ciEdIAMtABchDyADKAAIIRYgAygADCEaIAMoABAhIEGy2ojLByERQe7IgZkDIRdB5fDBiwYhGEH0yoHZBiETQQohCyAGKAIMIQcgBigCCCEDIAYoAhQhGSAGKAIQIRQDQCADIBdqQQd3IBpzIgkgF2pBCXcgDXMiDCACIBhqQQd3IAhzIgggGGpBCXcgFnMiFSAIakENdyACcyISIAEgE2pBB3cgCnMiCiATakEJdyAZcyIOIApqQQ13IAFzIhYgDmpBEncgE3MiEyARIBRqQQd3IBBzIgFqQQd3cyICIBNqQQl3cyINIAJqQQ13IAFzIhAgDWpBEncgE3MhEyABIAEgEWpBCXcgB3MiB2pBDXcgFHMiFCAHakESdyARcyIRIAlqQQd3IBZzIgEgEWpBCXcgFXMiFiABakENdyAJcyIaIBZqQRJ3IBFzIREgDCAJIAxqQQ13IANzIglqQRJ3IBdzIgMgCGpBB3cgFHMiFCADakEJdyAOcyIZIBRqQQ13IAhzIgggGWpBEncgA3MhFyAJIAogEiAVakESdyAYcyIJakEHd3MiAyAJakEJdyAHcyIHIANqQQ13IApzIgogB2pBEncgCXMhGCALQQFrIgsNAAsgBkH0yoHZBjYCWCAGIBo2AlQgBiAWNgJQIAYgGTYCTCAGIBQ2AkggBkGy2ojLBzYCRCAGQgA3AjwgBiAgNgI0IAZB7siBmQM2AjAgBiATNgIsIAYgETYCKCAGIBc2AiQgBiAYNgIgIAYgD0EYdCAdciIdNgI4IAZB3ABqQcEAEN4BGiAGQeXwwYsGNgIcAkAgBUUEQEEBIQIMAQsgBUEASA0CQdGAwwAtAAAaIAUQJyICRQ0DCyACIAQgBRDfASEkIAVBP3EhIyAFQcAATwRAIAVBBnYhJUEAIQRBACESA0BBCiEbQeXwwYsGIQIgGSEBIBMhDEHuyIGZAyEDIBghCiAWIRBBstqIywchDyAgIQggGiEVIBchC0H0yoHZBiENIBQhByARIQ4gHSEJA0AgAyAKakEHdyAEcyIcIANqQQl3IBBzIh4gASACakEHdyAMcyIMIAJqQQl3IBJzIh8gDGpBDXcgAXMiIiAHIA1qQQd3IA5zIg4gDWpBCXcgCXMiCSAOakENdyAHcyISIAlqQRJ3IA1zIgcgCCAPakEHdyAVcyIEakEHd3MiASAHakEJd3MiECABakENdyAEcyIVIBBqQRJ3IAdzIQ0gBCAEIA9qQQl3IAtzIgtqQQ13IAhzIiYgC2pBEncgD3MiCCAcakEHdyAScyIHIAhqQQl3IB9zIhIgB2pBDXcgHHMiBCASakESdyAIcyEPIB4gHCAeakENdyAKcyIKakESdyADcyIDIAxqQQd3ICZzIgggA2pBCXcgCXMiCSAIakENdyAMcyIMIAlqQRJ3IANzIQMgDiAfICJqQRJ3IAJzIgJqQQd3IApzIgogAmpBCXcgC3MiCyAKakENdyAOcyIOIAtqQRJ3IAJzIQIgG0EBayIbDQALIAYgDUH0yoHZBmo2AtwBIAYgFSAaajYC2AEgBiAQIBZqNgLUASAGIAEgGWo2AtABIAYgByAUajYCzAEgBiAPQbLaiMsHajYCyAEgBiAGKAJAIARqNgLEASAGIAYoAjwgEmo2AsABIAYgCSAdajYCvAEgBiAIICBqNgK4ASAGIANB7siBmQNqNgK0ASAGIAwgE2o2ArABIAYgDiARajYCrAEgBiALIBdqNgKoASAGIAogGGo2AqQBIAYgAkHl8MGLBmo2AqABIAYgBikCPEIBfCItNwI8IAZB2AJqIgNCADcDACAGQdACaiIHQgA3AwAgBkHIAmoiCkIANwMAIAZBwAJqIghCADcDACAGQbgCaiIQQgA3AwAgBkGwAmoiC0IANwMAIAZBqAJqIglCADcDACAGQZgCaiAkICFBBnRqIgFBOGoiDCkAADcDACAGQZACaiABQTBqIhUpAAA3AwAgBkGIAmogAUEoaiIOKQAANwMAIAZBgAJqIAFBIGoiDSkAADcDACAGQfgBaiABQRhqIg8pAAA3AwAgBkHwAWogAUEQaiIbKQAANwMAIAZB6AFqIAFBCGoiHCkAADcDACAGQgA3A6ACIAYgASkAADcD4AEgLachEiAtQiCIpyEEQQAhAgNAIAZBoAJqIAJqIh4gBkGgAWogAmoiHy0AACAGQeABaiACaiIiLQAAczoAACAeQQFqIB9BAWotAAAgIkEBai0AAHM6AAAgAkECaiICQcAARw0ACyABIAYpA6ACNwAAIAwgAykDADcAACAVIAcpAwA3AAAgDiAKKQMANwAAIA0gCCkDADcAACAPIBApAwA3AAAgGyALKQMANwAAIBwgCSkDADcAACAlICFBAWoiIUcNAAsLICNFDQQgJCAFQUBxaiETQQohGyAGKAIcIhkhAiAGKAJMIhohASAGKAIsIiAhDCAGKAI8Ih0hEiAGKAIwIiEhAyAGKAIgIhwhCiAGKAJAIh4hBCAGKAJQIh8hECAGKAJEIiUhDyAGKAI0IiIhCCAGKAJUIiYhFSAGKAIkIichCyAGKAJYIighDSAGKAJIIikhByAGKAIoIiohDiAGKAI4IishCQNAIAMgCmpBB3cgBHMiESADakEJdyAQcyIUIAEgAmpBB3cgDHMiFyACakEJdyAScyIWIBdqQQ13IAFzIiwgByANakEHdyAOcyIYIA1qQQl3IAlzIgkgGGpBDXcgB3MiDCAJakESdyANcyIHIAggD2pBB3cgFXMiBGpBB3dzIgEgB2pBCXdzIhAgAWpBDXcgBHMiFSAQakESdyAHcyENIAwgBCAEIA9qQQl3IAtzIgtqQQ13IAhzIgwgC2pBEncgD3MiCCARakEHd3MiByAIakEJdyAWcyISIAdqQQ13IBFzIgQgEmpBEncgCHMhDyAUIBEgFGpBDXcgCnMiCmpBEncgA3MiAyAXakEHdyAMcyIIIANqQQl3IAlzIgkgCGpBDXcgF3MiDCAJakESdyADcyEDIBggFiAsakESdyACcyICakEHdyAKcyIKIAJqQQl3IAtzIgsgCmpBDXcgGHMiDiALakESdyACcyECIBtBAWsiGw0ACyAGIA0gKGo2ApgBIAYgFSAmajYClAEgBiAQIB9qNgKQASAGIAEgGmo2AowBIAYgByApajYCiAEgBiAPICVqNgKEASAGIAQgHmo2AoABIAYgEiAdajYCfCAGIAkgK2o2AnggBiAIICJqNgJ0IAYgAyAhajYCcCAGIAwgIGo2AmwgBiAOICpqNgJoIAYgCyAnajYCZCAGIAogHGo2AmAgBiACIBlqNgJcIAYgBikCPEIBfCItPgI8IAYgLUIgiD4CQCAFQQFxIQFBACECICNBAUYNAyAjIAFrIQQDQCACIBNqIgMgBkEcaiACaiIHQUBrLQAAIAMtAABzOgAAIANBAWoiAyAHQcEAai0AACADLQAAczoAACAEIAJBAmoiAkcNAAsMAwsgAEEANgIADAQLEKcBAAsACyABRQ0AIAIgE2oiASAGQdwAaiACai0AACABLQAAczoAAAsgACAFNgIIIAAgJDYCBCAAQQo2AgAgBiAjOgCcASAGQdwAahBpIAZBADoAnAEgBkEANgIcIAZBADYCICAGQQA2AiQgBkEANgIoIAZBADYCLCAGQQA2AjAgBkEANgI0IAZBADYCOCAGQQA2AjwgBkEANgJAIAZBADYCRCAGQQA2AkggBkEANgJMIAZBADYCUCAGQQA2AlQgBkEANgJYCyAGQeACaiQAC/EYAhB/A34jAEHAEWsiCSQAAkACQAJAAkAgBEEOSQ0AQcGLwAAgA0EOENwBDQAgCUGHisAANgIwIAkgBEEOazYCLCAJIANBDmo2AiggCUGAEGoiDiAJQShqIg8QRCAJKAKAECISQYCAgIB4Rg0AIAkoAoQQIRACQAJAIAZBCEkNACAJKAKIECEKQc+LwAAgBUEIENwBDQAgCUGHisAANgIwIAkgBkEIazYCLCAJIAVBCGo2AiggDiAPEEQgCSgCgBAiFEGAgICAeEYNACAJKAKIECETIAkoAoQQIREgCUG4EGpCADcDACAJQbAQakIANwMAIAlBqBBqQgA3AwAgCUGgEGpCADcDACAJQZgQakIANwMAIAlBkBBqIgtCADcDACAJQYgQaiIWQgA3AwAgCUHIEGpBzIzAACkCACIZNwMAIAlB0BBqQdSMwAApAgAiGjcDACAJQdgQakHcjMAAKQIAIhs3AwAgCUEwaiIXIBk3AwAgCUE4aiIVIBo3AwAgCUFAayIYIBs3AwAgCUIANwOAECAJQcSMwAApAgAiGTcDwBAgCSAZNwMoIAlByABqIA5B4AAQ3wEaIAlBrwFqQQA2AAAgCUIANwOoASAJQQA2AsABIAlCADcDuAEgDiAPIAcgCBAtEDVB0YDDAC0AABpBGBAnIg1FDQEgDSAJKQCAEDcAACANQRBqIAspAAA3AAAgDUEIaiAWKQAANwAAAkACQAJAAkACQAJAIApBIEcgE0EgR3JFBEAgECgAAyELIAlBghBqIBFBAmotAAA6AAAgCUGfEGogEUEfai0AADoAACAJQY8QaiARQQ9qKQAANwAAIAkgES8AADsBgBAgCSARKQAXNwCXECAJIBEpAAc3AIcQIBEoAAMhCiAJQYoRaiAQQQJqLQAAOgAAIBBBD2opAAAhGSAQKQAHIRogEC8AACEMIAlBpxFqIBBBH2otAAA6AAAgCUGXEWogGTcAACAJIAw7AYgRIAkgCzYAixEgCSAQKQAXNwCfESAJIBo3AI8RIAkgCjYAgxAgDyAJQYgRaiILIA4QJCAJQQZqIgogCUEqai0AADoAACAJQRBqIgwgCUE3aikAADcDACAJQRhqIg4gCUE/aikAADcDACAJQSBqIhMgCUHHAGotAAA6AAAgCSAJLwAoOwEEIAkgCSkALzcDCCAJKAArIRYgCxCMASAPEIwBIBggEy0AACILOgAAIBUgDikDADcDACAXIAwpAwAiGTcDACAJIAkpAwgiGjcDKCAJQbsPaiAZNwAAIAlByw9qIAs6AAAgCSAaNwCzDyAJIBUpAwA3AMMPIAlBCmogDUECai0AADoAACAJQRdqIA1BD2opAAA3AAAgCSANLwAAOwEIIAkgDSkABzcADyANKAADIQsgDS0AFyEMIAlBrg9qIAotAAA6AAAgCSAJLwEEOwGsDyAJIAw6AB8gCSALNgALIAkgFjYArw8CQAJAIAJBEGoiCkUEQCAJQQA2AtQPIAlCgICAgBA3AswPDAELIApBAEgNA0EAIQtB0YDDAC0AABogChAnIgxFDQogCUEANgLUDyAJIAw2AtAPIAkgCjYCzA8gAkFwSQ0BCyAJQcwPakEAIAIQjQEgCSgC0A8hDCAJKALUDyELCyALIAxqIAEgAhDfARogCSACIAtqIg42AtQPIAlBMGpCADcDACAJQgA3AyggCUHMD2oiCygCACALKAIIIgxrQQ9NBEAjAEEgayIKJAAgDCAMQRBqIg9LBEBBAEEAEMUBAAtBASEMQQggCygCACIVQQF0IhMgDyAPIBNJGyIPIA9BCE0bIg9Bf3NBH3YhEwJAIBVFBEBBACEMDAELIAogFTYCHCAKIAsoAgQ2AhQLIAogDDYCGCAKQQhqIBMgDyAKQRRqEJABIAooAggEQCAKKAIMIAooAhAQxQEACyAKKAIMIQwgCyAPNgIAIAsgDDYCBCAKQSBqJAAgCygCCCEMCyALIAxBEGo2AgggCygCBCAMaiILIAlBKGoiCikAADcAACALQQhqIApBCGopAAA3AAAgCSgC1A8iCyAOSQ0CIAsgDmtBD00NAyAJKALQDyIMQRBqIAwgDhDdASEMIAtBD00NBCAKIAlBrA9qIAlBCGoQMyAJQYAQaiIOIApBhAEQ3wEaIAlBuBFqIAlB3AFqKQIANwMAIAlBsBFqIAlB1AFqKQIANwMAIAlBqBFqIAlBzAFqKQIANwMAIAlBoBFqIAlBxAFqKQIANwMAIAlBmBFqIAlBvAFqKQIANwMAIAlBkBFqIAlBtAFqKQIANwMAIAkgCSkCrAE3A4gRIA4gDCALQRBrIgsQKiAJQfAPaiIKIAlBiBFqIAwgCxBfIAlBADoA7w8gCUHAEGoQaSAJQQA6AIARIAlBADYCgBAgCUEANgKEECAJQQA2AogQIAlBADYCjBAgCUEANgKQECAJQQA2ApQQIAlBADYCmBAgCUEANgKcECAJQQA2AqAQIAlBADYCpBAgCUEANgKoECAJQQA2AqwQIAlBADYCsBAgCUEANgK0ECAJQQA2ArgQIAlBADYCvBACQCAJLQDvD0UEQCAJQeAPaiAKQQhqKQAANwMAIAkgCikAADcD2A8gCSgC1A8iCkEPSw0BQRAgCkHAh8AAEJgBAAsgCSgCzA8iCkUNBiAJKALQDyAKEJwBDAYLIAkoAtAPIgogCSkD2A83AAAgCkEIaiAJQeAPaikDADcAACAJKALMDyIOQYCAgIB4Rg0FIAkpAtAPIhmnIQpBCiEMQQEhDyAOIBlCIIinIgtNDQYgC0UEQCAKIA4QnAFBASEKQQAhCwwHCyAKIA5BASALEEoiCkUNCAwGCyANQRgQnAEgFEUNBiARIBQQnAEMBgsQpwEACyAOIAtBoIfAABCYAQALIAlBADYCOCAJQQE2AiwgCUGghcAANgIoIAlCBDcCMCAJQShqQaCHwAAQpgEAC0EQIAtBsIfAABCXAQALQQYhDEEAIQ8LIAlBADoArA8gCUEAOgCtDyAJQQA6AK4PIAlBADoArw8gCUEAOgCwDyAJQQA6ALEPIAlBADoAsg8gCUEAOgCzDyAJQQA6ALQPIAlBADoAtQ8gCUEAOgC2DyAJQQA6ALcPIAlBADoAuA8gCUEAOgC5DyAJQQA6ALoPIAlBADoAuw8gCUEAOgC8DyAJQQA6AL0PIAlBADoAvg8gCUEAOgC/DyAJQQA6AMAPIAlBADoAwQ8gCUEAOgDCDyAJQQA6AMMPIAlBADoAxA8gCUEAOgDFDyAJQQA6AMYPIAlBADoAxw8gCUEAOgDIDyAJQQA6AMkPIAlBADoAyg8gCUEAOgDLDyAPBEAgDUEYEJwBIBQEQCARIBQQnAELIBJFDQQgECASEJwBDAQLIA1BGBCcASAUBEAgESAUEJwBCyASRQ0CIBAgEhCcAQwCCyASRQ0BAkAgEEEEaygCACIKQXhxIgtBBEEIIApBA3EiChsgEmpPBEAgCkEAIAsgEkEnaksbDQEgEBBFDAMLDAQLDAQLAAsgCSALNgIwIAkgCjYCLCAJIAw2AiggCUGAEGogCUEoahBJIAkoAoQQIgogCSgCiBAQACELIAkoAoAQIg0EQCAKQQRrKAIAIgxBeHEiEEEEQQggDEEDcSIMGyANakkNAiAMQQAgECANQSdqSxsNAyAKEEULAkAgCSgCKCIKQQhNQQBBASAKdEHPA3EbDQAgCSgCLCIKRQ0AIAkoAjAiDUEEaygCACIMQXhxIhBBBEEIIAxBA3EiDBsgCmpJDQIgDEEAIBAgCkEnaksbDQMgDRBFC0EAIQoLIAgEQCAHQQRrKAIAIg1BeHEiDEEEQQggDUEDcSINGyAIakkNASANQQAgDCAIQSdqSxsNAiAHEEULIAYEQCAFQQRrKAIAIgdBeHEiCEEEQQggB0EDcSIHGyAGakkNASAHQQAgCCAGQSdqSxsNAiAFEEULIAQEQCADQQRrKAIAIgVBeHEiBkEEQQggBUEDcSIFGyAEakkNASAFQQAgBiAEQSdqSxsNAiADEEULIAIEQCABQQRrKAIAIgNBeHEiBEEEQQggA0EDcSIDGyACakkNASADQQAgBCACQSdqSxsNAiABEEULIAACfyAKRQRAQQAhCkEAIQZBAQwBCyALIQZBACELQQALNgIMIAAgCzYCCCAAIAY2AgQgACAKNgIAIAlBwBFqJAAPC0Gt9cIAQS5B3PXCABCjAQALQez1wgBBLkGc9sIAEKMBAAvJFQIsfwF+IwBB0AFrIgUkACAAKAIgIRkgAC0AgAEhCwJAAkACQAJAAkAgACgCJCIaQX9GBEAgAiEDIAsEQCADQcAAIAtrQf8BcSIGTQ0CIAMgBmshAwsgA0EGdiADQT9xQQBHaiAZQX9zSw0CCyALRQ0DC0HAACALayIXIAJLBEACQCACRQ0AIAJBA3EhByACQQRPBEAgACALaiEKIAJBfHEhAwNAIAEgBGoiDCAEIApqIhZBQGstAAAgDC0AAHM6AAAgDEEBaiIGIBZBwQBqLQAAIAYtAABzOgAAIAxBAmoiBiAWQcIAai0AACAGLQAAczoAACAMQQNqIgYgFkHDAGotAAAgBi0AAHM6AAAgAyAEQQRqIgRHDQALCyAHRQ0AIAEgBGohAyAEIAtqIABqQUBrIQQDQCADIAQtAAAgAy0AAHM6AAAgA0EBaiEDIARBAWohBCAHQQFrIgcNAAsLIAIgC2ohIwwECyAXQQNxIQcgC0E9a0EDSQ0BIAAgC2ohCiAXQXxxIQMDQCABIARqIgwgBCAKaiIWQUBrLQAAIAwtAABzOgAAIAxBAWoiBiAWQcEAai0AACAGLQAAczoAACAMQQJqIgYgFkHCAGotAAAgBi0AAHM6AAAgDEEDaiIGIBZBwwBqLQAAIAYtAABzOgAAIAMgBEEEaiIERw0ACwwBC0GkksAAQSsgBUHPAWpBkIbAAEH8hsAAEJQBAAsgBwRAIAEgBGohAyAEIAtqIABqQUBrIQQDQCADIAQtAAAgAy0AAHM6AAAgA0EBaiEDIARBAWohBCAHQQFrIgcNAAsLIAIgF2shAiABIBdqIQELIAJBP3EhIyACQcAATwRAIAJBBnYhGCAAKAI8ISQgACgCOCElIAAoAjQhJiAAKAIwIScgACgCLCEoIAAoAighKSAAKAIcISogACgCGCErIAAoAhQhLCAAKAIQIQsgACgCDCEXIAAoAgghDCAAKAIEIRYgACgCACEKA0BBCiENIAohAyAnIQQgCyEJICwhESAWIQcgJiEGICkhEiArIRMgJSEcIAwhDiAkIRQgKCEVIBchCCAqIQ8DQCAHIBFqQQd3IBpzIh0gEWpBCXcgBnMiECADIARqQQd3IAlzIh8gA2pBCXcgGXMiICAfakENdyAEcyIeIBQgFWpBB3cgCHMiISAUakEJdyAPcyIPICFqQQ13IBVzIhogD2pBEncgFHMiCCASIBNqQQd3IBxzIglqQQd3cyIEIAhqQQl3cyIGIARqQQ13IAlzIhwgBmpBEncgCHMhFCAJIAkgEmpBCXcgDnMiImpBDXcgE3MiCCAiakESdyAScyIJIB1qQQd3IBpzIhUgCWpBCXcgIHMiGSAVakENdyAdcyIaIBlqQRJ3IAlzIRIgCCAQIBAgHWpBDXcgB3MiCGpBEncgEXMiDiAfakEHd3MiEyAOakEJdyAPcyIPIBNqQQ13IB9zIgkgD2pBEncgDnMhESAhIB4gIGpBEncgA3MiA2pBB3cgCHMiByADakEJdyAicyIOIAdqQQ13ICFzIgggDmpBEncgA3MhAyANQQFrIg0NAAsgACgCICEeIAAoAiQhDSAAIAApAiBCAXwiLzcCICAFIBQgJGo2AkQgBSAcICVqNgJAIAUgBiAmajYCPCAFIAQgJ2o2AjggBSAVIChqNgI0IAUgEiApajYCMCAFIA8gKmo2AiQgBSATICtqNgIgIAUgESAsajYCHCAFIAkgC2o2AhggBSAIIBdqNgIUIAUgDCAOajYCECAFIAcgFmo2AgwgBSADIApqNgIIIAUgDSAaajYCLCAFIBkgHmo2AiggBUHAAWoiIEIANwMAIAVBuAFqIiJCADcDACAFQbABaiIeQgA3AwAgBUGoAWoiBEIANwMAIAVBoAFqIgdCADcDACAFQZgBaiIRQgA3AwAgBUGQAWoiEkIANwMAIAVBgAFqIAEgG0EGdGoiEEE4aiITKQAANwMAIAVB+ABqIBBBMGoiFCkAADcDACAFQfAAaiAQQShqIhUpAAA3AwAgBUHoAGogEEEgaiIOKQAANwMAIAVB4ABqIBBBGGoiDykAADcDACAFQdgAaiAQQRBqIgkpAAA3AwAgBUHQAGogEEEIaiIIKQAANwMAIAVCADcDiAEgBSAQKQAANwNIIC+nIRkgL0IgiKchGkFAIQMDQCAFQYgBaiADaiINQUBrIAVBCGogA2oiHEFAay0AACAFQcgAaiADaiIGQUBrLQAAczoAACANQcEAaiAcQcEAai0AACAGQcEAai0AAHM6AAAgA0ECaiIDDQALIBAgBSkDiAE3AAAgEyAgKQMANwAAIBQgIikDADcAACAVIB4pAwA3AAAgDiAEKQMANwAAIA8gBykDADcAACAJIBEpAwA3AAAgCCASKQMANwAAIBggG0EBaiIbRw0ACwsgI0UNACABIAJBQHEiIGohIkEKIR8gACgCACIeIQMgACgCMCIcIQQgACgCECIkIQkgGSEGIAAoAhQiJSERIAAoAgQiJiEHIBohDSAAKAI0IichDiAAKAIoIighEiAAKAIYIikhEyAAKAI4IiohLSAAKAIIIishGCAAKAI8IiwhFCAAKAIsIgshFSAAKAIMIhchCCAAKAIcIgwhDwNAIAcgEWpBB3cgDXMiLiARakEJdyAOcyIhIAMgBGpBB3cgCXMiGyADakEJdyAGcyIQIBtqQQ13IARzIhYgFCAVakEHdyAIcyIdIBRqQQl3IA9zIgkgHWpBDXcgFXMiBiAJakESdyAUcyIKIBIgE2pBB3cgLXMiDWpBB3dzIgQgCmpBCXdzIg4gBGpBDXcgDXMiLSAOakESdyAKcyEUIA0gDSASakEJdyAYcyIYakENdyATcyIKIBhqQRJ3IBJzIgggLmpBB3cgBnMiFSAIakEJdyAQcyIGIBVqQQ13IC5zIg0gBmpBEncgCHMhEiAKICEgISAuakENdyAHcyIKakESdyARcyIIIBtqQQd3cyITIAhqQQl3IAlzIg8gE2pBDXcgG3MiCSAPakESdyAIcyERIB0gECAWakESdyADcyIDakEHdyAKcyIHIANqQQl3IBhzIhggB2pBDXcgHXMiCCAYakESdyADcyEDIB9BAWsiHw0ACyAAIBQgLGo2AnwgACAqIC1qNgJ4IAAgDiAnajYCdCAAIAQgHGo2AnAgACALIBVqNgJsIAAgEiAoajYCaCAAIA0gGmo2AmQgACAGIBlqNgJgIAAgDCAPajYCXCAAIBMgKWo2AlggACARICVqNgJUIAAgCSAkajYCUCAAIAggF2o2AkwgACAYICtqNgJIIAAgByAmajYCRCAAIAMgHmo2AkAgACAAKQIgQgF8Ii8+AiAgACAvQiCIPgIkIAJBA3EhB0EAIQQgI0EETwRAICMgB2shBgNAIAQgImoiCiAAIARqIgNBQGstAAAgCi0AAHM6AAAgCkEBaiICIANBwQBqLQAAIAItAABzOgAAIApBAmoiAiADQcIAai0AACACLQAAczoAACAKQQNqIgIgA0HDAGotAAAgAi0AAHM6AAAgBiAEQQRqIgRHDQALCyAHRQ0AIAEgBCAgamohAyAAIARqQUBrIQQDQCADIAQtAAAgAy0AAHM6AAAgA0EBaiEDIARBAWohBCAHQQFrIgcNAAsLIAAgIzoAgAEgBUHQAWokAAuiFgIbfwN+IwBBkBFrIgkkAAJAAkACQAJAIARBDkkNAEHBi8AAIANBDhDcAQ0AIAlBh4rAADYCOCAJIARBDms2AjQgCSADQQ5qNgIwIAlB0A9qIhAgCUEwaiITEEQgCSgC0A8iEkGAgICAeEYNACAJKALUDyEMAkACQCAGQQhJDQAgCSgC2A8hCkHPi8AAIAVBCBDcAQ0AIAlBh4rAADYCOCAJIAZBCGs2AjQgCSAFQQhqNgIwIBAgExBEIAkoAtAPIhRBgICAgHhGDQAgCSgC2A8hDyAJKALUDyEOIAlBiBBqQgA3AwAgCUGAEGpCADcDACAJQfgPakIANwMAIAlB8A9qQgA3AwAgCUHoD2pCADcDACAJQeAPaiILQgA3AwAgCUHYD2oiFkIANwMAIAlBmBBqQcyMwAApAgAiJDcDACAJQaAQakHUjMAAKQIAIiU3AwAgCUGoEGpB3IzAACkCACImNwMAIAlBOGoiFyAkNwMAIAlBQGsiFSAlNwMAIAlByABqIhggJjcDACAJQgA3A9APIAlBxIzAACkCACIkNwOQECAJICQ3AzAgCUHQAGogEEHgABDfARogCUG3AWpBADYAACAJQgA3A7ABIAlBADYCyAEgCUIANwPAASAQIBMgByAIEC0QNUHRgMMALQAAGkEYECciDUUNASANIAkpANAPNwAAIA1BEGogCykAADcAACANQQhqIBYpAAA3AAACQAJAIApBIEcgD0EgR3JFBEAgDCgAAyELIAlB0g9qIA5BAmotAAA6AAAgCUHvD2ogDkEfai0AADoAACAJQd8PaiAOQQ9qKQAANwAAIAkgDi8AADsB0A8gCSAOKQAXNwDnDyAJIA4pAAc3ANcPIA4oAAMhCiAJQdoQaiAMQQJqLQAAOgAAIAxBD2opAAAhJCAMKQAHISUgDC8AACERIAlB9xBqIAxBH2otAAA6AAAgCUHnEGogJDcAACAJIBE7AdgQIAkgCzYA2xAgCSAMKQAXNwDvECAJICU3AN8QIAkgCjYA0w8gEyAJQdgQaiIWIBAQJCAJQQ5qIgogCUEyai0AADoAACAJQRhqIgsgCUE/aikAADcDACAJQSBqIhEgCUHHAGopAAA3AwAgCUEoaiIPIAlBzwBqLQAAOgAAIAkgCS8AMDsBDCAJIAkpADc3AxAgCSgAMyEQIBYQjAEgExCMASAYIA8tAAAiDzoAACAVIBEpAwA3AwAgFyALKQMAIiQ3AwAgCSAJKQMQIiU3AzAgCUG/D2ogJDcAACAJQc8PaiAPOgAAIAkgJTcAtw8gCSAVKQMANwDHDyAJQRJqIA1BAmotAAA6AAAgCUEfaiANQQ9qKQAANwAAIAkgDS8AADsBECAJIA0pAAc3ABcgDSgAAyELIA0tABchESAJQbIPaiAKLQAAOgAAIAkgCS8BDDsBsA8gCSAROgAnIAkgCzYAEyAJIBA2ALMPAkAgAkUEQEEGIRFBACEPDAELIAJBAEgNA0EAIQ9B0YDDAC0AABogAhAnIgtFDQUgCyABIAIQ3wEhCkEGIRECQAJAIAJBEEkNACAKLQAPIQ8gCi0ADiEVIAotAA0hEyAKLQAMIRYgCi0ACyEXIAotAAohGCAKLQAJIRkgCi0ACCEaIAotAAchGyAKLQAGIRwgCi0ABSEdIAotAAQhHiAKLQADIR8gCi0AAiEgIAotAAEhISAKLQAAIAlBMGoiCyAJQbAPaiAJQRBqEDMgCUHQD2oiIyALQYQBEN8BGiAJQYgRaiAJQeQBaikCADcDACAJQYARaiAJQdwBaikCADcDACAJQfgQaiAJQdQBaikCADcDACAJQfAQaiAJQcwBaikCADcDACAJQegQaiAJQcQBaikCADcDACAJQeAQaiAJQbwBaikCADcDACAJIAkpArQBNwPYECALIAlB2BBqIApBEGoiECACQRBrIgsQXyAJLQAwRhC/ASAhIAktADFGEL8BcSAgIAktADJGEL8BcSAfIAktADNGEL8BcSAeIAktADRGEL8BcSAdIAktADVGEL8BcSAcIAktADZGEL8BcSAbIAktADdGEL8BcSAaIAktADhGEL8BcSAZIAktADlGEL8BcSAYIAktADpGEL8BcSAXIAktADtGEL8BcSAWIAktADxGEL8BcSATIAktAD1GEL8BcSAVIAktAD5GEL8BcSAPIAktAD9GEL8BcUEBcRC/AUH/AXEiFQRAICMgECALECoLIAlBkBBqEGlBACEPIAlBADoA0BAgCUEANgLQDyAJQQA2AtQPIAlBADYC2A8gCUEANgLcDyAJQQA2AuAPIAlBADYC5A8gCUEANgLoDyAJQQA2AuwPIAlBADYC8A8gCUEANgL0DyAJQQA2AvgPIAlBADYC/A8gCUEANgKAECAJQQA2AoQQIAlBADYCiBAgCUEANgKMECAVRQ0AIAogECALEN0BIRBBCiERQQEhDyALDQELIAogAhCcAUEAIQtBASEKDAELIBAgAkEBIAsQSiIKRQ0FCyAJQQA6ALAPIAlBADoAsQ8gCUEAOgCyDyAJQQA6ALMPIAlBADoAtA8gCUEAOgC1DyAJQQA6ALYPIAlBADoAtw8gCUEAOgC4DyAJQQA6ALkPIAlBADoAug8gCUEAOgC7DyAJQQA6ALwPIAlBADoAvQ8gCUEAOgC+DyAJQQA6AL8PIAlBADoAwA8gCUEAOgDBDyAJQQA6AMIPIAlBADoAww8gCUEAOgDEDyAJQQA6AMUPIAlBADoAxg8gCUEAOgDHDyAJQQA6AMgPIAlBADoAyQ8gCUEAOgDKDyAJQQA6AMsPIAlBADoAzA8gCUEAOgDNDyAJQQA6AM4PIAlBADoAzw8gD0UNASANQRgQnAEgFARAIA4gFBCcAQsgEkUNBiAMIBIQnAEMBgsgDUEYEJwBIBRFDQIgDiAUEJwBDAILIA1BGBCcASAUBEAgDiAUEJwBCyASRQ0DIAwgEhCcAQwDCxCnAQALIBJFDQECQCAMQQRrKAIAIgpBeHEiC0EEQQggCkEDcSIKGyASak8EQCAKQQAgCyASQSdqSxsNASAMEEUMAwsMBAsMBAsACyAJIAs2AjggCSAKNgI0IAkgETYCMCAJQdAPaiAJQTBqEEkgCSgC1A8iCiAJKALYDxAAIQsgCSgC0A8iDQRAIApBBGsoAgAiDEF4cSIOQQRBCCAMQQNxIgwbIA1qSQ0CIAxBACAOIA1BJ2pLGw0DIAoQRQsCQCAJKAIwIgpBCE1BAEEBIAp0Qc8DcRsNACAJKAI0IgpFDQAgCSgCOCINQQRrKAIAIgxBeHEiDkEEQQggDEEDcSIMGyAKakkNAiAMQQAgDiAKQSdqSxsNAyANEEULQQAhCgsgCARAIAdBBGsoAgAiDUF4cSIMQQRBCCANQQNxIg0bIAhqSQ0BIA1BACAMIAhBJ2pLGw0CIAcQRQsgBgRAIAVBBGsoAgAiB0F4cSIIQQRBCCAHQQNxIgcbIAZqSQ0BIAdBACAIIAZBJ2pLGw0CIAUQRQsgBARAIANBBGsoAgAiBUF4cSIGQQRBCCAFQQNxIgUbIARqSQ0BIAVBACAGIARBJ2pLGw0CIAMQRQsgAgRAIAFBBGsoAgAiA0F4cSIEQQRBCCADQQNxIgMbIAJqSQ0BIANBACAEIAJBJ2pLGw0CIAEQRQsgAAJ/IApFBEBBACEKQQAhBkEBDAELIAshBkEAIQtBAAs2AgwgACALNgIIIAAgBjYCBCAAIAo2AgAgCUGQEWokAA8LQa31wgBBLkHc9cIAEKMBAAtB7PXCAEEuQZz2wgAQowEAC6YVAhB/BX4jAEHgAmsiAiQAIAFB0ABqIgggAS0A0AEiA2oiBUGAAToAACABKQNAIhJCAoZCgICA+A+DIBJCDohCgID8B4OEIBJCHohCgP4DgyASQgqGIhNCOIiEhCEVIAOtIhRCO4YgEyAUQgOGhCITQoD+A4NCKIaEIBNCgID8B4NCGIYgE0KAgID4D4NCCIaEhCABQcgAaikDACITQgKGQoCAgPgPgyATQg6IQoCA/AeDhCATQh6IQoD+A4MgE0IKhiITQjiIhIQhFiASQjaIIhJCOIYgEiAThCISQoD+A4NCKIaEIBJCgID8B4NCGIYgEkKAgID4D4NCCIaEhCETAkAgA0H/AHMiBkUNACAFQQFqIgVFDQAgBSAGEN4BGgsgFYQhEiATIBaEIRMCQCADQfAAc0EQTwRAIAEgEzcDwAEgAUHIAWogEjcDACABIAhBARAjDAELIAEgCEEBECMgAkHIAGoiA0HwABDeARogAkHAAWogEjcAACACIBM3ALgBIAEgA0EBECMLQQAhAyABQQA6ANABIAIgASkDOCISQjiGIBJCgP4Dg0IohoQgEkKAgPwHg0IYhiASQoCAgPgPg0IIhoSEIBJCCIhCgICA+A+DIBJCGIhCgID8B4OEIBJCKIhCgP4DgyASQjiIhISENwNAIAIgASkDMCISQjiGIBJCgP4Dg0IohoQgEkKAgPwHg0IYhiASQoCAgPgPg0IIhoSEIBJCCIhCgICA+A+DIBJCGIhCgID8B4OEIBJCKIhCgP4DgyASQjiIhISENwM4IAIgASkDKCISQjiGIBJCgP4Dg0IohoQgEkKAgPwHg0IYhiASQoCAgPgPg0IIhoSEIBJCCIhCgICA+A+DIBJCGIhCgID8B4OEIBJCKIhCgP4DgyASQjiIhISENwMwIAIgASkDICISQjiGIBJCgP4Dg0IohoQgEkKAgPwHg0IYhiASQoCAgPgPg0IIhoSEIBJCCIhCgICA+A+DIBJCGIhCgID8B4OEIBJCKIhCgP4DgyASQjiIhISENwMoIAIgASkDGCISQjiGIBJCgP4Dg0IohoQgEkKAgPwHg0IYhiASQoCAgPgPg0IIhoSEIBJCCIhCgICA+A+DIBJCGIhCgID8B4OEIBJCKIhCgP4DgyASQjiIhISENwMgIAIgASkDECISQjiGIBJCgP4Dg0IohoQgEkKAgPwHg0IYhiASQoCAgPgPg0IIhoSEIBJCCIhCgICA+A+DIBJCGIhCgID8B4OEIBJCKIhCgP4DgyASQjiIhISENwMYIAIgASkDCCISQjiGIBJCgP4Dg0IohoQgEkKAgPwHg0IYhiASQoCAgPgPg0IIhoSEIBJCCIhCgICA+A+DIBJCGIhCgID8B4OEIBJCKIhCgP4DgyASQjiIhISENwMQIAIgASkDACISQjiGIBJCgP4Dg0IohoQgEkKAgPwHg0IYhiASQoCAgPgPg0IIhoSEIBJCCIhCgICA+A+DIBJCGIhCgID8B4OEIBJCKIhCgP4DgyASQjiIhISENwMIIAJBgAFqQgA3AwAgAkH4AGpCADcDACACQfAAakIANwMAIAJB6ABqQgA3AwAgAkHgAGpCADcDACACQdgAakIANwMAIAJB0ABqQgA3AwAgAkIANwNIA0AgAkHIAGogA2oiASABKAIAIAJBCGogA2oiAS0AAHIgAUEBai0AAEEIdHIgAUECai0AAEEQdHIgAUEDai0AAEEYdHI2AgAgA0EEaiIDQcAARw0ACyACQfgBaiIBIAIoAlAiBkEGdCACKAJMIgRBGnZyQf////8BcTYCACACQYACaiIDIAIoAlgiC0EMdCACKAJUIgxBFHZyQf////8BcTYCACACQYgCaiIIIAIoAmAiCUESdCACKAJcIg1BDnZyQf////8BcTYCACACQZACaiIFIAIoAmgiDkEYdCACKAJkIgpBCHZyQf////8BcTYCACACIAIoAkgiB0H/////AXE2AvABIAIgBEEDdCAHQR12ckH/////AXE2AvQBIAIgDEEJdCAGQRd2ckH/////AXE2AvwBIAIgDUEPdCALQRF2ckH/////AXE2AoQCIAIgCkEVdCAJQQt2ckH/////AXE2AowCIAJBuAJqIgYgAigChAEiCUENdjYCACACQaACaiINIAIoAnAiCkEBdCACKAJsIgRBH3ZyQf////8BcTYCACACQagCaiILIAIoAngiB0EHdCACKAJ0Ig9BGXZyQf////8BcTYCACACQbACaiIMIAIoAoABIhBBDXQgAigCfCIRQRN2ckH/////AXE2AgAgAiAEQQJ2Qf////8BcTYCnAIgAiAEQRt0IA5BBXZyQf////8BcTYCmAIgAiAPQQR0IApBHHZyQf////8BcTYCpAIgAiARQQp0IAdBFnZyQf////8BcTYCrAIgAiAJQRB0IBBBEHZyQf////8BcTYCtAIgAkG8AmoiByACQfABakHwuMAAEDogBSACQdwCaiIEKAIANgIAIAggAkHUAmoiCSkCADcDACADIAJBzAJqIg4pAgA3AwAgASACQcQCaiIKKQIANwMAIAIgAikCvAI3A/ABIAcgAkGYAmpB1PnAABA6IAYgBCgCADYCACAMIAkpAgA3AwAgCyAOKQIANwMAIA0gCikCACISNwMAIAIgAikCvAIiEzcDmAIgAiACKALwASATp2oiBEH/////AXE2ArwCIAIgAigC9AEgAigCnAIgBEEddmpqIgRB/////wFxNgLAAiACIAEoAgAgEqcgBEEddmpqIgFB/////wFxNgLEAiACIAIoAvwBIAIoAqQCIAFBHXZqaiIBQf////8BcTYCyAIgAiADKAIAIAsoAgAgAUEddmpqIgFB/////wFxNgLMAiACIAIoAoQCIAIoAqwCIAFBHXZqaiIBQf////8BcTYC0AIgAiAIKAIAIAwoAgAgAUEddmpqIgFB/////wFxNgLUAiACIAIoAowCIAIoArQCIAFBHXZqaiIBQf////8BcTYC2AIgAiAFKAIAIAYoAgAgAUEddmpqQf////8BcTYC3AIgAkHMAWogBxBeIAAgAigC7AEiAUEQdjoAHyAAIAFBCHY6AB4gACABOgAdIAAgAigC6AEiAUEVdjoAHCAAIAFBDXY6ABsgACABQQV2OgAaIAAgAUEDdCACKALkASIBQRp2cjoAGSAAIAFBEnY6ABggACABQQp2OgAXIAAgAUECdjoAFiAAIAFBBnQgAigC4AEiAUEXdnI6ABUgACABQQ92OgAUIAAgAUEHdjoAEyAAIAFBAXQgAigC3AEiAUEcdnI6ABIgACABQRR2OgARIAAgAUEMdjoAECAAIAFBBHY6AA8gACABQQR0IAIoAtgBIgFBGXZyOgAOIAAgAUERdjoADSAAIAFBCXY6AAwgACABQQF2OgALIAAgAUEHdCACKALUASIBQRZ2cjoACiAAIAFBDnY6AAkgACABQQZ2OgAIIAAgAUECdCACKALQASIBQRt2cjoAByAAIAFBE3Y6AAYgACABQQt2OgAFIAAgAUEDdjoABCAAIAFBBXQgAigCzAEiAUEYdnI6AAMgACABQRB2OgACIAAgAUEIdjoAASAAIAE6AAAgAkHgAmokAAv8FAIYfwN+IwBBkAJrIgMkAAJAIAApA5ABIhtC/////////x+DIhxQBEAgAC0AiAEhBSAALQCJASEEDAELIAApA4ABIR0gA0KACCAceoYiHDcDACACrSAbIB19QgqGIBx8IAAtAIgBIgWtQv8BgyAALQCJASIErUL/AYNCBoZ8fVgNACADIBtCCoY3A/ABIANBBDYCFCADQeSVwAA2AhAgA0IDNwIcIAMgA0EMaq1CgICAgBCENwOQASADQoCAgICwASIbIAOthDcDiAEgAyAbIANB8AFqrYQ3A4ABIAMgAjYCDCADIANBgAFqNgIYIANBEGpBhJbAABCmAQALIABBIGohEwJAAkACQAJAAkACQAJAAkACQCAEQf8BcUEGdCAFaiIFRQ0AIBMgAUGACCAFayIFIAIgAiAFSxsiBBBnIQUgAiAEayICRQ0BIANByAFqIg8gAEHoAGoiCCkDADcDACADQdABaiIQIABB8ABqIgspAwA3AwAgA0HYAWoiESAAQfgAaiIMKQMANwMAIANBiAFqIhIgBUEIaikDADcDACADQZABaiIUIAVBEGopAwA3AwAgA0GYAWoiFSAFQRhqKQMANwMAIANBoAFqIhYgBUEgaikDADcDACADQagBaiIXIAVBKGopAwA3AwAgA0GwAWoiGCAFQTBqKQMANwMAIANBuAFqIhkgBUE4aikDADcDACADIAApA2A3A8ABIAMgBSkDADcDgAEgAC0AigEhDSAALQCJASEGIAMgAC0AiAEiCToA6AEgAyAAKQOAASIbNwPgASADIA0gBkVyQQJyIg06AOkBIANBKGoiBiAMKQIANwMAIANBIGoiDCALKQIANwMAIANBGGoiByAIKQIANwMAIAMgACkCYDcDECADQRBqIANBgAFqIhogCSAbIA0QJiAGKAIAIQggDCgCACELIAcoAgAhDCADKAIsIQ0gAygCJCEGIAMoAhwhCSADKAIUIQcgAygCECEKIAAgGxBLIAAoApgBIg5BN0kEQCABIARqIQEgACAOQQV0aiIEQbgBaiANNgIAIARBtAFqIAg2AgAgBEGwAWogBjYCACAEQawBaiALNgIAIARBqAFqIAk2AgAgBEGkAWogDDYCACAEQaABaiAHNgIAIARBnAFqIAo2AgAgACAOQQFqNgKYASASQgA3AwAgFEIANwMAIBVCADcDACAWQgA3AwAgF0IANwMAIBhCADcDACAZQgA3AwAgDyAAQQhqKQMANwMAIBAgAEEQaikDADcDACARIABBGGopAwA3AwAgA0IANwOAASADIAApAwA3A8ABIAApA4ABIRsgBSAaQeAAEN8BGiAAQQA7AYgBIAAgG0IBfDcDgAEMAQsgAyANNgKcASADIAg2ApgBIAMgBjYClAEgAyALNgKQASADIAk2AowBIAMgDDYCiAEgAyAHNgKEASADIAo2AoABDAgLIAJBgQhPBEAgAEGcAWohDSAAKQOAASEbIANB0ABqIQwgA0HAAWohCyADQTBqIQgDQCAbQgqGIRxBfyACQQF2Z3ZBAWohBANAIAQiBUEBdiEEIBwgBUEBa62DQgBSDQALIAVBCnatIRwCQCAFQYEITwRAIAIgBUkNBSAALQCKASEEIANBuAFqIgZCADcDACADQbABaiIJQgA3AwAgA0GoAWoiB0IANwMAIANBoAFqIgpCADcDACADQZgBaiIOQgA3AwAgA0GQAWoiD0IANwMAIANBiAFqIhBCADcDACADQgA3A4ABIAEgBSAAIBsgBCADQYABakHAABAxQQNGDQYgA0HIAGogBikDADcDACADQUBrIAkpAwA3AwAgA0E4aiAHKQMANwMAIAggCikDADcDACADQShqIgkgDikDADcDACADQSBqIgcgDykDADcDACADQRhqIgogECkDADcDACADIAMpA4ABNwMQIAAgACkDgAEQSyAAKAKYASIGQTdPDQcgDSAGQQV0aiIEQRhqIAkpAwA3AAAgBCADKQMQNwAAIARBEGogBykDADcAACAEQQhqIAopAwA3AAAgACAGQQFqNgKYASAAIAApA4ABIBxCAYh8EEsgACgCmAEiBkE3Tw0IIA0gBkEFdGoiBEEYaiAIQRhqKQAANwAAIAQgCCkAADcAACAEQRBqIAhBEGopAAA3AAAgBEEIaiAIQQhqKQAANwAAIAAgBkEBajYCmAEMAQsgA0GIAWpCADcDACADQZABakIANwMAIANBmAFqQgA3AwAgA0GgAWpCADcDACADQagBakIANwMAIANBsAFqQgA3AwAgA0G4AWpCADcDACALIAApAwA3AwAgC0EIaiIGIABBCGopAwA3AwAgC0EQaiIJIABBEGopAwA3AwAgC0EYaiIHIABBGGopAwA3AwAgA0IANwOAASADQQA7AegBIAMgGzcD4AEgAyAALQCKAToA6gEgA0GAAWogASAFEGchBCAMIAspAwA3AwAgDEEIaiAGKQMANwMAIAxBEGogCSkDADcDACAMQRhqIAcpAwA3AwAgA0EYaiAEQQhqKQMANwMAIANBIGogBEEQaikDADcDACADQShqIARBGGopAwA3AwAgCCAEQSBqKQMANwMAIANBOGogBEEoaikDADcDACADQUBrIARBMGopAwA3AwAgA0HIAGogBEE4aikDADcDACADIAQpAwA3AxAgAy0A6gEhBCADLQDpASEKIAMgAy0A6AEiDjoAeCADIAMpA+ABIhs3A3AgAyAEIApFckECciIEOgB5IANBiAJqIgogBykCADcDACADQYACaiIHIAkpAgA3AwAgA0H4AWoiDyAGKQIANwMAIAMgCykCADcD8AEgA0HwAWogA0EQaiAOIBsgBBAmIAooAgAhBiAHKAIAIQkgDygCACEHIAMoAowCIQogAygChAIhDiADKAL8ASEPIAMoAvQBIRAgAygC8AEhESAAIAApA4ABEEsgACgCmAEiEkE3Tw0IIA0gEkEFdGoiBCAKNgIcIAQgBjYCGCAEIA42AhQgBCAJNgIQIAQgDzYCDCAEIAc2AgggBCAQNgIEIAQgETYCACAAIBJBAWo2ApgBCyAAIAApA4ABIBx8Ihs3A4ABIAIgBUkNCCABIAVqIQEgAiAFayICQYAISw0ACwsgAkUNACATIAEgAhBnGiAAIAApA4ABEEsLIANBkAJqJAAgAA8LIAUgAkGUlsAAEJgBAAtB4ABBwABB7JTAABCYAQALIANBmAFqIANBKGopAwA3AwAgA0GQAWogA0EgaikDADcDACADQYgBaiADQRhqKQMANwMAIAMgAykDEDcDgAEMAwsgA0GYAWogCEEYaikAADcDACADQZABaiAIQRBqKQAANwMAIANBiAFqIAhBCGopAAA3AwAgAyAIKQAANwOAAQwCCyADIAo2AowCIAMgBjYCiAIgAyAONgKEAiADIAk2AoACIAMgDzYC/AEgAyAHNgL4ASADIBA2AvQBIAMgETYC8AFBpJLAAEErIANB8AFqQdCSwABBnJXAABCUAQALIAUgAkGklsAAEJcBAAtBpJLAAEErIANBgAFqQdCSwABBnJXAABCUAQALkBQCGn8ofiMAQYABayICJAAgAkEwaiIDIAEQViACKQNIIR0gAikDQCEiIAIpAzghKSACKQMwIRwgAikDeCEfIAIpA3AhJSACKQNoISYgAikDYCEoIAIpA1ghJyACKQNQIR4gAyABQShqEFYgAikDSCEqIAIpA0AhKyACKQM4ITEgAikDMCEgIAIpA3ghLCACKQNwIS0gAikDaCEuIAIpA2AhLyACKQNYITAgAikDUCEjIAMgAUHQAGoQViACKQN4ITIgAikDcCEzIAIpA2ghNCACKQNgITUgAikDSCE2IAIpA0AhNyACKQMwITggAikDOCE5IAIpA1AhOiACKQNYITsgASgCKCEEIAEoAgAhCyABKAIsIQUgASgCBCEGIAEoAjAhDCABKAIIIQcgASgCNCEIIAEoAgwhDSABKAI4IQkgASgCECEKIAEoAjwhDiABKAIUIQ8gASgCQCEQIAEoAhghESABKAJEIRIgASgCHCETIAEoAkghFCABKAIgIRUgAiABKAJMIAEoAiRqNgIsIAIgFCAVajYCKCACIBIgE2o2AiQgAiAQIBFqNgIgIAIgDiAPajYCHCACIAkgCmo2AhggAiAIIA1qNgIUIAIgByAMajYCECACIAUgBmo2AgwgAiAEIAtqNgIIIAMgAkEIahBWIAIpA3ghPCACKQNwIT0gAikDaCE+IAIpA2AhPyACKQNYIUAgAikDSCFBIAIpA0AhQiACKQM4IUMgAikDMCEkIAIpA1AhISAAICwgLSAuIC8gMCAjQhqIfCIwQhmIfCIvQhqIfCIuQhmIfCItQhqIfCIsp0H///8PcSIBIB8gJSAmICggJyAeQhqIfCInQhmIfCIoQhqIfCImQhmIfCIlQhqIfCIfp0H///8PcSIEaiILNgJMIAAgLadB////H3EiBSAlp0H///8fcSIGaiIMNgJIIAAgLqdB////D3EiByAmp0H///8PcSIIaiINNgJEIAAgL6dB////H3EiCSAop0H///8fcSIKaiIONgJAIAAgMEL///8PgyAjQv///x+DICogKyAxICBCGoh8IiNCGYh8IiVCGoh8IiZCGYh8IihCGoh8IiqnICdC////D4MgHkL///8fgyAdICIgKSAcQhqIfCIeQhmIfCIiQhqIfCIdQhmIfCIpQhqIfCInp2oiDzYCPCAAICinQf///x9xIhAgKadB////H3EiEWoiEjYCOCAAICanQf///w9xIhMgHadB////D3EiFGoiFTYCNCAAICWnQf///x9xIgMgIqdB////H3EiFmoiFzYCMCAAICxCGYhCE34gIEL///8fg3wiIKdB////H3EiGCAfQhmIQhN+IBxC////H4N8IhynQf///x9xIhlqIho2AiggACAjQv///w+DICBCGoh8IiCnIB5C////D4MgHEIaiHwiHKdqIhs2AiwgACAJIAprQfD///8Daq0gKiAnfSAQIBFrQfD///8Daq0iHkIaiHxC8P///wF8IiNCGYh8Ih2nQf///x9xIgk2AmggACAHIAhrQfD///8Baq0gHUIaiHwiHadB////D3EiBzYCbCAAIAUgBmtB8P///wNqrSAdQhmIfCIdp0H///8fcSIFNgJwIAAgAyAWa0Hw////A2qtICAgHH0gGCAZa0HQ/f//A2qtIhxCGoh8QvD///8BfCIgQhmIfCIip0H///8fcSIGNgJYIAAgASAEa0Hw////AWqtIB1CGoh8Ih2nQf///w9xIgE2AnQgACATIBRrQfD///8Baq0gIkIaiHwiIqdB////D3EiBDYCXCAAICNC////D4MgHkL///8fgyAiQhmIfCIeQhqIfCIjPgJkIAAgHqdB////H3EiCDYCYCAAICBC////D4MgHUIZiEITfiAcQv///x+DfCIcQhqIfCIePgJUIAAgHKdB////H3EiCjYCUCAAICFC////H4MgQSBCIEMgJEIaiHwiHEIZiHwiIEIaiHwiHUIZiHwiIqdB////H3EgEmtB8P///wNqrSIpQhqIIEAgIUIaiHwiIUL///8PgyAiQhqIfKcgD2tB8P///wFqrXwiIkIZiCA/ICFCGYh8IiGnQf///x9xIA5rQfD///8Daq18Ih+nQf///x9xNgIYIAAgPiAhQhqIfCIhp0H///8PcSANa0Hw////AWqtIB9CGoh8Ih+nQf///w9xNgIcIAAgPSAhQhmIfCIhp0H///8fcSAMa0Hw////A2qtIB9CGYh8Ih+nQf///x9xNgIgIAAgIKdB////H3EgF2tB8P///wNqrSA8ICFCGoh8IiBCGYhCE34gJEL///8fg3wiJKdB////H3EgGmtB0P3//wNqrSIhQhqIIBxC////D4MgJEIaiHynIBtrQfD///8Baq18IhxCGYh8IiSnQf///x9xNgIIIAAgIKdB////D3EgC2tB8P///wFqrSAfQhqIfCIgp0H///8PcTYCJCAAIB2nQf///w9xIBVrQfD///8Baq0gJEIaiHwiJKdB////D3E2AgwgACA7QgGGIDpCAYYiHUIaiHwiH0L///8PgyAdQv7//x+DIDZCAYYgN0IBhiA5QgGGIDhCAYYiHUIaiHwiJUIZiHwiJkIaiHwiKEIZiHwiJ0IaiHwgI30gJ6dB////H3EgCGtB8P///wNqrSIjQhqIfELw////AXwiJ0IZiCA1QgGGIB9CGYh8Ih+nQf///x9xIAlrQfD///8Daq18IiqnQf///x9xNgKQASAAICanQf///x9xIAZrQfD///8Daq0gJUL///8PgyAefSAyQgGGIDNCAYYgNEIBhiAfQhqIfCIeQhmIfCIfQhqIfCIlQhmIQhN+IB1C/v//H4N8Ih1CGoh8IB2nQf///x9xIAprQdD9//8Daq0iHUIaiHxC8P///wF8IiZCGYh8IiunQf///x9xNgKAASAAICJC////D4MgKUL///8fgyAkQhmIfCIkQhqIfD4CFCAAICSnQf///x9xNgIQIAAgHEL///8PgyAgQhmIQhN+ICFC////H4N8IhxCGoh8PgIEIAAgHKdB////H3E2AgAgACAep0H///8PcSAHa0Hw////AWqtICpCGoh8IhynQf///w9xNgKUASAAICinQf///w9xIARrQfD///8Baq0gK0IaiHwiHqdB////D3E2AoQBIAAgH6dB////H3EgBWtB8P///wNqrSAcQhmIfCIcp0H///8fcTYCmAEgACAnQv///w+DICNC////H4MgHkIZiHwiHkIaiHw+AowBIAAgHqdB////H3E2AogBIAAgJadB////D3EgAWtB8P///wFqrSAcQhqIfCIcp0H///8PcTYCnAEgACAmQv///w+DIBxCGYhCE34gHUL///8fg3wiHEIaiHw+AnwgACAcp0H///8fcTYCeCACQYABaiQAC8UOAgl/AX4jAEGgAWsiAyQAIANBkAFqIAEgAhBUAkACQAJAAkACQAJAAkACQAJAIAMoApABRQRAQQ4hBQJAIAMoApgBIgRBDk8EQEHBi8AAIAMoApQBIgZBDhDcAUUNAQtBCCEEQcGLwAAhBkGsjMAAIQkMBQsgA0GHisAANgJgIAMgBEEOazYCXCADIAZBDmo2AlggA0EQaiADQdgAaiIEEEQCQCADKAIQIghBgICAgHhHBEAgAygCFCEHIAMoAhhBIEYNASADQQA2AhQgA0HoAGogA0EkaigCADYCACADQeAAaiADQRxqKQIANwMAIAMgAykCFDcDWCADQYABaiAEEEkCQCADKAJYIgRBCE1BAEEBIAR0Qc8DcRsNACADKAJcIgRFDQAgAygCYCAEEJwBC0EFIQQgAygCiAEhCSADKAKEASEFIAMoAoABIQYgCEUNBiAHQQRrKAIAIgpBeHEiC0EEQQggCkEDcSIKGyAIakkNCiAKQQAgCyAIQSdqSxsNCyAHEEUMBgsgAykCFCEMIANBADYCYCADQoCAgIAQNwJYIAynIAxCIIinIANB2ABqEIQBDQIgAygCYCEJIAMoAlwhBSADKAJYIQZBCSEEDAULIAdBAmotAAAhBCAHKAADIQUgBy8AACEGIANB9wBqIAdBH2otAAA6AAAgA0HaAGogBDoAACADIAcpABc3AG8gA0HnAGogB0EPaikAADcAACADIAY7AVggAyAFNgBbIAMgBykABzcAXyADQRBqIglBAXIgA0HYAGoiBBBGIAQQjAEgA0GIAWogA0EgaigCACIENgIAIANB3gBqIAMtABM6AAAgA0H7AGogA0Ewai0AADoAACADQesAaiAENgAAIAMgAykCGCIMNwOAASADIAMvABE7AVwgAyADKQIoNwBzIAMgDDcAYyADKAIUIQQgAyADKAIkNgBvIAMgBDYAXyADQYeKwAA2AlggA0EANgKYASADQoCAgIAQNwKQASADQZABakEAQTAQjQEgAygClAEiBCADKAKYASIGaiIFQgA3AAAgBUEIakIANwAAIAVBEGpCADcAACAFQRhqQgA3AAAgBUEgakIANwAAIAVBKGpCADcAACADQQhqIANB3ABqQSAgBCAGQTBqIgYQUCADKAIIRQRAIAMoApABIQUgCSAEIAYgAygCDCIJIAYgCUkbIgYQVCADKAIQRQRAIAatIQwgBCEGDAULIAMpAhQhDCAFQYCAgIB4Rw0DIAQhBQwECyADKAKQASIABEAgBCAAEJwBC0GkksAAQSsgA0GfAWpB6ITAAEH4hMAAEJQBAAsgAyADKQKUATcDSCADQQE2AlwgA0H0jcAANgJYIANCATcCZCADIANByABqrUKAgICA0AGENwOAASADIANBgAFqNgJgIANBEGogA0HYAGoQayADKAIQIQUgAygCFCIGIAMoAhgQACEEIAVFDQQgBkEEaygCACIHQXhxIghBBEEIIAdBA3EiBxsgBWpJDQcgB0EAIAggBUEnaksbDQggBhBFDAQLQYSawABBNyADQZ8BakG8g8AAQZibwAAQlAEACyADIAw3AhwgAyAFNgIQIAMgBK0gBq1CIIaENwIUQaSSwABBKyADQRBqQfCFwABBgIbAABCUAQALIAMgDD4CUCADIAY2AkwgAyAFNgJIIANBATYCFCADQbyMwAA2AhAgA0IBNwIcIAMgA0HIAGqtQoCAgIDgAYQ3A0AgAyADQUBrNgIYIANBNGogA0EQahBrIAMoAkgiBARAIAMoAkwgBBCcAQsgAygCPCEFIAMoAjghBCADKAI0IQYgCEUNAiAHIAgQnAEMAgsgA0ENNgJoIAMgCTYCZCADIAU2AmAgAyAGNgJcIAMgBDYCWCADQRBqIANB2ABq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AAggBSAHKQMANwAACyABQf8HcSIMRQ0GIAdBuAFqQgA3AwAgB0GwAWpCADcDACAHQagBakIANwMAIAdBoAFqQgA3AwAgB0GYAWpCADcDACAHQZABakIANwMAIAdBiAFqQgA3AwAgB0HIAWoiCCACQQhqKQIANwMAIAdB0AFqIgogAkEQaikCADcDACAHQdgBaiILIAJBGGopAgA3AwAgB0IANwOAASAHIAQ6AOoBIAdBADsB6AEgByACKQIANwPAASAHIAmtIAN8NwPgASAHQYABaiAAIAFBgAhxaiAMEGchACAHQcgAaiAIKQMANwMAIAdB0ABqIAopAwA3AwAgB0HYAGogCykDADcDACAHQQhqIABBCGopAwA3AwAgB0EQaiAAQRBqKQMANwMAIAdBGGogAEEYaikDADcDACAHQSBqIABBIGopAwA3AwAgB0EoaiAAQShqKQMANwMAIAdBMGogAEEwaikDADcDACAHQThqIABBOGopAwA3AwAgByAHKQPAATcDQCAHIAApAwA3AwAgBy0A6gEhACAHLQDpASEBIAcgBy0A6AEiAjoAaCAHIAcpA+ABIgM3A2AgByAAIAFFckECciIAOgBpIAdBiAJqIgEgCykDADcDACAHQYACaiIEIAopAwA3AwAgB0H4AWoiCiAIKQMANwMAIAcgBykDwAE3A/ABIAdB8AFqIAcgAiADIAAQJiAJQQV0IgBBIGoiAiAGSw0BIAEoAgAhASAEKAIAIQIgCigCACEEIAcoAoQCIQYgBygC/AEhCCAHKAL0ASEKIAcoAvABIQsgACAFaiIAIAcoAowCNgAcIAAgATYAGCAAIAY2ABQgACACNgAQIAAgCDYADCAAIAQ2AAggACAKNgAEIAAgCzYAACAJQQFqIQkMBgtCfyABrUIBfEIBiEIBfXmIpyIIIAFPDQEgACAIQQFqIgkgAiADIAQgB0GAARDeASIIQSBBwAAgCUGACEYbIgoQMSELIAAgCWogASAJayACIAlBCnatIAN8IAQgCCAKakGAASAKaxAxIAtBAUYEQCAGQT9NDQMgBSAIKQAANwAAIAVBOGogCEE4aikAADcAACAFQTBqIAhBMGopAAA3AAAgBUEoaiAIQShqKQAANwAAIAVBIGogCEEgaikAADcAACAFQRhqIAhBGGopAAA3AAAgBUEQaiAIQRBqKQAA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AAshCyAGBEAgBUEEaygCACIJQXhxIgxBBEEIIAlBA3EiCRsgBmpJDQEgCUEAIAwgBkEnaksbDQIgBRBFCyAEBEAgA0EEaygCACIFQXhxIgZBBEEIIAVBA3EiBRsgBGpJDQEgBUEAIAYgBEEnaksbDQIgAxBFCyACBEAgAUEEaygCACIDQXhxIgRBBEEIIANBA3EiAxsgAmpJDQEgA0EAIAQgAkEnaksbDQIgARBFCyAAIAo2AgggACAIQf8BcSANIAsbIgFBACAKGzYCBCAAQQAgASAKGzYCACAHQdAAaiQADwtBrfXCAEEuQdz1wgAQowEAC0Hs9cIAQS5BnPbCABCjAQALQYSawABBNyAHQSRqQbyDwABBmJvAABCUAQAL8xACEn8EfiMAQeABayICJAACQAJAAkACQAJAAkAgASkDkAFQBEAgASgCmAEiA0UEQCACQcgAaiABQegAaikDADcDACACQdAAaiABQfAAaikDADcDACACQdgAaiABQfgAaikDADcDACACQQhqIAFBKGopAwA3AwAgAkEQaiABQTBqKQMANwMAIAJBGGogAUE4aikDADcDACACQSBqIAFBQGspAwA3AwAgAkEoaiABQcgAaikDADcDACACQTBqIAFB0ABqKQMANwMAIAJBOGogAUHYAGopAwA3AwAgAiABKQNgNwNAIAIgASkDIDcDACABLQCKASEFIAEtAIkBIQQgAiABLQCIASIDOgBoIAIgASkDgAE3A2AgAiAFIARFckECciIBOgBpDAYLQQAgAS0AiAEiCGsgAS0AiQEiBEEGdEcNASADQQJrIQUgA0EBRg0CIAEtAIoBIQcgAkGIAWoiCSABQZwBaiIGIAVBBXRqIgRBGGopAAA3AwAgAkGAAWoiCCAEQRBqKQAANwMAIAJB+ABqIgogBEEIaikAADcDACACQZABaiILIANBBXQgBmpBIGsiBikAADcDACACQZgBaiIMIAZBCGopAAA3AwAgAkGgAWoiDSAGQRBqKQAANwMAIAJBqAFqIg4gBkEYaikAADcDACACIAQpAAA3A3AgAkHYAGogAUEYaikDADcDACACQdAAaiABQRBqKQMANwMAIAJByABqIAFBCGopAwA3AwAgAiABKQMANwNAIAJBOGogDikDADcDACACQTBqIA0pAwA3AwAgAkEoaiAMKQMANwMAIAJB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HYh8IgOnQf////8BcTYCGCAnIARCFIYgDnwgA0IdiHwiA6dB/////wFxNgIcICcgBkIUhiAjfCADQh2IfCIDp0H/////AXE2AiAgJyAHQhSGIA18IANCHYh8IgOnQf////8BcTYCJCAnIAhCFIYgC3wgA0IdiHwiA0IdiD4CLCAnIAOnQf////8BcTYCKCAAICdBDGoQXiAnQTBqJAALhwwCBn8GfiMAQaAGayICJAAgAkHQBWoiBSABEFYgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCGCACIAIpA+AFIAIpA9gFIAIpA9AFIgxCGoh8Ig1CGYh8IgqnQf///x9xNgIIIAIgAikDiAYgCUIaiHwiCadB////D3E2AhwgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCDCACIAIpA5AGIAlCGYh8IgmnQf///x9xNgIgIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgIUIAIgCKdB////H3E2AhAgAiACKQOYBiAJQhqIfCIIp0H///8PcTYCJCACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CBCACIAinQf///x9xNgIAIAUgAhBWIAIgAikDgAYgAikD+AUgAikD8AUiCEIaiHwiC0IZiHwiCadB////H3E2AsAFIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2ArAFIAIgAikDiAYgCUIaiHwiCadB////D3E2AsQFIAIgAikD6AUgCkIaiHwiCqdB////D3E2ArQFIAIgAikDkAYgCUIZiHwiCadB////H3E2AsgFIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgK8BSACIAinQf///x9xNgK4BSACIAIpA5gGIAlCGoh8IginQf///w9xNgLMBSACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CrAUgAiAIp0H///8fcTYCqAUgBSACQagFaiIGEFYgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCQCACIAIpA+AFIAIpA9gFIAIpA9AFIgxCGoh8Ig1CGYh8IgqnQf///x9xNgIwIAIgAikDiAYgCUIaiHwiCadB////D3E2AkQgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCNCACIAIpA5AGIAlCGYh8IgmnQf///x9xNgJIIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgI8IAIgCKdB////H3E2AjggAiACKQOYBiAJQhqIfCIIp0H///8PcTYCTCACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CLCACIAinQf///x9xNgIoIAJB0ABqIgQgASACQShqEEEgAkH4AGoiASACIAQQQSAFIAEQViACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgK4ASACIAIpA+AFIAIpA9gFIAIpA9AFIgxCGoh8Ig1CGYh8IgqnQf///x9xNgKoASACIAIpA4gGIAlCGoh8IgmnQf///w9xNgK8ASACIAIpA+gFIApCGoh8IgqnQf///w9xNgKsASACIAIpA5AGIAlCGYh8IgmnQf///x9xNgLAASACIAtC////D4MgCEL///8fgyAKQhmIfCIIQhqIfD4CtAEgAiAIp0H///8fcTYCsAEgAiACKQOYBiAJQhqIfCIIp0H///8PcTYCxAEgAiANQv///w+DIAhCGYhCE34gDEL///8fg3wiCEIaiHw+AqQBIAIgCKdB////H3E2AqABIAJByAFqIgMgBCACQaABahBBIAJB8AFqIgQgA0EFEFUgAkGYAmoiASAEIAMQQSACQcACaiIDIAFBChBVIAJB6AJqIgQgAyABEEEgAkGQA2oiAyAEQRQQVSACQbgDaiIHIAMgBBBBIAJB4ANqIgMgB0EKEFUgAkGIBGoiBCADIAEQQSACQbAEaiIDIARBMhBVIAJB2ARqIgEgAyAEEEEgAkGABWoiAyABQeQAEFUgBiADIAEQQSAFIAZBMhBVIAAgBSAEEEEgAEHIAGogAkGYAWopAgA3AgAgAEFAayACQZABaikCADcCACAAQThqIAJBiAFqKQIANwIAIABBMGogAkGAAWopAgA3AgAgACACKQJ4NwIoIAJBoAZqJAAL0wwCJ38MfiMAQfABayIDJAAgASgCACEEIAEoAighBSABKAIEIQYgASgCLCEHIAEoAgghCCABKAIwIQkgASgCDCEKIAEoAjQhCyABKAIQIQwgASgCOCENIAEoAhQhDiABKAI8IQ8gASgCGCEQIAEoAkAhESABKAIcIRIgASgCRCETIAEoAiAhFCABKAJIIRUgAyABKAIkIAEoAkxqNgIkIAMgFCAVajYCICADIBIgE2o2AhwgAyAQIBFqNgIYIAMgDiAPajYCFCADIAwgDWo2AhAgAyAKIAtqNgIMIAMgCCAJajYCCCADIAYgB2o2AgQgAyAEIAVqNgIAIANBKGoiBCABQShqIAEQYSADQdAAaiADIAIQQSADQfgAaiAEIAJBKGoQQSADQaABaiABQfgAaiACQfgAahBBIANByAFqIAFB0ABqIAJB0ABqEEEgAygCoAEhASADKALIASEWIAMoAqQBIQIgAygCzAEhFyADKAKoASEEIAMoAtABIRggAygCrAEhBSADKALUASEZIAMoArABIQYgAygC2AEhGiADKAK0ASEHIAMoAtwBIRsgAygCuAEhCCADKALgASEcIAMoArwBIQkgAygC5AEhHSADKALAASEKIAMoAugBIR4gAygCxAEhCyADKALsASEfIAMoAnghDCADKAJQIQ0gAygCfCEOIAMoAlQhDyADKAKAASEQIAMoAlghESADKAKEASESIAMoAlwhEyADKAKIASEUIAMoAmAhFSADKAKMASEgIAMoAmQhISADKAKQASEiIAMoAmghIyADKAKUASEkIAMoAmwhJSADKAKYASEmIAMoAnAhJyAAIAMoApwBIiggAygCdCIpajYCTCAAICYgJ2o2AkggACAkICVqNgJEIAAgIiAjajYCQCAAICAgIWo2AjwgACAUIBVqNgI4IAAgEiATajYCNCAAIBAgEWo2AjAgACAOIA9qNgIsIAAgDCANajYCKCAAIAsgH0EBdCIfajYCdCAAIAogHkEBdCIeajYCcCAAIAkgHUEBdCIdajYCbCAAIAggHEEBdCIcajYCaCAAIAcgG0EBdCIbajYCZCAAIAYgGkEBdCIaajYCYCAAIAUgGUEBdCIZajYCXCAAIAQgGEEBdCIYajYCWCAAIAIgF0EBdCIXajYCVCAAIAEgFkEBdCIWajYCUCAAICMgImtB8P///wNqrSAhICBrQfD///8Baq0gFSAUa0Hw////A2qtIipCGoh8IitCGYh8IiynQf///x9xNgIYIAAgESAQa0Hw////A2qtIA8gDmtB8P///wFqrSANIAxrQdD9//8Daq0iMEIaiHwiMUIZiHwiLadB////H3E2AgggACAcIAhrQfD///8Daq0gGyAHa0Hw////AWqtIBogBmtB8P///wNqrSIyQhqIfCIzQhmIfCIup0H///8fcTYCkAEgACAYIARrQfD///8Daq0gFyACa0Hw////AWqtIBYgAWtB0P3//wNqrSI0QhqIfCI1QhmIfCIvp0H///8fcTYCgAEgACAlICRrQfD///8Baq0gLEIaiHwiLKdB////D3E2AhwgACATIBJrQfD///8Baq0gLUIaiHwiLadB////D3E2AgwgACAdIAlrQfD///8Baq0gLkIaiHwiLqdB////D3E2ApQBIAAgGSAFa0Hw////AWqtIC9CGoh8Ii+nQf///w9xNgKEASAAICcgJmtB8P///wNqrSAsQhmIfCIsp0H///8fcTYCICAAICtC////D4MgKkL///8fgyAtQhmIfCIqQhqIfD4CFCAAICqnQf///x9xNgIQIAAgHiAKa0Hw////A2qtIC5CGYh8IiqnQf///x9xNgKYASAAIDNC////D4MgMkL///8fgyAvQhmIfCIrQhqIfD4CjAEgACArp0H///8fcTYCiAEgACApIChrQfD///8Baq0gLEIaiHwiK6dB////D3E2AiQgACAfIAtrQfD///8Baq0gKkIaiHwiKqdB////D3E2ApwBIAAgMUL///8PgyArQhmIQhN+IDBC////H4N8IitCGoh8PgIEIAAgK6dB////H3E2AgAgACA1Qv///w+DICpCGYhCE34gNEL///8fg3wiKkIaiHw+AnwgACAqp0H///8fcTYCeCADQfABaiQAC7oMAid/DH4jAEHQAWsiAyQAIAEoAgAhBCABKAIoIQUgASgCBCEGIAEoAiwhByABKAIIIQggASgCMCEJIAEoAgwhCiABKAI0IQsgASgCECEMIAEoAjghDSABKAIUIQ4gASgCPCEPIAEoAhghECABKAJAIREgASgCHCESIAEoAkQhEyABKAIgIRQgASgCSCEVIAMgASgCJCABKAJMajYCLCADIBQgFWo2AiggAyASIBNqNgIkIAMgECARajYCICADIA4gD2o2AhwgAyAMIA1qNgIYIAMgCiALajYCFCADIAggCWo2AhAgAyAGIAdqNgIMIAMgBCAFajYCCCADQTBqIgQgAUEoaiABEGEgA0HYAGogA0EIaiACEEEgA0GAAWogBCACQShqEEEgA0GoAWogAUH4AGogAkHQAGoQQSABKAJQIRYgASgCVCEXIAEoAlghGCABKAJcIRkgASgCYCEaIAEoAmQhGyABKAJoIRwgASgCbCEdIAEoAnAhHiABKAJ0IR8gAygCqAEhASADKAKsASECIAMoArABIQQgAygCtAEhBSADKAK4ASEGIAMoArwBIQcgAygCwAEhCCADKALEASEJIAMoAsgBIQogAygCzAEhCyADKAKAASEMIAMoAlghDSADKAKEASEOIAMoAlwhDyADKAKIASEQIAMoAmAhESADKAKMASESIAMoAmQhEyADKAKQASEUIAMoAmghFSADKAKUASEgIAMoAmwhISADKAKYASEiIAMoAnAhIyADKAKcASEkIAMoAnQhJSADKAKgASEmIAMoAnghJyAAIAMoAqQBIiggAygCfCIpajYCTCAAICYgJ2o2AkggACAkICVqNgJEIAAgIiAjajYCQCAAICAgIWo2AjwgACAUIBVqNgI4IAAgEiATajYCNCAAIBAgEWo2AjAgACAOIA9qNgIsIAAgDCANajYCKCAAIAsgH0EBdCIfajYCdCAAIAogHkEBdCIeajYCcCAAIAkgHUEBdCIdajYCbCAAIAggHEEBdCIcajYCaCAAIAcgG0EBdCIbajYCZCAAIAYgGkEBdCIaajYCYCAAIAUgGUEBdCIZajYCXCAAIAQgGEEBdCIYajYCWCAAIAIgF0EBdCIXajYCVCAAIAEgFkEBdCIWajYCUCAAICMgImtB8P///wNqrSAhICBrQfD///8Baq0gFSAUa0Hw////A2qtIipCGoh8IitCGYh8IiynQf///x9xNgIYIAAgESAQa0Hw////A2qtIA8gDmtB8P///wFqrSANIAxrQdD9//8Daq0iMEIaiHwiMUIZiHwiLadB////H3E2AgggACAcIAhrQfD///8Daq0gGyAHa0Hw////AWqtIBogBmtB8P///wNqrSIyQhqIfCIzQhmIfCIup0H///8fcTYCkAEgACAYIARrQfD///8Daq0gFyACa0Hw////AWqtIBYgAWtB0P3//wNqrSI0QhqIfCI1QhmIfCIvp0H///8fcTYCgAEgACAlICRrQfD///8Baq0gLEIaiHwiLKdB////D3E2AhwgACATIBJrQfD///8Baq0gLUIaiHwiLadB////D3E2AgwgACAdIAlrQfD///8Baq0gLkIaiHwiLqdB////D3E2ApQBIAAgGSAFa0Hw////AWqtIC9CGoh8Ii+nQf///w9xNgKEASAAICcgJmtB8P///wNqrSAsQhmIfCIsp0H///8fcTYCICAAICtC////D4MgKkL///8fgyAtQhmIfCIqQhqIfD4CFCAAICqnQf///x9xNgIQIAAgHiAKa0Hw////A2qtIC5CGYh8IiqnQf///x9xNgKYASAAIDNC////D4MgMkL///8fgyAvQhmIfCIrQhqIfD4CjAEgACArp0H///8fcTYCiAEgACApIChrQfD///8Baq0gLEIaiHwiK6dB////D3E2AiQgACAfIAtrQfD///8Baq0gKkIaiHwiKqdB////D3E2ApwBIAAgMUL///8PgyArQhmIQhN+IDBC////H4N8IitCGoh8PgIEIAAgK6dB////H3E2AgAgACA1Qv///w+DICpCGYhCE34gNEL///8fg3wiKkIaiHw+AnwgACAqp0H///8fcTYCeCADQdABaiQAC9ILAgp+BH8jAEGwA2siDCQAIAxBqAJqQYEBEN4BGiAMQaACakIANwMAIAxBkAJqQbDqwgApAwA3AwAgDEGIAmpBqOrCACkDADcDACAMQYACakGg6sIAKQMANwMAIAxB+AFqQZjqwgApAwA3AwAgDEHwAWpBkOrCACkDADcDACAMQegBakGI6sIAKQMANwMAIAxB4AFqQYDqwgApAwA3AwAgDEGwAmogAUEIaikAADcDACAMQbgCaiABQRBqKQAANwMAIAxBwAJqIAFBGGopAAA3AwAgDEIANwOYAiAMQfjpwgApAwA3A9gBIAwgASkAADcDqAIgDEEgOgCoAyAMIAxB2AFqQdgBEN8BIgFB0ABqIg4gAS0A0AEiDGoiDUGAAToAACABQcgAaikDACICQgKGQoCAgPgPgyACQg6IQoCA/AeDhCACQh6IQoD+A4MgAkIKhiIDQjiIhIQhBiABKQNAIgJCNogiBEI4hiADIASEIgNCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIAJCAoZCgICA+A+DIAJCDohCgID8B4OEIAJCHohCgP4DgyACQgqGIgJCOIiEhCEEIAytIgVCO4YgAiAFQgOGhCICQoD+A4NCKIaE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gAE6AAALIARBEGokAAuXCAIjfg1/IAAgASgCDCImQQF0rSISIAIoAgwiJ60iDn4gASgCBCIoQQF0rSITIAIoAhQiKa0iFH58IAEoAhQiKkEBdK0iFSACKAIEIiutIgt+fCABKAIcIixBAXStIhYgAigCJCItQRNsrSIFfnwgATUCACIDIAIoAhgiLq0iHn58IAEoAiQiL0EBdK0iFyACKAIcIjBBE2ytIgx+fCABNQIIIgYgAigCECIxrSIPfnwgATUCECIHIAIoAggiMq0iDX58IAE1AhgiCCACNQIAIgl+fCABNQIgIgogAigCICIBQRNsrSIEfnwgJq0iGCANfiAorSIZIA9+fCAsrSIaIAR+fCAvrSIbIC5BE2ytIhB+fCADIBR+fCAJICqtIhx+fCAGIA5+fCAHIAt+fCAFIAh+fCAKIAx+fCALIBJ+IA4gE358IAUgFX58IAwgFn58IAMgD358IBcgKUETbK0iHX58IAYgDX58IAcgCX58IAQgCH58IAogEH58IiJCGoh8IiNCGYh8Ih+nQf///x9xNgIYIAAgBSASfiALIBN+fCAMIBV+fCAWIB1+fCADIA1+fCAXICdBE2ytIhF+fCAGIAl+fCAEIAd+fCAIIBB+fCAKIDFBE2ytIiB+fCAQIBx+IAQgGH58IBogIH58IBsgMkETbK0iIX58IAMgC358IAkgGX58IAUgBn58IAcgDH58IAggHX58IAogEX58IAwgEn4gBSATfnwgFSAdfnwgESAWfnwgFyArQRNsrX58IAMgCX58IAQgBn58IAcgEH58IAggIH58IAogIX58IiFCGoh8IiRCGYh8IiWnQf///x9xNgIIIAAgDyAYfiAZIB5+fCANIBx+fCAEIBt+fCADIDCtIhF+fCAJIBp+fCAGIBR+fCAHIA5+fCAIIAt+fCAFIAp+fCAfQhqIfCIfp0H///8PcTYCHCAAIAQgHH4gDSAZfnwgECAafnwgGyAgfnwgAyAOfnwgCSAYfnwgBiALfnwgBSAHfnwgCCAMfnwgCiAdfnwgJUIaiHwiBKdB////D3E2AgwgACASIBR+IBEgE358IA4gFX58IAsgFn58IAMgAa0iDH58IAUgF358IAYgHn58IAcgD358IAggDX58IAkgCn58IB9CGYh8IgWnQf///x9xNgIgIAAgI0L///8PgyAiQv//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ACIEQSlJDQBBiP7CACEAA0AgAiAAKAIAIgVPBEAgBSAAKAIEaiACSw0CCyAAKAIIIgANAAsLQZD+wgAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtByIDDAEH/HyABIAFB/x9NGzYCACADIARPDQRBwIDDAEF/NgIADAQLAkACQCAAIAMoAgAiAygCBEF4cUYEQCADIQIMAQsgAEEZIAJBAXZrQQAgAkEfRxt0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAkUNAiAEQQF0IQQgAiEDIAIoAgRBeHEgAEcNAAsLIAIoAggiACABNgIMIAIgATYCCCABQQA2AhggASACNgIMIAEgADYCCAwBCyAFIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggLQQAhAUHIgMMAQciAwwAoAgBBAWsiADYCACAADQJBkP7CACgCACIABEADQCABQQFqIQEgACgCCCIADQALC0HIgMMAQf8fIAEgAUH/H00bNgIADwsgAEF4cUGY/sIAaiECAn9BoIDDACgCACIDQQEgAEEDdnQiAHFFBEBBoIDDACAAIANyNgIAIAIMAQsgAigCCAshACACIAE2AgggACABNgIMIAEgAjYCDCABIAA2AggPC0GwgMMAIAE2AgBBqIDDAEGogMMAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAsLzwcCFX8GfiMAQcADayICJAAgAkH5AmogAUEJaikAADcAACACQYEDaiABQRFqKQAANwAAIAJBhwNqIAFBF2opAAA3AAAgAiABKQABNwDxAiACIAEtAABB+AFxOgDwAiACIAEtAB9BP3FBwAByOgCPAyACQQhqIAJB8AJqIgMQNyACKAJYIQEgAigCMCEEIAIoAlwhBSACKAI0IQYgAigCYCEHIAIoAjghCCACKAJkIQkgAigCPCEKIAIoAmghCyACKAJAIQwgAigCbCENIAIoAkQhDiACKAJwIQ8gAigCSCEQIAIoAnQhESACKAJMIRIgAigCeCETIAIoAlAhFCACIAIoAlQiFSACKAJ8IhZqNgLMASACIBMgFGo2AsgBIAIgESASajYCxAEgAiAPIBBqNgLAASACIA0gDmo2ArwBIAIgCyAMajYCuAEgAiAJIApqNgK0ASACIAcgCGo2ArABIAIgBSAGajYCrAEgAiABIARqNgKoASACIA8gEGtB8P///wNqrSANIA5rQfD///8Baq0gCyAMa0Hw////A2qtIhdCGoh8IhpCGYh8IhinQf///x9xNgLoASACIAcgCGtB8P///wNqrSAFIAZrQfD///8Baq0gASAEa0HQ/f//A2qtIhtCGoh8IhxCGYh8IhmnQf///x9xNgLYASACIBEgEmtB8P///wFqrSAYQhqIfCIYp0H///8PcTYC7AEgAiAJIAprQfD///8Baq0gGUIaiHwiGadB////D3E2AtwBIAIgEyAUa0Hw////A2qtIBhCGYh8IhinQf///x9xNgLwASACIBpC////D4MgF0L///8fgyAZQhmIfCIXQhqIfD4C5AEgAiAXp0H///8fcTYC4AEgAiAWIBVrQfD///8Baq0gGEIaiHwiF6dB////D3E2AvQBIAIgHEL///8PgyAXQhmIQhN+IBtC////H4N8IhdCGoh8PgLUASACIBenQf///x9xNgLQASADIAJB0AFqEDsgAkHAAmogAkGQA2opAgA3AwAgAkG4AmogAkGIA2opAgA3AwAgAkGwAmogAkGAA2opAgA3AwAgAkGoAmogAkH4AmopAgA3AwAgAiACKQLwAjcDoAIgAkHoAmogAkG4A2opAgA3AwAgAkHgAmogAkGwA2opAgA3AwAgAkHYAmogAkGoA2opAgA3AwAgAkHQAmogAkGgA2opAgA3AwAgAiACKQKYAzcDyAIgAyACQaACakEFEFUgAkH4AWoiASADIAJByAJqEEEgAyACQagBaiABEEEgACADEEwgAkHAA2okAAvFBwIOfwZ+IwBB8AFrIgMkACADQSBqIg1BrLrAACkCACISNwMAIANBGGoiDkGkusAAKQIAIhQ3AwAgA0EQaiIPQZy6wAApAgAiETcDACADQQhqIhBBlLrAACkCACITNwMAIANBMGoiBSATNwMAIANBOGoiBiARNwMAIANBQGsiByAUNwMAIANByABqIgggEjcDACADQfAAaiIJQgA3AwAgA0HoAGoiCkIANwMAIANB4ABqIgtCADcDACADQdgAaiIMQgA3AwAgA0IANwNQIANBjLrAACkCACISNwMAIAMgEjcDKCADIAEgAsAiAkEHdSIEIAJqIARzIgJBAUYQvwEQUiADIAFB+ABqIAJBAkYQvwEQUiADIAFB8AFqIAJBA0YQvwEQUiADIAFB6AJqIAJBBEYQvwEQUiADIAFB4ANqIAJBBUYQvwEQUiADIAFB2ARqIAJBBkYQvwEQUiADIAFB0AVqIAJBB0YQvwEQUiADIAFByAZqIAJBCEYQvwEQUiAEQQFxEL8BIQEgA0GYAWogCCkDADcDACADQZABaiAHKQMANwMAIANBiAFqIAYpAwA3AwAgA0GAAWogBSkDADcDACADIAMpAyg3A3ggCSgCACECIAooAgAhBCALKAIAIQUgDCgCACEGIAMoAnQhByADKAJsIQggAygCXCEJIAMoAmQhCiADKAJUIQsgAygCUCEMIANBwAFqIA0pAwA3AwAgA0G4AWogDikDADcDACADQbABaiAPKQMANwMAIANBqAFqIBApAwA3AwAgAyADKQMANwOgASADQfD///8DIAZrrUHw////ASALa61B0P3//wMgDGutIhJCGoh8IhRCGYh8IhGnQf///x9xNgLQASADQfD///8DIARrrUHw////ASAKa61B8P///wMgBWutIhNCGoh8IhZCGYh8IhWnQf///x9xNgLgASADQfD///8BIAlrrSARQhqIfCIRp0H///8PcTYC1AEgA0Hw////ASAIa60gFUIaiHwiFadB////D3E2AuQBIAMgE0L///8fgyARQhmIfCIRp0H///8fcTYC2AEgA0Hw////AyACa60gFUIZiHwiE6dB////H3E2AugBIAMgFkL///8PgyARQhqIfD4C3AEgA0Hw////ASAHa60gE0IaiHwiEadB////D3E2AuwBIAMgEUIZiEITfiASQv///x+DfCISp0H///8fcTYCyAEgAyAUQv///w+DIBJCGoh8PgLMASADIANB+ABqIAEQUiAAIANB+AAQ3wEaIANB8AFqJAALpgYCCn8CfiMAQZABayIFJAAgBUFAayABIAIgAyAEECUCQAJAAkACQCAFLQBARQRAIAVBOGoiCCAFQfkAaikAADcDACAFQTBqIgcgBUHxAGopAAA3AwAgBUEoaiIKIAVB6QBqKQAANwMAIAVBIGoiCyAFQeEAaikAADcDACAFQRhqIgwgBUHZAGopAAA3AwAgBUEQaiINIAVB0QBqKQAANwMAIAVBCGoiDiAFQckAaikAADcDACAFIAUpAEE3AwBB0YDDAC0AABpBwAAhCUHAABAnIgZFDQIgBiAFKQMANwAA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ADcAACALIAApAwA3AwAgC0EIaiAAQQhqIgwpAwA3AwAgC0EQaiAAQRBqIg0pAwA3AwAgC0EYaiAAQRhqIg4pAwA3AwAgAC0AigEhByACQShqIAYpAwA3AwAgAkEwaiAFKQMANwMAIAJBOGogBCkDADcDACACQUBrIAopAwA3AwAgAkHIAGogAkG4AWopAwA3AwAgAkHQAGogAkHAAWopAwA3AwAgAkHYAGogAkHIAWopAwA3AwAgAkHAADoAiAEgAiACKQOQATcDICACIAdBBHIiBzoAiQEgAkIANwOAASAEIA4pAgA3AwAgBSANKQIANwMAIAYgDCkCADcDACACIAApAgA3A5ABIAJBkAFqIAJBIGpBwABCACAHECYgBCgCACEEIAUoAgAhBSAGKAIAIQYgAigCrAEhDCACKAKkASENIAIoApwBIQ4gAigClAEhByACKAKQASETIBVFDQMgGSATNgIAIANB+ABqIAw2AgAgFiAENgIAIANB8ABqIA02AgAgFyAFNgIAIANB6ABqIA42AgAgGCAGNgIAIANB4ABqIAc2AgAgACAJNgKYASAPQSBrIQ8gCCIJIBRPDQALCyACQdABaiQADwtB/JTAABDRAQALIAIgDDYCrAEgAiAENgKoASACIA02AqQBIAIgBTYCoAEgAiAONgKcASACIAY2ApgBIAIgBzYClAEgAiATNgKQAUGkksAAQSsgAkGQAWpB0JLAAEGMlcAAEJQBAAuEBgIIfgl/IAAgATUCJCABNQIgIAE1AhwgATUCGCABNQIUIAE1AhAiA0IaiHwiBEIZiHwiBUIaiHwiBkIZiHwiB0IaiHwiCEIZiEITfiABNQIAIgJC////H4N8IgmnQf///x9xIgpBE2pBGnYgATUCBCACQhqIfCICQv///w+DIAlCGoh8pyILakEZdiABNQIIIAJCGYh8IgKnQf///x9xIgxqQRp2IAE1AgwgAkIaiHwiAqdB////D3EiDWpBGXYgA0L///8fgyACQhmIfCICp0H///8fcSIOakEadiAEQv///w+DIAJCGoh8pyIPakEZdiAFp0H///8fcSIQakEadiAGp0H///8PcSIRakEZdiAHp0H///8fcSISakEadiAIp0H///8PcSIBakEZdkETbCAKaiIKOgAAIAAgCkEQdjoAAiAAIApBCHY6AAEgACAKQRp2IAtqIgtBDnY6AAUgACALQQZ2OgAEIAAgCkEYdkEDcSALQQJ0cjoAAyAAIAtBGXYgDGoiDEENdjoACCAAIAxBBXY6AAcgACAMQQN0IAtBgICADnFBFnZyOgAGIAAgDEEadiANaiINQQt2OgALIAAgDUEDdjoACiAAIAxBFXZBH3EgDUEFdHI6AAkgACANQRl2IA5qIg5BEnY6AA8gACAOQQp2OgAOIAAgDkECdjoADSAAIA5BGnYgD2oiDzoAECAAIA1BE3ZBP3EgDkEGdHI6AAwgACAPQRB2OgASIAAgD0EIdjoAESAAIA9BGXYgEGoiEEEPdjoAFSAAIBBBB3Y6ABQgACAPQRh2QQFxIBBBAXRyOgATIAAgEEEadiARaiIRQQ12OgAYIAAgEUEFdjoAFyAAIBBBF3ZBB3EgEUEDdHI6ABYgACARQRl2IBJqIhJBDHY6ABsgACASQQR2OgAaIAAgEUEVdkEPcSASQQR0cjoAGSAAIBJBGnYgAWoiAUEKdjoAHiAAIAFBAnY6AB0gACABQYCA8A9xQRJ2OgAfIAAgEkEUdkE/cSABQQZ0cjoAHAuyBgIOfwJ+IwBB8A9rIgEkAAJAAkACQCAABEAgAEEIayIFIAUoAgAiCEEBaiICNgIAIAJFDQEgACgCACIGQX9GDQIgACAGQQFqNgIAIAFBwA9qIABBgAFqKQMANwMAIAFBuA9qIABB+ABqKQMANwMAIAFBsA9qIABB8ABqKQMANwMAIAFB8A5qIABBMGopAwA3AwAgAUH4DmogAEE4aikDADcDACABQYAPaiAAQUBrKQMANwMAIAFBiA9qIABByABqKQMANwMAIAFBkA9qIABB0ABqKQMANwMAIAFBmA9qIABB2ABqKQMANwMAIAFBoA9qIABB4ABqKQMANwMAIAEgACkDaDcDqA8gASAAKQMoNwPoDiAAKQOIASEPIAApA5gBIRAgAC0AkgEhCSAALQCRASEKIAAtAJABIQsgACgCoAEiAgRAIAAgAkEFdCIMakGkAWohByAAQaQBaiENIAFBgAFqQQRyIQ4DQAJAIAQgDmoiAiAEIA1qIgMpAAA3AAAgAkEYaiADQRhqKQAANwAAIAJBEGogA0EQaikAADcAACACQQhqIANBCGopAAA3AAAgA0EgaiIDIAdGDQAgBEHADUYNBiACQSBqIAMpAAA3AAAgAkE4aiADQRhqKQAANwAAIAJBMGogA0EQaikAADcAACACQShqIANBCGopAAA3AAAgBEFAayEEIANBIGogB0cNAQsLIAxBIGtBBXZBAWohBAsgAUEIaiAAQQhqIgJBCGopAwA3AwAgAUEQaiACQRBqKQMANwMAIAFBGGogAkEYaikDADcDACABIAQ2AoABIAEgAikDADcDACABQSBqIAFB6A5qIgJB4AAQ3wEaIAAgBjYCACAFIAg2AgAgAUHsDmogAUGAARDfARpB0YDDAC0AABpBkA8QJyIARQ0BIABBADYCCCAAQoGAgIAQNwMAIABBDGogAkGEARDfARogACAQNwOgASAAIAk6AJoBIAAgCjoAmQEgACALOgCYASAAIA83A5ABIABBqAFqIAFBgAFqQeQNEN8BGiABQfAPaiQAIABBCGoPCxDWAQALAAsQ2AEAC0GskcAAQS9B4IDAABCjAQALqAcBIn8jAEFAaiIBJAAgAUE4aiICQgA3AwAgAUEwaiIDQgA3AwAgAUEoaiIEQgA3AwAgAUIANwMgIAFBIGoQZiABIAEtACAiBToAHyABIAEtACEiBjoAHiABIAEtACIiBzoAHSABIAEtACMiCDoAHCABIAEtACQiCToAGyABIAEtACUiCjoAGiABIAEtACYiCzoAGSABIAEtACciDDoAGCABIAQtAAAiBDoAFyABIAEtACkiDToAFiABIAEtACoiDjoAFSABIAEtACsiDzoAFCABIAEtACwiEDoAEyABIAEtAC0iEToAEiABIAEtAC4iEjoAESABIAEtAC8iEzoAECABIAMtAAAiAzoADyABIAEtADEiFDoADiABIAEtADIiFToADSABIAEtADMiFjoADCABIAEtADQiFzoACyABIAEtADUiGDoACiABIAEtADYiGToACSABIAEtADciGjoACCABIAItAAAiGzoAByABIAEtADkiHDoABiABIAEtADoiHToABSABIAEtADsiHjoABCABIAEtADwiHzoAAyABIAEtAD0iIDoAAiABIAEtAD4iIToAASABIAEtAD8iIjoAAEHRgMMALQAAGkEgECciAkUEQAALIAIgIjoAHyACICE6AB4gAiAgOgAdIAIgHzoAHCACIB46ABsgAiAdOgAaIAIgHDoAGSACIBs6ABggAiAaOgAXIAIgGToAFiACIBg6ABUgAiAXOgAUIAIgFjoAEyACIBU6ABIgAiAUOgARIAIgAzoAECACIBM6AA8gAiASOgAOIAIgEToADSACIBA6AAwgAiAPOgALIAIgDjoACiACIA06AAkgAiAEOgAIIAIgDDoAByACIAs6AAYgAiAKOgAFIAIgCToABCACIAg6AAMgAiAHOgACIAIgBjoAASACIAU6AAAgAUEAOgAfIAFBADoAHiABQQA6AB0gAUEAOgAcIAFBADoAGyABQQA6ABogAUEAOgAZIAFBADoAGCABQQA6ABcgAUEAOgAWIAFBADoAFSABQQA6ABQgAUEAOgATIAFBADoAEiABQQA6ABEgAUEAOgAQIAFBADoADyABQQA6AA4gAUEAOgANIAFBADoADCABQQA6AAsgAUEAOgAKIAFBADoACSABQQA6AAggAUEAOgAHIAFBADoABiABQQA6AAUgAUEAOgAEIAFBADoAAyABQQA6AAIgAUEAOgABIAFBADoAACAAQSA2AgQgACACNgIAIAFBQGskAAvZBgEJfyMAQeADayIDJAACQAJAIAJBIEYEQCADQQJqIAFBAmoiAi0AADoAACADQQ9qIAFBD2oiBikAADcAACADQR9qIAFBH2oiBy0AADoAACADIAEvAAA7AQAgAyABKAADNgADIAMgASkABzcAByADIAEpABc3ABcgAS0ABiEIIAEtAAUhCSABLQAEIQogAS0AAyELIANBgAJqIgQgAxA+IANBwAJqIgUgBBA3IANBQGsgBRBlIANB4ABqIAVBoAEQ3wEaIAQQaSADIAs6AD0gAyAKOgA8IAMgCToAOyADIAg6ADogAyABLQAAOgDAAiADIAEtAAE6AIACIAMgAi0AADoAPiADIAEtAAc6ADkgAyABLQAIOgA4IAMgAS0ACToANyADIAEtAAo6ADYgAyABLQALOgA1IAMgAS0ADDoANCADIAEtAA06ADMgAyABLQAOOgAyIAMgBi0AADoAMSADIAEtABA6ADAgAyABLQAROgAvIAMgAS0AEjoALiADIAEtABM6AC0gAyABLQAUOgAsIAMgAS0AFToAKyADIAEtABY6ACogAyABLQAXOgApIAMgAS0AGDoAKCADIAEtABk6ACcgAyABLQAaOgAmIAMgAS0AGzoAJSADIAEtABw6ACQgAyABLQAdOgAjQdGAwwAtAAAaIAMgAS0AHjoA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AGpB/wFxQTBPDQIMAQsgBEGPf0oNAQsgAiADQQJqIgRNBEBCACEJDAULIAEgBGosAABBv39KDQJCACEJIANBA2oiBCACTw0EIAEgBGosAABBv39MDQVCgICAgIDgAAwDC0KAgICAgCAMAgtCACEJIANBAmoiBCACTw0CIAEgBGosAABBv39MDQMLQoCAgICAwAALIQpCgICAgBAhCQsgACAKIAOthCAJhDcCBCAAQQE2AgAPCyAEQQFqIQMMAgsgA0EBaiEDDAELIAIgA00NAANAIAEgA2osAABBAEgNASACIANBAWoiA0cNAAsMAgsgAiADSw0ACwsgACACNgIIIAAgATYCBCAAQQA2AgALuAUCAX8GfiMAQYABayIDJAAgA0EwaiABEFYgAyADKQNgIAMpA1ggAykDUCIEQhqIfCIHQhmIfCIFp0H///8fcTYCICADIAMpA0AgAykDOCADKQMwIghCGoh8IglCGYh8IganQf///x9xNgIQIAMgAykDaCAFQhqIfCIFp0H///8PcTYCJCADIAMpA0ggBkIaiHwiBqdB////D3E2AhQgAyADKQNwIAVCGYh8IgWnQf///x9xNgIoIAMgB0L///8PgyAEQv///x+DIAZCGYh8IgRCGoh8PgIcIAMgBKdB////H3E2AhggAyADKQN4IAVCGoh8IgSnQf///w9xNgIsIAMgCUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAkEBayEBA0AgA0EwaiADQQhqEFYgAyADKQNgIAMpA1ggAykDUCIEQhqIfCIHQhmIfCIFp0H///8fcTYCICADIAMpA0AgAykDOCADKQMwIghCGoh8IglCGYh8IganQf///x9xNgIQIAMgAykDaCAFQhqIfCIFp0H///8PcTYCJCADIAMpA0ggBkIaiHwiBqdB////D3E2AhQgAyADKQNwIAVCGYh8IgWnQf///x9xNgIoIAMgB0L///8PgyAEQv///x+DIAZCGYh8IgRCGoh8PgIcIAMgBKdB////H3E2AhggAyADKQN4IAVCGoh8IgSnQf///w9xNgIsIAMgCUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAUEBayIBDQALIAAgAykCCDcCACAAQSBq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IAMgARB7DAELQQELIQAgA0EBaiEDIAVBAWsiBQ0ACwtBASEDIABFBEAgASgCFEGynsAAQQEgASgCGCgCDBEAACEDCyACQUBrJAAgAwu3BAEPfyMAQRBrIgIgASgCICABKAIcIAEoAhggASgCFCABKAIQIAEoAgwgASgCCCABKAIEIAEoAgBB7afX5wFrIgNBH3VqQdKxzARrIgRBH3VqQZbrnO8BayIFQR91akHF+s7vAWsiBkEfdWpBzQJrIgdBH3VqIghBH3VqIglBH3VqIgpBH3VqQYCAQGoiC0EfdSIBNgIMIAIoAgwhDCACIAE2AgwgAigCDCENIAIgATYCDCACKAIMIQ4gAiABNgIMIAIoAgwhDyACIAE2AgwgAigCDCEQIAIgATYCDCACKAIMGiACIAE2AgwgAigCDBogAiABNgIMIAIoAgwaIAIgATYCDCACKAIMIQEgACAKQf////8BcSAJQf////8BcSAIQf////8BcSAHQf////8BcSAGQf////8BcSAFQf////8BcSAEQf////8BcSADQf////8BcSAMQe2n1+cBcWoiAkEddmogDUHSscwEcWoiA0EddmogDkGW65zvAXFqIgRBHXZqIA9BxfrO7wFxaiIFQR12aiAQQc0CcWoiBkEddmoiB0EddmoiCEEddmoiCUH/////AXE2AhwgACAIQf////8BcTYCGCAAIAdB/////wFxNgIUIAAgBkH/////AXE2AhAgACAFQf////8BcTYCDCAAIARB/////wFxNgIIIAAgA0H/////AXE2AgQgACACQf////8BcTYCACAAIAsgCUEddmogAUGAgMAAcWpB/////wFxNgIgC7wDAgx/AX4jAEEQayIIJAAgAwRAA0AgAyADQRAgA0EQSSIEGyIFayEDIAIgBWoCQCAERQRAIAEgAkEAEGAMAQsgBSAIakEQIAVrEN4BIAggAiAFEN8BIQJBAToAACABIAJBARBgCyECIAMNAAsLIAAgASgCJCABKAI0IAEoAjAgASgCLCABKAIoIgJBGnZqIgNBGnZqIgVBGnZqIgdBGnZBBWxqIgRB////H3EiBkEFaiIJQRp2IAJB////H3EgBEEadmoiAmoiBEEadiADQf///x9xIgpqIgtBGnYgBUH///8fcSIFaiIMQRp2IAdB////H3FqIg1BgICAIGsiDkEfdkEBayIPQf///x9xIgMgBHEgAiAOQR91IgJxciIEQRp0IAIgBnEgAyAJcXJyIgYgASgCAGoiCTYAACAAIAYgCUutIAE1AgQgAyALcSACIApxciIGQRR0IARBBnZyrXx8IhA+AAQgACABNQIIIAMgDHEgAiAFcXIiA0EOdCAGQQx2cq18IBBCIIh8IhA+AAggACABNQIMIA0gD3EgAiAHcXJBCHQgA0ESdnKtfCAQQiCIfD4ADCAIQRBqJAALxwMCDX4DfyAAIAAoAiggASgAA0ECdkH///8fcWqtIgMgACgCFCIQrSILfiAAKAIkIAEoAABB////H3FqrSIFIAAoAhgiEa0iDX58IAAoAiwgASgABkEEdkH///8fcWqtIgYgADUCECIHfnwgACgCMCABKAAJQQZ2aq0iCCAAKAIgIhJBBWytIgR+fCAAKAI0QQBBgICACCACG2ogASgADEEIdmqtIgkgACgCHCIBQQVsrSIKfnwgAyAHfiAFIAt+fCAEIAZ+fCAIIAp+fCAJIBFBBWytIgx+fCADIAR+IAUgB358IAYgCn58IAggDH58IAkgEEEFbK1+fCIKQhqIQv////8Pg3wiDEIaiEL/////D4N8Ig6nQf///x9xNgIsIAAgAyANfiAFIAGtIg9+fCAGIAt+fCAHIAh+fCAEIAl+fCAOQhqIQv////8Pg3wiBKdB////H3E2AjAgACADIA9+IAUgEq1+fCAGIA1+fCAIIAt+fCAHIAl+fCAEQhqIQv////8Pg3wiA6dB////H3E2AjQgACADQhqIp0EFbCAKp0H///8fcWoiAUH///8fcTYCJCAAIAynQf///x9xIAFBGnZqNgIoC+EDAgZ+Dn8gAigCJCEJIAEoAiQhCiACKAIgIQsgASgCICEMIAIoAgwhDSABKAIMIQ4gAigCHCEPIAEoAhwhECACKAIIIREgASgCCCESIAIoAgQhEyABKAIEIRQgAigCACEVIAEoAgAhFiAAIAEoAhggAigCGGtB8P///wNqrSABKAIUIAIoAhRrQfD///8Baq0gASgCECACKAIQa0Hw////A2qtIgNCGoh8IgZCGYh8IgSnQf///x9xNgIYIAAgEiARa0Hw////A2qtIBQgE2tB8P///wFqrSAWIBVrQdD9//8Daq0iB0IaiHwiCEIZiHwiBadB////H3E2AgggACAQIA9rQfD///8Baq0gBEIaiHwiBKdB////D3E2AhwgACAOIA1rQfD///8Baq0gBUIaiHwiBadB////D3E2AgwgACAMIAtrQfD///8Daq0gBEIZiHwiBKdB////H3E2AiAgACAGQv///w+DIANC////H4MgBUIZiHwiA0IaiHw+AhQgACADp0H///8fcTYCECAAIAogCWtB8P///wFqrSAEQhqIfCIDp0H///8PcTYCJCAAIAhC////D4MgA0IZiEITfiAHQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC9cDAgV/A34jAEHgD2siAyQAIANBCGpBzIzAACkCACIINwMAIANBEGpB1IzAACkCACIJNwMAIANBGGpB3IzAACkCACIKNwMAIANBuA9qQgA3AwAgA0GwD2pCADcDACADQagPakIANwMAIANBoA9qQgA3AwAgA0GYD2oiBUIANwMAIANBkA9qIgZCADcDACADQYgPaiIHQgA3AwAgA0HID2ogCDcDACADQdAPaiAJNwMAIANB2A9qIAo3AwAgA0HEjMAAKQIAIgg3AwAgA0IANwOADyADIAg3A8APIANBIGogA0GAD2oiBEHgABDfARogA0GHAWpBADYAACADQgA3A4ABIANBADYCmAEgA0IANwOQASAEIAMgASACEC0QNUHRgMMALQAAGgJAAkBBIBAnIgQEQCAEIAMpAIAPNwAAIARBGGogBSkAADcAACAEQRBqIAYpAAA3AAAgBEEIaiAHKQAANwAAIAIEQCABQQRrKAIAIgVBeHEiBkEEQQggBUEDcSIFGyACakkNAiAFQQAgBiACQSdqSxsNAyABEEULIABBIDYCBCAAIAQ2AgAgA0HgD2okAA8LAAtBrfXCAEEuQdz1wgAQowEAC0Hs9cIAQS5BnPbCABCjAQALyAMCBH8DfiMAQeAPayIDJAAgA0EIakHMjMAAKQIAIgc3AwAgA0EQakHUjMAAKQIAIgg3AwAgA0EYakHcjMAAKQIAIgk3AwAgA0G4D2pCADcDACADQbAPakIANwMAIANBqA9qQgA3AwAgA0GgD2pCADcDACADQZgPakIANwMAIANBkA9qIgVCADcDACADQYgPaiIGQgA3AwAgA0HID2ogBzcDACADQdAPaiAINwMAIANB2A9qIAk3AwAgA0HEjMAAKQIAIgc3AwAgA0IANwOADyADIAc3A8APIANBIGogA0GAD2oiBEHgABDfARogA0GHAWpBADYAACADQgA3A4ABIANBADYCmAEgA0IANwOQASAEIAMgASACEC0QNUHRgMMALQAAGgJAAkBBGBAnIgQEQCAEIAMpAIAPNwAAIARBEGogBSkAADcAACAEQQhqIAYpAAA3AAAgAgRAIAFBBGsoAgAiBUF4cSIGQQRBCCAFQQNxIgUbIAJqSQ0CIAVBACAGIAJBJ2pLGw0DIAEQRQsgAEEYNgIEIAAgBDYCACADQeAPaiQADwsAC0Gt9cIAQS5B3PXCABCjAQALQez1wgBBLkGc9sIAEKMBAAu6AwEFfwJAAkACQAJAAn8CQCACQcAARgRAQdGAwwAtAAAaIAEoAAMhAkHAABAnIgMNAQALQQEhBEG0iMAAQRgQACEGQQAgAkUNARogAUEEaygCACIFQXhxIgdBBEEIIAVBA3EiBRsgAmpJDQIgBUEAIAcgAkEnaksbDQMgARBFQQAMAQsgAyABLwAAOwAAIANBAmogAUECai0AADoAACADIAI2AAMgA0E/aiABQT9qLQAAOgAAIANBN2ogAUE3aikAADcAACADQS9qIAFBL2opAAA3AAAgA0EnaiABQSdqKQAANwAAIANBH2ogAUEfaikAADcAACADQRdqIAFBF2opAAA3AAAgA0EPaiABQQ9qKQAANwAAIAMgASkABzcAByABQQRrKAIAIgJBeHEiBEHEAEHIACACQQNxIgIbSQ0DIAJBACAEQegATxsNBCABEEVBACEEQcAACyEBIAAgBDYCDCAAIAY2AgggACABNgIEIAAgAzYCAA8LQa31wgBBLkHc9cIAEKMBAAtB7PXCAEEuQZz2wgAQowEAC0Gt9cIAQS5B3PXCABCjAQALQez1wgBBLkGc9sIAEKMBAAvfAgEHfyMAQdABayICJAAgAkGAAWoiAyABQdAAahA7IAJB0ABqIAJBoAFqKQIANwMAIAJByABqIAJBmAFqKQIANwMAIAJBQGsiByACQZABaikCADcDACACQThqIgggAkGIAWopAgA3AwAgAiACKQKAATcDMCACQfgAaiACQcgBaikCADcDACACQfAAaiACQcABaikCADcDACACQegAaiACQbgBaikCADcDACACQeAAaiACQbABaikCADcDACACIAIp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OgAAQfz8wgBBADYCAAsgAEEgaiQADAYLIABBADYCGCAAQQE2AgwgAEHg9sIANgIIIABCBDcCECAAQQhqQYT3wgAQpgEACyAAQQA2AhggAEEBNgIMIABBwILAADYCCAwDCyAAQQA2AhggAEEBNgIMIABBgILAADYCCAwCC0GUg8AAENEBAAsACyAAQgQ3AhAgAEEIakGsj8AAEKYBAAsLIAFBEGokAAstAAJAIANpQQFHQYCAgIB4IANrIAFJckUEQCAAIAEgAyACEEoiAA0BCwALIAALIwEBfyAAKAIAIgAgAEEfdSICcyACa60gAEF/c0EfdiABEHULJQAgAEUEQEGn8sIAQTIQ1wEACyAAIAIgAyAEIAUgASgCEBEKAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBENAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBEJAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBEWAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBEYAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBEaAAshACAARQRAQafywgBBMhDXAQALIAAgAiADIAEoAhARAwALHwAgAEUEQEGn8sIAQTIQ1wEACyAAIAIgASgCEBEBAAscACAAKAIAIgAoAgAgASAAQQRqKAIAKAIQEQEACxgAIAEgACgCACIAKAIAIABBBGooAgAQOAvcBgENfyAAKAIAIQcgACgCBCEDIAEoAhQhCSABKAIYIQtBACEAQQAhASMAQRBrIgQkAEEBIQwCQCAJQSIgCygCECINEQEADQACQCADRQRAQQAhAwwBCyAHIQUgAyEGAkACQANAIAUgBmohDkEAIQACQANAIAAgBWoiCC0AACIKQf8Aa0H/AXFBoQFJIApBIkZyIApB3ABGcg0BIAYgAEEBaiIARw0ACyACIAZqIQIMAwsgACACaiECAkACQAJAIAgsAAAiAEEATgRAIAhBAWohBSAAQf8BcSEADAELIAgtAAFBP3EhBSAAQR9xIQYgAEFfTQRAIAZBBnQgBXIhACAIQQJqIQUMAQsgCC0AAkE/cSAFQQZ0ciEKIABBcEkEQCAKIAZBDHRyIQAgCEEDaiEFDAELIAhBBGoh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AjwgBSAFQRhqrUKAgICA8ACENwNgIAUgBUEQaq1CgICAgPAAhDcDWCAFIAVBDGqtQoCAgIAQhDcDUCAFIAVBCGqtQoCAgIAQhDcDSAwDCyADIAdB+KXAABCaAQALIAQQ0QEACyAAIAEgAyABIAQQwwEACyAFIAVByABqNgI4IAVBMGogBBCmAQALFAAgACgCACABIAAoAgQoAhARAQALDQAgAEUEQBCnAQALAAsQACABIAAoAgQgACgCCBA4CxAAIAEgACgCACAAKAIEEDgLIQAgAEL6hJyDstaplFM3AwggAEL0qajcsoPpgod/NwMACxAAIAEoAhQgASgCGCAAEFgLIAAgAELPkYaA866RtgU3AwggAEKF4Z+i68irjmM3AwALIAAgAEKQx4yUopiKpQ43AwggAELn+MPj/N3QpgY3AwALEwAgAEEoNgIEIABB5PLCADYCAAsTACAAQbT3wgA2AgQgACABNgIACyIAIABC7bqtts2F1PXjADcDCCAAQviCmb2V7sbFuX83AwALIAAgAELakJn3/vvw5y43AwggAEL239fl4aeXtCY3AwALFgBB2IDDACAANgIAQdSAwwBBAToAAAsPAEHGm8AAQSsgABCjAQALDQAgADUCAEEBIAEQdQsNACAAKQMAQQEgARB1CwsAIAAjAGokACMACw0AIABBpIPAACABEFgLDQBBuPnCAEEbENcBAAsJACAAIAEQIQALDgBB0/nCAEHPABDXAQALDQAgAEG8j8AAIAEQWAsNACAAQYiewAAgARBYCw0AIABB7PTCACABEFgLQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIABBAWohACABQQFqIQEgAkEBayICDQEMAgsLIAQgBWshAwsgAwuUBQEIfwJAAn8CQCACIgYgACABa0sEQCABIAJqIgMhBSAAIAJqIQIgACAGQRBJDQIaIAJBfHEhBEEAIAJBA3EiB2shCCAHBEAgA0EBayEDA0AgAkEBayICIAMtAAA6AAAgA0EBayEDIAIgBEsNAAsLIAQgBiAHayIHQXxxIgZrIQIgBSAIaiIFQQNxBEAgBkEATA0CIAVBA3QiA0EYcSEIIAVBfHEiCUEEayEBQQAgA2tBGHEhCiAJKAIAIQMDQCAEQQRrIgQgAyAKdCABKAIAIgMgCHZyNgIAIAFBBGshASACIARJDQALDAILIAZBAEwNASABIAdqQQRrIQEDQCAEQQRrIgQgASgCADYCACABQQRrIQEgAiAESQ0ACwwBCwJAIAZBEEkEQCAAIQIMAQsgAEEAIABrQQNxIgVqIQQgBQRAIAAhAiABIQMDQCACIAMtAAA6AAAgA0EBaiEDIAJBAWoiAiAESQ0ACwsgBCAGIAVrIgZBfHEiB2ohAgJAIAEgBWoiBUEDcQRAIAdBAEwNASAFQQN0IgNBGHEhCCAFQXxxIglBBGohAUEAIANrQRhxIQogCSgCACEDA0AgBCADIAh2IAEoAgAiAyAKdHI2AgAgAUEEaiEBIARBBGoiBCACSQ0ACwwBCyAHQQBMDQAgBSEBA0AgBCABKAIANgIAIAFBBGohASAEQQRqIgQgAkkNAAsLIAZBA3EhBiAFIAdqIQELIAZFDQIgAiAGaiEDA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0kNAAsMAgsgB0EDcSIBRQ0BIAUgBmshBSACIAFrCyEDIAVBAWshAQNAIAJBAWsiAiABLQAAOgAAIAFBAWshASACIANLDQALCyAAC58BAQN/AkAgASICQRBJBEAgACEBDAELIABBACAAa0EDcSIEaiEDIAQEQCAAIQEDQCABQQA6AAAgAUEBaiIBIANJDQALCyADIAIgBGsiAkF8cSIEaiEBIARBAEoEQANAIANBADYCACADQQRqIgMgAUkNAAsLIAJBA3EhAgsgAgRAIAEgAmohAgNAIAFBADoAACABQQFqIgEgAkkNAAsLIAALuAIBB38CQCACIgRBEEkEQCAAIQIMAQsgAEEAIABrQQNxIgNqIQUgAwRAIAAhAiABIQYDQCACIAYtAAA6AAAgBkEBaiEGIAJBAWoiAiAFSQ0ACwsgBSAEIANrIghBfHEiB2ohAgJAIAEgA2oiA0EDcQRAIAdBAEwNASADQQN0IgRBGHEhCSADQXxxIgZBBGohAUEAIARrQRhxIQQgBigCACEGA0AgBSAGIAl2IAEoAgAiBiAEdHI2AgAgAUEEaiEBIAVBBGoiBSACSQ0ACwwBCyAHQQBMDQAgAyEBA0AgBSABKAIANgIAIAFBBGohASAFQQRqIgUgAkkNAAsLIAhBA3EhBCADIAdqIQELIAQEQCACIARqIQMDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADSQ0ACwsgAAsJACAAQQA2AgALAgALC9/7Ag4AQYCAwAALuQMvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hcnJheXZlYy0wLjcuNi9zcmMvYXJyYXl2ZWMucnMAABAAYAAAAHsEAAAPAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvY3J5cHRvX3NlY3JldGJveC0wLjEuMS9zcmMvbGliLnJzT25jZSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkAAAA0wAQACoAAABvbmUtdGltZSBpbml0aWFsaXphdGlvbiBtYXkgbm90IGJlIHBlcmZvcm1lZCByZWN1cnNpdmVseQgBEAA4AAAAL3J1c3RjLzA1MTQ3ODk1NzM3MWVlMDA4NGE3YzA5MTM5NDFkMmE4YzQ3NTdiYjkvbGlicmFyeS9zdGQvc3JjL3N5bmMvb25jZS5yc0gBEABMAAAAlQAAADIAAAAkAAAADAAAAAQAAAAlAAAAJgAAACcAQcSDwAALoQEBAAAAKAAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JzNTgtMC41LjEvc3JjL2VuY29kZS5ycwAAzAEQAFoAAADQAQAAGwAAAMwBEABaAAAA0QEAABAAAADMARAAWgAAAMwBAAAJAAAAzAEQAFoAAAC5AQAAIABB8ITAAAudAQEAAAApAAAAzAEQAFoAAAA9AQAAIAAAAGRlc3QgaXMgb3V0IG9mIGJvdW5kcwAAAIgCEAAVAAAAQnVmZmVyVG9vU21hbGxVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlbkZyb21VdGY4RXJyb3JieXRlc2Vycm9yU29tZQAAKgAAABQAAAAEAAAAKwAAAMwBEABaAAAAkwAAACsAQZiGwAAL2goBAAAALAAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2NpcGhlci0wLjQuNC9zcmMvc3RyZWFtLnJzIAMQAFwAAAB4AAAAJwAAAFN0cmVhbUNpcGhlckVycm9yAAAAcAAQAGMAAAD9AAAAGQAAAHAAEABjAAAAAgEAACEAAABwABAAYwAAAAUBAAAYAAAASW52YWxpZCBrZXkgbGVuZ3RoSW52YWxpZCBub25jZSBsZW5ndGhJbnZhbGlkIHNlYWxlciBzZWNyZXQgZm9ybWF0OiBtdXN0IHN0YXJ0IHdpdGggJ3NlYWxlclNlY3JldF96J0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aEludmFsaWQgdmVyaWZ5aW5nIGtleTogAEwEEAAXAAAASW52YWxpZCBwdWJsaWMga2V5OiBsBBAAFAAAAFdyb25nIHRhZ0ZhaWxlZCB0byBjcmVhdGUgY2lwaGVySW52YWxpZCAgZm9ybWF0OiBtdXN0IHN0YXJ0IHdpdGggJycAqAQQAAgAAACwBBAAGgAAAMoEEAABAAAASW52YWxpZCBiYXNlNTg6IOQEEAAQAAAAa2V5U2VjcmV0X3r/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpzZWFsZXJTZWNyZXRfenNlYWxlcl96c2lnbmVyU2VjcmV0X3pzaWduZXIgc2VjcmV0c2lnbmF0dXJlX3oAAADyBRAACwAAAHNpZ25hdHVyZXNpZ25lcl96c2lnbmVyIElEAAARBhAACAAAAHNlYWxlciBzZWNyZXQAAADPBRAACAAAAGfmCWqFrme7cvNuPDr1T6V/Ug5RjGgFm6vZgx8ZzeBbYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkSW52YWxpZCBzaWduaW5nIGtleSBsZW5ndGhJbnZhbGlkIHZlcmlmeWluZyBrZXkgbGVuZ3RoSW52YWxpZCBVVEYtOCBpbiBzZWNyZXQ6IAAA2QYQABkAAABJbnZhbGlkIFVURi04IGluIHNpZ25hdHVyZTog/AYQABwAAABJbnZhbGlkIFVURi04IGluIGlkOiAAAAAgBxAAFQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2NvbnNvbGVfZXJyb3JfcGFuaWNfaG9vay0wLjEuNy9zcmMvbGliLnJzAEAHEABrAAAAlQAAAA4AAAAtAAAADAAAAAQAAAAuAAAALwAAADAAAABjYXBhY2l0eSBvdmVyZmxvdwAAANQHEAARAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc/AHEAAcAAAAGQAAAAUAAABhIGZvcm1hdHRpbmcgdHJhaXQgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3Igd2hlbiB0aGUgdW5kZXJseWluZyBzdHJlYW0gZGlkIG5vdABB/JDAAAuFAgEAAAAxAAAAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzhAgQABgAAAB7AgAADgAAAEFycmF5VmVjOiBjYXBhY2l0eSBleGNlZWRlZCBpbiBleHRlbmQvZnJvbV9pdGVyAAAAAAAEAAAABAAAADIAAABpbnN1ZmZpY2llbnQgY2FwYWNpdHkAAADsCBAAFQAAAENhcGFjaXR5RXJyb3I6IAAMCRAADwAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAAAAAACAAAAABAAAAMwAAAAAAAAAEAAAABAAAADQAAABtaWQgPiBsZW4AAABwCRAACQBBkJPAAAurBy9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JsYWtlMy0xLjguMS9zcmMvbGliLnJzAAAAkAkQAFkAAAALAgAAEQAAAJAJEABZAAAAvgIAAAoAAACQCRAAWQAAAOwCAAAMAAAAkAkQAFkAAADsAgAAKAAAAJAJEABZAAAA3AIAABcAAACQCRAAWQAAABgDAAAfAAAAkAkQAFkAAAA1AwAADAAAAJAJEABZAAAAPAMAABIAAACQCRAAWQAAAGADAAAhAAAAkAkQAFkAAAB1BAAAMgAAAJAJEABZAAAAfQQAABsAAACQCRAAWQAAAKQEAAAXAAAAdGhlIHN1YnRyZWUgc3RhcnRpbmcgYXQgIGNvbnRhaW5zIGF0IG1vc3QgIGJ5dGVzIChmb3VuZCCsChAAGAAAAMQKEAASAAAA1goQAA4AAABMuhAAAQAAAJAJEABZAAAAtgQAAA0AAACQCRAAWQAAABMFAAAbAAAAkAkQAFkAAAAlBQAAGwAAAJAJEABZAAAAVgUAABIAAACQCRAAWQAAAGAFAAASAAAAc2V0X2lucHV0X29mZnNldCBtdXN0IGJlIHVzZWQgd2l0aCBmaW5hbGl6ZV9ub25fcm9vdFQLEAA0AAAAkAkQAFkAAABxBQAACQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JzNTgtMC41LjEvc3JjL2RlY29kZS5ycwAAoAsQAFoAAADAAQAACwAAAKALEABaAAAArAEAACAAAABidWZmZXIgcHJvdmlkZWQgdG8gZGVjb2RlIGJhc2U1OCBlbmNvZGVkIHN0cmluZyBpbnRvIHdhcyB0b28gc21hbGxwcm92aWRlZCBzdHJpbmcgY29udGFpbmVkIGludmFsaWQgY2hhcmFjdGVyICBhdCBieXRlIABeDBAALAAAAIoMEAAJAAAAcHJvdmlkZWQgc3RyaW5nIGNvbnRhaW5lZCBub24tYXNjaWkgY2hhcmFjdGVyIHN0YXJ0aW5nIGF0IGJ5dGUgAKQMEAA/AAAANQAAAAwAAAAEAAAANgAAADcAAAA4AAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQBBxJrAAAvVAQEAAAAoAAAAL3J1c3RjLzA1MTQ3ODk1NzM3MWVlMDA4NGE3YzA5MTM5NDFkMmE4YzQ3NTdiYjkvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAEwNEABLAAAAAwoAAA4AAAAKClN0YWNrOgoKLi4wMTIzNDU2Nzg5YWJjZGVmOltjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAAAAAQAA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dHVhdGlvblNlY1JhbmRvbUNvcHlCeXRlczogaU9TIFNlY3VyaXR5IGZyYW1ld29yayBmYWlsdXJlUnRsR2VuUmFuZG9tOiBXaW5kb3dzIHN5c3RlbSBmdW5jdGlvbiBmYWlsdXJlUkRSQU5EOiBmYWlsZWQgbXVsdGlwbGUgdGltZXM6IENQVSBpc3N1ZSBsaWtlbHlSRFJBTkQ6IGluc3RydWN0aW9uIG5vdCBzdXBwb3J0ZWRXZWIgQ3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZUNhbGxpbmcgV2ViIEFQSSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGZhaWxlZHJhbmRTZWN1cmU6IFZ4V29ya3MgUk5HIG1vZHVsZSBpcyBub3QgaW5pdGlhbGl6ZWROb2RlLmpzIGNyeXB0byBDb21tb25KUyBtb2R1bGUgaXMgdW5hdmFpbGFibGVDYWxsaW5nIE5vZGUuanMgQVBJIGNyeXB0by5yYW5kb21GaWxsU3luYyBmYWlsZWROb2RlLmpzIEVTIG1vZHVsZXMgYXJlIG5vdCBkaXJlY3RseSBzdXBwb3J0ZWQsIHNlZSBodHRwczovL2RvY3MucnMvZ2V0cmFuZG9tI25vZGVqcy1lcy1tb2R1bGUtc3VwcG9ydGNyeXB0b2Nsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkcmV0dXJuIHRoaXNkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5AQAAAAAAAABFcnJvcjogAJS5EAAHAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcmFuZF9jb3JlLTAuNi40L3NyYy9vcy5ycwCkuRAAWwAAAD8AAAANAAAAAAAAAAQAAAAEAAAASAAAAAAAAAAEAAAABAAAAEkAAABIAAAAELoQAD8AAABKAAAAQQAAAD8AAABCAAAAKU5vbmUgfXNpZ25hdHVyZSBlcnJvcjogYroQAAIAAABLAAAADAAAAAQAAABMAAAATQAAAE4AAAAvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi42L3NyYy9kbG1hbGxvYy5yc2Fzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQAhLoQACkAAACoBAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplIDw9IHNpemUgKyBtYXhfb3ZlcmhlYWQAAIS6EAApAAAArgQAAA0AAABjYW5ub3QgbW9kaWZ5IHRoZSBwYW5pYyBob29rIGZyb20gYSBwYW5pY2tpbmcgdGhyZWFkLLsQADQAAABsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzaLsQABwAAACGAAAACQAAAGi7EAAcAAAAiwIAAB4AAABLAAAADAAAAAQAAABPAAAAAAAAAAgAAAAEAAAAUAAAAAAAAAAIAAAABAAAAFEAAABSAAAAUwAAABAAAAAEAAAAVAAAAFUAAABMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAOy7EAAqAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAILwQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AACQvBAADgAAACC8EABdAAAAegIAAA0AAABudWxsIHBvaW50ZXIgcGFzc2VkIHRvIHJ1c3RyZWN1cnNpdmUgdXNlIG9mIGFuIG9iamVjdCBkZXRlY3RlZCB3aGljaCB3b3VsZCBsZWFkIHRvIHVuc2FmZSBhbGlhc2luZyBpbiBydXN0AAAnAAAAJgAAABQAAAAyAAAALQAAAC8AAAAhAAAAHQAAAC0AAAAnAAAAJwAAADEAAAAtAAAAMAAAAGUAAADUthAA+7YQACG3EAA1txAAZ7cQAJS3EADDtxAA5LcQAAG4EADUthAA1LYQAC64EABfuBAAjLgQALy4EAAnAAAAJgAAABQAAAAyAAAALQAAAC8AAAAhAAAAHQAAAC0AAAAnAAAAJwAAADEAAAAtAAAAMAAAAGUAAADUthAA+7YQACG3EAA1txAAZ7cQAJS3EADDtxAA5LcQAAG4EADUthAA1LYQAC64EABfuBAAjLgQALy4EABBlPzCAAs1AwAAAEMAAAACAAAAAAAAAEQAAAACAAAAAAAAAEUAAAACAAAAAAAAAEYAAAACAAAAAAAAAEcAQeT8wgALAVYASAlwcm9kdWNlcnMBDHByb2Nlc3NlZC1ieQIGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4TMC4yLjEwMCAoMjQwNWVjMmI0KQ==";

// node_modules/.pnpm/jazz-crypto-rs@0.0.7/node_modules/jazz-crypto-rs/dist/esm/src/index.mjs
var output = void 0;
async function initialize() {
  return output ?? (output = await __wbg_init({ module_or_path: data }));
}

// node_modules/.pnpm/@noble+ciphers@0.1.4/node_modules/@noble/ciphers/esm/utils.js
var u8a = (a) => a instanceof Uint8Array;
var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes2(data2);
  if (!u8a(data2))
    throw new Error(`expected Uint8Array, got ${typeof data2}`);
  return data2;
}
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function ensureBytes(b, len) {
  if (!(b instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  if (typeof len === "number") {
    if (b.length !== len)
      throw new Error(`Uint8Array length ${len} expected`);
  }
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    throw new Error("equalBytes: Different size of Uint8Arrays");
  let isSame = true;
  for (let i = 0; i < a.length; i++)
    isSame && (isSame = a[i] === b[i]);
  return isSame;
}

// node_modules/.pnpm/@noble+ciphers@0.1.4/node_modules/@noble/ciphers/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = { number, bool, bytes, hash, exists, output: output2 };
var assert_default = assert;

// node_modules/.pnpm/@noble+ciphers@0.1.4/node_modules/@noble/ciphers/esm/_salsa.js
var sigma16 = utf8ToBytes2("expand 16-byte k");
var sigma32 = utf8ToBytes2("expand 32-byte k");
var sigma16_32 = u322(sigma16);
var sigma32_32 = u322(sigma32);
var isAligned32 = (b) => !(b.byteOffset % 4);
var salsaBasic = (opts) => {
  const { core, rounds, counterRight, counterLen, allow128bitKeys, extendNonceFn, blockLen } = checkOpts({ rounds: 20, counterRight: false, counterLen: 8, allow128bitKeys: true, blockLen: 64 }, opts);
  assert_default.number(counterLen);
  assert_default.number(rounds);
  assert_default.number(blockLen);
  assert_default.bool(counterRight);
  assert_default.bool(allow128bitKeys);
  const blockLen32 = blockLen / 4;
  if (blockLen % 4 !== 0)
    throw new Error("Salsa/ChaCha: blockLen should be aligned to 4 bytes");
  return (key, nonce, data2, output3, counter = 0) => {
    assert_default.bytes(key);
    assert_default.bytes(nonce);
    assert_default.bytes(data2);
    if (!output3)
      output3 = new Uint8Array(data2.length);
    assert_default.bytes(output3);
    assert_default.number(counter);
    if (counter < 0 || counter >= 2 ** 32 - 1)
      throw new Error("Salsa/ChaCha: counter overflow");
    if (output3.length < data2.length) {
      throw new Error(`Salsa/ChaCha: output (${output3.length}) is shorter than data (${data2.length})`);
    }
    const toClean = [];
    let k, sigma;
    if (key.length === 32) {
      k = key;
      sigma = sigma32_32;
    } else if (key.length === 16 && allow128bitKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else
      throw new Error(`Salsa/ChaCha: wrong key length=${key.length}, expected`);
    if (extendNonceFn) {
      if (nonce.length <= 16)
        throw new Error(`Salsa/ChaCha: extended nonce should be bigger than 16 bytes`);
      k = extendNonceFn(sigma, k, nonce.subarray(0, 16), new Uint8Array(32));
      toClean.push(k);
      nonce = nonce.subarray(16);
    }
    const nonceLen = 16 - counterLen;
    if (nonce.length !== nonceLen)
      throw new Error(`Salsa/ChaCha: nonce should be ${nonceLen} or 16 bytes`);
    if (nonceLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      toClean.push(nonce = nc);
    }
    const block = new Uint8Array(blockLen);
    const b32 = u322(block);
    const k32 = u322(k);
    const n32 = u322(nonce);
    const d32 = isAligned32(data2) && u322(data2);
    const o32 = isAligned32(output3) && u322(output3);
    toClean.push(b32);
    const len = data2.length;
    for (let pos = 0, ctr = counter; pos < len; ctr++) {
      core(sigma, k32, n32, b32, ctr, rounds);
      if (ctr >= 2 ** 32 - 1)
        throw new Error("Salsa/ChaCha: counter overflow");
      const take = Math.min(blockLen, len - pos);
      if (take === blockLen && o32 && d32) {
        const pos32 = pos / 4;
        if (pos % 4 !== 0)
          throw new Error("Salsa/ChaCha: wrong block position");
        for (let j = 0; j < blockLen32; j++)
          o32[pos32 + j] = d32[pos32 + j] ^ b32[j];
        pos += blockLen;
        continue;
      }
      for (let j = 0; j < take; j++)
        output3[pos + j] = data2[pos + j] ^ block[j];
      pos += take;
    }
    for (let i = 0; i < toClean.length; i++)
      toClean[i].fill(0);
    return output3;
  };
};

// node_modules/.pnpm/@noble+ciphers@0.1.4/node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes2(key);
    ensureBytes(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data2, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data2, offset + 0);
    const t1 = u8to16(data2, offset + 2);
    const t2 = u8to16(data2, offset + 4);
    const t3 = u8to16(data2, offset + 6);
    const t4 = u8to16(data2, offset + 8);
    const t5 = u8to16(data2, offset + 10);
    const t6 = u8to16(data2, offset + 12);
    const t7 = u8to16(data2, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h[i] += c;
      c = h[i] >>> 13;
      h[i] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h[i] + c;
      c = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h[i] = h[i] & mask | g[i];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad[0];
    h[0] = f & 65535;
    for (let i = 1; i < 8; i++) {
      f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
      h[i] = f & 65535;
    }
  }
  update(data2) {
    assert_default.exists(this);
    const { buffer, blockLen } = this;
    data2 = toBytes2(data2);
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data2, pos);
        continue;
      }
      buffer.set(data2.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h[i] >>> 0;
      out[opos++] = h[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes2(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/.pnpm/@noble+ciphers@0.1.4/node_modules/@noble/ciphers/esm/salsa.js
var rotl = (a, b) => a << b | a >>> 32 - b;
function salsaCore(c, k, i, out, cnt, rounds = 20) {
  let y00 = c[0], y01 = k[0], y02 = k[1], y03 = k[2];
  let y04 = k[3], y05 = c[1], y06 = i[0], y07 = i[1];
  let y08 = cnt, y09 = 0, y10 = c[2], y11 = k[4];
  let y12 = k[5], y13 = k[6], y14 = k[7], y15 = c[3];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i2 = 0; i2 < rounds; i2 += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hsalsa(c, key, nonce, out) {
  const k32 = u322(key);
  const i32 = u322(nonce);
  const o32 = u322(out);
  let x00 = c[0], x01 = k32[0], x02 = k32[1], x03 = k32[2], x04 = k32[3];
  let x05 = c[1], x06 = i32[0], x07 = i32[1], x08 = i32[2], x09 = i32[3];
  let x10 = c[2], x11 = k32[4], x12 = k32[5], x13 = k32[6], x14 = k32[7];
  let x15 = c[3];
  for (let i = 0; i < 20; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  o32[0] = x00;
  o32[1] = x05;
  o32[2] = x10;
  o32[3] = x15;
  o32[4] = x06;
  o32[5] = x07;
  o32[6] = x08;
  o32[7] = x09;
  return out;
}
var salsa20 = salsaBasic({ core: salsaCore, counterRight: true });
var xsalsa20 = salsaBasic({
  core: salsaCore,
  counterRight: true,
  extendNonceFn: hsalsa,
  allow128bitKeys: false
});
var xsalsa20_poly1305 = (key, nonce) => {
  const tagLength = 16;
  ensureBytes(key, 32);
  ensureBytes(nonce, 24);
  return {
    tagLength,
    encrypt: (plaintext) => {
      ensureBytes(plaintext);
      const res = new Uint8Array(32 + plaintext.length);
      res.set(plaintext, 32);
      xsalsa20(key, nonce, res, res);
      const authKey = res.subarray(0, 32);
      const tag = poly1305(res.subarray(32), authKey);
      res.set(tag, 16);
      res.subarray(0, 16).fill(0);
      return res.subarray(16);
    },
    decrypt: (ciphertext) => {
      ensureBytes(ciphertext);
      if (ciphertext.length < 16)
        throw new Error("Encrypted data should be at least 16 bytes");
      const c = new Uint8Array(16 + ciphertext.length);
      c.set(ciphertext, 16);
      const authKey = xsalsa20(key, nonce, new Uint8Array(32));
      const tag = poly1305(c.subarray(32), authKey);
      if (!equalBytes(c.subarray(16, 32), tag))
        throw new Error("Wrong tag");
      const decoded = xsalsa20(key, nonce, c);
      decoded.subarray(0, 32).fill(0);
      authKey.fill(0);
      return decoded.subarray(32);
    }
  };
};

// node_modules/.pnpm/@noble+curves@1.9.0/node_modules/@noble/curves/esm/abstract/utils.js
var _0n = BigInt(0);
var _1n = BigInt(1);
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
var hasHexBuiltin = (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
);
var hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  abytes2(bytes2);
  if (hasHexBuiltin)
    return bytes2.toHex();
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes2[bytes2[i]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes2(bytes2);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes2(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n) => (_1n << BigInt(n)) - _1n;
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// node_modules/.pnpm/@noble+curves@1.9.0/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (Z < P && FpIsSquare(_Fp, Z)) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp2, n) {
    if (!FpIsSquare(Fp2, n))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp2.sqr(ge);
      x = Fp2.mul(x, ge);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    return function sqrt3mod4(Fp2, n) {
      const p1div4 = (P + _1n2) / _4n;
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n);
      const c1 = (P - _5n) / _8n;
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(Fp2, num, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp2.ONE;
  if (power === _1n2)
    return num;
  let p = Fp2.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp2.mul(p, d);
    d = Fp2.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp2, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i) => {
    if (Fp2.is0(num))
      return acc;
    inverted[i] = acc;
    return Fp2.mul(acc, num);
  }, Fp2.ONE);
  const invertedAcc = Fp2.inv(multipliedAcc);
  nums.reduceRight((acc, num, i) => {
    if (Fp2.is0(num))
      return acc;
    inverted[i] = Fp2.mul(acc, inverted[i]);
    return Fp2.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp2, n) {
  const legc = (Fp2.ORDER - _1n2) / _2n;
  const powered = Fp2.pow(n, legc);
  const yes = Fp2.eql(powered, Fp2.ONE);
  const zero = Fp2.eql(powered, Fp2.ZERO);
  const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
  if (!yes && !zero && !no)
    throw new Error("Cannot find square root: probably non-prime P");
  return yes ? 1 : zero ? 0 : -1;
}
function FpIsSquare(Fp2, n) {
  const l = FpLegendre(Fp2, n);
  return l === 0 || l === 1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function FpSqrtEven(Fp2, elm) {
  if (!Fp2.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp2.sqrt(elm);
  return Fp2.isOdd(root) ? Fp2.neg(root) : root;
}

// node_modules/.pnpm/@noble+curves@1.9.0/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n, p = c.ZERO) {
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      let p = c.ZERO;
      let f = c.BASE;
      const wo = calcWOpts(W, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(constTimeNegate(isNeg, precomputes[offset]));
        }
      }
      return { p, f };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
      const wo = calcWOpts(W, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n === _0n3)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      return acc;
    },
    getPrecomputes(W, P, transform) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return comp;
    },
    wNAFCached(P, n, transform) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
    },
    wNAFCachedUnsafe(P, n, transform, prev) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W, bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/.pnpm/@noble+curves@1.9.0/node_modules/@noble/curves/esm/abstract/edwards.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _8n2 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n2 << BigInt(nByteLength * 8) - _1n4;
  const modP = Fp2.create;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const uvRatio2 = CURVE.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v)) };
    } catch (e) {
      return { isValid: false, value: _0n4 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data2, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data2;
  });
  function aCoordinate(title, n, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n, min, MASK);
  }
  function aextpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp2.inv(z);
    const ax = modP(x * iz);
    const ay = modP(y * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(ex, ey, ez, et) {
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez, true);
      aCoordinate("t", et);
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      aCoordinate("x", x);
      aCoordinate("y", y);
      return new Point(x, y, _1n4, modP(x * y));
    }
    static normalizeZ(points) {
      const toInv = FpInvertBatch(Fp2, points.map((p) => p.ez));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n2 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G2 = D + B;
      const F = G2 - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G2 = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n4, CURVE_ORDER);
      const { p, f } = this.wNAF(n);
      return Point.normalizeZ([p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      const n = scalar;
      aInRange("scalar", n, _0n4, CURVE_ORDER);
      if (n === _0n4)
        return I;
      if (this.is0() || n === _1n4)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp2.BYTES;
      hex = ensureBytes2("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y, _0n4, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n4);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point.fromAffine({ x, y });
    }
    static fromPrivateKey(privKey) {
      const { scalar } = getPrivateScalar(privKey);
      return G.multiply(scalar);
    }
    toRawBytes() {
      const { x, y } = this.toAffine();
      const bytes2 = numberToBytesLE(y, Fp2.BYTES);
      bytes2[bytes2.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
  const { BASE: G, ZERO: I } = Point;
  const wnaf = wNAF(Point, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE(hash2));
  }
  function getPrivateScalar(key) {
    const len = Fp2.BYTES;
    key = ensureBytes2("private key", key, len);
    const hashed = ensureBytes2("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head, prefix, scalar } = getPrivateScalar(key);
    const point = G.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes2("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options = {}) {
    msg = ensureBytes2("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toRawBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    aInRange("signature.s", s, _0n4, CURVE_ORDER);
    const res = concatBytes2(R, numberToBytesLE(s, Fp2.BYTES));
    return ensureBytes2("result", res, Fp2.BYTES * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify2(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig = ensureBytes2("signature", sig, 2 * len);
    msg = ensureBytes2("message", msg);
    publicKey = ensureBytes2("publicKey", publicKey, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point.fromHex(publicKey, zip215);
      R = Point.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
  }
  G._setWindowSize(8);
  const utils2 = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomPrivateKey: () => randomBytes2(Fp2.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign: sign2,
    verify: verify2,
    ExtendedPoint: Point,
    utils: utils2
  };
}

// node_modules/.pnpm/@noble+curves@1.9.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes3("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes3("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash2, expand, DST: _DST } = options;
  abytes2(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes3(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function createHasher(Point, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map(num) {
    return Point.fromAffine(mapToCurve(num));
  }
  function clear(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point.ZERO))
      return Point.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults,
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...defaults, DST: defaults.DST, ...options });
      const u0 = map(u[0]);
      const u1 = map(u[1]);
      return clear(u0.add(u1));
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...defaults, DST: defaults.encodeDST, ...options });
      return clear(map(u[0]));
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map(scalars));
    }
  };
}

// node_modules/.pnpm/@noble+curves@1.9.0/node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
function validateOpts2(curve) {
  validateObject(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { P } = CURVE;
  const Fp2 = Field(P);
  const modP = (n) => mod(n, P);
  const montgomeryBits = CURVE.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen = CURVE.nByteLength;
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const powPminus2 = CURVE.powPminus2 || ((x) => Fp2.pow(x, P - BigInt(2)));
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return [x_2, x_3];
  }
  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n5, P);
    aInRange("scalar", scalar, _0n5, P);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u;
    let z_3 = _1n5;
    let swap = _0n5;
    let sw;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n5; t--) {
      const k_t = k >> t & _1n5;
      swap ^= k_t;
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  function encodeUCoordinate(u) {
    return numberToBytesLE(modP(u), montgomeryBytes);
  }
  function decodeUCoordinate(uEnc) {
    const u = ensureBytes2("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen === 32)
      u[31] &= 127;
    return bytesToNumberLE(u);
  }
  function decodeScalar(n) {
    const bytes2 = ensureBytes2("scalar", n);
    const len = bytes2.length;
    if (len !== montgomeryBytes && len !== fieldLen) {
      let valid = "" + montgomeryBytes + " or " + fieldLen;
      throw new Error("invalid scalar, expected " + valid + " bytes, got " + len);
    }
    return bytesToNumberLE(adjustScalarBytes2(bytes2));
  }
  function scalarMult(scalar, u) {
    const pointU = decodeUCoordinate(u);
    const _scalar = decodeScalar(scalar);
    const pu = montgomeryLadder(pointU, _scalar);
    if (pu === _0n5)
      throw new Error("invalid private or public key received");
    return encodeUCoordinate(pu);
  }
  const GuBytes = encodeUCoordinate(CURVE.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
    GuBytes
  };
}

// node_modules/.pnpm/@noble+curves@1.9.0/node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ED25519_P;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n3, P) * b2 % P;
  const b5 = pow2(b4, _1n6, P) * x % P;
  const b10 = pow2(b5, _5n2, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n3, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u, v) {
  const P = ED25519_P;
  const v3 = mod(v * v * v, P);
  const v7 = mod(v3 * v3 * v, P);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp = (() => Field(ED25519_P, void 0, true))();
var ed25519Defaults = (() => ({
  // Removing Fp.create() will still work, and is 10% faster on sign
  a: Fp.create(BigInt(-1)),
  // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 2n**255n - 19n
  Fp,
  // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  h: _8n3,
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
var ed25519 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain(data2, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data2);
}
var ed25519ctx = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
}))();
var ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain,
  prehash: sha512
})))();
var x25519 = (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  // n is 253 bits
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x) => {
    const P = ED25519_P;
    const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
    return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);
  },
  adjustScalarBytes,
  randomBytes
}))();
var ELL2_C1 = (() => (Fp.ORDER + _3n2) / _8n3)();
var ELL2_C2 = (() => Fp.pow(_2n3, ELL2_C1))();
var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
function map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (Fp.ORDER - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u);
  tv1 = Fp.mul(tv1, _2n3);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e2 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e2);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e3 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e3);
  let y = Fp.cmov(y2, y1, e3);
  let e4 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n6 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e);
  xd = Fp.cmov(xd, Fp.ONE, e);
  yn = Fp.cmov(yn, Fp.ONE, e);
  yd = Fp.cmov(yd, Fp.ONE, e);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
}
var ed25519_hasher = (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var hashToCurve = (() => ed25519_hasher.hashToCurve)();
var encodeToCurve = (() => ed25519_hasher.encodeToCurve)();
function aristp(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n6, number2);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes2) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes2) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519.CURVE;
  const P = ed25519.CURVE.Fp.ORDER;
  const mod2 = ed25519.CURVE.Fp.create;
  const r = mod2(SQRT_M1 * r0 * r0);
  const Ns = mod2((r + _1n6) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D = mod2((c - d * r) * mod2(r + d));
  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
  let s_ = mod2(s * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod2(-s_);
  if (!Ns_D_is_sq)
    s = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod2(c * (r - _1n6) * D_MINUS_ONE_SQ - D);
  const s2 = s * s;
  const W0 = mod2((s + s) * D);
  const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod2(_1n6 - s2);
  const W3 = mod2(_1n6 + s2);
  return new ed25519.ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
}
var RistPoint = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep) {
    this.ep = ep;
  }
  static fromAffine(ap) {
    return new _RistPoint(ed25519.ExtendedPoint.fromAffine(ap));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * https://ristretto.group/formulas/elligator.html
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex) {
    hex = ensureBytes2("ristrettoHash", hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistPoint(R1.add(R2));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * https://ristretto.group/formulas/decoding.html
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    hex = ensureBytes2("ristrettoHex", hex, 32);
    const { a, d } = ed25519.CURVE;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s = bytes255ToNumberLE(hex);
    if (!equalBytes2(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P))
      throw new Error(emsg);
    const s2 = mod2(s * s);
    const u1 = mod2(_1n6 + a * s2);
    const u2 = mod2(_1n6 - a * s2);
    const u1_2 = mod2(u1 * u1);
    const u2_2 = mod2(u2 * u2);
    const v = mod2(a * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod2(v * u2_2));
    const Dx = mod2(I * u2);
    const Dy = mod2(I * Dx * v);
    let x = mod2((s + s) * Dx);
    if (isNegativeLE(x, P))
      x = mod2(-x);
    const y = mod2(u1 * Dy);
    const t = mod2(x * y);
    if (!isValid || isNegativeLE(t, P) || y === _0n6)
      throw new Error(emsg);
    return new _RistPoint(new ed25519.ExtendedPoint(x, y, _1n6, t));
  }
  static msm(points, scalars) {
    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);
    return pippenger(_RistPoint, Fn, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * https://ristretto.group/formulas/encoding.html
   */
  toRawBytes() {
    let { ex: x, ey: y, ez: z, et: t } = this.ep;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const u1 = mod2(mod2(z + y) * mod2(z - y));
    const u2 = mod2(x * y);
    const u2sq = mod2(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
    const D1 = mod2(invsqrt * u1);
    const D2 = mod2(invsqrt * u2);
    const zInv = mod2(D1 * D2 * t);
    let D;
    if (isNegativeLE(t * zInv, P)) {
      let _x = mod2(y * SQRT_M1);
      let _y = mod2(x * SQRT_M1);
      x = _x;
      y = _y;
      D = mod2(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (isNegativeLE(x * zInv, P))
      y = mod2(-y);
    let s = mod2((z - y) * D);
    if (isNegativeLE(s, P))
      s = mod2(-s);
    return numberToBytesLE(s, 32);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  // Compare one point to another.
  equals(other) {
    aristp(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X2, ey: Y2 } = other.ep;
    const mod2 = ed25519.CURVE.Fp.create;
    const one = mod2(X1 * Y2) === mod2(Y1 * X2);
    const two = mod2(Y1 * Y2) === mod2(X1 * X2);
    return one || two;
  }
  add(other) {
    aristp(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    aristp(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return new _RistPoint(this.ep.double());
  }
  negate() {
    return new _RistPoint(this.ep.negate());
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
  return RistPoint;
})();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_blake.js
var BSIGMA = Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
function G1s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 16);
  c = c + d | 0;
  b = rotr(b ^ c, 12);
  return { a, b, c, d };
}
function G2s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 8);
  c = c + d | 0;
  b = rotr(b ^ c, 7);
  return { a, b, c, d };
}

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2.js
var B2B_IV = Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = new Uint32Array(32);
function G1b(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
  anumber(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key, salt, personalization } = opts;
  if (key !== void 0 && (key.length < 1 || key.length > keyLen))
    throw new Error("key length must be undefined or 1.." + keyLen);
  if (salt !== void 0 && salt.length !== saltLen)
    throw new Error("salt must be undefined or " + saltLen);
  if (personalization !== void 0 && personalization.length !== persLen)
    throw new Error("personalization must be undefined or " + persLen);
}
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen) {
    super();
    this.finished = false;
    this.destroyed = false;
    this.length = 0;
    this.pos = 0;
    anumber(blockLen);
    anumber(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u32(this.buffer);
  }
  update(data2) {
    aexists(this);
    data2 = toBytes(data2);
    abytes(data2);
    const { blockLen, buffer, buffer32 } = this;
    const len = data2.length;
    const offset = data2.byteOffset;
    const buf = data2.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer.set(data2.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u32(out);
    this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.buffer.set(buffer);
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    to.outputLen = outputLen;
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
    super(128, olen);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    checkBlake2Opts(olen, opts, 64, 16, 16);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes(key);
      keyLength = key.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes(salt);
      const slt = u32(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      personalization = toBytes(personalization);
      const pers = u32(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BBUF[i] = v);
    BBUF.set(B2B_IV, 16);
    let { h, l } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j = 0;
    const s = BSIGMA;
    for (let i = 0; i < 12; i++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = createOptHasher((opts) => new BLAKE2b(opts));
function compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
  let j = 0;
  for (let i = 0; i < rounds; i++) {
    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));
    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));
    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));
    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));
    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));
    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));
    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));
    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));
    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));
    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));
  }
  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };
}
var B2S_IV = SHA256_IV;
var BLAKE2s = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 32 : opts.dkLen;
    super(64, olen);
    this.v0 = B2S_IV[0] | 0;
    this.v1 = B2S_IV[1] | 0;
    this.v2 = B2S_IV[2] | 0;
    this.v3 = B2S_IV[3] | 0;
    this.v4 = B2S_IV[4] | 0;
    this.v5 = B2S_IV[5] | 0;
    this.v6 = B2S_IV[6] | 0;
    this.v7 = B2S_IV[7] | 0;
    checkBlake2Opts(olen, opts, 32, 8, 8);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes(key);
      keyLength = key.length;
    }
    this.v0 ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes(salt);
      const slt = u32(salt);
      this.v4 ^= swap8IfBE(slt[0]);
      this.v5 ^= swap8IfBE(slt[1]);
    }
    if (personalization !== void 0) {
      personalization = toBytes(personalization);
      const pers = u32(personalization);
      this.v6 ^= swap8IfBE(pers[0]);
      this.v7 ^= swap8IfBE(pers[1]);
    }
    if (key !== void 0) {
      abytes(key);
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  get() {
    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;
    return [v0, v1, v2, v3, v4, v5, v6, v7];
  }
  // prettier-ignore
  set(v0, v1, v2, v3, v4, v5, v6, v7) {
    this.v0 = v0 | 0;
    this.v1 = v1 | 0;
    this.v2 = v2 | 0;
    this.v3 = v3 | 0;
    this.v4 = v4 | 0;
    this.v5 = v5 | 0;
    this.v6 = v6 | 0;
    this.v7 = v7 | 0;
  }
  compress(msg, offset, isLast) {
    const { h, l } = fromBig(BigInt(this.length));
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);
    this.v0 ^= v0 ^ v8;
    this.v1 ^= v1 ^ v9;
    this.v2 ^= v2 ^ v10;
    this.v3 ^= v3 ^ v11;
    this.v4 ^= v4 ^ v12;
    this.v5 ^= v5 ^ v13;
    this.v6 ^= v6 ^ v14;
    this.v7 ^= v7 ^ v15;
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2s = createOptHasher((opts) => new BLAKE2s(opts));

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake3.js
var B3_Flags = {
  CHUNK_START: 1,
  CHUNK_END: 2,
  PARENT: 4,
  ROOT: 8,
  KEYED_HASH: 16,
  DERIVE_KEY_CONTEXT: 32,
  DERIVE_KEY_MATERIAL: 64
};
var B3_IV = SHA256_IV.slice();
var B3_SIGMA = (() => {
  const Id = Array.from({ length: 16 }, (_, i) => i);
  const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);
  const res = [];
  for (let i = 0, v = Id; i < 7; i++, v = permute(v))
    res.push(...v);
  return Uint8Array.from(res);
})();
var BLAKE3 = class _BLAKE3 extends BLAKE2 {
  constructor(opts = {}, flags = 0) {
    super(64, opts.dkLen === void 0 ? 32 : opts.dkLen);
    this.chunkPos = 0;
    this.chunksDone = 0;
    this.flags = 0 | 0;
    this.stack = [];
    this.posOut = 0;
    this.bufferOut32 = new Uint32Array(16);
    this.chunkOut = 0;
    this.enableXOF = true;
    const { key, context } = opts;
    const hasContext = context !== void 0;
    if (key !== void 0) {
      if (hasContext)
        throw new Error('Only "key" or "context" can be specified at same time');
      const k = toBytes(key).slice();
      abytes(k, 32);
      this.IV = u32(k);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.KEYED_HASH;
    } else if (hasContext) {
      const ctx = toBytes(context);
      const contextKey = new _BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
      this.IV = u32(contextKey);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
    } else {
      this.IV = B3_IV.slice();
      this.flags = flags;
    }
    this.state = this.IV.slice();
    this.bufferOut = u8(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(counter, flags, buf, bufPos = 0) {
    const { state: s, pos } = this;
    const { h, l } = fromBig(BigInt(counter), true);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);
    s[0] = v0 ^ v8;
    s[1] = v1 ^ v9;
    s[2] = v2 ^ v10;
    s[3] = v3 ^ v11;
    s[4] = v4 ^ v12;
    s[5] = v5 ^ v13;
    s[6] = v6 ^ v14;
    s[7] = v7 ^ v15;
  }
  compress(buf, bufPos = 0, isLast = false) {
    let flags = this.flags;
    if (!this.chunkPos)
      flags |= B3_Flags.CHUNK_START;
    if (this.chunkPos === 15 || isLast)
      flags |= B3_Flags.CHUNK_END;
    if (!isLast)
      this.pos = this.blockLen;
    this.b2Compress(this.chunksDone, flags, buf, bufPos);
    this.chunkPos += 1;
    if (this.chunkPos === 16 || isLast) {
      let chunk = this.state;
      this.state = this.IV.slice();
      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
        if (!(last = this.stack.pop()))
          break;
        this.buffer32.set(last, 0);
        this.buffer32.set(chunk, 8);
        this.pos = this.blockLen;
        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
        chunk = this.state;
        this.state = this.IV.slice();
      }
      this.chunksDone++;
      this.chunkPos = 0;
      this.stack.push(chunk);
    }
    this.pos = 0;
  }
  _cloneInto(to) {
    to = super._cloneInto(to);
    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
    to.state.set(state.slice());
    to.stack = stack.map((i) => Uint32Array.from(i));
    to.IV.set(IV);
    to.flags = flags;
    to.chunkPos = chunkPos;
    to.chunksDone = chunksDone;
    to.posOut = posOut;
    to.chunkOut = chunkOut;
    to.enableXOF = this.enableXOF;
    to.bufferOut32.set(this.bufferOut32);
    return to;
  }
  destroy() {
    this.destroyed = true;
    clean(this.state, this.buffer32, this.IV, this.bufferOut32);
    clean(...this.stack);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;
    const { h, l } = fromBig(BigInt(this.chunkOut++));
    swap32IfBE(buffer32);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);
    out32[0] = v0 ^ v8;
    out32[1] = v1 ^ v9;
    out32[2] = v2 ^ v10;
    out32[3] = v3 ^ v11;
    out32[4] = v4 ^ v12;
    out32[5] = v5 ^ v13;
    out32[6] = v6 ^ v14;
    out32[7] = v7 ^ v15;
    out32[8] = s[0] ^ v8;
    out32[9] = s[1] ^ v9;
    out32[10] = s[2] ^ v10;
    out32[11] = s[3] ^ v11;
    out32[12] = s[4] ^ v12;
    out32[13] = s[5] ^ v13;
    out32[14] = s[6] ^ v14;
    out32[15] = s[7] ^ v15;
    swap32IfBE(buffer32);
    swap32IfBE(out32);
    this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    clean(this.buffer.subarray(this.pos));
    let flags = this.flags | B3_Flags.ROOT;
    if (this.stack.length) {
      flags |= B3_Flags.PARENT;
      swap32IfBE(this.buffer32);
      this.compress(this.buffer32, 0, true);
      swap32IfBE(this.buffer32);
      this.chunksDone = 0;
      this.pos = this.blockLen;
    } else {
      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
    }
    this.flags = flags;
    this.b2CompressOut();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const { blockLen, bufferOut } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.b2CompressOut();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.enableXOF = false;
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
};
var blake3 = createXOFer((opts) => new BLAKE3(opts));

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/crypto/PureJSCrypto.js
var PureJSCrypto = class _PureJSCrypto extends CryptoProvider {
  static async create() {
    return new _PureJSCrypto();
  }
  emptyBlake3State() {
    return blake3.create({});
  }
  cloneBlake3State(state) {
    return state.clone();
  }
  blake3HashOnce(data2) {
    return blake3(data2);
  }
  blake3HashOnceWithContext(data2, { context }) {
    return blake3.create({}).update(context).update(data2).digest();
  }
  blake3IncrementalUpdate(state, data2) {
    return state.update(data2);
  }
  blake3DigestForState(state) {
    return state.clone().digest();
  }
  generateNonce(input) {
    return this.blake3HashOnce(input).slice(0, 24);
  }
  generateJsonNonce(material) {
    return this.generateNonce(textEncoder.encode(stableStringify(material)));
  }
  newEd25519SigningKey() {
    return ed25519.utils.randomPrivateKey();
  }
  getSignerID(secret) {
    return `signer_z${base58.encode(ed25519.getPublicKey(base58.decode(secret.substring("signerSecret_z".length))))}`;
  }
  sign(secret, message) {
    const signature = ed25519.sign(textEncoder.encode(stableStringify(message)), base58.decode(secret.substring("signerSecret_z".length)));
    return `signature_z${base58.encode(signature)}`;
  }
  verify(signature, message, id) {
    return ed25519.verify(base58.decode(signature.substring("signature_z".length)), textEncoder.encode(stableStringify(message)), base58.decode(id.substring("signer_z".length)));
  }
  newX25519StaticSecret() {
    return x25519.utils.randomPrivateKey();
  }
  getSealerID(secret) {
    return `sealer_z${base58.encode(x25519.getPublicKey(base58.decode(secret.substring("sealerSecret_z".length))))}`;
  }
  encrypt(value, keySecret, nOnceMaterial) {
    const keySecretBytes = base58.decode(keySecret.substring("keySecret_z".length));
    const nOnce = this.generateJsonNonce(nOnceMaterial);
    const plaintext = textEncoder.encode(stableStringify(value));
    const ciphertext = xsalsa20(keySecretBytes, nOnce, plaintext);
    return `encrypted_U${bytesToBase64url(ciphertext)}`;
  }
  decryptRaw(encrypted, keySecret, nOnceMaterial) {
    const keySecretBytes = base58.decode(keySecret.substring("keySecret_z".length));
    const nOnce = this.generateJsonNonce(nOnceMaterial);
    const ciphertext = base64URLtoBytes(encrypted.substring("encrypted_U".length));
    const plaintext = xsalsa20(keySecretBytes, nOnce, ciphertext);
    return textDecoder.decode(plaintext);
  }
  seal({ message, from, to, nOnceMaterial }) {
    const nOnce = this.generateJsonNonce(nOnceMaterial);
    const sealerPub = base58.decode(to.substring("sealer_z".length));
    const senderPriv = base58.decode(from.substring("sealerSecret_z".length));
    const plaintext = textEncoder.encode(stableStringify(message));
    const sharedSecret = x25519.getSharedSecret(senderPriv, sealerPub);
    const sealedBytes = xsalsa20_poly1305(sharedSecret, nOnce).encrypt(plaintext);
    return `sealed_U${bytesToBase64url(sealedBytes)}`;
  }
  unseal(sealed, sealer, from, nOnceMaterial) {
    const nOnce = this.generateJsonNonce(nOnceMaterial);
    const sealerPriv = base58.decode(sealer.substring("sealerSecret_z".length));
    const senderPub = base58.decode(from.substring("sealer_z".length));
    const sealedBytes = base64URLtoBytes(sealed.substring("sealed_U".length));
    const sharedSecret = x25519.getSharedSecret(sealerPriv, senderPub);
    const plaintext = xsalsa20_poly1305(sharedSecret, nOnce).decrypt(sealedBytes);
    try {
      return JSON.parse(textDecoder.decode(plaintext));
    } catch (e) {
      logger.error("Failed to decrypt/parse sealed message", { err: e });
      return void 0;
    }
  }
};

// node_modules/.pnpm/cojson@0.13.17/node_modules/cojson/dist/crypto/WasmCrypto.js
var WasmCrypto = class _WasmCrypto extends CryptoProvider {
  constructor() {
    super();
  }
  static async create() {
    try {
      await initialize();
    } catch (e) {
      logger.warn("Failed to initialize WasmCrypto, falling back to PureJSCrypto", { err: e });
      return new PureJSCrypto();
    }
    return new _WasmCrypto();
  }
  emptyBlake3State() {
    return blake3_empty_state();
  }
  cloneBlake3State(state) {
    return state.clone();
  }
  blake3HashOnce(data2) {
    return blake3_hash_once(data2);
  }
  blake3HashOnceWithContext(data2, { context }) {
    return blake3_hash_once_with_context(data2, context);
  }
  blake3IncrementalUpdate(state, data2) {
    state.update(data2);
    return state;
  }
  blake3DigestForState(state) {
    return state.finalize();
  }
  newEd25519SigningKey() {
    return new_ed25519_signing_key();
  }
  getSignerID(secret) {
    return get_signer_id(textEncoder.encode(secret));
  }
  sign(secret, message) {
    return sign(textEncoder.encode(stableStringify(message)), textEncoder.encode(secret));
  }
  verify(signature, message, id) {
    return verify(textEncoder.encode(signature), textEncoder.encode(stableStringify(message)), textEncoder.encode(id));
  }
  newX25519StaticSecret() {
    return new_x25519_private_key();
  }
  getSealerID(secret) {
    return get_sealer_id(textEncoder.encode(secret));
  }
  encrypt(value, keySecret, nOnceMaterial) {
    return `encrypted_U${bytesToBase64url(encrypt(textEncoder.encode(stableStringify(value)), keySecret, textEncoder.encode(stableStringify(nOnceMaterial))))}`;
  }
  decryptRaw(encrypted, keySecret, nOnceMaterial) {
    return textDecoder.decode(decrypt(base64URLtoBytes(encrypted.substring("encrypted_U".length)), keySecret, textEncoder.encode(stableStringify(nOnceMaterial))));
  }
  seal({ message, from, to, nOnceMaterial }) {
    return `sealed_U${bytesToBase64url(seal(textEncoder.encode(stableStringify(message)), from, to, textEncoder.encode(stableStringify(nOnceMaterial))))}`;
  }
  unseal(sealed, sealer, from, nOnceMaterial) {
    const plaintext = textDecoder.decode(unseal(base64URLtoBytes(sealed.substring("sealed_U".length)), sealer, from, textEncoder.encode(stableStringify(nOnceMaterial))));
    try {
      return JSON.parse(plaintext);
    } catch (e) {
      logger.error("Failed to decrypt/parse sealed message", { err: e });
      return void 0;
    }
  }
};

// node_modules/.pnpm/jazz-browser@0.13.17/node_modules/jazz-browser/dist/storageOptions.js
function getStorageOptions(storage) {
  const useIndexedDB = !storage || Array.isArray(storage) && storage.includes("indexedDB") || storage === "indexedDB";
  return { useIndexedDB };
}

// node_modules/.pnpm/jazz-browser@0.13.17/node_modules/jazz-browser/dist/createBrowserContext.js
setupInspector();
var BrowserWebSocketPeerWithReconnection = class extends WebSocketPeerWithReconnection {
  onNetworkChange(callback) {
    const handler = () => callback(navigator.onLine);
    window.addEventListener("online", handler);
    window.addEventListener("offline", handler);
    return () => {
      window.removeEventListener("online", handler);
      window.removeEventListener("offline", handler);
    };
  }
};
async function setupPeers(options) {
  const crypto = options.crypto || await WasmCrypto.create();
  let node = void 0;
  const { useIndexedDB } = getStorageOptions(options.storage);
  const peersToLoadFrom = [];
  if (useIndexedDB) {
    peersToLoadFrom.push(await IDBNode.asPeer());
  }
  if (options.sync.when === "never") {
    return {
      toggleNetwork: () => {
      },
      peersToLoadFrom,
      setNode: () => {
      },
      crypto
    };
  }
  const wsPeer = new BrowserWebSocketPeerWithReconnection({
    peer: options.sync.peer,
    reconnectionTimeout: options.reconnectionTimeout,
    addPeer: (peer) => {
      if (node) {
        node.syncManager.addPeer(peer);
      } else {
        peersToLoadFrom.push(peer);
      }
    },
    removePeer: (peer) => {
      peersToLoadFrom.splice(peersToLoadFrom.indexOf(peer), 1);
    }
  });
  function toggleNetwork(enabled) {
    if (enabled) {
      wsPeer.enable();
    } else {
      wsPeer.disable();
    }
  }
  function setNode(value) {
    node = value;
  }
  if (options.sync.when === "always" || !options.sync.when) {
    toggleNetwork(true);
  }
  return {
    toggleNetwork,
    peersToLoadFrom,
    setNode,
    crypto
  };
}
async function createJazzBrowserGuestContext(options) {
  const { toggleNetwork, peersToLoadFrom, setNode, crypto } = await setupPeers(options);
  const context = await createAnonymousJazzContext({
    crypto,
    peersToLoadFrom
  });
  setNode(context.agent.node);
  options.authSecretStorage.emitUpdate(null);
  return {
    guest: context.agent,
    node: context.agent.node,
    done: () => {
      toggleNetwork(false);
      context.done();
    },
    logOut: () => {
      return context.logOut();
    }
  };
}
async function createJazzBrowserContext(options) {
  const { toggleNetwork, peersToLoadFrom, setNode, crypto } = await setupPeers(options);
  let unsubscribeAuthUpdate = () => {
  };
  if (options.sync.when === "signedUp") {
    let handleAuthUpdate = function(isAuthenticated) {
      if (isAuthenticated) {
        toggleNetwork(true);
      } else {
        toggleNetwork(false);
      }
    };
    const authSecretStorage = options.authSecretStorage;
    const credentials = options.credentials ?? await authSecretStorage.get();
    unsubscribeAuthUpdate = authSecretStorage.onUpdate(handleAuthUpdate);
    handleAuthUpdate(authSecretStorage.getIsAuthenticated(credentials));
  }
  const context = await createJazzContext({
    credentials: options.credentials,
    newAccountProps: options.newAccountProps,
    peersToLoadFrom,
    crypto,
    defaultProfileName: options.defaultProfileName,
    AccountSchema: options.AccountSchema,
    sessionProvider: provideBrowserLockSession,
    authSecretStorage: options.authSecretStorage
  });
  setNode(context.node);
  return {
    me: context.account,
    node: context.node,
    authSecretStorage: context.authSecretStorage,
    done: () => {
      toggleNetwork(false);
      unsubscribeAuthUpdate();
      context.done();
    },
    logOut: () => {
      unsubscribeAuthUpdate();
      return context.logOut();
    }
  };
}
function provideBrowserLockSession(accountID, crypto) {
  let sessionDone;
  const donePromise = new Promise((resolve) => {
    sessionDone = resolve;
  });
  let resolveSession;
  const sessionPromise = new Promise((resolve) => {
    resolveSession = resolve;
  });
  void async function() {
    for (let idx = 0; idx < 100; idx++) {
      for (let retry = 0; retry < 2; retry++) {
        const sessionFinishedOrNoLock = await navigator.locks.request(accountID + "_" + idx, { ifAvailable: true }, async (lock) => {
          if (!lock)
            return "noLock";
          const sessionID = localStorage.getItem(accountID + "_" + idx) || crypto.newRandomSessionID(accountID);
          localStorage.setItem(accountID + "_" + idx, sessionID);
          resolveSession(sessionID);
          await donePromise;
          console.log("Done with lock", accountID + "_" + idx, sessionID);
          return "sessionFinished";
        });
        if (sessionFinishedOrNoLock === "sessionFinished") {
          return;
        }
      }
    }
    throw new Error("Couldn't get lock on session after 100x2 tries");
  }();
  return sessionPromise.then((sessionID) => ({
    sessionID,
    sessionDone
  }));
}

// node_modules/.pnpm/jazz-browser@0.13.17/node_modules/jazz-browser/dist/auth/LocalStorageKVStore.js
var LocalStorageKVStore = class {
  constructor() {
  }
  async get(key) {
    return localStorage.getItem(key);
  }
  async set(key, value) {
    localStorage.setItem(key, value);
  }
  async delete(key) {
    localStorage.removeItem(key);
  }
  async clearAll() {
    localStorage.clear();
  }
};

// node_modules/.pnpm/jazz-browser@0.13.17/node_modules/jazz-browser/dist/BrowserContextManager.js
var JazzBrowserContextManager = class extends JazzContextManager {
  // TODO: When the storage changes, if the user is changed, update the context
  getKvStore() {
    if (typeof window === "undefined") {
      return new InMemoryKVStore();
    } else {
      return new LocalStorageKVStore();
    }
  }
  async getNewContext(props, authProps) {
    if (props.guestMode) {
      return createJazzBrowserGuestContext({
        sync: props.sync,
        storage: props.storage,
        authSecretStorage: this.authSecretStorage
      });
    } else {
      return createJazzBrowserContext({
        sync: props.sync,
        storage: props.storage,
        AccountSchema: props.AccountSchema,
        credentials: authProps == null ? void 0 : authProps.credentials,
        newAccountProps: authProps == null ? void 0 : authProps.newAccountProps,
        defaultProfileName: props.defaultProfileName,
        authSecretStorage: this.authSecretStorage
      });
    }
  }
  propsChanged(props) {
    if (!this.props) {
      return true;
    }
    return this.props.sync.when !== props.sync.when || this.props.sync.peer !== props.sync.peer || this.props.guestMode !== props.guestMode;
  }
};

// node_modules/.pnpm/jazz-browser@0.13.17/node_modules/jazz-browser/dist/index.js
setupInspector();
function createInviteLink2(value, role, { baseURL = window.location.href.replace(/#.*$/, ""), valueHint } = {}) {
  return createInviteLink(value, role, baseURL, valueHint);
}
async function consumeInviteLinkFromWindowLocation({ as, forValueHint, invitedObjectSchema }) {
  const result = await consumeInviteLink({
    inviteURL: window.location.href,
    as,
    forValueHint,
    invitedObjectSchema
  });
  if (result) {
    window.history.replaceState({}, "", window.location.href.replace(/#.*$/, ""));
  }
  return result;
}

// node_modules/.pnpm/jazz-react-core@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react-core/dist/hooks.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/.pnpm/jazz-react-core@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react-core/dist/provider.js
var import_react = __toESM(require_react(), 1);
var JazzContext = import_react.default.createContext(void 0);
var JazzContextManagerContext = import_react.default.createContext(void 0);

// node_modules/.pnpm/jazz-react-core@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react-core/dist/utils.js
function getCurrentAccountFromContextManager(contextManager) {
  const context = contextManager.getCurrentValue();
  if (!context) {
    throw new Error("No context found");
  }
  return "me" in context ? context.me : context.guest;
}
function subscribeToContextManager(contextManager, callback) {
  let unsub = () => {
  };
  const handler = () => {
    unsub();
    unsub = callback();
  };
  handler();
  return contextManager.subscribe(handler);
}

// node_modules/.pnpm/jazz-react-core@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react-core/dist/hooks.js
function useJazzContext() {
  const value = (0, import_react2.useContext)(JazzContext);
  if (!value) {
    throw new Error("You need to set up a JazzProvider on top of your app to use this hook.");
  }
  return value;
}
function useJazzContextManager() {
  const value = (0, import_react2.useContext)(JazzContextManagerContext);
  if (!value) {
    throw new Error("You need to set up a JazzProvider on top of your app to use this hook.");
  }
  return value;
}
function useAuthSecretStorage() {
  const value = (0, import_react2.useContext)(JazzContextManagerContext);
  if (!value) {
    throw new Error("You need to set up a JazzProvider on top of your app to use this useAuthSecretStorage.");
  }
  return value.getAuthSecretStorage();
}
function useIsAuthenticated() {
  const authSecretStorage = useAuthSecretStorage();
  return (0, import_react2.useSyncExternalStore)((0, import_react2.useCallback)((callback) => {
    return authSecretStorage.onUpdate(callback);
  }, [authSecretStorage]), () => authSecretStorage.isAuthenticated, () => authSecretStorage.isAuthenticated);
}
function useCoValueObservable() {
  const [initialValue] = import_react2.default.useState(() => createCoValueObservable());
  const ref = (0, import_react2.useRef)(initialValue);
  return {
    getCurrentValue() {
      return ref.current.getCurrentValue();
    },
    getCurrentObservable() {
      return ref.current;
    },
    reset(initialValue2) {
      ref.current = createCoValueObservable(initialValue2);
    }
  };
}
function useCoState(Schema, id, options) {
  const contextManager = useJazzContextManager();
  const observable = useCoValueObservable();
  const value = import_react2.default.useSyncExternalStore(import_react2.default.useCallback((callback) => {
    if (!id) {
      observable.reset(null);
      return () => {
      };
    }
    observable.reset();
    return subscribeToContextManager(contextManager, () => {
      const agent = getCurrentAccountFromContextManager(contextManager);
      observable.reset();
      return observable.getCurrentObservable().subscribe(Schema, id, {
        loadAs: agent,
        resolve: options == null ? void 0 : options.resolve,
        onUnauthorized: callback,
        onUnavailable: callback,
        syncResolution: true
      }, callback);
    });
  }, [Schema, id, contextManager]), () => observable.getCurrentValue(), () => observable.getCurrentValue());
  return value;
}
function useAccount(options) {
  const context = useJazzContext();
  const contextManager = useJazzContextManager();
  if (!("me" in context)) {
    throw new Error("useAccount can't be used in a JazzProvider with auth === 'guest' - consider using useAccountOrGuest()");
  }
  const observable = useCoValueObservable();
  const me = import_react2.default.useSyncExternalStore(import_react2.default.useCallback((callback) => {
    return subscribeToContextManager(contextManager, () => {
      const agent = getCurrentAccountFromContextManager(contextManager);
      if (agent._type === "Anonymous") {
        throw new Error("useAccount can't be used in a JazzProvider with auth === 'guest' - consider using useAccountOrGuest()");
      }
      observable.reset();
      const Schema = agent.constructor;
      return observable.getCurrentObservable().subscribe(Schema, agent.id, {
        loadAs: agent,
        resolve: options == null ? void 0 : options.resolve,
        onUnauthorized: callback,
        onUnavailable: callback,
        syncResolution: true
      }, callback);
    });
  }, [contextManager]), () => observable.getCurrentValue(), () => observable.getCurrentValue());
  return {
    me: (options == null ? void 0 : options.resolve) === void 0 ? me || context.me : me,
    logOut: contextManager.logOut
  };
}
function useAccountOrGuest(options) {
  const context = useJazzContext();
  const contextManager = useJazzContextManager();
  const observable = useCoValueObservable();
  const me = import_react2.default.useSyncExternalStore(import_react2.default.useCallback((callback) => {
    return subscribeToContextManager(contextManager, () => {
      const agent = getCurrentAccountFromContextManager(contextManager);
      if (agent._type === "Anonymous") {
        return () => {
        };
      }
      observable.reset();
      const Schema = agent.constructor;
      return observable.getCurrentObservable().subscribe(Schema, agent.id, {
        loadAs: agent,
        resolve: options == null ? void 0 : options.resolve,
        onUnauthorized: callback,
        onUnavailable: callback,
        syncResolution: true
      }, callback);
    });
  }, [contextManager]), () => observable.getCurrentValue(), () => observable.getCurrentValue());
  if ("me" in context) {
    return {
      me: (options == null ? void 0 : options.resolve) === void 0 ? me || context.me : me
    };
  } else {
    return { me: context.guest };
  }
}
function experimental_useInboxSender(inboxOwnerID) {
  const context = useJazzContext();
  if (!("me" in context)) {
    throw new Error("useInboxSender can't be used in a JazzProvider with auth === 'guest'.");
  }
  const me = context.me;
  const inboxRef = (0, import_react2.useRef)(void 0);
  const sendMessage = (0, import_react2.useCallback)(async (message) => {
    if (!inboxOwnerID)
      throw new Error("Inbox owner ID is required");
    if (!inboxRef.current) {
      const inbox2 = InboxSender.load(inboxOwnerID, me);
      inboxRef.current = inbox2;
    }
    let inbox = await inboxRef.current;
    if (inbox.owner.id !== inboxOwnerID) {
      const req = InboxSender.load(inboxOwnerID, me);
      inboxRef.current = req;
      inbox = await req;
    }
    return inbox.sendMessage(message);
  }, [inboxOwnerID]);
  return sendMessage;
}

// node_modules/.pnpm/jazz-react-core@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react-core/dist/auth/DemoAuth.js
var import_react3 = __toESM(require_react(), 1);
function useDemoAuth() {
  const context = useJazzContext();
  const authSecretStorage = useAuthSecretStorage();
  if ("guest" in context) {
    throw new Error("Demo auth is not supported in guest mode");
  }
  const authMethod = (0, import_react3.useMemo)(() => {
    return new DemoAuth(context.authenticate, authSecretStorage);
  }, []);
  const isAuthenticated = useIsAuthenticated();
  const [existingUsers, setExistingUsers] = (0, import_react3.useState)([]);
  (0, import_react3.useEffect)(() => {
    authMethod.getExistingUsers().then(setExistingUsers);
  }, [authMethod]);
  function handleSignUp(username) {
    return authMethod.signUp(username).then(() => {
      setExistingUsers(existingUsers.concat([username]));
    });
  }
  return {
    state: isAuthenticated ? "signedIn" : "anonymous",
    logIn: authMethod.logIn,
    signUp: handleSignUp,
    existingUsers
  };
}

// node_modules/.pnpm/jazz-react-core@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react-core/dist/auth/PassphraseAuth.js
var import_react4 = __toESM(require_react(), 1);
function usePassphraseAuth({ wordlist }) {
  const context = useJazzContext();
  const authSecretStorage = useAuthSecretStorage();
  if ("guest" in context) {
    throw new Error("Passphrase auth is not supported in guest mode");
  }
  const authMethod = (0, import_react4.useMemo)(() => {
    return new PassphraseAuth(context.node.crypto, context.authenticate, context.register, authSecretStorage, wordlist);
  }, [wordlist]);
  const passphrase = (0, import_react4.useSyncExternalStore)((0, import_react4.useCallback)((callback) => {
    authMethod.loadCurrentAccountPassphrase();
    return authMethod.subscribe(callback);
  }, [authMethod]), () => authMethod.passphrase);
  const isAuthenticated = useIsAuthenticated();
  return {
    state: isAuthenticated ? "signedIn" : "anonymous",
    logIn: authMethod.logIn,
    signUp: authMethod.signUp,
    registerNewAccount: authMethod.registerNewAccount,
    generateRandomPassphrase: authMethod.generateRandomPassphrase,
    passphrase
  };
}

// node_modules/.pnpm/jazz-react@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react/dist/provider.js
var import_react5 = __toESM(require_react(), 1);
function JazzProvider({ children, guestMode, sync, storage, AccountSchema, defaultProfileName, onLogOut, logOutReplacement, onAnonymousAccountDiscarded }) {
  const [contextManager] = import_react5.default.useState(() => new JazzBrowserContextManager());
  const onLogOutRefCallback = useRefCallback(onLogOut);
  const logOutReplacementRefCallback = useRefCallback(logOutReplacement);
  const onAnonymousAccountDiscardedRefCallback = useRefCallback(onAnonymousAccountDiscarded);
  const logoutReplacementActiveRef = (0, import_react5.useRef)(false);
  logoutReplacementActiveRef.current = Boolean(logOutReplacement);
  const value = import_react5.default.useSyncExternalStore(import_react5.default.useCallback((callback) => {
    const props = {
      AccountSchema,
      guestMode,
      sync,
      storage,
      defaultProfileName,
      onLogOut: onLogOutRefCallback,
      logOutReplacement: logoutReplacementActiveRef.current ? logOutReplacementRefCallback : void 0,
      onAnonymousAccountDiscarded: onAnonymousAccountDiscardedRefCallback
    };
    if (contextManager.propsChanged(props)) {
      contextManager.createContext(props).catch((error) => {
        console.error("Error creating Jazz browser context:", error);
      });
    }
    return contextManager.subscribe(callback);
  }, [sync, guestMode].concat(storage)), () => contextManager.getCurrentValue(), () => contextManager.getCurrentValue());
  (0, import_react5.useEffect)(() => {
    if (true)
      return;
    return () => {
      contextManager.done();
    };
  }, []);
  return (0, import_jsx_runtime.jsx)(JazzContext.Provider, { value, children: (0, import_jsx_runtime.jsx)(JazzContextManagerContext.Provider, { value: contextManager, children: value && children }) });
}
function useRefCallback(callback) {
  const callbackRef = import_react5.default.useRef(callback);
  callbackRef.current = callback;
  return (0, import_react5.useRef)((...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }).current;
}

// node_modules/.pnpm/jazz-react@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react/dist/hooks.js
var import_react6 = __toESM(require_react(), 1);
function useAcceptInvite({ invitedObjectSchema, onAccept, forValueHint }) {
  const context = useJazzContext();
  if (!("me" in context)) {
    throw new Error("useAcceptInvite can't be used in a JazzProvider with auth === 'guest'.");
  }
  (0, import_react6.useEffect)(() => {
    const handleInvite = () => {
      const result = consumeInviteLinkFromWindowLocation({
        as: context.me,
        invitedObjectSchema,
        forValueHint
      });
      result.then((result2) => result2 && onAccept(result2 == null ? void 0 : result2.valueID)).catch((e) => {
        console.error("Failed to accept invite", e);
      });
    };
    handleInvite();
    window.addEventListener("hashchange", handleInvite);
    return () => window.removeEventListener("hashchange", handleInvite);
  }, [onAccept]);
}

// node_modules/.pnpm/jazz-react@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react/dist/auth/DemoAuth.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var DemoAuthBasicUI = (props) => {
  const auth = useDemoAuth();
  const [username, setUsername] = (0, import_react7.useState)("");
  const darkMode = typeof window !== "undefined" ? window.matchMedia("(prefers-color-scheme: dark)").matches : false;
  if (auth.state === "signedIn")
    return props.children ?? null;
  const { signUp, logIn, existingUsers } = auth;
  return (0, import_jsx_runtime2.jsxs)("div", { style: {
    minHeight: "100%",
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    width: "18rem",
    maxWidth: "calc(100vw - 2rem)",
    gap: "2rem",
    margin: "0 auto"
  }, children: [(0, import_jsx_runtime2.jsx)("h1", { style: {
    color: darkMode ? "#fff" : "#000",
    textAlign: "center",
    fontSize: "1.5rem",
    fontWeight: "bold"
  }, children: props.appName }), (0, import_jsx_runtime2.jsxs)("form", { style: {
    display: "flex",
    flexDirection: "column",
    gap: "0.5rem"
  }, onSubmit: (e) => {
    e.preventDefault();
    signUp(username);
  }, children: [(0, import_jsx_runtime2.jsx)("input", { placeholder: "Display name", value: username, onChange: (e) => setUsername(e.target.value), autoComplete: "webauthn", style: {
    border: darkMode ? "1px solid #444" : "1px solid #ddd",
    padding: "11px 8px",
    borderRadius: "6px",
    background: darkMode ? "#000" : "#fff",
    color: darkMode ? "#fff" : "#000"
  } }), (0, import_jsx_runtime2.jsx)("input", { type: "submit", value: "Sign up", style: {
    padding: "13px 5px",
    border: "none",
    borderRadius: "6px",
    cursor: "pointer",
    background: darkMode ? "#444" : "#ddd",
    color: darkMode ? "#fff" : "#000"
  } })] }), existingUsers.length > 0 && (0, import_jsx_runtime2.jsxs)("div", { style: {
    display: "flex",
    flexDirection: "column",
    gap: "0.5rem"
  }, children: [(0, import_jsx_runtime2.jsx)("p", { style: {
    color: darkMode ? "#e2e2e2" : "#000",
    textAlign: "center",
    paddingTop: "0.5rem",
    borderTop: "1px solid",
    borderColor: darkMode ? "#111" : "#e2e2e2"
  }, children: "Log in as" }), existingUsers.map((user) => (0, import_jsx_runtime2.jsx)("button", { onClick: () => logIn(user), type: "button", "aria-label": `Log in as ${user}`, style: {
    background: darkMode ? "#0d0d0d" : "#eee",
    color: darkMode ? "#fff" : "#000",
    padding: "0.5rem",
    border: "none",
    borderRadius: "6px"
  }, children: user }, user))] })] });
};

// node_modules/.pnpm/jazz-react@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react/dist/auth/PasskeyAuth.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
function usePasskeyAuth({ appName, appHostname }) {
  const context = useJazzContext();
  const authSecretStorage = useAuthSecretStorage();
  if ("guest" in context) {
    throw new Error("Passkey auth is not supported in guest mode");
  }
  const authMethod = (0, import_react8.useMemo)(() => {
    return new BrowserPasskeyAuth(context.node.crypto, context.authenticate, authSecretStorage, appName, appHostname);
  }, [appName, appHostname, authSecretStorage]);
  const isAuthenticated = useIsAuthenticated();
  return {
    state: isAuthenticated ? "signedIn" : "anonymous",
    logIn: authMethod.logIn,
    signUp: authMethod.signUp
  };
}
var PasskeyAuthBasicUI = (props) => {
  const [username, setUsername] = (0, import_react8.useState)("");
  const [error, setError] = (0, import_react8.useState)(null);
  const auth = usePasskeyAuth({
    appName: props.appName,
    appHostname: props.appHostname
  });
  if (auth.state === "signedIn") {
    return props.children ?? null;
  }
  const { logIn, signUp } = auth;
  return (0, import_jsx_runtime3.jsxs)("div", { style: {
    width: "100vw",
    height: "100vh",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }, children: [error && (0, import_jsx_runtime3.jsx)("div", { style: { color: "red" }, children: error }), (0, import_jsx_runtime3.jsxs)("div", { style: {
    width: "18rem",
    display: "flex",
    flexDirection: "column",
    gap: "2rem"
  }, children: [(0, import_jsx_runtime3.jsxs)("form", { style: {
    width: "18rem",
    display: "flex",
    flexDirection: "column",
    gap: "0.5rem"
  }, onSubmit: (e) => {
    e.preventDefault();
    setError(null);
    signUp(username).catch((error2) => setError(error2.message));
  }, children: [(0, import_jsx_runtime3.jsx)("input", { placeholder: "Display name", value: username, onChange: (e) => setUsername(e.target.value), autoComplete: "webauthn", style: {
    border: "2px solid #000",
    padding: "11px 8px",
    borderRadius: "6px"
  } }), (0, import_jsx_runtime3.jsx)("input", { type: "submit", value: "Sign up", style: {
    background: "#000",
    color: "#fff",
    padding: "13px 5px",
    border: "none",
    borderRadius: "6px",
    cursor: "pointer"
  } })] }), (0, import_jsx_runtime3.jsx)("button", { onClick: () => {
    setError(null);
    logIn().catch((error2) => setError(error2.message));
  }, style: {
    background: "#000",
    color: "#fff",
    padding: "13px 5px",
    border: "none",
    borderRadius: "6px",
    cursor: "pointer"
  }, children: "Log in with existing account" })] })] });
};

// node_modules/.pnpm/jazz-react@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react/dist/auth/PassphraseAuth.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
function PassphraseAuthBasicUI(props) {
  const auth = usePassphraseAuth({
    wordlist: props.wordlist
  });
  const [step, setStep] = (0, import_react9.useState)("initial");
  const [loginPassphrase, setLoginPassphrase] = (0, import_react9.useState)("");
  const [isCopied, setIsCopied] = (0, import_react9.useState)(false);
  if (auth.state === "signedIn") {
    return props.children ?? null;
  }
  const handleCreateAccount = async () => {
    setStep("create");
  };
  const handleLogin = () => {
    setStep("login");
  };
  const handleBack = () => {
    setStep("initial");
    setLoginPassphrase("");
  };
  const handleCopy = async () => {
    await navigator.clipboard.writeText(auth.passphrase);
    setIsCopied(true);
  };
  const handleLoginSubmit = async () => {
    await auth.logIn(loginPassphrase);
    setStep("initial");
    setLoginPassphrase("");
  };
  const handleNext = async () => {
    await auth.signUp();
    setStep("initial");
    setLoginPassphrase("");
  };
  return (0, import_jsx_runtime4.jsx)("div", { style: containerStyle, children: (0, import_jsx_runtime4.jsxs)("div", { style: cardStyle, children: [step === "initial" && (0, import_jsx_runtime4.jsxs)("div", { children: [(0, import_jsx_runtime4.jsx)("h1", { style: headingStyle, children: props.appName }), (0, import_jsx_runtime4.jsx)("button", { onClick: handleCreateAccount, style: primaryButtonStyle, children: "Create new account" }), (0, import_jsx_runtime4.jsx)("button", { onClick: handleLogin, style: secondaryButtonStyle, children: "Log in" })] }), step === "create" && (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [(0, import_jsx_runtime4.jsx)("h1", { style: headingStyle, children: "Your Passphrase" }), (0, import_jsx_runtime4.jsx)("p", { style: {
    fontSize: "0.875rem",
    color: "#4b5563",
    textAlign: "center",
    marginBottom: "1rem"
  }, children: "Please copy and store this passphrase somewhere safe. You'll need it to log in." }), (0, import_jsx_runtime4.jsx)("textarea", { readOnly: true, value: auth.passphrase, style: textareaStyle, rows: 5 }), (0, import_jsx_runtime4.jsxs)("div", { style: {
    display: "flex",
    justifyContent: "space-between",
    gap: "1rem"
  }, children: [(0, import_jsx_runtime4.jsx)("button", { onClick: handleBack, style: secondaryButtonStyle, children: "Back" }), (0, import_jsx_runtime4.jsx)("button", { onClick: handleCopy, style: primaryButtonStyle, children: isCopied ? "Copied!" : "Copy Passphrase" }), (0, import_jsx_runtime4.jsx)("button", { onClick: handleNext, style: primaryButtonStyle, children: "I have saved it!" })] })] }), step === "login" && (0, import_jsx_runtime4.jsxs)("div", { children: [(0, import_jsx_runtime4.jsx)("h1", { style: headingStyle, children: "Log In" }), (0, import_jsx_runtime4.jsx)("textarea", { value: loginPassphrase, onChange: (e) => setLoginPassphrase(e.target.value), placeholder: "Enter your passphrase", style: textareaStyle, rows: 5 }), (0, import_jsx_runtime4.jsxs)("div", { style: {
    display: "flex",
    justifyContent: "space-between",
    gap: "1rem"
  }, children: [(0, import_jsx_runtime4.jsx)("button", { onClick: handleBack, style: secondaryButtonStyle, children: "Back" }), (0, import_jsx_runtime4.jsx)("button", { onClick: handleLoginSubmit, style: primaryButtonStyle, children: "Log In" })] })] })] }) });
}
var containerStyle = {
  minHeight: "100vh",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  backgroundColor: "#f3f4f6"
};
var cardStyle = {
  backgroundColor: "white",
  padding: "2rem",
  borderRadius: "0.5rem",
  boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  width: "24rem"
};
var buttonStyle = {
  width: "100%",
  padding: "0.5rem 1rem",
  borderRadius: "0.25rem",
  fontWeight: "bold",
  cursor: "pointer",
  marginBottom: "1rem"
};
var primaryButtonStyle = {
  ...buttonStyle,
  backgroundColor: "black",
  color: "white",
  border: "none"
};
var secondaryButtonStyle = {
  ...buttonStyle,
  backgroundColor: "white",
  color: "black",
  border: "1px solid black"
};
var headingStyle = {
  color: "black",
  fontSize: "1.5rem",
  fontWeight: "bold",
  textAlign: "center",
  marginBottom: "1rem"
};
var textareaStyle = {
  width: "100%",
  padding: "0.5rem",
  border: "1px solid #d1d5db",
  borderRadius: "0.25rem",
  marginBottom: "1rem",
  boxSizing: "border-box"
};

// node_modules/.pnpm/jazz-react@0.13.17_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/jazz-react/dist/media.js
var import_react10 = __toESM(require_react(), 1);
function useProgressiveImg({ image, maxWidth, targetWidth }) {
  const [current, setCurrent] = (0, import_react10.useState)(void 0);
  (0, import_react10.useEffect)(() => {
    let lastHighestRes;
    if (!image)
      return;
    const unsub = image.subscribe({}, (update) => {
      const highestRes = update == null ? void 0 : update.highestResAvailable({ maxWidth, targetWidth });
      if (highestRes) {
        if (highestRes.res !== lastHighestRes) {
          lastHighestRes = highestRes.res;
          const blob = highestRes.stream.toBlob();
          if (blob) {
            const blobURI = URL.createObjectURL(blob);
            setCurrent({ src: blobURI, res: highestRes.res });
            return () => {
              setTimeout(() => URL.revokeObjectURL(blobURI), 200);
            };
          }
        }
      } else {
        setCurrent({
          src: update == null ? void 0 : update.placeholderDataURL,
          res: "placeholder"
        });
      }
    });
    return unsub;
  }, [image == null ? void 0 : image.id, maxWidth]);
  return {
    src: current == null ? void 0 : current.src,
    res: current == null ? void 0 : current.res,
    originalSize: image == null ? void 0 : image.originalSize
  };
}
function ProgressiveImg({ children, image, maxWidth, targetWidth }) {
  const result = useProgressiveImg({ image, maxWidth, targetWidth });
  return result && children(result);
}

// node_modules/.pnpm/image-blob-reduce@4.1.0/node_modules/image-blob-reduce/dist/image-blob-reduce.esm.mjs
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var utils$1 = {};
utils$1.assign = function assign(to) {
  var from;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (Object.prototype.hasOwnProperty.call(from, key)) to[key] = from[key];
    }
  }
  return to;
};
function pick(from, props) {
  var to = {};
  props.forEach(function(key) {
    if (Object.prototype.hasOwnProperty.call(from, key)) to[key] = from[key];
  });
  return to;
}
function pick_pica_resize_options(from) {
  return pick(from, [
    "alpha",
    "unsharpAmount",
    "unsharpRadius",
    "unsharpThreshold",
    "cancelToken"
  ]);
}
utils$1.pick = pick;
utils$1.pick_pica_resize_options = pick_pica_resize_options;
var pica$1 = { exports: {} };
(function(module2, exports) {
  (function(f) {
    {
      module2.exports = f();
    }
  })(function() {
    return (/* @__PURE__ */ function() {
      function r(e, n, t) {
        function o(i2, f) {
          if (!n[i2]) {
            if (!e[i2]) {
              var c = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f && c) return c(i2, true);
              if (u) return u(i2, true);
              var a = new Error("Cannot find module '" + i2 + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i2] = { exports: {} };
            e[i2][0].call(p.exports, function(r2) {
              var n2 = e[i2][1][r2];
              return o(n2 || r2);
            }, p, p.exports, r, e, n, t);
          }
          return n[i2].exports;
        }
        for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++) o(t[i]);
        return o;
      }
      return r;
    }())({ 1: [function(_dereq_, module3, exports2) {
      var Multimath = _dereq_("multimath");
      var mm_unsharp_mask = _dereq_("./mm_unsharp_mask");
      var mm_resize = _dereq_("./mm_resize");
      function MathLib(requested_features) {
        var __requested_features = requested_features || [];
        var features = {
          js: __requested_features.indexOf("js") >= 0,
          wasm: __requested_features.indexOf("wasm") >= 0
        };
        Multimath.call(this, features);
        this.features = {
          js: features.js,
          wasm: features.wasm && this.has_wasm()
        };
        this.use(mm_unsharp_mask);
        this.use(mm_resize);
      }
      MathLib.prototype = Object.create(Multimath.prototype);
      MathLib.prototype.constructor = MathLib;
      MathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {
        var result = this.resize(options, cache);
        if (options.unsharpAmount) {
          this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);
        }
        return result;
      };
      module3.exports = MathLib;
    }, { "./mm_resize": 4, "./mm_unsharp_mask": 9, "multimath": 19 }], 2: [function(_dereq_, module3, exports2) {
      function clampTo8(i) {
        return i < 0 ? 0 : i > 255 ? 255 : i;
      }
      function clampNegative(i) {
        return i >= 0 ? i : 0;
      }
      function convolveHor(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a;
        var filterPtr, filterShift, filterSize;
        var srcPtr, srcY, destX, filterVal;
        var srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
          filterPtr = 0;
          for (destX = 0; destX < destW; destX++) {
            filterShift = filters[filterPtr++];
            filterSize = filters[filterPtr++];
            srcPtr = srcOffset + filterShift * 4 | 0;
            r = g = b = a = 0;
            for (; filterSize > 0; filterSize--) {
              filterVal = filters[filterPtr++];
              a = a + filterVal * src[srcPtr + 3] | 0;
              b = b + filterVal * src[srcPtr + 2] | 0;
              g = g + filterVal * src[srcPtr + 1] | 0;
              r = r + filterVal * src[srcPtr] | 0;
              srcPtr = srcPtr + 4 | 0;
            }
            dest[destOffset + 3] = clampNegative(a >> 7);
            dest[destOffset + 2] = clampNegative(b >> 7);
            dest[destOffset + 1] = clampNegative(g >> 7);
            dest[destOffset] = clampNegative(r >> 7);
            destOffset = destOffset + srcH * 4 | 0;
          }
          destOffset = (srcY + 1) * 4 | 0;
          srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
      }
      function convolveVert(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a;
        var filterPtr, filterShift, filterSize;
        var srcPtr, srcY, destX, filterVal;
        var srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
          filterPtr = 0;
          for (destX = 0; destX < destW; destX++) {
            filterShift = filters[filterPtr++];
            filterSize = filters[filterPtr++];
            srcPtr = srcOffset + filterShift * 4 | 0;
            r = g = b = a = 0;
            for (; filterSize > 0; filterSize--) {
              filterVal = filters[filterPtr++];
              a = a + filterVal * src[srcPtr + 3] | 0;
              b = b + filterVal * src[srcPtr + 2] | 0;
              g = g + filterVal * src[srcPtr + 1] | 0;
              r = r + filterVal * src[srcPtr] | 0;
              srcPtr = srcPtr + 4 | 0;
            }
            r >>= 7;
            g >>= 7;
            b >>= 7;
            a >>= 7;
            dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14);
            dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);
            dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);
            dest[destOffset] = clampTo8(r + (1 << 13) >> 14);
            destOffset = destOffset + srcH * 4 | 0;
          }
          destOffset = (srcY + 1) * 4 | 0;
          srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
      }
      function convolveHorWithPre(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, alpha;
        var filterPtr, filterShift, filterSize;
        var srcPtr, srcY, destX, filterVal;
        var srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
          filterPtr = 0;
          for (destX = 0; destX < destW; destX++) {
            filterShift = filters[filterPtr++];
            filterSize = filters[filterPtr++];
            srcPtr = srcOffset + filterShift * 4 | 0;
            r = g = b = a = 0;
            for (; filterSize > 0; filterSize--) {
              filterVal = filters[filterPtr++];
              alpha = src[srcPtr + 3];
              a = a + filterVal * alpha | 0;
              b = b + filterVal * src[srcPtr + 2] * alpha | 0;
              g = g + filterVal * src[srcPtr + 1] * alpha | 0;
              r = r + filterVal * src[srcPtr] * alpha | 0;
              srcPtr = srcPtr + 4 | 0;
            }
            b = b / 255 | 0;
            g = g / 255 | 0;
            r = r / 255 | 0;
            dest[destOffset + 3] = clampNegative(a >> 7);
            dest[destOffset + 2] = clampNegative(b >> 7);
            dest[destOffset + 1] = clampNegative(g >> 7);
            dest[destOffset] = clampNegative(r >> 7);
            destOffset = destOffset + srcH * 4 | 0;
          }
          destOffset = (srcY + 1) * 4 | 0;
          srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
      }
      function convolveVertWithPre(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a;
        var filterPtr, filterShift, filterSize;
        var srcPtr, srcY, destX, filterVal;
        var srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
          filterPtr = 0;
          for (destX = 0; destX < destW; destX++) {
            filterShift = filters[filterPtr++];
            filterSize = filters[filterPtr++];
            srcPtr = srcOffset + filterShift * 4 | 0;
            r = g = b = a = 0;
            for (; filterSize > 0; filterSize--) {
              filterVal = filters[filterPtr++];
              a = a + filterVal * src[srcPtr + 3] | 0;
              b = b + filterVal * src[srcPtr + 2] | 0;
              g = g + filterVal * src[srcPtr + 1] | 0;
              r = r + filterVal * src[srcPtr] | 0;
              srcPtr = srcPtr + 4 | 0;
            }
            r >>= 7;
            g >>= 7;
            b >>= 7;
            a >>= 7;
            a = clampTo8(a + (1 << 13) >> 14);
            if (a > 0) {
              r = r * 255 / a | 0;
              g = g * 255 / a | 0;
              b = b * 255 / a | 0;
            }
            dest[destOffset + 3] = a;
            dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);
            dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);
            dest[destOffset] = clampTo8(r + (1 << 13) >> 14);
            destOffset = destOffset + srcH * 4 | 0;
          }
          destOffset = (srcY + 1) * 4 | 0;
          srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
      }
      module3.exports = {
        convolveHor,
        convolveVert,
        convolveHorWithPre,
        convolveVertWithPre
      };
    }, {}], 3: [function(_dereq_, module3, exports2) {
      module3.exports = "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEYA2AGf39/f39/AGAAAGAIf39/f39/f38AAg8BA2VudgZtZW1vcnkCAAADBwYBAAAAAAIGBgF/AEEACweUAQgRX193YXNtX2NhbGxfY3RvcnMAAAtjb252b2x2ZUhvcgABDGNvbnZvbHZlVmVydAACEmNvbnZvbHZlSG9yV2l0aFByZQADE2NvbnZvbHZlVmVydFdpdGhQcmUABApjb252b2x2ZUhWAAUMX19kc29faGFuZGxlAwAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAAKyA4GAwABC4wDARB/AkAgA0UNACAERQ0AIANBAnQhFQNAQQAhE0EAIQsDQCALQQJqIQcCfyALQQF0IAVqIgYuAQIiC0UEQEEAIQhBACEGQQAhCUEAIQogBwwBCyASIAYuAQBqIQhBACEJQQAhCiALIRRBACEOIAchBkEAIQ8DQCAFIAZBAXRqLgEAIhAgACAIQQJ0aigCACIRQRh2bCAPaiEPIBFB/wFxIBBsIAlqIQkgEUEQdkH/AXEgEGwgDmohDiARQQh2Qf8BcSAQbCAKaiEKIAhBAWohCCAGQQFqIQYgFEEBayIUDQALIAlBB3UhCCAKQQd1IQYgDkEHdSEJIA9BB3UhCiAHIAtqCyELIAEgDEEBdCIHaiAIQQAgCEEAShs7AQAgASAHQQJyaiAGQQAgBkEAShs7AQAgASAHQQRyaiAJQQAgCUEAShs7AQAgASAHQQZyaiAKQQAgCkEAShs7AQAgDCAVaiEMIBNBAWoiEyAERw0ACyANQQFqIg0gAmwhEiANQQJ0IQwgAyANRw0ACwsL2gMBD38CQCADRQ0AIARFDQAgAkECdCEUA0AgCyEMQQAhE0EAIQIDQCACQQJqIQYCfyACQQF0IAVqIgcuAQIiAkUEQEEAIQhBACEHQQAhCkEAIQkgBgwBCyAHLgEAQQJ0IBJqIQhBACEJIAIhCkEAIQ0gBiEHQQAhDkEAIQ8DQCAFIAdBAXRqLgEAIhAgACAIQQF0IhFqLwEAbCAJaiEJIAAgEUEGcmovAQAgEGwgDmohDiAAIBFBBHJqLwEAIBBsIA9qIQ8gACARQQJyai8BACAQbCANaiENIAhBBGohCCAHQQFqIQcgCkEBayIKDQALIAlBB3UhCCANQQd1IQcgDkEHdSEKIA9BB3UhCSACIAZqCyECIAEgDEECdGogB0GAQGtBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobQQh0QYD+A3EgCUGAQGtBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobQRB0QYCA/AdxIApBgEBrQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EYdHJyIAhBgEBrQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG3I2AgAgAyAMaiEMIBNBAWoiEyAERw0ACyAUIAtBAWoiC2whEiADIAtHDQALCwuSAwEQfwJAIANFDQAgBEUNACADQQJ0IRUDQEEAIRNBACEGA0AgBkECaiEIAn8gBkEBdCAFaiIGLgECIgdFBEBBACEJQQAhDEEAIQ1BACEOIAgMAQsgEiAGLgEAaiEJQQAhDkEAIQ1BACEMIAchFEEAIQ8gCCEGA0AgBSAGQQF0ai4BACAAIAlBAnRqKAIAIhBBGHZsIhEgD2ohDyARIBBBEHZB/wFxbCAMaiEMIBEgEEEIdkH/AXFsIA1qIQ0gESAQQf8BcWwgDmohDiAJQQFqIQkgBkEBaiEGIBRBAWsiFA0ACyAPQQd1IQkgByAIagshBiABIApBAXQiCGogDkH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEECcmogDUH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEEEcmogDEH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEEGcmogCUEAIAlBAEobOwEAIAogFWohCiATQQFqIhMgBEcNAAsgC0EBaiILIAJsIRIgC0ECdCEKIAMgC0cNAAsLC4IEAQ9/AkAgA0UNACAERQ0AIAJBAnQhFANAIAshDEEAIRJBACEHA0AgB0ECaiEKAn8gB0EBdCAFaiICLgECIhNFBEBBACEIQQAhCUEAIQYgCiEHQQAMAQsgAi4BAEECdCARaiEJQQAhByATIQJBACENIAohBkEAIQ5BACEPA0AgBSAGQQF0ai4BACIIIAAgCUEBdCIQai8BAGwgB2ohByAAIBBBBnJqLwEAIAhsIA5qIQ4gACAQQQRyai8BACAIbCAPaiEPIAAgEEECcmovAQAgCGwgDWohDSAJQQRqIQkgBkEBaiEGIAJBAWsiAg0ACyAHQQd1IQggDUEHdSEJIA9BB3UhBiAKIBNqIQcgDkEHdQtBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKGyIKQf8BcQRAIAlB/wFsIAJtIQkgCEH/AWwgAm0hCCAGQf8BbCACbSEGCyABIAxBAnRqIAlBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKG0EIdEGA/gNxIAZBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKG0EQdEGAgPwHcSAKQRh0ciAIQYBAa0EOdSICQf8BIAJB/wFIGyICQQAgAkEAShtycjYCACADIAxqIQwgEkEBaiISIARHDQALIBQgC0EBaiILbCERIAMgC0cNAAsLC0AAIAcEQEEAIAIgAyAEIAUgABADIAJBACAEIAUgBiABEAQPC0EAIAIgAyAEIAUgABABIAJBACAEIAUgBiABEAIL";
    }, {}], 4: [function(_dereq_, module3, exports2) {
      module3.exports = {
        name: "resize",
        fn: _dereq_("./resize"),
        wasm_fn: _dereq_("./resize_wasm"),
        wasm_src: _dereq_("./convolve_wasm_base64")
      };
    }, { "./convolve_wasm_base64": 3, "./resize": 5, "./resize_wasm": 8 }], 5: [function(_dereq_, module3, exports2) {
      var createFilters = _dereq_("./resize_filter_gen");
      var _require = _dereq_("./convolve"), convolveHor = _require.convolveHor, convolveVert = _require.convolveVert, convolveHorWithPre = _require.convolveHorWithPre, convolveVertWithPre = _require.convolveVertWithPre;
      function hasAlpha(src, width, height) {
        var ptr = 3, len = width * height * 4 | 0;
        while (ptr < len) {
          if (src[ptr] !== 255) return true;
          ptr = ptr + 4 | 0;
        }
        return false;
      }
      function resetAlpha(dst, width, height) {
        var ptr = 3, len = width * height * 4 | 0;
        while (ptr < len) {
          dst[ptr] = 255;
          ptr = ptr + 4 | 0;
        }
      }
      module3.exports = function resize(options) {
        var src = options.src;
        var srcW = options.width;
        var srcH = options.height;
        var destW = options.toWidth;
        var destH = options.toHeight;
        var scaleX = options.scaleX || options.toWidth / options.width;
        var scaleY = options.scaleY || options.toHeight / options.height;
        var offsetX = options.offsetX || 0;
        var offsetY = options.offsetY || 0;
        var dest = options.dest || new Uint8Array(destW * destH * 4);
        var filter = typeof options.filter === "undefined" ? "mks2013" : options.filter;
        var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);
        var tmp = new Uint16Array(destW * srcH * 4);
        if (hasAlpha(src, srcW, srcH)) {
          convolveHorWithPre(src, tmp, srcW, srcH, destW, filtersX);
          convolveVertWithPre(tmp, dest, srcH, destW, destH, filtersY);
        } else {
          convolveHor(src, tmp, srcW, srcH, destW, filtersX);
          convolveVert(tmp, dest, srcH, destW, destH, filtersY);
          resetAlpha(dest, destW, destH);
        }
        return dest;
      };
    }, { "./convolve": 2, "./resize_filter_gen": 6 }], 6: [function(_dereq_, module3, exports2) {
      var FILTER_INFO = _dereq_("./resize_filter_info");
      var FIXED_FRAC_BITS = 14;
      function toFixedPoint(num) {
        return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));
      }
      module3.exports = function resizeFilterGen(filter, srcSize, destSize, scale, offset) {
        var filterFunction = FILTER_INFO.filter[filter].fn;
        var scaleInverted = 1 / scale;
        var scaleClamped = Math.min(1, scale);
        var srcWindow = FILTER_INFO.filter[filter].win / scaleClamped;
        var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;
        var leftNotEmpty, rightNotEmpty, filterShift, filterSize;
        var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);
        var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);
        var packedFilterPtr = 0;
        var slowCopy = !packedFilter.subarray || !packedFilter.set;
        for (destPixel = 0; destPixel < destSize; destPixel++) {
          srcPixel = (destPixel + 0.5) * scaleInverted + offset;
          srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));
          srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));
          filterElementSize = srcLast - srcFirst + 1;
          floatFilter = new Float32Array(filterElementSize);
          fxpFilter = new Int16Array(filterElementSize);
          total = 0;
          for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {
            floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);
            total += floatVal;
            floatFilter[idx] = floatVal;
          }
          filterTotal = 0;
          for (idx = 0; idx < floatFilter.length; idx++) {
            filterVal = floatFilter[idx] / total;
            filterTotal += filterVal;
            fxpFilter[idx] = toFixedPoint(filterVal);
          }
          fxpFilter[destSize >> 1] += toFixedPoint(1 - filterTotal);
          leftNotEmpty = 0;
          while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {
            leftNotEmpty++;
          }
          if (leftNotEmpty < fxpFilter.length) {
            rightNotEmpty = fxpFilter.length - 1;
            while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {
              rightNotEmpty--;
            }
            filterShift = srcFirst + leftNotEmpty;
            filterSize = rightNotEmpty - leftNotEmpty + 1;
            packedFilter[packedFilterPtr++] = filterShift;
            packedFilter[packedFilterPtr++] = filterSize;
            if (!slowCopy) {
              packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);
              packedFilterPtr += filterSize;
            } else {
              for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {
                packedFilter[packedFilterPtr++] = fxpFilter[idx];
              }
            }
          } else {
            packedFilter[packedFilterPtr++] = 0;
            packedFilter[packedFilterPtr++] = 0;
          }
        }
        return packedFilter;
      };
    }, { "./resize_filter_info": 7 }], 7: [function(_dereq_, module3, exports2) {
      var filter = {
        // Nearest neibor
        box: {
          win: 0.5,
          fn: function fn(x) {
            if (x < 0) x = -x;
            return x < 0.5 ? 1 : 0;
          }
        },
        // // Hamming
        hamming: {
          win: 1,
          fn: function fn(x) {
            if (x < 0) x = -x;
            if (x >= 1) {
              return 0;
            }
            if (x < 11920929e-14) {
              return 1;
            }
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1));
          }
        },
        // Lanczos, win = 2
        lanczos2: {
          win: 2,
          fn: function fn(x) {
            if (x < 0) x = -x;
            if (x >= 2) {
              return 0;
            }
            if (x < 11920929e-14) {
              return 1;
            }
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * Math.sin(xpi / 2) / (xpi / 2);
          }
        },
        // Lanczos, win = 3
        lanczos3: {
          win: 3,
          fn: function fn(x) {
            if (x < 0) x = -x;
            if (x >= 3) {
              return 0;
            }
            if (x < 11920929e-14) {
              return 1;
            }
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * Math.sin(xpi / 3) / (xpi / 3);
          }
        },
        // Magic Kernel Sharp 2013, win = 2.5
        // http://johncostella.com/magic/
        mks2013: {
          win: 2.5,
          fn: function fn(x) {
            if (x < 0) x = -x;
            if (x >= 2.5) {
              return 0;
            }
            if (x >= 1.5) {
              return -0.125 * (x - 2.5) * (x - 2.5);
            }
            if (x >= 0.5) {
              return 0.25 * (4 * x * x - 11 * x + 7);
            }
            return 1.0625 - 1.75 * x * x;
          }
        }
      };
      module3.exports = {
        filter,
        // Legacy mapping
        f2q: {
          box: 0,
          hamming: 1,
          lanczos2: 2,
          lanczos3: 3
        },
        q2f: ["box", "hamming", "lanczos2", "lanczos3"]
      };
    }, {}], 8: [function(_dereq_, module3, exports2) {
      var createFilters = _dereq_("./resize_filter_gen");
      function hasAlpha(src, width, height) {
        var ptr = 3, len = width * height * 4 | 0;
        while (ptr < len) {
          if (src[ptr] !== 255) return true;
          ptr = ptr + 4 | 0;
        }
        return false;
      }
      function resetAlpha(dst, width, height) {
        var ptr = 3, len = width * height * 4 | 0;
        while (ptr < len) {
          dst[ptr] = 255;
          ptr = ptr + 4 | 0;
        }
      }
      function asUint8Array(src) {
        return new Uint8Array(src.buffer, 0, src.byteLength);
      }
      var IS_LE = true;
      try {
        IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
      } catch (__) {
      }
      function copyInt16asLE(src, target, target_offset) {
        if (IS_LE) {
          target.set(asUint8Array(src), target_offset);
          return;
        }
        for (var ptr = target_offset, i = 0; i < src.length; i++) {
          var data2 = src[i];
          target[ptr++] = data2 & 255;
          target[ptr++] = data2 >> 8 & 255;
        }
      }
      module3.exports = function resize_wasm(options) {
        var src = options.src;
        var srcW = options.width;
        var srcH = options.height;
        var destW = options.toWidth;
        var destH = options.toHeight;
        var scaleX = options.scaleX || options.toWidth / options.width;
        var scaleY = options.scaleY || options.toHeight / options.height;
        var offsetX = options.offsetX || 0;
        var offsetY = options.offsetY || 0;
        var dest = options.dest || new Uint8Array(destW * destH * 4);
        var filter = typeof options.filter === "undefined" ? "mks2013" : options.filter;
        var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);
        var src_offset = 0;
        var src_size = Math.max(src.byteLength, dest.byteLength);
        var tmp_offset = this.__align(src_offset + src_size);
        var tmp_size = srcH * destW * 4 * 2;
        var filtersX_offset = this.__align(tmp_offset + tmp_size);
        var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);
        var alloc_bytes = filtersY_offset + filtersY.byteLength;
        var instance = this.__instance("resize", alloc_bytes);
        var mem = new Uint8Array(this.__memory.buffer);
        var mem32 = new Uint32Array(this.__memory.buffer);
        var src32 = new Uint32Array(src.buffer);
        mem32.set(src32);
        copyInt16asLE(filtersX, mem, filtersX_offset);
        copyInt16asLE(filtersY, mem, filtersY_offset);
        var fn = instance.exports.convolveHV || instance.exports._convolveHV;
        if (hasAlpha(src, srcW, srcH)) {
          fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 1);
        } else {
          fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 0);
          resetAlpha(dest, destW, destH);
        }
        var dest32 = new Uint32Array(dest.buffer);
        dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW));
        return dest;
      };
    }, { "./resize_filter_gen": 6 }], 9: [function(_dereq_, module3, exports2) {
      module3.exports = {
        name: "unsharp_mask",
        fn: _dereq_("./unsharp_mask"),
        wasm_fn: _dereq_("./unsharp_mask_wasm"),
        wasm_src: _dereq_("./unsharp_mask_wasm_base64")
      };
    }, { "./unsharp_mask": 10, "./unsharp_mask_wasm": 11, "./unsharp_mask_wasm_base64": 12 }], 10: [function(_dereq_, module3, exports2) {
      var glur_mono16 = _dereq_("glur/mono16");
      function hsv_v16(img, width, height) {
        var size = width * height;
        var out = new Uint16Array(size);
        var r, g, b, max;
        for (var i = 0; i < size; i++) {
          r = img[4 * i];
          g = img[4 * i + 1];
          b = img[4 * i + 2];
          max = r >= g && r >= b ? r : g >= b && g >= r ? g : b;
          out[i] = max << 8;
        }
        return out;
      }
      module3.exports = function unsharp(img, width, height, amount, radius, threshold) {
        var v1, v2, vmul;
        var diff, iTimes4;
        if (amount === 0 || radius < 0.5) {
          return;
        }
        if (radius > 2) {
          radius = 2;
        }
        var brightness = hsv_v16(img, width, height);
        var blured = new Uint16Array(brightness);
        glur_mono16(blured, width, height, radius);
        var amountFp = amount / 100 * 4096 + 0.5 | 0;
        var thresholdFp = threshold << 8;
        var size = width * height;
        for (var i = 0; i < size; i++) {
          v1 = brightness[i];
          diff = v1 - blured[i];
          if (Math.abs(diff) >= thresholdFp) {
            v2 = v1 + (amountFp * diff + 2048 >> 12);
            v2 = v2 > 65280 ? 65280 : v2;
            v2 = v2 < 0 ? 0 : v2;
            v1 = v1 !== 0 ? v1 : 1;
            vmul = (v2 << 12) / v1 | 0;
            iTimes4 = i * 4;
            img[iTimes4] = img[iTimes4] * vmul + 2048 >> 12;
            img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 2048 >> 12;
            img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 2048 >> 12;
          }
        }
      };
    }, { "glur/mono16": 18 }], 11: [function(_dereq_, module3, exports2) {
      module3.exports = function unsharp(img, width, height, amount, radius, threshold) {
        if (amount === 0 || radius < 0.5) {
          return;
        }
        if (radius > 2) {
          radius = 2;
        }
        var pixels = width * height;
        var img_bytes_cnt = pixels * 4;
        var hsv_bytes_cnt = pixels * 2;
        var blur_bytes_cnt = pixels * 2;
        var blur_line_byte_cnt = Math.max(width, height) * 4;
        var blur_coeffs_byte_cnt = 8 * 4;
        var img_offset = 0;
        var hsv_offset = img_bytes_cnt;
        var blur_offset = hsv_offset + hsv_bytes_cnt;
        var blur_tmp_offset = blur_offset + blur_bytes_cnt;
        var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;
        var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;
        var instance = this.__instance("unsharp_mask", img_bytes_cnt + hsv_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {
          exp: Math.exp
        });
        var img32 = new Uint32Array(img.buffer);
        var mem32 = new Uint32Array(this.__memory.buffer);
        mem32.set(img32);
        var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;
        fn(img_offset, hsv_offset, width, height);
        fn = instance.exports.blurMono16 || instance.exports._blurMono16;
        fn(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius);
        fn = instance.exports.unsharp || instance.exports._unsharp;
        fn(img_offset, img_offset, hsv_offset, blur_offset, width, height, amount, threshold);
        img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));
      };
    }, {}], 12: [function(_dereq_, module3, exports2) {
      module3.exports = "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";
    }, {}], 13: [function(_dereq_, module3, exports2) {
      var GC_INTERVAL = 100;
      function Pool(create, idle) {
        this.create = create;
        this.available = [];
        this.acquired = {};
        this.lastId = 1;
        this.timeoutId = 0;
        this.idle = idle || 2e3;
      }
      Pool.prototype.acquire = function() {
        var _this = this;
        var resource;
        if (this.available.length !== 0) {
          resource = this.available.pop();
        } else {
          resource = this.create();
          resource.id = this.lastId++;
          resource.release = function() {
            return _this.release(resource);
          };
        }
        this.acquired[resource.id] = resource;
        return resource;
      };
      Pool.prototype.release = function(resource) {
        var _this2 = this;
        delete this.acquired[resource.id];
        resource.lastUsed = Date.now();
        this.available.push(resource);
        if (this.timeoutId === 0) {
          this.timeoutId = setTimeout(function() {
            return _this2.gc();
          }, GC_INTERVAL);
        }
      };
      Pool.prototype.gc = function() {
        var _this3 = this;
        var now = Date.now();
        this.available = this.available.filter(function(resource) {
          if (now - resource.lastUsed > _this3.idle) {
            resource.destroy();
            return false;
          }
          return true;
        });
        if (this.available.length !== 0) {
          this.timeoutId = setTimeout(function() {
            return _this3.gc();
          }, GC_INTERVAL);
        } else {
          this.timeoutId = 0;
        }
      };
      module3.exports = Pool;
    }, {}], 14: [function(_dereq_, module3, exports2) {
      var MIN_INNER_TILE_SIZE = 2;
      module3.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {
        var scaleX = toWidth / fromWidth;
        var scaleY = toHeight / fromHeight;
        var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize;
        if (minScale > 0.5) return [[toWidth, toHeight]];
        var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale));
        if (stageCount <= 1) return [[toWidth, toHeight]];
        var result = [];
        for (var i = 0; i < stageCount; i++) {
          var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));
          var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));
          result.push([width, height]);
        }
        return result;
      };
    }, {}], 15: [function(_dereq_, module3, exports2) {
      var PIXEL_EPSILON = 1e-5;
      function pixelFloor(x) {
        var nearest = Math.round(x);
        if (Math.abs(x - nearest) < PIXEL_EPSILON) {
          return nearest;
        }
        return Math.floor(x);
      }
      function pixelCeil(x) {
        var nearest = Math.round(x);
        if (Math.abs(x - nearest) < PIXEL_EPSILON) {
          return nearest;
        }
        return Math.ceil(x);
      }
      module3.exports = function createRegions(options) {
        var scaleX = options.toWidth / options.width;
        var scaleY = options.toHeight / options.height;
        var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;
        var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder;
        if (innerTileWidth < 1 || innerTileHeight < 1) {
          throw new Error("Internal error in pica: target tile width/height is too small.");
        }
        var x, y;
        var innerX, innerY, toTileWidth, toTileHeight;
        var tiles = [];
        var tile;
        for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {
          for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {
            x = innerX - options.destTileBorder;
            if (x < 0) {
              x = 0;
            }
            toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;
            if (x + toTileWidth >= options.toWidth) {
              toTileWidth = options.toWidth - x;
            }
            y = innerY - options.destTileBorder;
            if (y < 0) {
              y = 0;
            }
            toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;
            if (y + toTileHeight >= options.toHeight) {
              toTileHeight = options.toHeight - y;
            }
            tile = {
              toX: x,
              toY: y,
              toWidth: toTileWidth,
              toHeight: toTileHeight,
              toInnerX: innerX,
              toInnerY: innerY,
              toInnerWidth: innerTileWidth,
              toInnerHeight: innerTileHeight,
              offsetX: x / scaleX - pixelFloor(x / scaleX),
              offsetY: y / scaleY - pixelFloor(y / scaleY),
              scaleX,
              scaleY,
              x: pixelFloor(x / scaleX),
              y: pixelFloor(y / scaleY),
              width: pixelCeil(toTileWidth / scaleX),
              height: pixelCeil(toTileHeight / scaleY)
            };
            tiles.push(tile);
          }
        }
        return tiles;
      };
    }, {}], 16: [function(_dereq_, module3, exports2) {
      function objClass(obj) {
        return Object.prototype.toString.call(obj);
      }
      module3.exports.isCanvas = function isCanvas(element) {
        var cname = objClass(element);
        return cname === "[object HTMLCanvasElement]" || cname === "[object OffscreenCanvas]" || cname === "[object Canvas]";
      };
      module3.exports.isImage = function isImage(element) {
        return objClass(element) === "[object HTMLImageElement]";
      };
      module3.exports.isImageBitmap = function isImageBitmap(element) {
        return objClass(element) === "[object ImageBitmap]";
      };
      module3.exports.limiter = function limiter(concurrency) {
        var active = 0, queue = [];
        function roll() {
          if (active < concurrency && queue.length) {
            active++;
            queue.shift()();
          }
        }
        return function limit(fn) {
          return new Promise(function(resolve, reject) {
            queue.push(function() {
              fn().then(function(result) {
                resolve(result);
                active--;
                roll();
              }, function(err) {
                reject(err);
                active--;
                roll();
              });
            });
            roll();
          });
        };
      };
      module3.exports.cib_quality_name = function cib_quality_name(num) {
        switch (num) {
          case 0:
            return "pixelated";
          case 1:
            return "low";
          case 2:
            return "medium";
        }
        return "high";
      };
      module3.exports.cib_support = function cib_support(createCanvas) {
        return Promise.resolve().then(function() {
          if (typeof createImageBitmap === "undefined") {
            return false;
          }
          var c = createCanvas(100, 100);
          return createImageBitmap(c, 0, 0, 100, 100, {
            resizeWidth: 10,
            resizeHeight: 10,
            resizeQuality: "high"
          }).then(function(bitmap) {
            var status = bitmap.width === 10;
            bitmap.close();
            c = null;
            return status;
          });
        })["catch"](function() {
          return false;
        });
      };
      module3.exports.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {
        return new Promise(function(resolve, reject) {
          if (typeof OffscreenCanvas === "undefined") {
            resolve(false);
            return;
          }
          function workerPayload(self2) {
            if (typeof createImageBitmap === "undefined") {
              self2.postMessage(false);
              return;
            }
            Promise.resolve().then(function() {
              var canvas = new OffscreenCanvas(10, 10);
              var ctx = canvas.getContext("2d");
              ctx.rect(0, 0, 1, 1);
              return createImageBitmap(canvas, 0, 0, 1, 1);
            }).then(function() {
              return self2.postMessage(true);
            }, function() {
              return self2.postMessage(false);
            });
          }
          var code = btoa("(".concat(workerPayload.toString(), ")(self);"));
          var w = new Worker("data:text/javascript;base64,".concat(code));
          w.onmessage = function(ev) {
            return resolve(ev.data);
          };
          w.onerror = reject;
        }).then(function(result) {
          return result;
        }, function() {
          return false;
        });
      };
      module3.exports.can_use_canvas = function can_use_canvas(createCanvas) {
        var usable = false;
        try {
          var canvas = createCanvas(2, 1);
          var ctx = canvas.getContext("2d");
          var d = ctx.createImageData(2, 1);
          d.data[0] = 12;
          d.data[1] = 23;
          d.data[2] = 34;
          d.data[3] = 255;
          d.data[4] = 45;
          d.data[5] = 56;
          d.data[6] = 67;
          d.data[7] = 255;
          ctx.putImageData(d, 0, 0);
          d = null;
          d = ctx.getImageData(0, 0, 2, 1);
          if (d.data[0] === 12 && d.data[1] === 23 && d.data[2] === 34 && d.data[3] === 255 && d.data[4] === 45 && d.data[5] === 56 && d.data[6] === 67 && d.data[7] === 255) {
            usable = true;
          }
        } catch (err) {
        }
        return usable;
      };
      module3.exports.cib_can_use_region = function cib_can_use_region() {
        return new Promise(function(resolve) {
          if (typeof createImageBitmap === "undefined") {
            resolve(false);
            return;
          }
          var image = new Image();
          image.src = "data:image/jpeg;base64,/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRcZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRAf/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z";
          image.onload = function() {
            createImageBitmap(image, 0, 0, image.width, image.height).then(function(bitmap) {
              if (bitmap.width === image.width && bitmap.height === image.height) {
                resolve(true);
              } else {
                resolve(false);
              }
            }, function() {
              return resolve(false);
            });
          };
          image.onerror = function() {
            return resolve(false);
          };
        });
      };
    }, {}], 17: [function(_dereq_, module3, exports2) {
      module3.exports = function() {
        var MathLib = _dereq_("./mathlib");
        var mathLib;
        onmessage = function onmessage2(ev) {
          var tileOpts = ev.data.opts;
          if (!tileOpts.src && tileOpts.srcBitmap) {
            var canvas = new OffscreenCanvas(tileOpts.width, tileOpts.height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(tileOpts.srcBitmap, 0, 0);
            tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data;
            canvas.width = canvas.height = 0;
            canvas = null;
            tileOpts.srcBitmap.close();
            tileOpts.srcBitmap = null;
          }
          if (!mathLib) mathLib = new MathLib(ev.data.features);
          var data2 = mathLib.resizeAndUnsharp(tileOpts);
          {
            postMessage({
              data: data2
            }, [data2.buffer]);
          }
        };
      };
    }, { "./mathlib": 1 }], 18: [function(_dereq_, module3, exports2) {
      var a0, a1, a2, a3, b1, b2, left_corner, right_corner;
      function gaussCoef(sigma) {
        if (sigma < 0.5) {
          sigma = 0.5;
        }
        var a = Math.exp(0.726 * 0.726) / sigma, g1 = Math.exp(-a), g2 = Math.exp(-2 * a), k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);
        a0 = k;
        a1 = k * (a - 1) * g1;
        a2 = k * (a + 1) * g1;
        a3 = -k * g2;
        b1 = 2 * g1;
        b2 = -g2;
        left_corner = (a0 + a1) / (1 - b1 - b2);
        right_corner = (a2 + a3) / (1 - b1 - b2);
        return new Float32Array([a0, a1, a2, a3, b1, b2, left_corner, right_corner]);
      }
      function convolveMono16(src, out, line, coeff, width, height) {
        var prev_src, curr_src, curr_out, prev_out, prev_prev_out;
        var src_index, out_index, line_index;
        var i, j;
        var coeff_a0, coeff_a1, coeff_b1, coeff_b2;
        for (i = 0; i < height; i++) {
          src_index = i * width;
          out_index = i;
          line_index = 0;
          prev_src = src[src_index];
          prev_prev_out = prev_src * coeff[6];
          prev_out = prev_prev_out;
          coeff_a0 = coeff[0];
          coeff_a1 = coeff[1];
          coeff_b1 = coeff[4];
          coeff_b2 = coeff[5];
          for (j = 0; j < width; j++) {
            curr_src = src[src_index];
            curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
            prev_prev_out = prev_out;
            prev_out = curr_out;
            prev_src = curr_src;
            line[line_index] = prev_out;
            line_index++;
            src_index++;
          }
          src_index--;
          line_index--;
          out_index += height * (width - 1);
          prev_src = src[src_index];
          prev_prev_out = prev_src * coeff[7];
          prev_out = prev_prev_out;
          curr_src = prev_src;
          coeff_a0 = coeff[2];
          coeff_a1 = coeff[3];
          for (j = width - 1; j >= 0; j--) {
            curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
            prev_prev_out = prev_out;
            prev_out = curr_out;
            prev_src = curr_src;
            curr_src = src[src_index];
            out[out_index] = line[line_index] + prev_out;
            src_index--;
            line_index--;
            out_index -= height;
          }
        }
      }
      function blurMono16(src, width, height, radius) {
        if (!radius) {
          return;
        }
        var out = new Uint16Array(src.length), tmp_line = new Float32Array(Math.max(width, height));
        var coeff = gaussCoef(radius);
        convolveMono16(src, out, tmp_line, coeff, width, height);
        convolveMono16(out, src, tmp_line, coeff, height, width);
      }
      module3.exports = blurMono16;
    }, {}], 19: [function(_dereq_, module3, exports2) {
      var assign3 = _dereq_("object-assign");
      var base64decode = _dereq_("./lib/base64decode");
      var hasWebAssembly = _dereq_("./lib/wa_detect");
      var DEFAULT_OPTIONS = {
        js: true,
        wasm: true
      };
      function MultiMath(options) {
        if (!(this instanceof MultiMath)) return new MultiMath(options);
        var opts = assign3({}, DEFAULT_OPTIONS, options || {});
        this.options = opts;
        this.__cache = {};
        this.__init_promise = null;
        this.__modules = opts.modules || {};
        this.__memory = null;
        this.__wasm = {};
        this.__isLE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
        if (!this.options.js && !this.options.wasm) {
          throw new Error('mathlib: at least "js" or "wasm" should be enabled');
        }
      }
      MultiMath.prototype.has_wasm = hasWebAssembly;
      MultiMath.prototype.use = function(module4) {
        this.__modules[module4.name] = module4;
        if (this.options.wasm && this.has_wasm() && module4.wasm_fn) {
          this[module4.name] = module4.wasm_fn;
        } else {
          this[module4.name] = module4.fn;
        }
        return this;
      };
      MultiMath.prototype.init = function() {
        if (this.__init_promise) return this.__init_promise;
        if (!this.options.js && this.options.wasm && !this.has_wasm()) {
          return Promise.reject(new Error(`mathlib: only "wasm" was enabled, but it's not supported`));
        }
        var self2 = this;
        this.__init_promise = Promise.all(Object.keys(self2.__modules).map(function(name) {
          var module4 = self2.__modules[name];
          if (!self2.options.wasm || !self2.has_wasm() || !module4.wasm_fn) return null;
          if (self2.__wasm[name]) return null;
          return WebAssembly.compile(self2.__base64decode(module4.wasm_src)).then(function(m) {
            self2.__wasm[name] = m;
          });
        })).then(function() {
          return self2;
        });
        return this.__init_promise;
      };
      MultiMath.prototype.__base64decode = base64decode;
      MultiMath.prototype.__reallocate = function mem_grow_to(bytes2) {
        if (!this.__memory) {
          this.__memory = new WebAssembly.Memory({
            initial: Math.ceil(bytes2 / (64 * 1024))
          });
          return this.__memory;
        }
        var mem_size = this.__memory.buffer.byteLength;
        if (mem_size < bytes2) {
          this.__memory.grow(Math.ceil((bytes2 - mem_size) / (64 * 1024)));
        }
        return this.__memory;
      };
      MultiMath.prototype.__instance = function instance(name, memsize, env_extra) {
        if (memsize) this.__reallocate(memsize);
        if (!this.__wasm[name]) {
          var module4 = this.__modules[name];
          this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module4.wasm_src));
        }
        if (!this.__cache[name]) {
          var env_base = {
            memoryBase: 0,
            memory: this.__memory,
            tableBase: 0,
            table: new WebAssembly.Table({ initial: 0, element: "anyfunc" })
          };
          this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {
            env: assign3(env_base, env_extra || {})
          });
        }
        return this.__cache[name];
      };
      MultiMath.prototype.__align = function align(number2, base) {
        base = base || 8;
        var reminder = number2 % base;
        return number2 + (reminder ? base - reminder : 0);
      };
      module3.exports = MultiMath;
    }, { "./lib/base64decode": 20, "./lib/wa_detect": 21, "object-assign": 22 }], 20: [function(_dereq_, module3, exports2) {
      var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      module3.exports = function base64decode(str) {
        var input = str.replace(/[\r\n=]/g, ""), max = input.length;
        var out = new Uint8Array(max * 3 >> 2);
        var bits = 0;
        var ptr = 0;
        for (var idx = 0; idx < max; idx++) {
          if (idx % 4 === 0 && idx) {
            out[ptr++] = bits >> 16 & 255;
            out[ptr++] = bits >> 8 & 255;
            out[ptr++] = bits & 255;
          }
          bits = bits << 6 | BASE64_MAP.indexOf(input.charAt(idx));
        }
        var tailbits = max % 4 * 6;
        if (tailbits === 0) {
          out[ptr++] = bits >> 16 & 255;
          out[ptr++] = bits >> 8 & 255;
          out[ptr++] = bits & 255;
        } else if (tailbits === 18) {
          out[ptr++] = bits >> 10 & 255;
          out[ptr++] = bits >> 2 & 255;
        } else if (tailbits === 12) {
          out[ptr++] = bits >> 4 & 255;
        }
        return out;
      };
    }, {}], 21: [function(_dereq_, module3, exports2) {
      var wa;
      module3.exports = function hasWebAssembly() {
        if (typeof wa !== "undefined") return wa;
        wa = false;
        if (typeof WebAssembly === "undefined") return wa;
        try {
          var bin = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]);
          var module4 = new WebAssembly.Module(bin);
          var instance = new WebAssembly.Instance(module4, {});
          if (instance.exports.test(4) !== 0) wa = true;
          return wa;
        } catch (__) {
        }
        return wa;
      };
    }, {}], 22: [function(_dereq_, module3, exports2) {
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module3.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }, {}], 23: [function(_dereq_, module3, exports2) {
      var bundleFn = arguments[3];
      var sources = arguments[4];
      var cache = arguments[5];
      var stringify = JSON.stringify;
      module3.exports = function(fn, options) {
        var wkey;
        var cacheKeys = Object.keys(cache);
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
          var key = cacheKeys[i];
          var exp = cache[key].exports;
          if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
          }
        }
        if (!wkey) {
          wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
          var wcache = {};
          for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
          }
          sources[wkey] = [
            "function(require,module,exports){" + fn + "(self); }",
            wcache
          ];
        }
        var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var scache = {};
        scache[wkey] = wkey;
        sources[skey] = [
          "function(require,module,exports){var f = require(" + stringify(wkey) + ");(f.default ? f.default : f)(self);}",
          scache
        ];
        var workerSources = {};
        resolveSources(skey);
        function resolveSources(key2) {
          workerSources[key2] = true;
          for (var depPath in sources[key2][1]) {
            var depKey = sources[key2][1][depPath];
            if (!workerSources[depKey]) {
              resolveSources(depKey);
            }
          }
        }
        var src = "(" + bundleFn + ")({" + Object.keys(workerSources).map(function(key2) {
          return stringify(key2) + ":[" + sources[key2][0] + "," + stringify(sources[key2][1]) + "]";
        }).join(",") + "},{},[" + stringify(skey) + "])";
        var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
        var blob = new Blob([src], { type: "text/javascript" });
        if (options && options.bare) {
          return blob;
        }
        var workerUrl = URL2.createObjectURL(blob);
        var worker = new Worker(workerUrl);
        worker.objectURL = workerUrl;
        return worker;
      };
    }, {}], "/index.js": [function(_dereq_, module3, exports2) {
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _iterableToArrayLimit(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      var assign3 = _dereq_("object-assign");
      var webworkify = _dereq_("webworkify");
      var MathLib = _dereq_("./lib/mathlib");
      var Pool = _dereq_("./lib/pool");
      var utils2 = _dereq_("./lib/utils");
      var worker = _dereq_("./lib/worker");
      var createStages = _dereq_("./lib/stepper");
      var createRegions = _dereq_("./lib/tiler");
      var filter_info = _dereq_("./lib/mm_resize/resize_filter_info");
      var singletones = {};
      var NEED_SAFARI_FIX = false;
      try {
        if (typeof navigator !== "undefined" && navigator.userAgent) {
          NEED_SAFARI_FIX = navigator.userAgent.indexOf("Safari") >= 0;
        }
      } catch (e) {
      }
      var concurrency = 1;
      if (typeof navigator !== "undefined") {
        concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);
      }
      var DEFAULT_PICA_OPTS = {
        tile: 1024,
        concurrency,
        features: ["js", "wasm", "ww"],
        idle: 2e3,
        createCanvas: function createCanvas(width, height) {
          var tmpCanvas = document.createElement("canvas");
          tmpCanvas.width = width;
          tmpCanvas.height = height;
          return tmpCanvas;
        }
      };
      var DEFAULT_RESIZE_OPTS = {
        filter: "mks2013",
        unsharpAmount: 0,
        unsharpRadius: 0,
        unsharpThreshold: 0
      };
      var CAN_NEW_IMAGE_DATA = false;
      var CAN_CREATE_IMAGE_BITMAP = false;
      var CAN_USE_CANVAS_GET_IMAGE_DATA = false;
      var CAN_USE_OFFSCREEN_CANVAS = false;
      var CAN_USE_CIB_REGION_FOR_IMAGE = false;
      function workerFabric() {
        return {
          value: webworkify(worker),
          destroy: function destroy() {
            this.value.terminate();
            if (typeof window !== "undefined") {
              var url = window.URL || window.webkitURL || window.mozURL || window.msURL;
              if (url && url.revokeObjectURL && this.value.objectURL) {
                url.revokeObjectURL(this.value.objectURL);
              }
            }
          }
        };
      }
      function Pica2(options) {
        if (!(this instanceof Pica2)) return new Pica2(options);
        this.options = assign3({}, DEFAULT_PICA_OPTS, options || {});
        var limiter_key = "lk_".concat(this.options.concurrency);
        this.__limit = singletones[limiter_key] || utils2.limiter(this.options.concurrency);
        if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit;
        this.features = {
          js: false,
          // pure JS implementation, can be disabled for testing
          wasm: false,
          // webassembly implementation for heavy functions
          cib: false,
          // resize via createImageBitmap (only FF at this moment)
          ww: false
          // webworkers
        };
        this.__workersPool = null;
        this.__requested_features = [];
        this.__mathlib = null;
      }
      Pica2.prototype.init = function() {
        var _this = this;
        if (this.__initPromise) return this.__initPromise;
        if (typeof ImageData !== "undefined" && typeof Uint8ClampedArray !== "undefined") {
          try {
            new ImageData(new Uint8ClampedArray(400), 10, 10);
            CAN_NEW_IMAGE_DATA = true;
          } catch (__) {
          }
        }
        if (typeof ImageBitmap !== "undefined") {
          if (ImageBitmap.prototype && ImageBitmap.prototype.close) {
            CAN_CREATE_IMAGE_BITMAP = true;
          } else {
            this.debug("ImageBitmap does not support .close(), disabled");
          }
        }
        var features = this.options.features.slice();
        if (features.indexOf("all") >= 0) {
          features = ["cib", "wasm", "js", "ww"];
        }
        this.__requested_features = features;
        this.__mathlib = new MathLib(features);
        if (features.indexOf("ww") >= 0) {
          if (typeof window !== "undefined" && "Worker" in window) {
            try {
              var wkr = _dereq_("webworkify")(function() {
              });
              wkr.terminate();
              this.features.ww = true;
              var wpool_key = "wp_".concat(JSON.stringify(this.options));
              if (singletones[wpool_key]) {
                this.__workersPool = singletones[wpool_key];
              } else {
                this.__workersPool = new Pool(workerFabric, this.options.idle);
                singletones[wpool_key] = this.__workersPool;
              }
            } catch (__) {
            }
          }
        }
        var initMath = this.__mathlib.init().then(function(mathlib) {
          assign3(_this.features, mathlib.features);
        });
        var checkCibResize;
        if (!CAN_CREATE_IMAGE_BITMAP) {
          checkCibResize = Promise.resolve(false);
        } else {
          checkCibResize = utils2.cib_support(this.options.createCanvas).then(function(status) {
            if (_this.features.cib && features.indexOf("cib") < 0) {
              _this.debug("createImageBitmap() resize supported, but disabled by config");
              return;
            }
            if (features.indexOf("cib") >= 0) _this.features.cib = status;
          });
        }
        CAN_USE_CANVAS_GET_IMAGE_DATA = utils2.can_use_canvas(this.options.createCanvas);
        var checkOffscreenCanvas;
        if (CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && features.indexOf("ww") !== -1) {
          checkOffscreenCanvas = utils2.worker_offscreen_canvas_support();
        } else {
          checkOffscreenCanvas = Promise.resolve(false);
        }
        checkOffscreenCanvas = checkOffscreenCanvas.then(function(result) {
          CAN_USE_OFFSCREEN_CANVAS = result;
        });
        var checkCibRegion = utils2.cib_can_use_region().then(function(result) {
          CAN_USE_CIB_REGION_FOR_IMAGE = result;
        });
        this.__initPromise = Promise.all([initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion]).then(function() {
          return _this;
        });
        return this.__initPromise;
      };
      Pica2.prototype.__invokeResize = function(tileOpts, opts) {
        var _this2 = this;
        opts.__mathCache = opts.__mathCache || {};
        return Promise.resolve().then(function() {
          if (!_this2.features.ww) {
            return {
              data: _this2.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)
            };
          }
          return new Promise(function(resolve, reject) {
            var w = _this2.__workersPool.acquire();
            if (opts.cancelToken) opts.cancelToken["catch"](function(err) {
              return reject(err);
            });
            w.value.onmessage = function(ev) {
              w.release();
              if (ev.data.err) reject(ev.data.err);
              else resolve(ev.data);
            };
            var transfer = [];
            if (tileOpts.src) transfer.push(tileOpts.src.buffer);
            if (tileOpts.srcBitmap) transfer.push(tileOpts.srcBitmap);
            w.value.postMessage({
              opts: tileOpts,
              features: _this2.__requested_features,
              preload: {
                wasm_nodule: _this2.__mathlib.__
              }
            }, transfer);
          });
        });
      };
      Pica2.prototype.__extractTileData = function(tile, from, opts, stageEnv, extractTo) {
        if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,
        // can use canvas because canvas doesn't have orientation;
        // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671
        (utils2.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) {
          this.debug("Create tile for OffscreenCanvas");
          return createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then(function(bitmap) {
            extractTo.srcBitmap = bitmap;
            return extractTo;
          });
        }
        if (utils2.isCanvas(from)) {
          if (!stageEnv.srcCtx) stageEnv.srcCtx = from.getContext("2d");
          this.debug("Get tile pixel data");
          extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data;
          return extractTo;
        }
        this.debug("Draw tile imageBitmap/image to temporary canvas");
        var tmpCanvas = this.options.createCanvas(tile.width, tile.height);
        var tmpCtx = tmpCanvas.getContext("2d");
        tmpCtx.globalCompositeOperation = "copy";
        tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);
        this.debug("Get tile pixel data");
        extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data;
        tmpCanvas.width = tmpCanvas.height = 0;
        return extractTo;
      };
      Pica2.prototype.__landTileData = function(tile, result, stageEnv) {
        var toImageData;
        this.debug("Convert raw rgba tile result to ImageData");
        if (result.bitmap) {
          stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY);
          return null;
        }
        if (CAN_NEW_IMAGE_DATA) {
          toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight);
        } else {
          toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight);
          if (toImageData.data.set) {
            toImageData.data.set(result.data);
          } else {
            for (var i = toImageData.data.length - 1; i >= 0; i--) {
              toImageData.data[i] = result.data[i];
            }
          }
        }
        this.debug("Draw tile");
        if (NEED_SAFARI_FIX) {
          stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);
        } else {
          stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);
        }
        return null;
      };
      Pica2.prototype.__tileAndResize = function(from, to, opts) {
        var _this3 = this;
        var stageEnv = {
          srcCtx: null,
          srcImageBitmap: null,
          isImageBitmapReused: false,
          toCtx: null
        };
        var processTile = function processTile2(tile) {
          return _this3.__limit(function() {
            if (opts.canceled) return opts.cancelToken;
            var tileOpts = {
              width: tile.width,
              height: tile.height,
              toWidth: tile.toWidth,
              toHeight: tile.toHeight,
              scaleX: tile.scaleX,
              scaleY: tile.scaleY,
              offsetX: tile.offsetX,
              offsetY: tile.offsetY,
              filter: opts.filter,
              unsharpAmount: opts.unsharpAmount,
              unsharpRadius: opts.unsharpRadius,
              unsharpThreshold: opts.unsharpThreshold
            };
            _this3.debug("Invoke resize math");
            return Promise.resolve(tileOpts).then(function(tileOpts2) {
              return _this3.__extractTileData(tile, from, opts, stageEnv, tileOpts2);
            }).then(function(tileOpts2) {
              _this3.debug("Invoke resize math");
              return _this3.__invokeResize(tileOpts2, opts);
            }).then(function(result) {
              if (opts.canceled) return opts.cancelToken;
              stageEnv.srcImageData = null;
              return _this3.__landTileData(tile, result, stageEnv);
            });
          });
        };
        return Promise.resolve().then(function() {
          stageEnv.toCtx = to.getContext("2d");
          if (utils2.isCanvas(from)) return null;
          if (utils2.isImageBitmap(from)) {
            stageEnv.srcImageBitmap = from;
            stageEnv.isImageBitmapReused = true;
            return null;
          }
          if (utils2.isImage(from)) {
            if (!CAN_CREATE_IMAGE_BITMAP) return null;
            _this3.debug("Decode image via createImageBitmap");
            return createImageBitmap(from).then(function(imageBitmap) {
              stageEnv.srcImageBitmap = imageBitmap;
            })["catch"](function(e) {
              return null;
            });
          }
          throw new Error('Pica: ".from" should be Image, Canvas or ImageBitmap');
        }).then(function() {
          if (opts.canceled) return opts.cancelToken;
          _this3.debug("Calculate tiles");
          var regions = createRegions({
            width: opts.width,
            height: opts.height,
            srcTileSize: _this3.options.tile,
            toWidth: opts.toWidth,
            toHeight: opts.toHeight,
            destTileBorder: opts.__destTileBorder
          });
          var jobs = regions.map(function(tile) {
            return processTile(tile);
          });
          function cleanup(stageEnv2) {
            if (stageEnv2.srcImageBitmap) {
              if (!stageEnv2.isImageBitmapReused) stageEnv2.srcImageBitmap.close();
              stageEnv2.srcImageBitmap = null;
            }
          }
          _this3.debug("Process tiles");
          return Promise.all(jobs).then(function() {
            _this3.debug("Finished!");
            cleanup(stageEnv);
            return to;
          }, function(err) {
            cleanup(stageEnv);
            throw err;
          });
        });
      };
      Pica2.prototype.__processStages = function(stages, from, to, opts) {
        var _this4 = this;
        if (opts.canceled) return opts.cancelToken;
        var _stages$shift = stages.shift(), _stages$shift2 = _slicedToArray(_stages$shift, 2), toWidth = _stages$shift2[0], toHeight = _stages$shift2[1];
        var isLastStage = stages.length === 0;
        var filter;
        if (isLastStage || filter_info.q2f.indexOf(opts.filter) < 0) filter = opts.filter;
        else if (opts.filter === "box") filter = "box";
        else filter = "hamming";
        opts = assign3({}, opts, {
          toWidth,
          toHeight,
          filter
        });
        var tmpCanvas;
        if (!isLastStage) {
          tmpCanvas = this.options.createCanvas(toWidth, toHeight);
        }
        return this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function() {
          if (isLastStage) return to;
          opts.width = toWidth;
          opts.height = toHeight;
          return _this4.__processStages(stages, tmpCanvas, to, opts);
        }).then(function(res) {
          if (tmpCanvas) {
            tmpCanvas.width = tmpCanvas.height = 0;
          }
          return res;
        });
      };
      Pica2.prototype.__resizeViaCreateImageBitmap = function(from, to, opts) {
        var _this5 = this;
        var toCtx = to.getContext("2d");
        this.debug("Resize via createImageBitmap()");
        return createImageBitmap(from, {
          resizeWidth: opts.toWidth,
          resizeHeight: opts.toHeight,
          resizeQuality: utils2.cib_quality_name(filter_info.f2q[opts.filter])
        }).then(function(imageBitmap) {
          if (opts.canceled) return opts.cancelToken;
          if (!opts.unsharpAmount) {
            toCtx.drawImage(imageBitmap, 0, 0);
            imageBitmap.close();
            toCtx = null;
            _this5.debug("Finished!");
            return to;
          }
          _this5.debug("Unsharp result");
          var tmpCanvas = _this5.options.createCanvas(opts.toWidth, opts.toHeight);
          var tmpCtx = tmpCanvas.getContext("2d");
          tmpCtx.drawImage(imageBitmap, 0, 0);
          imageBitmap.close();
          var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);
          _this5.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);
          toCtx.putImageData(iData, 0, 0);
          tmpCanvas.width = tmpCanvas.height = 0;
          iData = tmpCtx = tmpCanvas = toCtx = null;
          _this5.debug("Finished!");
          return to;
        });
      };
      Pica2.prototype.resize = function(from, to, options) {
        var _this6 = this;
        this.debug("Start resize...");
        var opts = assign3({}, DEFAULT_RESIZE_OPTS);
        if (!isNaN(options)) {
          opts = assign3(opts, {
            quality: options
          });
        } else if (options) {
          opts = assign3(opts, options);
        }
        opts.toWidth = to.width;
        opts.toHeight = to.height;
        opts.width = from.naturalWidth || from.width;
        opts.height = from.naturalHeight || from.height;
        if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
          if (opts.quality < 0 || opts.quality > 3) {
            throw new Error("Pica: .quality should be [0..3], got ".concat(opts.quality));
          }
          opts.filter = filter_info.q2f[opts.quality];
        }
        if (to.width === 0 || to.height === 0) {
          return Promise.reject(new Error("Invalid output size: ".concat(to.width, "x").concat(to.height)));
        }
        if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;
        opts.canceled = false;
        if (opts.cancelToken) {
          opts.cancelToken = opts.cancelToken.then(function(data2) {
            opts.canceled = true;
            throw data2;
          }, function(err) {
            opts.canceled = true;
            throw err;
          });
        }
        var DEST_TILE_BORDER = 3;
        opts.__destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));
        return this.init().then(function() {
          if (opts.canceled) return opts.cancelToken;
          if (_this6.features.cib) {
            if (filter_info.q2f.indexOf(opts.filter) >= 0) {
              return _this6.__resizeViaCreateImageBitmap(from, to, opts);
            }
            _this6.debug("cib is enabled, but not supports provided filter, fallback to manual math");
          }
          if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {
            var err = new Error("Pica: cannot use getImageData on canvas, make sure fingerprinting protection isn't enabled");
            err.code = "ERR_GET_IMAGE_DATA";
            throw err;
          }
          var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this6.options.tile, opts.__destTileBorder);
          return _this6.__processStages(stages, from, to, opts);
        });
      };
      Pica2.prototype.resizeBuffer = function(options) {
        var _this7 = this;
        var opts = assign3({}, DEFAULT_RESIZE_OPTS, options);
        if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
          if (opts.quality < 0 || opts.quality > 3) {
            throw new Error("Pica: .quality should be [0..3], got ".concat(opts.quality));
          }
          opts.filter = filter_info.q2f[opts.quality];
        }
        return this.init().then(function() {
          return _this7.__mathlib.resizeAndUnsharp(opts);
        });
      };
      Pica2.prototype.toBlob = function(canvas, mimeType, quality) {
        mimeType = mimeType || "image/png";
        return new Promise(function(resolve) {
          if (canvas.toBlob) {
            canvas.toBlob(function(blob) {
              return resolve(blob);
            }, mimeType, quality);
            return;
          }
          if (canvas.convertToBlob) {
            resolve(canvas.convertToBlob({
              type: mimeType,
              quality
            }));
            return;
          }
          var asString = atob(canvas.toDataURL(mimeType, quality).split(",")[1]);
          var len = asString.length;
          var asBuffer = new Uint8Array(len);
          for (var i = 0; i < len; i++) {
            asBuffer[i] = asString.charCodeAt(i);
          }
          resolve(new Blob([asBuffer], {
            type: mimeType
          }));
        });
      };
      Pica2.prototype.debug = function() {
      };
      module3.exports = Pica2;
    }, { "./lib/mathlib": 1, "./lib/mm_resize/resize_filter_info": 7, "./lib/pool": 13, "./lib/stepper": 14, "./lib/tiler": 15, "./lib/utils": 16, "./lib/worker": 17, "object-assign": 22, "webworkify": 23 }] }, {}, [])("/index.js");
  });
})(pica$1);
var jpeg_plugins = {};
var image_traverse$1 = { exports: {} };
(function(module2) {
  function error(message, code) {
    var err = new Error(message);
    err.code = code;
    return err;
  }
  function to_hex(number2) {
    var n = number2.toString(16).toUpperCase();
    for (var i = 2 - n.length; i > 0; i--) n = "0" + n;
    return "0x" + n;
  }
  function utf8_encode(str) {
    try {
      return unescape(encodeURIComponent(str));
    } catch (_) {
      return str;
    }
  }
  function utf8_decode(str) {
    try {
      return decodeURIComponent(escape(str));
    } catch (_) {
      return str;
    }
  }
  function is_uint8array(bin) {
    return Object.prototype.toString.call(bin) === "[object Uint8Array]";
  }
  function ExifParser(jpeg_bin, exif_start, exif_end) {
    this.input = jpeg_bin.subarray(exif_start, exif_end);
    this.start = exif_start;
    var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));
    if (sig !== "II*\0" && sig !== "MM\0*") {
      throw error("invalid TIFF signature", "EBADDATA");
    }
    this.big_endian = sig[0] === "M";
  }
  ExifParser.prototype.each = function(on_entry) {
    this.aborted = false;
    var offset = this.read_uint32(4);
    this.ifds_to_read = [{
      id: 0,
      offset
    }];
    while (this.ifds_to_read.length > 0 && !this.aborted) {
      var i = this.ifds_to_read.shift();
      if (!i.offset) continue;
      this.scan_ifd(i.id, i.offset, on_entry);
    }
  };
  ExifParser.prototype.filter = function(on_entry) {
    var ifds = {};
    ifds.ifd0 = { id: 0, entries: [] };
    this.each(function(entry) {
      if (on_entry(entry) === false && !entry.is_subifd_link) return;
      if (entry.is_subifd_link && entry.count !== 1 && entry.format !== 4) return;
      if (!ifds["ifd" + entry.ifd]) {
        ifds["ifd" + entry.ifd] = { id: entry.ifd, entries: [] };
      }
      ifds["ifd" + entry.ifd].entries.push(entry);
    });
    delete ifds.ifd1;
    var length = 8;
    Object.keys(ifds).forEach(function(ifd_no) {
      length += 2;
      ifds[ifd_no].entries.forEach(function(entry) {
        length += 12 + (entry.data_length > 4 ? Math.ceil(entry.data_length / 2) * 2 : 0);
      });
      length += 4;
    });
    this.output = new Uint8Array(length);
    this.output[0] = this.output[1] = (this.big_endian ? "M" : "I").charCodeAt(0);
    this.write_uint16(2, 42);
    var offset = 8;
    var self2 = this;
    this.write_uint32(4, offset);
    Object.keys(ifds).forEach(function(ifd_no) {
      ifds[ifd_no].written_offset = offset;
      var ifd_start = offset;
      var ifd_end = ifd_start + 2 + ifds[ifd_no].entries.length * 12 + 4;
      offset = ifd_end;
      self2.write_uint16(ifd_start, ifds[ifd_no].entries.length);
      ifds[ifd_no].entries.sort(function(a, b) {
        return a.tag - b.tag;
      }).forEach(function(entry, idx) {
        var entry_offset = ifd_start + 2 + idx * 12;
        self2.write_uint16(entry_offset, entry.tag);
        self2.write_uint16(entry_offset + 2, entry.format);
        self2.write_uint32(entry_offset + 4, entry.count);
        if (entry.is_subifd_link) {
          if (ifds["ifd" + entry.tag]) ifds["ifd" + entry.tag].link_offset = entry_offset + 8;
        } else if (entry.data_length <= 4) {
          self2.output.set(
            self2.input.subarray(entry.data_offset - self2.start, entry.data_offset - self2.start + 4),
            entry_offset + 8
          );
        } else {
          self2.write_uint32(entry_offset + 8, offset);
          self2.output.set(
            self2.input.subarray(entry.data_offset - self2.start, entry.data_offset - self2.start + entry.data_length),
            offset
          );
          offset += Math.ceil(entry.data_length / 2) * 2;
        }
      });
      var next_ifd = ifds["ifd" + (ifds[ifd_no].id + 1)];
      if (next_ifd) next_ifd.link_offset = ifd_end - 4;
    });
    Object.keys(ifds).forEach(function(ifd_no) {
      if (ifds[ifd_no].written_offset && ifds[ifd_no].link_offset) {
        self2.write_uint32(ifds[ifd_no].link_offset, ifds[ifd_no].written_offset);
      }
    });
    if (this.output.length !== offset) throw error("internal error: incorrect buffer size allocated");
    return this.output;
  };
  ExifParser.prototype.read_uint16 = function(offset) {
    var d = this.input;
    if (offset + 2 > d.length) throw error("unexpected EOF", "EBADDATA");
    return this.big_endian ? d[offset] * 256 + d[offset + 1] : d[offset] + d[offset + 1] * 256;
  };
  ExifParser.prototype.read_uint32 = function(offset) {
    var d = this.input;
    if (offset + 4 > d.length) throw error("unexpected EOF", "EBADDATA");
    return this.big_endian ? d[offset] * 16777216 + d[offset + 1] * 65536 + d[offset + 2] * 256 + d[offset + 3] : d[offset] + d[offset + 1] * 256 + d[offset + 2] * 65536 + d[offset + 3] * 16777216;
  };
  ExifParser.prototype.write_uint16 = function(offset, value) {
    var d = this.output;
    if (this.big_endian) {
      d[offset] = value >>> 8 & 255;
      d[offset + 1] = value & 255;
    } else {
      d[offset] = value & 255;
      d[offset + 1] = value >>> 8 & 255;
    }
  };
  ExifParser.prototype.write_uint32 = function(offset, value) {
    var d = this.output;
    if (this.big_endian) {
      d[offset] = value >>> 24 & 255;
      d[offset + 1] = value >>> 16 & 255;
      d[offset + 2] = value >>> 8 & 255;
      d[offset + 3] = value & 255;
    } else {
      d[offset] = value & 255;
      d[offset + 1] = value >>> 8 & 255;
      d[offset + 2] = value >>> 16 & 255;
      d[offset + 3] = value >>> 24 & 255;
    }
  };
  ExifParser.prototype.is_subifd_link = function(ifd, tag) {
    return ifd === 0 && tag === 34665 || // SubIFD
    ifd === 0 && tag === 34853 || // GPS Info
    ifd === 34665 && tag === 40965;
  };
  ExifParser.prototype.exif_format_length = function(format) {
    switch (format) {
      case 1:
      // byte
      case 2:
      // ascii
      case 6:
      // sbyte
      case 7:
        return 1;
      case 3:
      // short
      case 8:
        return 2;
      case 4:
      // long
      case 9:
      // slong
      case 11:
        return 4;
      case 5:
      // rational
      case 10:
      // srational
      case 12:
        return 8;
      default:
        return 0;
    }
  };
  ExifParser.prototype.exif_format_read = function(format, offset) {
    var v;
    switch (format) {
      case 1:
      // byte
      case 2:
        v = this.input[offset];
        return v;
      case 6:
        v = this.input[offset];
        return v | (v & 128) * 33554430;
      case 3:
        v = this.read_uint16(offset);
        return v;
      case 8:
        v = this.read_uint16(offset);
        return v | (v & 32768) * 131070;
      case 4:
        v = this.read_uint32(offset);
        return v;
      case 9:
        v = this.read_uint32(offset);
        return v | 0;
      case 5:
      // rational
      case 10:
      // srational
      case 11:
      // float
      case 12:
        return null;
      // not implemented
      case 7:
        return null;
      // blob
      default:
        return null;
    }
  };
  ExifParser.prototype.scan_ifd = function(ifd_no, offset, on_entry) {
    var entry_count = this.read_uint16(offset);
    offset += 2;
    for (var i = 0; i < entry_count; i++) {
      var tag = this.read_uint16(offset);
      var format = this.read_uint16(offset + 2);
      var count = this.read_uint32(offset + 4);
      var comp_length = this.exif_format_length(format);
      var data_length = count * comp_length;
      var data_offset = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);
      var is_subifd_link = false;
      if (data_offset + data_length > this.input.length) {
        throw error("unexpected EOF", "EBADDATA");
      }
      var value = [];
      var comp_offset = data_offset;
      for (var j = 0; j < count; j++, comp_offset += comp_length) {
        var item = this.exif_format_read(format, comp_offset);
        if (item === null) {
          value = null;
          break;
        }
        value.push(item);
      }
      if (Array.isArray(value) && format === 2) {
        try {
          value = utf8_decode(String.fromCharCode.apply(null, value));
        } catch (_) {
          value = null;
        }
        if (value && value[value.length - 1] === "\0") value = value.slice(0, -1);
      }
      if (this.is_subifd_link(ifd_no, tag)) {
        if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {
          this.ifds_to_read.push({
            id: tag,
            offset: value[0]
          });
          is_subifd_link = true;
        }
      }
      var entry = {
        is_big_endian: this.big_endian,
        ifd: ifd_no,
        tag,
        format,
        count,
        entry_offset: offset + this.start,
        data_length,
        data_offset: data_offset + this.start,
        value,
        is_subifd_link
      };
      if (on_entry(entry) === false) {
        this.aborted = true;
        return;
      }
      offset += 12;
    }
    if (ifd_no === 0) {
      this.ifds_to_read.push({
        id: 1,
        offset: this.read_uint32(offset)
      });
    }
  };
  module2.exports.is_jpeg = function(jpeg_bin) {
    return jpeg_bin.length >= 4 && jpeg_bin[0] === 255 && jpeg_bin[1] === 216 && jpeg_bin[2] === 255;
  };
  module2.exports.jpeg_segments_each = function(jpeg_bin, on_segment) {
    if (!is_uint8array(jpeg_bin)) {
      throw error("Invalid argument (jpeg_bin), Uint8Array expected", "EINVAL");
    }
    if (typeof on_segment !== "function") {
      throw error("Invalid argument (on_segment), Function expected", "EINVAL");
    }
    if (!module2.exports.is_jpeg(jpeg_bin)) {
      throw error("Unknown file format", "ENOTJPEG");
    }
    var offset = 0, length = jpeg_bin.length, inside_scan = false;
    for (; ; ) {
      var segment_code, segment_length;
      if (offset + 1 >= length) throw error("Unexpected EOF", "EBADDATA");
      var byte1 = jpeg_bin[offset];
      var byte2 = jpeg_bin[offset + 1];
      if (byte1 === 255 && byte2 === 255) {
        segment_code = 255;
        segment_length = 1;
      } else if (byte1 === 255 && byte2 !== 0) {
        segment_code = byte2;
        segment_length = 2;
        if (208 <= segment_code && segment_code <= 217 || segment_code === 1) ;
        else {
          if (offset + 3 >= length) throw error("Unexpected EOF", "EBADDATA");
          segment_length += jpeg_bin[offset + 2] * 256 + jpeg_bin[offset + 3];
          if (segment_length < 2) throw error("Invalid segment length", "EBADDATA");
          if (offset + segment_length - 1 >= length) throw error("Unexpected EOF", "EBADDATA");
        }
        if (inside_scan) {
          if (segment_code >= 208 && segment_code <= 215) ;
          else {
            inside_scan = false;
          }
        }
        if (segment_code === 218) inside_scan = true;
      } else if (inside_scan) {
        for (var pos = offset + 1; ; pos++) {
          if (pos >= length) throw error("Unexpected EOF", "EBADDATA");
          if (jpeg_bin[pos] === 255) {
            if (pos + 1 >= length) throw error("Unexpected EOF", "EBADDATA");
            if (jpeg_bin[pos + 1] !== 0) {
              segment_code = 0;
              segment_length = pos - offset;
              break;
            }
          }
        }
      } else {
        throw error("Unexpected byte at segment start: " + to_hex(byte1) + " (offset " + to_hex(offset) + ")", "EBADDATA");
      }
      if (on_segment({ code: segment_code, offset, length: segment_length }) === false) break;
      if (segment_code === 217) break;
      offset += segment_length;
    }
  };
  module2.exports.jpeg_segments_filter = function(jpeg_bin, on_segment) {
    if (!is_uint8array(jpeg_bin)) {
      throw error("Invalid argument (jpeg_bin), Uint8Array expected", "EINVAL");
    }
    if (typeof on_segment !== "function") {
      throw error("Invalid argument (on_segment), Function expected", "EINVAL");
    }
    var ranges = [];
    var out_length = 0;
    module2.exports.jpeg_segments_each(jpeg_bin, function(segment) {
      var new_segment = on_segment(segment);
      if (is_uint8array(new_segment)) {
        ranges.push({ data: new_segment });
        out_length += new_segment.length;
      } else if (Array.isArray(new_segment)) {
        new_segment.filter(is_uint8array).forEach(function(s) {
          ranges.push({ data: s });
          out_length += s.length;
        });
      } else if (new_segment !== false) {
        var new_range = { start: segment.offset, end: segment.offset + segment.length };
        if (ranges.length > 0 && ranges[ranges.length - 1].end === new_range.start) {
          ranges[ranges.length - 1].end = new_range.end;
        } else {
          ranges.push(new_range);
        }
        out_length += segment.length;
      }
    });
    var result = new Uint8Array(out_length);
    var offset = 0;
    ranges.forEach(function(range) {
      var data2 = range.data || jpeg_bin.subarray(range.start, range.end);
      result.set(data2, offset);
      offset += data2.length;
    });
    return result;
  };
  module2.exports.jpeg_exif_tags_each = function(jpeg_bin, on_exif_entry) {
    if (!is_uint8array(jpeg_bin)) {
      throw error("Invalid argument (jpeg_bin), Uint8Array expected", "EINVAL");
    }
    if (typeof on_exif_entry !== "function") {
      throw error("Invalid argument (on_exif_entry), Function expected", "EINVAL");
    }
    module2.exports.jpeg_segments_each(jpeg_bin, function(segment) {
      if (segment.code === 218) return false;
      if (segment.code === 225 && segment.length >= 10 && jpeg_bin[segment.offset + 4] === 69 && jpeg_bin[segment.offset + 5] === 120 && jpeg_bin[segment.offset + 6] === 105 && jpeg_bin[segment.offset + 7] === 102 && jpeg_bin[segment.offset + 8] === 0 && jpeg_bin[segment.offset + 9] === 0) {
        new ExifParser(jpeg_bin, segment.offset + 10, segment.offset + segment.length).each(on_exif_entry);
        return false;
      }
    });
  };
  module2.exports.jpeg_exif_tags_filter = function(jpeg_bin, on_exif_entry) {
    if (!is_uint8array(jpeg_bin)) {
      throw error("Invalid argument (jpeg_bin), Uint8Array expected", "EINVAL");
    }
    if (typeof on_exif_entry !== "function") {
      throw error("Invalid argument (on_exif_entry), Function expected", "EINVAL");
    }
    var stop_search = false;
    return module2.exports.jpeg_segments_filter(jpeg_bin, function(segment) {
      if (stop_search) return;
      if (segment.code === 218) stop_search = true;
      if (segment.code === 225 && segment.length >= 10 && jpeg_bin[segment.offset + 4] === 69 && jpeg_bin[segment.offset + 5] === 120 && jpeg_bin[segment.offset + 6] === 105 && jpeg_bin[segment.offset + 7] === 102 && jpeg_bin[segment.offset + 8] === 0 && jpeg_bin[segment.offset + 9] === 0) {
        var new_exif = new ExifParser(jpeg_bin, segment.offset + 10, segment.offset + segment.length).filter(on_exif_entry);
        if (!new_exif) return false;
        var header = new Uint8Array(10);
        header.set(jpeg_bin.slice(segment.offset, segment.offset + 10));
        header[2] = new_exif.length + 8 >>> 8 & 255;
        header[3] = new_exif.length + 8 & 255;
        stop_search = true;
        return [header, new_exif];
      }
    });
  };
  module2.exports.jpeg_add_comment = function(jpeg_bin, comment) {
    var comment_inserted = false, segment_count = 0;
    return module2.exports.jpeg_segments_filter(jpeg_bin, function(segment) {
      segment_count++;
      if (segment_count === 1 && segment.code === 216) return;
      if (segment_count === 2 && segment.code === 224) return;
      if (comment_inserted) return;
      comment = utf8_encode(comment);
      var csegment = new Uint8Array(5 + comment.length);
      var offset = 0;
      csegment[offset++] = 255;
      csegment[offset++] = 254;
      csegment[offset++] = comment.length + 3 >>> 8 & 255;
      csegment[offset++] = comment.length + 3 & 255;
      comment.split("").forEach(function(c) {
        csegment[offset++] = c.charCodeAt(0) & 255;
      });
      csegment[offset++] = 0;
      comment_inserted = true;
      return [csegment, jpeg_bin.subarray(segment.offset, segment.offset + segment.length)];
    });
  };
})(image_traverse$1);
var image_traverse = image_traverse$1.exports;
function jpeg_patch_exif(env) {
  return this._getUint8Array(env.blob).then(function(data2) {
    env.is_jpeg = image_traverse.is_jpeg(data2);
    if (!env.is_jpeg) return Promise.resolve(env);
    env.orig_blob = env.blob;
    try {
      var exif_is_big_endian, orientation_offset;
      image_traverse.jpeg_exif_tags_each(data2, function(entry) {
        if (entry.ifd === 0 && entry.tag === 274 && Array.isArray(entry.value)) {
          env.orientation = entry.value[0] || 1;
          exif_is_big_endian = entry.is_big_endian;
          orientation_offset = entry.data_offset;
          return false;
        }
      });
      if (orientation_offset) {
        var orientation_patch = exif_is_big_endian ? new Uint8Array([0, 1]) : new Uint8Array([1, 0]);
        env.blob = new Blob([
          data2.slice(0, orientation_offset),
          orientation_patch,
          data2.slice(orientation_offset + 2)
        ], { type: "image/jpeg" });
      }
    } catch (_) {
    }
    return env;
  });
}
function jpeg_rotate_canvas(env) {
  if (!env.is_jpeg) return Promise.resolve(env);
  var orientation = env.orientation - 1;
  if (!orientation) return Promise.resolve(env);
  var canvas;
  if (orientation & 4) {
    canvas = this.pica.options.createCanvas(env.out_canvas.height, env.out_canvas.width);
  } else {
    canvas = this.pica.options.createCanvas(env.out_canvas.width, env.out_canvas.height);
  }
  var ctx = canvas.getContext("2d");
  ctx.save();
  if (orientation & 1) ctx.transform(-1, 0, 0, 1, canvas.width, 0);
  if (orientation & 2) ctx.transform(-1, 0, 0, -1, canvas.width, canvas.height);
  if (orientation & 4) ctx.transform(0, 1, 1, 0, 0, 0);
  ctx.drawImage(env.out_canvas, 0, 0);
  ctx.restore();
  env.out_canvas.width = env.out_canvas.height = 0;
  env.out_canvas = canvas;
  return Promise.resolve(env);
}
function jpeg_attach_orig_segments(env) {
  if (!env.is_jpeg) return Promise.resolve(env);
  return Promise.all([
    this._getUint8Array(env.blob),
    this._getUint8Array(env.out_blob)
  ]).then(function(res) {
    var data2 = res[0];
    var data_out = res[1];
    if (!image_traverse.is_jpeg(data2)) return Promise.resolve(env);
    var segments = [];
    image_traverse.jpeg_segments_each(data2, function(segment) {
      if (segment.code === 218) return false;
      segments.push(segment);
    });
    segments = segments.filter(function(segment) {
      if (segment.code === 226) return false;
      if (segment.code >= 224 && segment.code < 240) return true;
      if (segment.code === 254) return true;
      return false;
    }).map(function(segment) {
      return data2.slice(segment.offset, segment.offset + segment.length);
    });
    env.out_blob = new Blob(
      // intentionally omitting expected JFIF segment (offset 2 to 20)
      [data_out.slice(0, 2)].concat(segments).concat([data_out.slice(20)]),
      { type: "image/jpeg" }
    );
    return env;
  });
}
function assign2(reducer) {
  reducer.before("_blob_to_image", jpeg_patch_exif);
  reducer.after("_transform", jpeg_rotate_canvas);
  reducer.after("_create_blob", jpeg_attach_orig_segments);
}
jpeg_plugins.jpeg_patch_exif = jpeg_patch_exif;
jpeg_plugins.jpeg_rotate_canvas = jpeg_rotate_canvas;
jpeg_plugins.jpeg_attach_orig_segments = jpeg_attach_orig_segments;
jpeg_plugins.assign = assign2;
var utils = utils$1;
var pica = pica$1.exports;
function ImageBlobReduce(options) {
  if (!(this instanceof ImageBlobReduce)) return new ImageBlobReduce(options);
  options = options || {};
  this.pica = options.pica || pica({});
  this.initialized = false;
  this.utils = utils;
}
ImageBlobReduce.prototype.use = function(plugin) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
ImageBlobReduce.prototype.init = function() {
  this.use(jpeg_plugins.assign);
};
ImageBlobReduce.prototype.toBlob = function(blob, options) {
  var opts = utils.assign({ max: Infinity }, options);
  var env = {
    blob,
    opts
  };
  if (!this.initialized) {
    this.init();
    this.initialized = true;
  }
  return Promise.resolve(env).then(this._blob_to_image).then(this._calculate_size).then(this._transform).then(this._cleanup).then(this._create_blob).then(function(_env) {
    _env.out_canvas.width = _env.out_canvas.height = 0;
    return _env.out_blob;
  });
};
ImageBlobReduce.prototype.toCanvas = function(blob, options) {
  var opts = utils.assign({ max: Infinity }, options);
  var env = {
    blob,
    opts
  };
  if (!this.initialized) {
    this.init();
    this.initialized = true;
  }
  return Promise.resolve(env).then(this._blob_to_image).then(this._calculate_size).then(this._transform).then(this._cleanup).then(function(_env) {
    return _env.out_canvas;
  });
};
ImageBlobReduce.prototype.before = function(method_name, fn) {
  if (!this[method_name]) throw new Error('Method "' + method_name + '" does not exist');
  if (typeof fn !== "function") throw new Error('Invalid argument "fn", function expected');
  var old_fn = this[method_name];
  var self2 = this;
  this[method_name] = function(env) {
    return fn.call(self2, env).then(function(_env) {
      return old_fn.call(self2, _env);
    });
  };
  return this;
};
ImageBlobReduce.prototype.after = function(method_name, fn) {
  if (!this[method_name]) throw new Error('Method "' + method_name + '" does not exist');
  if (typeof fn !== "function") throw new Error('Invalid argument "fn", function expected');
  var old_fn = this[method_name];
  var self2 = this;
  this[method_name] = function(env) {
    return old_fn.call(self2, env).then(function(_env) {
      return fn.call(self2, _env);
    });
  };
  return this;
};
ImageBlobReduce.prototype._blob_to_image = function(env) {
  var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
  env.image = document.createElement("img");
  env.image_url = URL2.createObjectURL(env.blob);
  env.image.src = env.image_url;
  return new Promise(function(resolve, reject) {
    env.image.onerror = function() {
      reject(new Error("ImageBlobReduce: failed to create Image() from blob"));
    };
    env.image.onload = function() {
      resolve(env);
    };
  });
};
ImageBlobReduce.prototype._calculate_size = function(env) {
  var scale_factor = env.opts.max / Math.max(env.image.width, env.image.height);
  if (scale_factor > 1) scale_factor = 1;
  env.transform_width = Math.max(Math.round(env.image.width * scale_factor), 1);
  env.transform_height = Math.max(Math.round(env.image.height * scale_factor), 1);
  env.scale_factor = scale_factor;
  return Promise.resolve(env);
};
ImageBlobReduce.prototype._transform = function(env) {
  env.out_canvas = this.pica.options.createCanvas(env.transform_width, env.transform_height);
  env.transform_width = null;
  env.transform_height = null;
  var pica_opts = { alpha: env.blob.type === "image/png" };
  this.utils.assign(pica_opts, this.utils.pick_pica_resize_options(env.opts));
  return this.pica.resize(env.image, env.out_canvas, pica_opts).then(function() {
    return env;
  });
};
ImageBlobReduce.prototype._cleanup = function(env) {
  env.image.src = "";
  env.image = null;
  var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
  if (URL2.revokeObjectURL) URL2.revokeObjectURL(env.image_url);
  env.image_url = null;
  return Promise.resolve(env);
};
ImageBlobReduce.prototype._create_blob = function(env) {
  return this.pica.toBlob(env.out_canvas, env.blob.type).then(function(blob) {
    env.out_blob = blob;
    return env;
  });
};
ImageBlobReduce.prototype._getUint8Array = function(blob) {
  if (blob.arrayBuffer) {
    return blob.arrayBuffer().then(function(buf) {
      return new Uint8Array(buf);
    });
  }
  return new Promise(function(resolve, reject) {
    var fr = new FileReader();
    fr.readAsArrayBuffer(blob);
    fr.onload = function() {
      resolve(new Uint8Array(fr.result));
    };
    fr.onerror = function() {
      reject(new Error("ImageBlobReduce: failed to load data from input blob"));
      fr.abort();
    };
    fr.onabort = function() {
      reject(new Error("ImageBlobReduce: failed to load data from input blob (aborted)"));
    };
  });
};
ImageBlobReduce.pica = pica;
var imageBlobReduce = ImageBlobReduce;

// node_modules/.pnpm/jazz-browser-media-images@0.13.17/node_modules/jazz-browser-media-images/dist/index.js
var import_pica = __toESM(require_pica());
var pica2;
async function createImage(imageBlobOrFile, options) {
  if (!pica2) {
    pica2 = new import_pica.default();
  }
  const owner = options == null ? void 0 : options.owner;
  let originalWidth;
  let originalHeight;
  const Reducer = new imageBlobReduce({ pica: pica2 });
  Reducer.after("_blob_to_image", (env) => {
    originalWidth = env.orientation & 4 ? env.image.height : env.image.width;
    originalHeight = env.orientation & 4 ? env.image.width : env.image.height;
    return Promise.resolve(env);
  });
  const placeholderDataURL = (await Reducer.toCanvas(imageBlobOrFile, { max: 8 })).toDataURL("image/png");
  const imageDefinition = ImageDefinition.create({
    originalSize: [originalWidth, originalHeight],
    placeholderDataURL
  }, owner);
  const fillImageResolutions = async () => {
    const max256 = await Reducer.toBlob(imageBlobOrFile, { max: 256 });
    if (originalWidth > 256 || originalHeight > 256) {
      const width = originalWidth > originalHeight ? 256 : Math.round(256 * (originalWidth / originalHeight));
      const height = originalHeight > originalWidth ? 256 : Math.round(256 * (originalHeight / originalWidth));
      const binaryStream = await FileStream.createFromBlob(max256, owner);
      imageDefinition[`${width}x${height}`] = binaryStream;
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
    if ((options == null ? void 0 : options.maxSize) === 256)
      return;
    const max1024 = await Reducer.toBlob(imageBlobOrFile, { max: 1024 });
    if (originalWidth > 1024 || originalHeight > 1024) {
      const width = originalWidth > originalHeight ? 1024 : Math.round(1024 * (originalWidth / originalHeight));
      const height = originalHeight > originalWidth ? 1024 : Math.round(1024 * (originalHeight / originalWidth));
      const binaryStream = await FileStream.createFromBlob(max1024, owner);
      imageDefinition[`${width}x${height}`] = binaryStream;
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
    if ((options == null ? void 0 : options.maxSize) === 1024)
      return;
    const max2048 = await Reducer.toBlob(imageBlobOrFile, { max: 2048 });
    if (originalWidth > 2048 || originalHeight > 2048) {
      const width = originalWidth > originalHeight ? 2048 : Math.round(2048 * (originalWidth / originalHeight));
      const height = originalHeight > originalWidth ? 2048 : Math.round(2048 * (originalHeight / originalWidth));
      const binaryStream = await FileStream.createFromBlob(max2048, owner);
      imageDefinition[`${width}x${height}`] = binaryStream;
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
    if ((options == null ? void 0 : options.maxSize) === 2048)
      return;
    const originalBinaryStream = await FileStream.createFromBlob(imageBlobOrFile, owner);
    imageDefinition[`${originalWidth}x${originalHeight}`] = originalBinaryStream;
  };
  await fillImageResolutions();
  return imageDefinition;
}
export {
  DemoAuthBasicUI,
  JazzProvider,
  PasskeyAuthBasicUI,
  PassphraseAuthBasicUI,
  ProgressiveImg,
  createImage,
  createInviteLink2 as createInviteLink,
  experimental_useInboxSender,
  parseInviteLink,
  useAcceptInvite,
  useAccount,
  useAccountOrGuest,
  useAuthSecretStorage,
  useCoState,
  useDemoAuth,
  useIsAuthenticated,
  useJazzContext,
  usePasskeyAuth,
  usePassphraseAuth,
  useProgressiveImg
};
/*! Bundled license information:

pica/dist/pica.js:
  (*!
  
  pica
  https://github.com/nodeca/pica
  
  *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

image-blob-reduce/dist/image-blob-reduce.esm.mjs:
  (*! image-blob-reduce 4.1.0 https://github.com/nodeca/image-blob-reduce @license MIT *)
  (*!
  
  pica
  https://github.com/nodeca/pica
  
  *)
*/
//# sourceMappingURL=jazz-react.js.map
