{
  "version": 3,
  "sources": ["../../.pnpm/fast-myers-diff@3.2.0/node_modules/fast-myers-diff/bin/index.js", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/base64url.ts", "../../.pnpm/neverthrow@7.2.0/node_modules/neverthrow/dist/index.es.js", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValue.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/logger.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/typeUtils/accountOrAgentIDfromSessionID.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValues/coList.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/typeUtils/isAccountID.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValues/coStream.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/typeUtils/isCoValue.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValues/coMap.ts", "../../.pnpm/@scure+base@1.2.1/node_modules/@scure/base/index.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/jsonStringify.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/crypto/crypto.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/ids.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/typeUtils/expectGroup.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValues/group.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValues/account.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValues/coPlainText.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coreToCoValue.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/permissions.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/priority.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValueCore.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/platform/browser/globalThis.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/version.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/internal/semver.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/internal/global-utils.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/ComponentLogger.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/types.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/internal/logLevelLogger.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/diag.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/baggage/internal/baggage-impl.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/baggage/internal/symbol.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/baggage/utils.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context/context.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/metrics/NoopMeter.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/metrics/Metric.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/propagation/TextMapPropagator.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context/NoopContextManager.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/context.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/trace_flags.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/invalid-span-constants.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NonRecordingSpan.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/context-utils.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/spancontext-utils.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NoopTracer.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/ProxyTracer.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NoopTracerProvider.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/ProxyTracerProvider.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/SamplingResult.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/span_kind.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/status.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/internal/tracestate-validators.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/internal/tracestate-impl.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context-api.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag-api.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/metrics/NoopMeterProvider.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/metrics.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/metrics-api.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/propagation/NoopTextMapPropagator.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/baggage/context-helpers.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/propagation.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/propagation-api.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/trace.ts", "../../.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace-api.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/PeerKnownStates.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/PriorityBasedMessageQueue.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/PeerState.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/SyncStateManager.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/sync.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/coValueState.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/CoValuesStore.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/localNode.ts", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/src/Deferred.ts", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/.yarn/cache/fast-list-npm-1.0.3-73493e1bdd-2bc01386f6.zip/node_modules/fast-list/fast-list.js", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/src/Buffer.ts", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/src/common.ts", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/src/fromDom.ts", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/src/fromEmitter.ts", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/src/adapters/Multicast.ts", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/src/adapters/LastResult.ts", "../../.pnpm/queueueue@4.1.2/node_modules/queueueue/src/adapters/Channel.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/streamUtils.ts", "../../.pnpm/cojson@0.13.17/node_modules/cojson/src/exports.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/activeAccountContext.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/anonymousJazzAgent.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/interfaces.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/inspect.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/symbols.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/deepLoading.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/refs.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/lib/cache.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/schema.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/subscriptionScope.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/createContext.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/registeredSchemas.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/devtoolsFormatters.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/inbox.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/coMap.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/profile.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/account.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/coFeed.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/coList.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/group.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/coPlainText.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/coRichText.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/extensions/imageDef.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/coValues/schemaUnion.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/auth/KvStoreContext.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/auth/AuthSecretStorage.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/auth/InMemoryKVStore.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/ContextManager.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/auth/DemoAuth.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/auth/PassphraseAuth.ts", "../../.pnpm/jazz-tools@0.13.17/node_modules/jazz-tools/src/implementation/invites.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/crypto.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/utils.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/hmac.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_md.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_u64.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/sha2.ts", "../../.pnpm/@scure+base@1.2.5/node_modules/@scure/base/index.ts", "../../.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/esm/index.js"],
  "sourcesContent": ["\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.calcSlices=exports.applyPatch=exports.calcPatch=exports.lcs=exports.diff=exports.diff_core=void 0;function diff_internal(state,c){const{b,eq,stack_base}=state;let{i,N,j,M,Z,stack_top}=state;for(;;){switch(c){case 0:{Z_block:while(N>0&&M>0){b.fill(0,0,2*Z);const W=N-M;const L=N+M;const parity=L&1;const offsetx=i+N-1;const offsety=j+M-1;const hmax=(L+parity)/2;let z;h_loop:for(let h=0;h<=hmax;h++){const kmin=2*Math.max(0,h-M)-h;const kmax=h-2*Math.max(0,h-N);for(let k=kmin;k<=kmax;k+=2){const gkm=b[k-1-Z*Math.floor((k-1)/Z)];const gkp=b[k+1-Z*Math.floor((k+1)/Z)];const u=(k===-h||(k!==h&&gkm<gkp))?gkp:gkm+1;const v=u-k;let x=u;let y=v;while(x<N&&y<M&&eq(i+x,j+y))\nx++,y++;b[k-Z*Math.floor(k/Z)]=x;if(parity===1&&(z=W-k)>=1-h&&z<h&&x+b[Z+z-Z*Math.floor(z/Z)]>=N){if(h>1||x!==u){stack_base[stack_top++]=i+x;stack_base[stack_top++]=N-x;stack_base[stack_top++]=j+y;stack_base[stack_top++]=M-y;N=u;M=v;Z=2*(Math.min(N,M)+1);continue Z_block;}\nelse\nbreak h_loop;}}\nfor(let k=kmin;k<=kmax;k+=2){const pkm=b[Z+k-1-Z*Math.floor((k-1)/Z)];const pkp=b[Z+k+1-Z*Math.floor((k+1)/Z)];const u=(k===-h||(k!==h&&pkm<pkp))?pkp:pkm+1;const v=u-k;let x=u;let y=v;while(x<N&&y<M&&eq(offsetx-x,offsety-y))\nx++,y++;b[Z+k-Z*Math.floor(k/Z)]=x;if(parity===0&&(z=W-k)>=-h&&z<=h&&x+b[z-Z*Math.floor(z/Z)]>=N){if(h>0||x!==u){stack_base[stack_top++]=i+N-u;stack_base[stack_top++]=u;stack_base[stack_top++]=j+M-v;stack_base[stack_top++]=v;N=N-x;M=M-y;Z=2*(Math.min(N,M)+1);continue Z_block;}\nelse\nbreak h_loop;}}}\nif(N===M)\ncontinue;if(M>N){i+=N;j+=N;M-=N;N=0;}\nelse{i+=M;j+=M;N-=M;M=0;}\nbreak;}\nif(N+M!==0){if(state.pxe===i||state.pye===j){state.pxe=i+N;state.pye=j+M;}\nelse{const sx=state.pxs;state.oxs=state.pxs;state.oxe=state.pxe;state.oys=state.pys;state.oye=state.pye;state.pxs=i;state.pxe=i+N;state.pys=j;state.pye=j+M;if(sx>=0){state.i=i;state.N=N;state.j=j;state.M=M;state.Z=Z;state.stack_top=stack_top;return 1;}}}}\ncase 1:{if(stack_top===0)\nreturn 2;M=stack_base[--stack_top];j=stack_base[--stack_top];N=stack_base[--stack_top];i=stack_base[--stack_top];Z=2*(Math.min(N,M)+1);c=0;}}}}\nclass DiffGen{constructor(state){this.state=state;this.c=0;this.result={value:null,done:false};}\n[Symbol.iterator](){return this;}\nnext(){const{state,result}=this;if(this.c>1){result.done=true;result.value=undefined;return result;}\nconst c=diff_internal(state,this.c);this.c=c;if(c===1){result.value=[state.oxs,state.oxe,state.oys,state.oye];return result;}\nif(state.pxs>=0){result.value=[state.pxs,state.pxe,state.pys,state.pye];return result;}\nresult.done=true;result.value=undefined;return result;}}\nfunction diff_core(i,N,j,M,eq){const Z=(Math.min(N,M)+1)*2;const L=N+M;const b=new(L<256?Uint8Array:L<65536?Uint16Array:Uint32Array)(2*Z);return new DiffGen({i,N,j,M,Z,b,eq,pxs:-1,pxe:-1,pys:-1,pye:-1,oxs:-1,oxe:-1,oys:-1,oye:-1,stack_top:0,stack_base:[],});}\nexports.diff_core=diff_core;function diff(xs,ys,eq){let[i,N,M]=[0,xs.length,ys.length];if(typeof eq==='function'){while(i<N&&i<M&&eq(i,i))\ni++;if(i===N&&i===M)\nreturn[][Symbol.iterator]();while(eq(--N,--M)&&N>i&&M>i);}\nelse{while(i<N&&i<M&&xs[i]===ys[i])\ni++;if(i===N&&i===M)\nreturn[][Symbol.iterator]();while(xs[--N]===ys[--M]&&N>i&&M>i);eq=(i,j)=>xs[i]===ys[j];}\nreturn diff_core(i,N+1-i,i,M+1-i,eq);}\nexports.diff=diff;class LCSGen{constructor(diff,N){this.diff=diff;this.N=N;this.i=0;this.j=0;}\n[Symbol.iterator](){return this;}\nnext(){const rec=this.diff.next();if(rec.done){const{i,j,N}=this;if(i<N){rec.done=false;rec.value=[i,j,N-i];this.i=N;}\nreturn rec;}\nconst v=rec.value;const sx=v[0];const ex=v[1];const ey=v[3];const{i,j}=this;if(i!==sx){v.length--;v[0]=i;v[1]=j;v[2]=sx-i;}\nthis.i=ex;this.j=ey;return rec;}}\nfunction lcs(xs,ys,eq){return new LCSGen(diff(xs,ys,eq),xs.length);}\nexports.lcs=lcs;function*calcPatch(xs,ys,eq){const slice=ArrayBuffer.isView(xs)?Uint8Array.prototype.subarray:xs.slice;for(const v of diff(xs,ys,eq)){v[2]=slice.call(ys,v[2],v[3]);yield v;}}\nexports.calcPatch=calcPatch;function*applyPatch(xs,patch){let i=0;const slice=ArrayBuffer.isView(xs)?Uint8Array.prototype.subarray:xs.slice;for(const[dels,dele,ins]of patch){if(i<dels)\nyield slice.call(xs,i,dels);if(ins.length>0)\nyield ins;i=dele;}\nif(i<xs.length)\nyield slice.call(xs,i);}\nexports.applyPatch=applyPatch;function*calcSlices(xs,ys,eq){let i=0;const slice=ArrayBuffer.isView(xs)?Uint8Array.prototype.subarray:xs.slice;for(const[dels,dele,inss,inse]of diff(xs,ys,eq)){if(i<dels)\nyield[0,slice.call(xs,i,dels)];if(dels<dele)\nyield[-1,slice.call(xs,dels,dele)];if(inss<inse)\nyield[1,slice.call(ys,inss,inse)];i=dele;}\nif(i<xs.length)\nyield[0,xs.slice(i)];}\nexports.calcSlices=calcSlices;", "const encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nexport function base64URLtoBytes(base64: string) {\n  base64 = base64.replace(/=/g, \"\");\n  const n = base64.length;\n  const rem = n % 4;\n  const k = rem && rem - 1; // how many bytes the last base64 chunk encodes\n  const m = (n >> 2) * 3 + k; // total encoded bytes\n\n  const encoded = new Uint8Array(n + 3);\n  encoder.encodeInto(base64 + \"===\", encoded);\n\n  for (let i = 0, j = 0; i < n; i += 4, j += 3) {\n    const x =\n      (lookup[encoded[i]!]! << 18) +\n      (lookup[encoded[i + 1]!]! << 12) +\n      (lookup[encoded[i + 2]!]! << 6) +\n      lookup[encoded[i + 3]!]!;\n    encoded[j] = x >> 16;\n    encoded[j + 1] = (x >> 8) & 0xff;\n    encoded[j + 2] = x & 0xff;\n  }\n  return new Uint8Array(encoded.buffer, 0, m);\n}\n\nexport function bytesToBase64url(bytes: Uint8Array) {\n  // const before = performance.now();\n  const m = bytes.length;\n  const k = m % 3;\n  const n = Math.floor(m / 3) * 4 + (k && k + 1);\n  const N = Math.ceil(m / 3) * 4;\n  const encoded = new Uint8Array(N);\n\n  for (let i = 0, j = 0; j < m; i += 4, j += 3) {\n    const y = (bytes[j]! << 16) + (bytes[j + 1]! << 8) + (bytes[j + 2]! | 0);\n    encoded[i] = encodeLookup[y >> 18]!;\n    encoded[i + 1] = encodeLookup[(y >> 12) & 0x3f]!;\n    encoded[i + 2] = encodeLookup[(y >> 6) & 0x3f]!;\n    encoded[i + 3] = encodeLookup[y & 0x3f]!;\n  }\n\n  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, n));\n  if (k === 1) base64 += \"==\";\n  if (k === 2) base64 += \"=\";\n\n  return base64;\n}\n\nconst alphabet =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\nconst lookup = new Uint8Array(128);\nfor (const [i, a] of Array.from(alphabet).entries()) {\n  lookup[a.charCodeAt(0)] = i;\n}\nlookup[\"=\".charCodeAt(0)] = 0;\n\nconst encodeLookup = new Uint8Array(64);\nfor (const [i, a] of Array.from(alphabet).entries()) {\n  encodeLookup[i] = a.charCodeAt(0);\n}\n", "const defaultErrorConfig = {\r\n    withStackTrace: false,\r\n};\r\n// Custom error object\r\n// Context / discussion: https://github.com/supermacro/neverthrow/pull/215\r\nconst createNeverThrowError = (message, result, config = defaultErrorConfig) => {\r\n    const data = result.isOk()\r\n        ? { type: 'Ok', value: result.value }\r\n        : { type: 'Err', value: result.error };\r\n    const maybeStack = config.withStackTrace ? new Error().stack : undefined;\r\n    return {\r\n        data,\r\n        message,\r\n        stack: maybeStack,\r\n    };\r\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, [])).next());\r\n    });\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\n\nclass ResultAsync {\r\n    constructor(res) {\r\n        this._promise = res;\r\n    }\r\n    static fromSafePromise(promise) {\r\n        const newPromise = promise.then((value) => new Ok(value));\r\n        return new ResultAsync(newPromise);\r\n    }\r\n    static fromPromise(promise, errorFn) {\r\n        const newPromise = promise\r\n            .then((value) => new Ok(value))\r\n            .catch((e) => new Err(errorFn(e)));\r\n        return new ResultAsync(newPromise);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    static fromThrowable(fn, errorFn) {\r\n        return (...args) => {\r\n            return new ResultAsync((() => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    return new Ok(yield fn(...args));\r\n                }\r\n                catch (error) {\r\n                    return new Err(errorFn ? errorFn(error) : error);\r\n                }\r\n            }))());\r\n        };\r\n    }\r\n    static combine(asyncResultList) {\r\n        return combineResultAsyncList(asyncResultList);\r\n    }\r\n    static combineWithAllErrors(asyncResultList) {\r\n        return combineResultAsyncListWithAllErrors(asyncResultList);\r\n    }\r\n    map(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            return new Ok(yield f(res.value));\r\n        })));\r\n    }\r\n    andThrough(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            const newRes = yield f(res.value);\r\n            if (newRes.isErr()) {\r\n                return new Err(newRes.error);\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    andTee(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            try {\r\n                yield f(res.value);\r\n            }\r\n            catch (e) {\r\n                // Tee does not care about the error\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    mapErr(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isOk()) {\r\n                return new Ok(res.value);\r\n            }\r\n            return new Err(yield f(res.error));\r\n        })));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(f) {\r\n        return new ResultAsync(this._promise.then((res) => {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            const newValue = f(res.value);\r\n            return newValue instanceof ResultAsync ? newValue._promise : newValue;\r\n        }));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return f(res.error);\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    match(ok, _err) {\r\n        return this._promise.then((res) => res.match(ok, _err));\r\n    }\r\n    unwrapOr(t) {\r\n        return this._promise.then((res) => res.unwrapOr(t));\r\n    }\r\n    /**\r\n     * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.\r\n     */\r\n    safeUnwrap() {\r\n        return __asyncGenerator(this, arguments, function* safeUnwrap_1() {\r\n            return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));\r\n        });\r\n    }\r\n    // Makes ResultAsync implement PromiseLike<Result>\r\n    then(successCallback, failureCallback) {\r\n        return this._promise.then(successCallback, failureCallback);\r\n    }\r\n}\r\nconst okAsync = (value) => new ResultAsync(Promise.resolve(new Ok(value)));\r\nconst errAsync = (err) => new ResultAsync(Promise.resolve(new Err(err)));\r\nconst fromPromise = ResultAsync.fromPromise;\r\nconst fromSafePromise = ResultAsync.fromSafePromise;\r\nconst fromAsyncThrowable = ResultAsync.fromThrowable;\n\n/**\r\n * Short circuits on the FIRST Err value that we find\r\n */\r\nconst combineResultList = (resultList) => {\r\n    let acc = ok([]);\r\n    for (const result of resultList) {\r\n        if (result.isErr()) {\r\n            acc = err(result.error);\r\n            break;\r\n        }\r\n        else {\r\n            acc.map((list) => list.push(result.value));\r\n        }\r\n    }\r\n    return acc;\r\n};\r\n/* This is the typesafe version of Promise.all\r\n *\r\n * Takes a list of ResultAsync<T, E> and success if all inner results are Ok values\r\n * or fails if one (or more) of the inner results are Err values\r\n */\r\nconst combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);\r\n/**\r\n * Give a list of all the errors we find\r\n */\r\nconst combineResultListWithAllErrors = (resultList) => {\r\n    let acc = ok([]);\r\n    for (const result of resultList) {\r\n        if (result.isErr() && acc.isErr()) {\r\n            acc.error.push(result.error);\r\n        }\r\n        else if (result.isErr() && acc.isOk()) {\r\n            acc = err([result.error]);\r\n        }\r\n        else if (result.isOk() && acc.isOk()) {\r\n            acc.value.push(result.value);\r\n        }\r\n        // do nothing when result.isOk() && acc.isErr()\r\n    }\r\n    return acc;\r\n};\r\nconst combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\r\nvar Result;\r\n(function (Result) {\r\n    /**\r\n     * Wraps a function with a try catch, creating a new function with the same\r\n     * arguments but returning `Ok` if successful, `Err` if the function throws\r\n     *\r\n     * @param fn function to wrap with ok on success or err on failure\r\n     * @param errorFn when an error is thrown, this will wrap the error result if provided\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    function fromThrowable(fn, errorFn) {\r\n        return (...args) => {\r\n            try {\r\n                const result = fn(...args);\r\n                return ok(result);\r\n            }\r\n            catch (e) {\r\n                return err(errorFn ? errorFn(e) : e);\r\n            }\r\n        };\r\n    }\r\n    Result.fromThrowable = fromThrowable;\r\n    function combine(resultList) {\r\n        return combineResultList(resultList);\r\n    }\r\n    Result.combine = combine;\r\n    function combineWithAllErrors(resultList) {\r\n        return combineResultListWithAllErrors(resultList);\r\n    }\r\n    Result.combineWithAllErrors = combineWithAllErrors;\r\n})(Result || (Result = {}));\r\nconst ok = (value) => new Ok(value);\r\nfunction err(err) {\r\n    return new Err(err);\r\n}\r\nfunction safeTry(body) {\r\n    const n = body().next();\r\n    if (n instanceof Promise) {\r\n        return new ResultAsync(n.then((r) => r.value));\r\n    }\r\n    return n.value;\r\n}\r\nclass Ok {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n    isOk() {\r\n        return true;\r\n    }\r\n    isErr() {\r\n        return !this.isOk();\r\n    }\r\n    map(f) {\r\n        return ok(f(this.value));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    mapErr(_f) {\r\n        return ok(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(f) {\r\n        return f(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThrough(f) {\r\n        return f(this.value).map((_value) => this.value);\r\n    }\r\n    andTee(f) {\r\n        try {\r\n            f(this.value);\r\n        }\r\n        catch (e) {\r\n            // Tee doesn't care about the error\r\n        }\r\n        return ok(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(_f) {\r\n        return ok(this.value);\r\n    }\r\n    asyncAndThen(f) {\r\n        return f(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    asyncAndThrough(f) {\r\n        return f(this.value).map(() => this.value);\r\n    }\r\n    asyncMap(f) {\r\n        return ResultAsync.fromSafePromise(f(this.value));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    unwrapOr(_v) {\r\n        return this.value;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    match(ok, _err) {\r\n        return ok(this.value);\r\n    }\r\n    safeUnwrap() {\r\n        const value = this.value;\r\n        /* eslint-disable-next-line require-yield */\r\n        return (function* () {\r\n            return value;\r\n        })();\r\n    }\r\n    _unsafeUnwrap(_) {\r\n        return this.value;\r\n    }\r\n    _unsafeUnwrapErr(config) {\r\n        throw createNeverThrowError('Called `_unsafeUnwrapErr` on an Ok', this, config);\r\n    }\r\n}\r\nclass Err {\r\n    constructor(error) {\r\n        this.error = error;\r\n    }\r\n    isOk() {\r\n        return false;\r\n    }\r\n    isErr() {\r\n        return !this.isOk();\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    map(_f) {\r\n        return err(this.error);\r\n    }\r\n    mapErr(f) {\r\n        return err(f(this.error));\r\n    }\r\n    andThrough(_f) {\r\n        return err(this.error);\r\n    }\r\n    andTee(_f) {\r\n        return err(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(_f) {\r\n        return err(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(f) {\r\n        return f(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    asyncAndThen(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    asyncAndThrough(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    asyncMap(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    unwrapOr(v) {\r\n        return v;\r\n    }\r\n    match(_ok, err) {\r\n        return err(this.error);\r\n    }\r\n    safeUnwrap() {\r\n        const error = this.error;\r\n        return (function* () {\r\n            yield err(error);\r\n            throw new Error('Do not use this generator out of `safeTry`');\r\n        })();\r\n    }\r\n    _unsafeUnwrap(config) {\r\n        throw createNeverThrowError('Called `_unsafeUnwrap` on an Err', this, config);\r\n    }\r\n    _unsafeUnwrapErr(_) {\r\n        return this.error;\r\n    }\r\n}\r\nconst fromThrowable = Result.fromThrowable;\r\n//#endregion\n\nexport { Err, Ok, Result, ResultAsync, err, errAsync, fromAsyncThrowable, fromPromise, fromSafePromise, fromThrowable, ok, okAsync, safeTry };\n", "import { CoValueCore } from \"./coValueCore.js\";\nimport { RawProfile as Profile, RawAccount } from \"./coValues/account.js\";\nimport { RawCoList } from \"./coValues/coList.js\";\nimport { RawCoMap } from \"./coValues/coMap.js\";\nimport { RawCoPlainText } from \"./coValues/coPlainText.js\";\nimport { RawBinaryCoStream, RawCoStream } from \"./coValues/coStream.js\";\nimport { RawGroup } from \"./coValues/group.js\";\nimport { RawCoID } from \"./ids.js\";\nimport { JsonObject, JsonValue } from \"./jsonValue.js\";\n\nexport type CoID<T extends RawCoValue> = RawCoID & {\n  readonly __type: T;\n};\n\nexport interface RawCoValue {\n  /** The `CoValue`'s (precisely typed) `CoID` */\n  id: CoID<this>;\n  core: CoValueCore;\n  /** Specifies which kind of `CoValue` this is */\n  type: string;\n  /** The `CoValue`'s (precisely typed) static metadata */\n  headerMeta: JsonObject | null;\n  /** The `Group` this `CoValue` belongs to (determining permissions) */\n  group: RawGroup;\n  /** Returns an immutable JSON presentation of this `CoValue` */\n  toJSON(): JsonValue;\n  atTime(time: number): this;\n  /** Lets you subscribe to future updates to this CoValue (whether made locally or by other users).\n   *\n   * Takes a listener function that will be called with the current state for each update.\n   *\n   * Returns an unsubscribe function.\n   *\n   * Used internally by `useTelepathicData()` for reactive updates on changes to a `CoValue`. */\n  subscribe(listener: (coValue: this) => void): () => void;\n\n  totalValidTransactions: number;\n}\n\nexport class RawUnknownCoValue implements RawCoValue {\n  id: CoID<this>;\n  core: CoValueCore;\n  totalValidTransactions = 0;\n\n  constructor(core: CoValueCore) {\n    this.id = core.id as CoID<this>;\n    this.core = core;\n  }\n\n  get type() {\n    return this.core.header.type;\n  }\n\n  get headerMeta() {\n    return this.core.header.meta as JsonObject;\n  }\n\n  /** @category 6. Meta */\n  get group(): RawGroup {\n    return this.core.getGroup();\n  }\n\n  toJSON() {\n    return {};\n  }\n\n  atTime() {\n    return this;\n  }\n\n  subscribe(listener: (value: this) => void): () => void {\n    return this.core.subscribe((content) => {\n      listener(content as this);\n    });\n  }\n}\n\nexport type AnyRawCoValue =\n  | RawCoMap\n  | RawGroup\n  | RawAccount\n  | Profile\n  | RawCoList\n  | RawCoPlainText\n  | RawCoStream\n  | RawBinaryCoStream;\n\nexport function expectMap(content: RawCoValue): RawCoMap {\n  if (content.type !== \"comap\") {\n    throw new Error(\"Expected map\");\n  }\n\n  return content as RawCoMap;\n}\n\nexport function expectList(content: RawCoValue): RawCoList {\n  if (content.type !== \"colist\") {\n    throw new Error(\"Expected list\");\n  }\n\n  return content as RawCoList;\n}\n\nexport function expectStream(content: RawCoValue): RawCoStream {\n  if (content.type !== \"costream\") {\n    throw new Error(\"Expected stream\");\n  }\n\n  return content as RawCoStream;\n}\n\nexport function expectPlainText(content: RawCoValue): RawCoPlainText {\n  if (content.type !== \"coplaintext\") {\n    throw new Error(\"Expected plaintext\");\n  }\n\n  return content as RawCoPlainText;\n}\n", "import type { JsonValue } from \"./jsonValue.js\";\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  NONE = 4,\n}\n\ntype ErrorAttributes = { err: unknown };\n\nexport interface LogSystem {\n  debug(message: string, attributes?: Record<string, JsonValue>): void;\n  info(message: string, attributes?: Record<string, JsonValue>): void;\n  warn(\n    message: string,\n    attributes?: Record<string, JsonValue> | ErrorAttributes,\n  ): void;\n  error(\n    message: string,\n    attributes?: Record<string, JsonValue> | ErrorAttributes,\n  ): void;\n}\n\n// Default console-based logging system\nexport class ConsoleLogSystem implements LogSystem {\n  debug(message: string, attributes?: Record<string, JsonValue>) {\n    console.debug(message, attributes);\n  }\n  info(message: string, attributes?: Record<string, JsonValue>) {\n    console.info(message, attributes);\n  }\n  warn(\n    message: string,\n    attributes?: Record<string, JsonValue> | ErrorAttributes,\n  ) {\n    console.warn(message, attributes);\n  }\n  error(\n    message: string,\n    attributes?: Record<string, JsonValue> | ErrorAttributes,\n  ) {\n    console.error(message, attributes);\n  }\n}\n\nexport class Logger {\n  private level: LogLevel;\n  private logSystem: LogSystem;\n\n  constructor(\n    level: LogLevel = LogLevel.INFO,\n    logSystem: LogSystem = new ConsoleLogSystem(),\n  ) {\n    this.level = level;\n    this.logSystem = logSystem;\n  }\n\n  setLevel(level: LogLevel) {\n    this.level = level;\n  }\n\n  setLogSystem(logSystem: LogSystem) {\n    this.logSystem = logSystem;\n  }\n\n  debug(message: string, attributes?: Record<string, JsonValue>) {\n    if (this.level <= LogLevel.DEBUG) {\n      this.logSystem.debug(message, attributes);\n    }\n  }\n\n  info(message: string, attributes?: Record<string, JsonValue>) {\n    if (this.level <= LogLevel.INFO) {\n      this.logSystem.info(message, attributes);\n    }\n  }\n\n  warn(\n    message: string,\n    attributes?: Record<string, JsonValue> | ErrorAttributes,\n  ) {\n    if (this.level <= LogLevel.WARN) {\n      this.logSystem.warn(message, attributes);\n    }\n  }\n\n  error(\n    message: string,\n    attributes?: Record<string, JsonValue> | ErrorAttributes,\n  ) {\n    if (this.level <= LogLevel.ERROR) {\n      this.logSystem.error(message, attributes);\n    }\n  }\n}\n\n// Create default logger instance\nexport const logger = new Logger();\n", "import { RawAccountID } from \"../coValues/account.js\";\nimport { AgentID, SessionID } from \"../ids.js\";\n\nexport function accountOrAgentIDfromSessionID(\n  sessionID: SessionID,\n): RawAccountID | AgentID {\n  const until = sessionID.indexOf(\"_session\");\n  return sessionID.slice(0, until) as RawAccountID | AgentID;\n}\n", "import { CoID, RawCoValue } from \"../coValue.js\";\nimport { CoValueCore } from \"../coValueCore.js\";\nimport { AgentID, SessionID, TransactionID } from \"../ids.js\";\nimport { JsonObject, JsonValue } from \"../jsonValue.js\";\nimport { CoValueKnownState } from \"../sync.js\";\nimport { accountOrAgentIDfromSessionID } from \"../typeUtils/accountOrAgentIDfromSessionID.js\";\nimport { isCoValue } from \"../typeUtils/isCoValue.js\";\nimport { RawAccountID } from \"./account.js\";\nimport { RawGroup } from \"./group.js\";\n\nexport type OpID = TransactionID & { changeIdx: number };\n\nexport type InsertionOpPayload<T extends JsonValue> =\n  | {\n      op: \"pre\";\n      value: T;\n      before: OpID | \"end\";\n    }\n  | {\n      op: \"app\";\n      value: T;\n      after: OpID | \"start\";\n    };\n\nexport type DeletionOpPayload = {\n  op: \"del\";\n  insertion: OpID;\n};\n\nexport type ListOpPayload<T extends JsonValue> =\n  | InsertionOpPayload<T>\n  | DeletionOpPayload;\n\ntype InsertionEntry<T extends JsonValue> = {\n  madeAt: number;\n  predecessors: OpID[];\n  successors: OpID[];\n} & InsertionOpPayload<T>;\n\ntype DeletionEntry = {\n  madeAt: number;\n  deletionID: OpID;\n} & DeletionOpPayload;\n\nexport class RawCoList<\n  Item extends JsonValue = JsonValue,\n  Meta extends JsonObject | null = null,\n> implements RawCoValue\n{\n  /** @category 6. Meta */\n  id: CoID<this>;\n  /** @category 6. Meta */\n  type: \"colist\" | \"coplaintext\" = \"colist\" as const;\n  /** @category 6. Meta */\n  core: CoValueCore;\n  /** @internal */\n  afterStart: OpID[];\n  /** @internal */\n  beforeEnd: OpID[];\n  /** @internal */\n  insertions: {\n    [sessionID: SessionID]: {\n      [txIdx: number]: {\n        [changeIdx: number]: InsertionEntry<Item>;\n      };\n    };\n  };\n  /** @internal */\n  deletionsByInsertion: {\n    [deletedSessionID: SessionID]: {\n      [deletedTxIdx: number]: {\n        [deletedChangeIdx: number]: DeletionEntry[];\n      };\n    };\n  };\n  /** @category 6. Meta */\n  readonly _item!: Item;\n\n  /** @internal */\n  _cachedEntries?: {\n    value: Item;\n    madeAt: number;\n    opID: OpID;\n  }[];\n  /** @internal */\n  totalValidTransactions = 0;\n  knownTransactions: CoValueKnownState[\"sessions\"] = {};\n  lastValidTransaction: number | undefined;\n\n  /** @internal */\n  constructor(core: CoValueCore) {\n    this.id = core.id as CoID<this>;\n    this.core = core;\n\n    this.insertions = {};\n    this.deletionsByInsertion = {};\n    this.afterStart = [];\n    this.beforeEnd = [];\n    this.knownTransactions = {};\n\n    this.processNewTransactions();\n  }\n\n  processNewTransactions() {\n    const transactions = this.core.getValidSortedTransactions({\n      ignorePrivateTransactions: false,\n      knownTransactions: this.knownTransactions,\n    });\n\n    if (transactions.length === 0) {\n      return;\n    }\n\n    this.totalValidTransactions += transactions.length;\n    let lastValidTransaction: number | undefined = undefined;\n    let oldestValidTransaction: number | undefined = undefined;\n    this._cachedEntries = undefined;\n\n    for (const { txID, changes, madeAt } of transactions) {\n      lastValidTransaction = Math.max(lastValidTransaction ?? 0, madeAt);\n      oldestValidTransaction = Math.min(\n        oldestValidTransaction ?? Infinity,\n        madeAt,\n      );\n\n      this.knownTransactions[txID.sessionID] = Math.max(\n        this.knownTransactions[txID.sessionID] ?? 0,\n        txID.txIndex,\n      );\n\n      for (const [changeIdx, changeUntyped] of changes.entries()) {\n        const change = changeUntyped as ListOpPayload<Item>;\n\n        if (change.op === \"pre\" || change.op === \"app\") {\n          let sessionEntry = this.insertions[txID.sessionID];\n          if (!sessionEntry) {\n            sessionEntry = {};\n            this.insertions[txID.sessionID] = sessionEntry;\n          }\n          let txEntry = sessionEntry[txID.txIndex];\n          if (!txEntry) {\n            txEntry = {};\n            sessionEntry[txID.txIndex] = txEntry;\n          }\n          txEntry[changeIdx] = {\n            madeAt,\n            predecessors: [],\n            successors: [],\n            ...change,\n          };\n          if (change.op === \"pre\") {\n            if (change.before === \"end\") {\n              this.beforeEnd.push({\n                ...txID,\n                changeIdx,\n              });\n            } else {\n              const beforeEntry =\n                this.insertions[change.before.sessionID]?.[\n                  change.before.txIndex\n                ]?.[change.before.changeIdx];\n              if (!beforeEntry) {\n                continue;\n              }\n              beforeEntry.predecessors.splice(0, 0, {\n                ...txID,\n                changeIdx,\n              });\n            }\n          } else {\n            if (change.after === \"start\") {\n              this.afterStart.push({\n                ...txID,\n                changeIdx,\n              });\n            } else {\n              const afterEntry =\n                this.insertions[change.after.sessionID]?.[\n                  change.after.txIndex\n                ]?.[change.after.changeIdx];\n              if (!afterEntry) {\n                continue;\n              }\n              afterEntry.successors.push({\n                ...txID,\n                changeIdx,\n              });\n            }\n          }\n        } else if (change.op === \"del\") {\n          let sessionEntry =\n            this.deletionsByInsertion[change.insertion.sessionID];\n          if (!sessionEntry) {\n            sessionEntry = {};\n            this.deletionsByInsertion[change.insertion.sessionID] =\n              sessionEntry;\n          }\n          let txEntry = sessionEntry[change.insertion.txIndex];\n          if (!txEntry) {\n            txEntry = {};\n            sessionEntry[change.insertion.txIndex] = txEntry;\n          }\n          let changeEntry = txEntry[change.insertion.changeIdx];\n          if (!changeEntry) {\n            changeEntry = [];\n            txEntry[change.insertion.changeIdx] = changeEntry;\n          }\n          changeEntry.push({\n            madeAt,\n            deletionID: {\n              ...txID,\n              changeIdx,\n            },\n            ...change,\n          });\n        } else {\n          throw new Error(\n            \"Unknown list operation \" + (change as { op: unknown }).op,\n          );\n        }\n      }\n    }\n\n    if (\n      this.lastValidTransaction &&\n      oldestValidTransaction &&\n      oldestValidTransaction < this.lastValidTransaction\n    ) {\n      this.rebuildFromCore();\n    } else {\n      this.lastValidTransaction = lastValidTransaction;\n    }\n  }\n\n  /** @category 6. Meta */\n  get headerMeta(): Meta {\n    return this.core.header.meta as Meta;\n  }\n\n  /** @category 6. Meta */\n  get group(): RawGroup {\n    return this.core.getGroup();\n  }\n\n  /**\n   * Not yet implemented\n   *\n   * @category 4. Time travel\n   */\n  atTime(_time: number): this {\n    throw new Error(\"Not yet implemented\");\n  }\n\n  /**\n   * Get the item currently at `idx`.\n   *\n   * @category 1. Reading\n   */\n  get(idx: number): Item | undefined {\n    const entry = this.entries()[idx];\n    if (!entry) {\n      return undefined;\n    }\n    return entry.value;\n  }\n\n  /**\n   * Returns the current items in the CoList as an array.\n   *\n   * @category 1. Reading\n   **/\n  asArray(): Item[] {\n    return this.entries().map((entry) => entry.value);\n  }\n\n  /** @internal */\n  entries(): {\n    value: Item;\n    madeAt: number;\n    opID: OpID;\n  }[] {\n    if (this._cachedEntries) {\n      return this._cachedEntries;\n    }\n    const arr = this.entriesUncached();\n    this._cachedEntries = arr;\n    return arr;\n  }\n\n  /** @internal */\n  entriesUncached(): {\n    value: Item;\n    madeAt: number;\n    opID: OpID;\n  }[] {\n    const arr: {\n      value: Item;\n      madeAt: number;\n      opID: OpID;\n    }[] = [];\n    for (const opID of this.afterStart) {\n      this.fillArrayFromOpID(opID, arr);\n    }\n    for (const opID of this.beforeEnd) {\n      this.fillArrayFromOpID(opID, arr);\n    }\n    return arr;\n  }\n\n  /** @internal */\n  private fillArrayFromOpID(\n    opID: OpID,\n    arr: {\n      value: Item;\n      madeAt: number;\n      opID: OpID;\n    }[],\n  ) {\n    const todo = [opID]; // a stack with the next item to do at the end\n    const predecessorsVisited = new Set<OpID>();\n\n    while (todo.length > 0) {\n      const currentOpID = todo[todo.length - 1]!;\n\n      const entry =\n        this.insertions[currentOpID.sessionID]?.[currentOpID.txIndex]?.[\n          currentOpID.changeIdx\n        ];\n\n      if (!entry) {\n        throw new Error(\"Missing op \" + currentOpID);\n      }\n\n      const shouldTraversePredecessors =\n        entry.predecessors.length > 0 && !predecessorsVisited.has(currentOpID);\n\n      // We navigate the predecessors before processing the current opID in the list\n      if (shouldTraversePredecessors) {\n        for (let i = entry.predecessors.length - 1; i >= 0; i--) {\n          todo.push(entry.predecessors[i]!);\n        }\n        predecessorsVisited.add(currentOpID);\n      } else {\n        // Remove the current opID from the todo stack to consider it processed.\n        todo.pop();\n\n        const deleted =\n          (this.deletionsByInsertion[currentOpID.sessionID]?.[\n            currentOpID.txIndex\n          ]?.[currentOpID.changeIdx]?.length || 0) > 0;\n\n        if (!deleted) {\n          arr.push({\n            value: entry.value,\n            madeAt: entry.madeAt,\n            opID: currentOpID,\n          });\n        }\n\n        // traverse successors in reverse for correct insertion behavior\n        for (const successor of entry.successors) {\n          todo.push(successor);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the current items in the CoList as an array. (alias of `asArray`)\n   *\n   * @category 1. Reading\n   */\n  toJSON(): Item[] {\n    return this.asArray();\n  }\n\n  /** @category 5. Edit history */\n  editAt(idx: number):\n    | {\n        by: RawAccountID | AgentID;\n        tx: TransactionID;\n        at: Date;\n        value: Item;\n      }\n    | undefined {\n    const entry = this.entries()[idx];\n    if (!entry) {\n      return undefined;\n    }\n    const madeAt = new Date(entry.madeAt);\n    const by = accountOrAgentIDfromSessionID(entry.opID.sessionID);\n    const value = entry.value;\n    return {\n      by,\n      tx: {\n        sessionID: entry.opID.sessionID,\n        txIndex: entry.opID.txIndex,\n      },\n      at: madeAt,\n      value,\n    };\n  }\n\n  /** @category 5. Edit history */\n  deletionEdits(): {\n    by: RawAccountID | AgentID;\n    tx: TransactionID;\n    at: Date;\n    // TODO: add indices that are now before and after the deleted item\n  }[] {\n    const edits: {\n      by: RawAccountID | AgentID;\n      tx: TransactionID;\n      at: Date;\n    }[] = [];\n\n    for (const sessionID in this.deletionsByInsertion) {\n      const sessionEntry = this.deletionsByInsertion[sessionID as SessionID];\n      for (const txIdx in sessionEntry) {\n        const txEntry = sessionEntry[Number(txIdx)];\n        for (const changeIdx in txEntry) {\n          const changeEntry = txEntry[Number(changeIdx)];\n          for (const deletion of changeEntry || []) {\n            const madeAt = new Date(deletion.madeAt);\n            const by = accountOrAgentIDfromSessionID(\n              deletion.deletionID.sessionID,\n            );\n            edits.push({\n              by,\n              tx: deletion.deletionID,\n              at: madeAt,\n            });\n          }\n        }\n      }\n    }\n\n    return edits;\n  }\n\n  /** @category 3. Subscription */\n  subscribe(listener: (coList: this) => void): () => void {\n    return this.core.subscribe((content) => {\n      listener(content as this);\n    });\n  }\n\n  /** Appends `item` after the item currently at index `after`.\n   *\n   * If `privacy` is `\"private\"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.\n   *\n   * If `privacy` is `\"trusting\"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.\n   *\n   * @category 2. Editing\n   **/\n  append(\n    item: Item,\n    after?: number,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ) {\n    this.appendItems([item], after, privacy);\n  }\n\n  /**\n   * Appends `items` to the list at index `after`. If `after` is negative, it is treated as `0`.\n   *\n   * If `privacy` is `\"private\"` **(default)**, `items` are encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.\n   *\n   * If `privacy` is `\"trusting\"`, `items` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.\n   *\n   * @category 2. Editing\n   */\n  appendItems(\n    items: Item[],\n    after?: number,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ) {\n    const entries = this.entries();\n    after =\n      after === undefined\n        ? entries.length > 0\n          ? entries.length - 1\n          : 0\n        : Math.max(0, after);\n    let opIDBefore: OpID | \"start\";\n    if (entries.length > 0) {\n      const entryBefore = entries[after];\n      if (!entryBefore) {\n        throw new Error(\"Invalid index \" + after);\n      }\n      opIDBefore = entryBefore.opID;\n    } else {\n      if (after !== 0) {\n        throw new Error(\"Invalid index \" + after);\n      }\n      opIDBefore = \"start\";\n    }\n\n    const changes = items.map((item) => ({\n      op: \"app\",\n      value: isCoValue(item) ? item.id : item,\n      after: opIDBefore,\n    }));\n\n    if (opIDBefore !== \"start\") {\n      // When added as successors we need to reverse the items\n      // to keep the same insertion order\n      changes.reverse();\n    }\n\n    this.core.makeTransaction(changes, privacy);\n    this.processNewTransactions();\n  }\n\n  /**\n   * Prepends `item` before the item currently at index `before`.\n   *\n   * If `privacy` is `\"private\"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.\n   *\n   * If `privacy` is `\"trusting\"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.\n   *\n   * @category 2. Editing\n   */\n  prepend(\n    item: Item,\n    before?: number,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ) {\n    const entries = this.entries();\n    before = before === undefined ? 0 : before;\n    let opIDAfter;\n    if (entries.length > 0) {\n      const entryAfter = entries[before];\n      if (entryAfter) {\n        opIDAfter = entryAfter.opID;\n      } else {\n        if (before !== entries.length) {\n          throw new Error(\"Invalid index \" + before);\n        }\n        opIDAfter = \"end\";\n      }\n    } else {\n      if (before !== 0) {\n        throw new Error(\"Invalid index \" + before);\n      }\n      opIDAfter = \"end\";\n    }\n    this.core.makeTransaction(\n      [\n        {\n          op: \"pre\",\n          value: isCoValue(item) ? item.id : item,\n          before: opIDAfter,\n        },\n      ],\n      privacy,\n    );\n\n    this.processNewTransactions();\n  }\n\n  /** Deletes the item at index `at`.\n   *\n   * If `privacy` is `\"private\"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.\n   *\n   * If `privacy` is `\"trusting\"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.\n   *\n   * @category 2. Editing\n   **/\n  delete(at: number, privacy: \"private\" | \"trusting\" = \"private\") {\n    const entries = this.entries();\n    const entry = entries[at];\n    if (!entry) {\n      throw new Error(\"Invalid index \" + at);\n    }\n    this.core.makeTransaction(\n      [\n        {\n          op: \"del\",\n          insertion: entry.opID,\n        },\n      ],\n      privacy,\n    );\n\n    this.processNewTransactions();\n  }\n\n  replace(\n    at: number,\n    newItem: Item,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ) {\n    const entries = this.entries();\n    const entry = entries[at];\n    if (!entry) {\n      throw new Error(\"Invalid index \" + at);\n    }\n\n    this.core.makeTransaction(\n      [\n        {\n          op: \"app\",\n          value: isCoValue(newItem) ? newItem.id : newItem,\n          after: entry.opID,\n        },\n        {\n          op: \"del\",\n          insertion: entry.opID,\n        },\n      ],\n      privacy,\n    );\n    this.processNewTransactions();\n  }\n\n  /** @internal */\n  rebuildFromCore() {\n    const listAfter = new RawCoList(this.core) as this;\n\n    this.afterStart = listAfter.afterStart;\n    this.beforeEnd = listAfter.beforeEnd;\n    this.insertions = listAfter.insertions;\n    this.deletionsByInsertion = listAfter.deletionsByInsertion;\n    this._cachedEntries = undefined;\n  }\n}\n", "import type { RawAccountID } from \"../coValues/account.js\";\nimport type { AgentID } from \"../ids.js\";\n\nexport function isAccountID(id: RawAccountID | AgentID): id is RawAccountID {\n  return id.startsWith(\"co_\");\n}\n", "import { base64URLtoBytes, bytesToBase64url } from \"../base64url.js\";\nimport { CoID, RawCoValue } from \"../coValue.js\";\nimport { CoValueCore } from \"../coValueCore.js\";\nimport { AgentID, SessionID, TransactionID } from \"../ids.js\";\nimport { JsonObject, JsonValue } from \"../jsonValue.js\";\nimport { logger } from \"../logger.js\";\nimport { CoValueKnownState } from \"../sync.js\";\nimport { accountOrAgentIDfromSessionID } from \"../typeUtils/accountOrAgentIDfromSessionID.js\";\nimport { isAccountID } from \"../typeUtils/isAccountID.js\";\nimport { isCoValue } from \"../typeUtils/isCoValue.js\";\nimport { RawAccountID } from \"./account.js\";\nimport { RawGroup } from \"./group.js\";\n\nexport type BinaryStreamInfo = {\n  mimeType: string;\n  fileName?: string;\n  totalSizeBytes?: number;\n};\n\nexport type BinaryStreamStart = {\n  type: \"start\";\n} & BinaryStreamInfo;\n\nexport type BinaryStreamChunk = {\n  type: \"chunk\";\n  chunk: `binary_U${string}`;\n};\n\nexport type BinaryStreamEnd = {\n  type: \"end\";\n};\n\nexport type BinaryCoStreamMeta = JsonObject & { type: \"binary\" };\n\nexport type BinaryStreamItem =\n  | BinaryStreamStart\n  | BinaryStreamChunk\n  | BinaryStreamEnd;\n\nexport type CoStreamItem<Item extends JsonValue> = {\n  value: Item;\n  tx: TransactionID;\n  madeAt: number;\n};\n\nexport class RawCoStreamView<\n  Item extends JsonValue = JsonValue,\n  Meta extends JsonObject | null = JsonObject | null,\n> implements RawCoValue\n{\n  id: CoID<this>;\n  type = \"costream\" as const;\n  core: CoValueCore;\n  items: {\n    [key: SessionID]: CoStreamItem<Item>[];\n  };\n  /** @internal */\n  knownTransactions: CoValueKnownState[\"sessions\"];\n  totalValidTransactions = 0;\n  readonly _item!: Item;\n\n  constructor(core: CoValueCore) {\n    this.id = core.id as CoID<this>;\n    this.core = core;\n    this.items = {};\n    this.knownTransactions = {};\n    this.processNewTransactions();\n  }\n\n  get headerMeta(): Meta {\n    return this.core.header.meta as Meta;\n  }\n\n  get group(): RawGroup {\n    return this.core.getGroup();\n  }\n\n  /** Not yet implemented */\n  atTime(_time: number): this {\n    throw new Error(\"Not yet implemented\");\n  }\n\n  /** @internal */\n  protected compareStreamItems(\n    a: CoStreamItem<Item>,\n    b: CoStreamItem<Item>,\n  ): number {\n    return (\n      a.madeAt - b.madeAt ||\n      (a.tx.sessionID === b.tx.sessionID\n        ? 0\n        : a.tx.sessionID < b.tx.sessionID\n          ? -1\n          : 1) ||\n      a.tx.txIndex - b.tx.txIndex\n    );\n  }\n\n  /** @internal */\n  processNewTransactions() {\n    const changeEntries = new Set<CoStreamItem<Item>[]>();\n\n    const newValidTransactions = this.core.getValidTransactions({\n      ignorePrivateTransactions: false,\n      knownTransactions: this.knownTransactions,\n    });\n\n    if (newValidTransactions.length === 0) {\n      return;\n    }\n\n    for (const { txID, madeAt, changes } of newValidTransactions) {\n      this.totalValidTransactions++;\n      for (const changeUntyped of changes) {\n        const change = changeUntyped as Item;\n        let entries = this.items[txID.sessionID];\n        if (!entries) {\n          entries = [];\n          this.items[txID.sessionID] = entries;\n        }\n        entries.push({ value: change, madeAt, tx: txID });\n        changeEntries.add(entries);\n      }\n      this.knownTransactions[txID.sessionID] = Math.max(\n        this.knownTransactions[txID.sessionID] ?? 0,\n        txID.txIndex,\n      );\n    }\n\n    for (const entries of changeEntries) {\n      entries.sort(this.compareStreamItems);\n    }\n  }\n\n  getSingleStream(): Item[] | undefined {\n    const streams = Object.values(this.items);\n    const firstStream = streams[0];\n\n    if (!firstStream) {\n      return undefined;\n    }\n\n    if (streams.length > 1) {\n      throw new Error(\n        \"CoStream.getSingleStream() can only be called when there is exactly one stream\",\n      );\n    }\n\n    return firstStream.map((item) => item.value);\n  }\n\n  sessions(): SessionID[] {\n    return Object.keys(this.items) as SessionID[];\n  }\n\n  accounts(): Set<RawAccountID> {\n    return new Set(\n      this.sessions().map(accountOrAgentIDfromSessionID).filter(isAccountID),\n    );\n  }\n\n  nthItemIn(\n    sessionID: SessionID,\n    n: number,\n  ):\n    | {\n        by: RawAccountID | AgentID;\n        tx: TransactionID;\n        at: Date;\n        value: Item;\n      }\n    | undefined {\n    const items = this.items[sessionID];\n    if (!items) return;\n\n    const item = items[n];\n    if (!item) return;\n\n    return {\n      by: accountOrAgentIDfromSessionID(sessionID),\n      tx: item.tx,\n      at: new Date(item.madeAt),\n      value: item.value,\n    };\n  }\n\n  lastItemIn(sessionID: SessionID):\n    | {\n        by: RawAccountID | AgentID;\n        tx: TransactionID;\n        at: Date;\n        value: Item;\n      }\n    | undefined {\n    const items = this.items[sessionID];\n    if (!items) return;\n    return this.nthItemIn(sessionID, items.length - 1);\n  }\n\n  *itemsIn(sessionID: SessionID) {\n    const items = this.items[sessionID];\n    if (!items) return;\n    for (const item of items) {\n      yield {\n        by: accountOrAgentIDfromSessionID(sessionID),\n        tx: item.tx,\n        at: new Date(item.madeAt),\n        value: item.value as Item,\n      };\n    }\n  }\n\n  lastItemBy(account: RawAccountID | AgentID):\n    | {\n        by: RawAccountID | AgentID;\n        tx: TransactionID;\n        at: Date;\n        value: Item;\n      }\n    | undefined {\n    let latestItem:\n      | {\n          by: RawAccountID | AgentID;\n          tx: TransactionID;\n          at: Date;\n          value: Item;\n        }\n      | undefined;\n\n    for (const sessionID of Object.keys(this.items)) {\n      if (sessionID.startsWith(account)) {\n        const item = this.lastItemIn(sessionID as SessionID);\n        if (!item) continue;\n        if (!latestItem || item.at > latestItem.at) {\n          latestItem = {\n            by: item.by,\n            tx: item.tx,\n            at: item.at,\n            value: item.value,\n          };\n        }\n      }\n    }\n\n    return latestItem;\n  }\n\n  *itemsBy(account: RawAccountID | AgentID) {\n    // TODO: this can be made more lazy without a huge collect and sort\n    const items = [\n      ...Object.keys(this.items).flatMap((sessionID) =>\n        sessionID.startsWith(account)\n          ? [...this.itemsIn(sessionID as SessionID)].map((item) => ({\n              in: sessionID as SessionID,\n              ...item,\n            }))\n          : [],\n      ),\n    ];\n\n    items.sort((a, b) => a.at.getTime() - b.at.getTime());\n\n    for (const item of items) {\n      yield item;\n    }\n  }\n\n  toJSON(): {\n    [key: SessionID]: Item[];\n  } {\n    return Object.fromEntries(\n      Object.entries(this.items).map(([sessionID, items]) => [\n        sessionID,\n        items.map((item) => item.value),\n      ]),\n    );\n  }\n\n  subscribe(listener: (coStream: this) => void): () => void {\n    return this.core.subscribe((content) => {\n      listener(content as this);\n    });\n  }\n}\n\nexport class RawCoStream<\n    Item extends JsonValue = JsonValue,\n    Meta extends JsonObject | null = JsonObject | null,\n  >\n  extends RawCoStreamView<Item, Meta>\n  implements RawCoValue\n{\n  push(item: Item, privacy: \"private\" | \"trusting\" = \"private\"): void {\n    this.core.makeTransaction([isCoValue(item) ? item.id : item], privacy);\n    this.processNewTransactions();\n  }\n}\n\nconst binary_U_prefixLength = 8; // \"binary_U\".length;\n\nexport class RawBinaryCoStreamView<\n    Meta extends BinaryCoStreamMeta = { type: \"binary\" },\n  >\n  extends RawCoStreamView<BinaryStreamItem, Meta>\n  implements RawCoValue\n{\n  isBinaryStreamEnded() {\n    const items = this.getSingleStream();\n\n    if (!items || items.length === 0) {\n      return false;\n    }\n\n    const lastItem = items[items.length - 1];\n\n    return lastItem?.type === \"end\";\n  }\n\n  getBinaryChunks(\n    allowUnfinished?: boolean,\n  ):\n    | (BinaryStreamInfo & { chunks: Uint8Array[]; finished: boolean })\n    | undefined {\n    const items = this.getSingleStream();\n\n    // No active streams\n    if (!items) return;\n\n    const start = items[0];\n\n    if (start?.type !== \"start\") {\n      logger.error(\"Invalid binary stream start\", start);\n      return;\n    }\n\n    const end = items[items.length - 1];\n\n    if (end?.type !== \"end\" && !allowUnfinished) return;\n\n    const chunks: Uint8Array[] = [];\n\n    let finished = false;\n\n    for (const item of items.slice(1)) {\n      if (item.type === \"end\") {\n        finished = true;\n        break;\n      }\n\n      if (item.type !== \"chunk\") {\n        logger.error(\"Invalid binary stream chunk\", item);\n        return undefined;\n      }\n\n      const chunk = base64URLtoBytes(item.chunk.slice(binary_U_prefixLength));\n      chunks.push(chunk);\n    }\n\n    return {\n      mimeType: start.mimeType,\n      fileName: start.fileName,\n      totalSizeBytes: start.totalSizeBytes,\n      chunks,\n      finished,\n    };\n  }\n}\n\nexport class RawBinaryCoStream<\n    Meta extends BinaryCoStreamMeta = { type: \"binary\" },\n  >\n  extends RawBinaryCoStreamView<Meta>\n  implements RawCoValue\n{\n  /** @internal */\n  push(\n    item: BinaryStreamItem,\n    privacy: \"private\" | \"trusting\" = \"private\",\n    updateView: boolean = true,\n  ): void {\n    this.core.makeTransaction([item], privacy);\n    if (updateView) {\n      this.processNewTransactions();\n    }\n  }\n\n  startBinaryStream(\n    settings: BinaryStreamInfo,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ): void {\n    this.push(\n      {\n        type: \"start\",\n        ...settings,\n      } satisfies BinaryStreamStart,\n      privacy,\n      false,\n    );\n  }\n\n  pushBinaryStreamChunk(\n    chunk: Uint8Array,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ): void {\n    this.push(\n      {\n        type: \"chunk\",\n        chunk: `binary_U${bytesToBase64url(chunk)}`,\n      } satisfies BinaryStreamChunk,\n      privacy,\n      false,\n    );\n  }\n\n  endBinaryStream(privacy: \"private\" | \"trusting\" = \"private\") {\n    this.push(\n      {\n        type: \"end\",\n      } satisfies BinaryStreamEnd,\n      privacy,\n      true,\n    );\n  }\n}\n", "import { type RawCoValue } from \"../coValue.js\";\nimport { RawCoList } from \"../coValues/coList.js\";\nimport { RawCoMap } from \"../coValues/coMap.js\";\nimport { RawCoStream } from \"../coValues/coStream.js\";\nimport { RawBinaryCoStream } from \"../coValues/coStream.js\";\nimport type { JsonValue } from \"../jsonValue.js\";\n\nexport function isCoValue(\n  value: JsonValue | RawCoValue | undefined,\n): value is RawCoValue {\n  return (\n    value instanceof RawCoMap ||\n    value instanceof RawCoList ||\n    value instanceof RawCoStream ||\n    value instanceof RawBinaryCoStream\n  );\n}\n", "import { CoID, RawCoValue } from \"../coValue.js\";\nimport { CoValueCore } from \"../coValueCore.js\";\nimport { AgentID, TransactionID } from \"../ids.js\";\nimport { JsonObject, JsonValue } from \"../jsonValue.js\";\nimport { CoValueKnownState } from \"../sync.js\";\nimport { accountOrAgentIDfromSessionID } from \"../typeUtils/accountOrAgentIDfromSessionID.js\";\nimport { isCoValue } from \"../typeUtils/isCoValue.js\";\nimport { RawAccountID } from \"./account.js\";\nimport type { RawGroup } from \"./group.js\";\n\ntype MapOp<K extends string, V extends JsonValue | undefined> = {\n  txID: TransactionID;\n  madeAt: number;\n  changeIdx: number;\n  change: MapOpPayload<K, V>;\n};\n// TODO: add after TransactionID[] for conflicts/ordering\n\nexport type MapOpPayload<K extends string, V extends JsonValue | undefined> =\n  | {\n      op: \"set\";\n      key: K;\n      value: V;\n    }\n  | {\n      op: \"del\";\n      key: K;\n    };\n\nexport class RawCoMapView<\n  Shape extends { [key: string]: JsonValue | undefined } = {\n    [key: string]: JsonValue | undefined;\n  },\n  Meta extends JsonObject | null = JsonObject | null,\n> implements RawCoValue\n{\n  /** @category 6. Meta */\n  id: CoID<this>;\n  /** @category 6. Meta */\n  type = \"comap\" as const;\n  /** @category 6. Meta */\n  core: CoValueCore;\n  /** @internal */\n  latest: {\n    [Key in keyof Shape & string]?: MapOp<Key, Shape[Key]>;\n  };\n  /** @internal */\n  latestTxMadeAt: number;\n  /** @internal */\n  ops: {\n    [Key in keyof Shape & string]?: MapOp<Key, Shape[Key]>[];\n  };\n  /** @internal */\n  knownTransactions: CoValueKnownState[\"sessions\"];\n\n  /** @internal */\n  ignorePrivateTransactions: boolean;\n  /** @internal */\n  atTimeFilter?: number = undefined;\n  /** @category 6. Meta */\n  readonly _shape!: Shape;\n\n  totalValidTransactions = 0;\n\n  /** @internal */\n  constructor(\n    core: CoValueCore,\n    options?: {\n      ignorePrivateTransactions: boolean;\n    },\n  ) {\n    this.id = core.id as CoID<this>;\n    this.core = core;\n    this.latestTxMadeAt = 0;\n    this.ignorePrivateTransactions =\n      options?.ignorePrivateTransactions ?? false;\n    this.ops = {};\n    this.latest = {};\n    this.knownTransactions = {};\n\n    this.processNewTransactions();\n  }\n\n  processNewTransactions() {\n    if (this.isTimeTravelEntity()) {\n      throw new Error(\"Cannot process transactions on a time travel entity\");\n    }\n\n    const newValidTransactions = this.core.getValidTransactions({\n      ignorePrivateTransactions: this.ignorePrivateTransactions,\n      knownTransactions: this.knownTransactions,\n    });\n\n    if (newValidTransactions.length === 0) {\n      return;\n    }\n\n    const { ops } = this;\n\n    const changedEntries = new Map<\n      keyof typeof ops,\n      NonNullable<(typeof ops)[keyof typeof ops]>\n    >();\n\n    for (const { txID, changes, madeAt } of newValidTransactions) {\n      for (let changeIdx = 0; changeIdx < changes.length; changeIdx++) {\n        const change = changes[changeIdx] as MapOpPayload<\n          keyof Shape & string,\n          Shape[keyof Shape & string]\n        >;\n        const entry = {\n          txID,\n          madeAt,\n          changeIdx,\n          change,\n        };\n\n        if (madeAt > this.latestTxMadeAt) {\n          this.latestTxMadeAt = madeAt;\n        }\n\n        const entries = ops[change.key];\n        if (!entries) {\n          const entries = [entry];\n          ops[change.key] = entries;\n          changedEntries.set(change.key, entries);\n        } else {\n          entries.push(entry);\n          changedEntries.set(change.key, entries);\n        }\n        this.knownTransactions[txID.sessionID] = Math.max(\n          this.knownTransactions[txID.sessionID] ?? 0,\n          txID.txIndex,\n        );\n      }\n    }\n\n    this.totalValidTransactions += newValidTransactions.length;\n\n    for (const entries of changedEntries.values()) {\n      entries.sort(this.core.compareTransactions);\n    }\n\n    for (const [key, entries] of changedEntries.entries()) {\n      this.latest[key] = entries[entries.length - 1];\n    }\n  }\n\n  isTimeTravelEntity() {\n    return Boolean(this.atTimeFilter);\n  }\n\n  /** @category 6. Meta */\n  get headerMeta(): Meta {\n    return this.core.header.meta as Meta;\n  }\n\n  /** @category 6. Meta */\n  get group(): RawGroup {\n    return this.core.getGroup();\n  }\n\n  /** @category 4. Time travel */\n  atTime(time: number): this {\n    if (time >= this.latestTxMadeAt) {\n      return this;\n    } else {\n      const clone = Object.create(this) as RawCoMapView<Shape, Meta>;\n\n      clone.atTimeFilter = time;\n      clone.latest = {};\n\n      return clone as this;\n    }\n  }\n\n  /** @internal */\n  timeFilteredOps<K extends keyof Shape & string>(\n    key: K,\n  ): MapOp<K, Shape[K]>[] | undefined {\n    if (key === \"constructor\") {\n      return undefined;\n    }\n\n    const atTimeFilter = this.atTimeFilter;\n\n    if (atTimeFilter) {\n      return this.ops[key]?.filter((op) => op.madeAt <= atTimeFilter);\n    } else {\n      return this.ops[key];\n    }\n  }\n\n  /**\n   * Get all keys currently in the map.\n   *\n   * @category 1. Reading */\n  keys<K extends keyof Shape & string = keyof Shape & string>(): K[] {\n    return (Object.keys(this.ops) as K[]).filter((key) => {\n      const entry = this.getRaw(key);\n\n      if (entry === undefined) {\n        return false;\n      }\n\n      if (entry.change.op === \"del\") {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  getRaw<K extends keyof Shape & string>(key: K) {\n    let latestChange = this.latest[key];\n\n    if (latestChange === undefined) {\n      const entries = this.ops[key];\n\n      // Time travel values are lazily computed\n      if (entries && !(key in this.latest)) {\n        const atTimeFilter = this.atTimeFilter;\n\n        if (!atTimeFilter) {\n          latestChange = entries[entries.length - 1];\n        } else {\n          latestChange = entries.findLast((op) => op.madeAt <= atTimeFilter);\n        }\n\n        this.latest[key] = latestChange;\n      }\n\n      if (latestChange === undefined) {\n        return undefined;\n      }\n    }\n\n    return latestChange;\n  }\n\n  /**\n   * Returns the current value for the given key.\n   *\n   * @category 1. Reading\n   **/\n  get<K extends keyof Shape & string>(key: K): Shape[K] | undefined {\n    const entry = this.getRaw(key);\n\n    if (entry?.change === undefined) {\n      return undefined;\n    }\n\n    if (entry.change.op === \"del\") {\n      return undefined;\n    } else {\n      return entry.change.value as Shape[K];\n    }\n  }\n\n  /** @category 1. Reading */\n  asObject(): {\n    [K in keyof Shape & string]: Shape[K];\n  } {\n    const object: Partial<{\n      [K in keyof Shape & string]: Shape[K];\n    }> = {};\n\n    for (const key of Object.keys(this.ops) as (keyof Shape & string)[]) {\n      const value = this.get(key);\n      if (value !== undefined) {\n        object[key] = value;\n      }\n    }\n\n    return object as {\n      [K in keyof Shape & string]: Shape[K];\n    };\n  }\n\n  /** @category 1. Reading */\n  toJSON(): {\n    [K in keyof Shape & string]: Shape[K];\n  } {\n    return this.asObject();\n  }\n\n  /** @category 5. Edit history */\n  nthEditAt<K extends keyof Shape & string>(key: K, n: number) {\n    const ops = this.ops[key];\n\n    const atTimeFilter = this.atTimeFilter;\n    const entry = ops?.[n];\n\n    if (!entry) {\n      return undefined;\n    }\n\n    if (atTimeFilter && entry.madeAt > atTimeFilter) {\n      return undefined;\n    }\n\n    return operationToEditEntry(entry);\n  }\n\n  /** @category 5. Edit history */\n  lastEditAt<K extends keyof Shape & string>(\n    key: K,\n  ):\n    | {\n        by: RawAccountID | AgentID;\n        tx: TransactionID;\n        at: Date;\n        value?: Shape[K];\n      }\n    | undefined {\n    const entry = this.getRaw(key);\n\n    if (!entry) {\n      return undefined;\n    }\n\n    return operationToEditEntry(entry);\n  }\n\n  /** @category 5. Edit history */\n  *editsAt<K extends keyof Shape & string>(key: K) {\n    const entries = this.ops[key];\n\n    if (!entries) {\n      return;\n    }\n\n    const atTimeFilter = this.atTimeFilter;\n\n    for (const entry of entries) {\n      // Entries are sorted by madeAt\n      if (atTimeFilter && entry.madeAt > atTimeFilter) {\n        return;\n      }\n\n      yield operationToEditEntry(entry);\n    }\n  }\n\n  /** @category 3. Subscription */\n  subscribe(listener: (coMap: this) => void): () => void {\n    return this.core.subscribe((content) => {\n      listener(content as this);\n    });\n  }\n}\n\n/** A collaborative map with precise shape `Shape` and optional static metadata `Meta` */\nexport class RawCoMap<\n    Shape extends { [key: string]: JsonValue | undefined } = {\n      [key: string]: JsonValue | undefined;\n    },\n    Meta extends JsonObject | null = JsonObject | null,\n  >\n  extends RawCoMapView<Shape, Meta>\n  implements RawCoValue\n{\n  /** Set a new value for the given key.\n   *\n   * If `privacy` is `\"private\"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.\n   *\n   * If `privacy` is `\"trusting\"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.\n   *\n   * @category 2. Editing\n   **/\n  set<K extends keyof Shape & string>(\n    key: K,\n    value: Shape[K],\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ): void {\n    if (this.isTimeTravelEntity()) {\n      throw new Error(\"Cannot set value on a time travel entity\");\n    }\n\n    this.core.makeTransaction(\n      [\n        {\n          op: \"set\",\n          key,\n          value: isCoValue(value) ? value.id : value,\n        },\n      ],\n      privacy,\n    );\n\n    this.processNewTransactions();\n  }\n\n  assign(\n    entries: Partial<Shape>,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ): void {\n    if (this.isTimeTravelEntity()) {\n      throw new Error(\"Cannot set value on a time travel entity\");\n    }\n\n    this.core.makeTransaction(\n      Object.entries(entries).map(([key, value]) => ({\n        op: \"set\",\n        key,\n        value: isCoValue(value) ? value.id : value,\n      })),\n      privacy,\n    );\n\n    this.processNewTransactions();\n  }\n\n  /** Delete the given key (setting it to undefined).\n   *\n   * If `privacy` is `\"private\"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.\n   *\n   * If `privacy` is `\"trusting\"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.\n   *\n   * @category 2. Editing\n   **/\n  delete(\n    key: keyof Shape & string,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ) {\n    if (this.isTimeTravelEntity()) {\n      throw new Error(\"Cannot delete value on a time travel entity\");\n    }\n\n    this.core.makeTransaction(\n      [\n        {\n          op: \"del\",\n          key,\n        },\n      ],\n      privacy,\n    );\n\n    this.processNewTransactions();\n  }\n}\n\nexport function operationToEditEntry<\n  K extends string,\n  V extends JsonValue | undefined,\n>(op: MapOp<K, V>) {\n  return {\n    by: accountOrAgentIDfromSessionID(op.txID.sessionID),\n    tx: op.txID,\n    at: new Date(op.madeAt),\n    value: op.change.op === \"del\" ? undefined : op.change.value,\n  };\n}\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number) {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\nexport const assertNumber = anumber;\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding.\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n/**\n * base64 with padding. For no padding, use `base64nopad`.\n * @example\n * const b = base64.decode('A951'); // Uint8Array.from([ 3, 222, 117 ])\n * base64.encode(b); // 'A951'\n */\nexport const base64: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 without padding.\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\nexport const base64url: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * Base58: base64 without characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * XMR version of base58.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check = createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * Low-level bech32 operations. Operates on words.\n */\nexport const bech32: Bech32 = genBech32('bech32');\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n/**\n * hex string decoder.\n * @example\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n */\nexport const hex: BytesCoder = chain(\n  radix2(4),\n  alphabet('0123456789abcdef'),\n  join(''),\n  normalize((s: string) => {\n    if (typeof s !== 'string' || s.length % 2 !== 0)\n      throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n  })\n);\n\n// prettier-ignore\nconst CODERS = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof typeof CODERS;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\n\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n", "// adapted from fast-json-stable-stringify (https://github.com/epoberezkin/fast-json-stable-stringify)\n\nexport type Stringified<T> = string & { __type: T };\n\nexport function stableStringify<T>(data: T): Stringified<T>;\nexport function stableStringify(data: undefined): undefined;\nexport function stableStringify<T>(\n  data: T | undefined,\n): Stringified<T> | undefined {\n  const cycles = false;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const seen: any[] = [];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let node = data as any;\n\n  if (node && node.toJSON && typeof node.toJSON === \"function\") {\n    node = node.toJSON();\n  }\n\n  if (node === undefined) return;\n  if (typeof node == \"number\")\n    return (isFinite(node) ? \"\" + node : \"null\") as Stringified<T>;\n  if (typeof node !== \"object\") {\n    if (\n      typeof node === \"string\" &&\n      (node.startsWith(\"encrypted_U\") || node.startsWith(\"binary_U\"))\n    ) {\n      return `\"${node}\"` as Stringified<T>;\n    }\n    return JSON.stringify(node) as Stringified<T>;\n  }\n\n  let i, out;\n  if (Array.isArray(node)) {\n    out = \"[\";\n    for (i = 0; i < node.length; i++) {\n      if (i) out += \",\";\n      out += stableStringify(node[i]) || \"null\";\n    }\n    return (out + \"]\") as Stringified<T>;\n  }\n\n  if (node === null) return \"null\" as Stringified<T>;\n\n  if (seen.indexOf(node) !== -1) {\n    if (cycles) return JSON.stringify(\"__cycle__\") as Stringified<T>;\n    throw new TypeError(\"Converting circular structure to JSON\");\n  }\n\n  const seenIndex = seen.push(node) - 1;\n  const keys = Object.keys(node).sort();\n  out = \"\";\n  for (i = 0; i < keys.length; i++) {\n    const key = keys[i]!;\n    const value = stableStringify(node[key]);\n\n    if (!value) continue;\n    if (out) out += \",\";\n    out += JSON.stringify(key) + \":\" + value;\n  }\n  seen.splice(seenIndex, 1);\n  return (\"{\" + out + \"}\") as Stringified<T>;\n}\n\nexport function parseJSON<T>(json: Stringified<T>): T {\n  return JSON.parse(json);\n}\n", "import { base58 } from \"@scure/base\";\nimport { RawAccountID } from \"../coValues/account.js\";\nimport { AgentID, RawCoID, TransactionID } from \"../ids.js\";\nimport { SessionID } from \"../ids.js\";\nimport { Stringified, parseJSON, stableStringify } from \"../jsonStringify.js\";\nimport { JsonValue } from \"../jsonValue.js\";\nimport { logger } from \"../logger.js\";\n\nfunction randomBytes(bytesLength = 32): Uint8Array {\n  return crypto.getRandomValues(new Uint8Array(bytesLength));\n}\n\nexport type SignerSecret = `signerSecret_z${string}`;\nexport type SignerID = `signer_z${string}`;\nexport type Signature = `signature_z${string}`;\n\nexport type SealerSecret = `sealerSecret_z${string}`;\nexport type SealerID = `sealer_z${string}`;\nexport type Sealed<T> = `sealed_U${string}` & { __type: T };\n\nexport type AgentSecret = `${SealerSecret}/${SignerSecret}`;\n\nexport const textEncoder = new TextEncoder();\nexport const textDecoder = new TextDecoder();\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport abstract class CryptoProvider<Blake3State = any> {\n  randomBytes(length: number): Uint8Array {\n    return randomBytes(length);\n  }\n\n  abstract newEd25519SigningKey(): Uint8Array;\n\n  newRandomSigner(): SignerSecret {\n    return `signerSecret_z${base58.encode(this.newEd25519SigningKey())}`;\n  }\n\n  signerSecretToBytes(secret: SignerSecret): Uint8Array {\n    return base58.decode(secret.substring(\"signerSecret_z\".length));\n  }\n\n  signerSecretFromBytes(bytes: Uint8Array): SignerSecret {\n    return `signerSecret_z${base58.encode(bytes)}`;\n  }\n\n  abstract getSignerID(secret: SignerSecret): SignerID;\n\n  abstract sign(secret: SignerSecret, message: JsonValue): Signature;\n\n  abstract verify(\n    signature: Signature,\n    message: JsonValue,\n    id: SignerID,\n  ): boolean;\n\n  abstract newX25519StaticSecret(): Uint8Array;\n\n  newRandomSealer(): SealerSecret {\n    return `sealerSecret_z${base58.encode(this.newX25519StaticSecret())}`;\n  }\n\n  sealerSecretToBytes(secret: SealerSecret): Uint8Array {\n    return base58.decode(secret.substring(\"sealerSecret_z\".length));\n  }\n\n  sealerSecretFromBytes(bytes: Uint8Array): SealerSecret {\n    return `sealerSecret_z${base58.encode(bytes)}`;\n  }\n\n  abstract getSealerID(secret: SealerSecret): SealerID;\n\n  newRandomAgentSecret(): AgentSecret {\n    return `${this.newRandomSealer()}/${this.newRandomSigner()}`;\n  }\n\n  agentSecretToBytes(secret: AgentSecret): Uint8Array {\n    const [sealerSecret, signerSecret] = secret.split(\"/\");\n    return new Uint8Array([\n      ...this.sealerSecretToBytes(sealerSecret as SealerSecret),\n      ...this.signerSecretToBytes(signerSecret as SignerSecret),\n    ]);\n  }\n\n  agentSecretFromBytes(bytes: Uint8Array): AgentSecret {\n    const sealerSecret = this.sealerSecretFromBytes(bytes.slice(0, 32));\n    const signerSecret = this.signerSecretFromBytes(bytes.slice(32));\n    return `${sealerSecret}/${signerSecret}`;\n  }\n\n  getAgentID(secret: AgentSecret): AgentID {\n    const [sealerSecret, signerSecret] = secret.split(\"/\");\n    return `${this.getSealerID(\n      sealerSecret as SealerSecret,\n    )}/${this.getSignerID(signerSecret as SignerSecret)}`;\n  }\n\n  getAgentSignerID(agentId: AgentID): SignerID {\n    return agentId.split(\"/\")[1] as SignerID;\n  }\n\n  getAgentSignerSecret(agentSecret: AgentSecret): SignerSecret {\n    return agentSecret.split(\"/\")[1] as SignerSecret;\n  }\n\n  getAgentSealerID(agentId: AgentID): SealerID {\n    return agentId.split(\"/\")[0] as SealerID;\n  }\n\n  getAgentSealerSecret(agentSecret: AgentSecret): SealerSecret {\n    return agentSecret.split(\"/\")[0] as SealerSecret;\n  }\n\n  abstract emptyBlake3State(): Blake3State;\n  abstract cloneBlake3State(state: Blake3State): Blake3State;\n  abstract blake3HashOnce(data: Uint8Array): Uint8Array;\n  abstract blake3HashOnceWithContext(\n    data: Uint8Array,\n    { context }: { context: Uint8Array },\n  ): Uint8Array;\n  abstract blake3IncrementalUpdate(\n    state: Blake3State,\n    data: Uint8Array,\n  ): Blake3State;\n  abstract blake3DigestForState(state: Blake3State): Uint8Array;\n\n  secureHash(value: JsonValue): Hash {\n    return `hash_z${base58.encode(\n      this.blake3HashOnce(textEncoder.encode(stableStringify(value))),\n    )}`;\n  }\n\n  shortHash(value: JsonValue): ShortHash {\n    return `shortHash_z${base58.encode(\n      this.blake3HashOnce(textEncoder.encode(stableStringify(value))).slice(\n        0,\n        shortHashLength,\n      ),\n    )}`;\n  }\n\n  abstract encrypt<T extends JsonValue, N extends JsonValue>(\n    value: T,\n    keySecret: KeySecret,\n    nOnceMaterial: N,\n  ): Encrypted<T, N>;\n\n  encryptForTransaction<T extends JsonValue>(\n    value: T,\n    keySecret: KeySecret,\n    nOnceMaterial: { in: RawCoID; tx: TransactionID },\n  ): Encrypted<T, { in: RawCoID; tx: TransactionID }> {\n    return this.encrypt(value, keySecret, nOnceMaterial);\n  }\n\n  abstract decryptRaw<T extends JsonValue, N extends JsonValue>(\n    encrypted: Encrypted<T, N>,\n    keySecret: KeySecret,\n    nOnceMaterial: N,\n  ): Stringified<T>;\n\n  decrypt<T extends JsonValue, N extends JsonValue>(\n    encrypted: Encrypted<T, N>,\n    keySecret: KeySecret,\n    nOnceMaterial: N,\n  ): T | undefined {\n    try {\n      return parseJSON(this.decryptRaw(encrypted, keySecret, nOnceMaterial));\n    } catch (e) {\n      logger.error(\"Decryption error\", { err: e });\n      return undefined;\n    }\n  }\n\n  newRandomKeySecret(): { secret: KeySecret; id: KeyID } {\n    return {\n      secret: `keySecret_z${base58.encode(this.randomBytes(32))}`,\n      id: `key_z${base58.encode(this.randomBytes(12))}`,\n    };\n  }\n\n  decryptRawForTransaction<T extends JsonValue>(\n    encrypted: Encrypted<T, { in: RawCoID; tx: TransactionID }>,\n    keySecret: KeySecret,\n    nOnceMaterial: { in: RawCoID; tx: TransactionID },\n  ): Stringified<T> | undefined {\n    return this.decryptRaw(encrypted, keySecret, nOnceMaterial);\n  }\n\n  decryptForTransaction<T extends JsonValue>(\n    encrypted: Encrypted<T, { in: RawCoID; tx: TransactionID }>,\n    keySecret: KeySecret,\n    nOnceMaterial: { in: RawCoID; tx: TransactionID },\n  ): T | undefined {\n    return this.decrypt(encrypted, keySecret, nOnceMaterial);\n  }\n\n  encryptKeySecret(keys: {\n    toEncrypt: { id: KeyID; secret: KeySecret };\n    encrypting: { id: KeyID; secret: KeySecret };\n  }): {\n    encryptedID: KeyID;\n    encryptingID: KeyID;\n    encrypted: Encrypted<\n      KeySecret,\n      { encryptedID: KeyID; encryptingID: KeyID }\n    >;\n  } {\n    const nOnceMaterial = {\n      encryptedID: keys.toEncrypt.id,\n      encryptingID: keys.encrypting.id,\n    };\n\n    return {\n      encryptedID: keys.toEncrypt.id,\n      encryptingID: keys.encrypting.id,\n      encrypted: this.encrypt(\n        keys.toEncrypt.secret,\n        keys.encrypting.secret,\n        nOnceMaterial,\n      ),\n    };\n  }\n\n  decryptKeySecret(\n    encryptedInfo: {\n      encryptedID: KeyID;\n      encryptingID: KeyID;\n      encrypted: Encrypted<\n        KeySecret,\n        { encryptedID: KeyID; encryptingID: KeyID }\n      >;\n    },\n    sealingSecret: KeySecret,\n  ): KeySecret | undefined {\n    const nOnceMaterial = {\n      encryptedID: encryptedInfo.encryptedID,\n      encryptingID: encryptedInfo.encryptingID,\n    };\n\n    return this.decrypt(encryptedInfo.encrypted, sealingSecret, nOnceMaterial);\n  }\n\n  abstract seal<T extends JsonValue>({\n    message,\n    from,\n    to,\n    nOnceMaterial,\n  }: {\n    message: T;\n    from: SealerSecret;\n    to: SealerID;\n    nOnceMaterial: { in: RawCoID; tx: TransactionID };\n  }): Sealed<T>;\n\n  abstract unseal<T extends JsonValue>(\n    sealed: Sealed<T>,\n    sealer: SealerSecret,\n    from: SealerID,\n    nOnceMaterial: { in: RawCoID; tx: TransactionID },\n  ): T | undefined;\n\n  uniquenessForHeader(): `z${string}` {\n    return `z${base58.encode(this.randomBytes(12))}`;\n  }\n\n  createdNowUnique(): {\n    createdAt: `2${string}`;\n    uniqueness: `z${string}`;\n  } {\n    const createdAt = new Date().toISOString() as `2${string}`;\n    return {\n      createdAt,\n      uniqueness: this.uniquenessForHeader(),\n    };\n  }\n\n  newRandomSecretSeed(): Uint8Array {\n    return this.randomBytes(secretSeedLength);\n  }\n\n  agentSecretFromSecretSeed(secretSeed: Uint8Array): AgentSecret {\n    if (secretSeed.length !== secretSeedLength) {\n      throw new Error(`Secret seed needs to be ${secretSeedLength} bytes long`);\n    }\n\n    return `sealerSecret_z${base58.encode(\n      this.blake3HashOnceWithContext(secretSeed, {\n        context: textEncoder.encode(\"seal\"),\n      }),\n    )}/signerSecret_z${base58.encode(\n      this.blake3HashOnceWithContext(secretSeed, {\n        context: textEncoder.encode(\"sign\"),\n      }),\n    )}`;\n  }\n\n  newRandomSessionID(accountID: RawAccountID | AgentID): SessionID {\n    return `${accountID}_session_z${base58.encode(this.randomBytes(8))}`;\n  }\n}\n\nexport type Hash = `hash_z${string}`;\n\nexport class StreamingHash {\n  state: Uint8Array;\n  crypto: CryptoProvider;\n\n  constructor(crypto: CryptoProvider, fromClone?: Uint8Array) {\n    this.state = fromClone || crypto.emptyBlake3State();\n    this.crypto = crypto;\n  }\n\n  update(value: JsonValue): Uint8Array {\n    const encoded = textEncoder.encode(stableStringify(value));\n    this.state = this.crypto.blake3IncrementalUpdate(this.state, encoded);\n    return encoded;\n  }\n\n  digest(): Hash {\n    const hash = this.crypto.blake3DigestForState(this.state);\n    return `hash_z${base58.encode(hash)}`;\n  }\n\n  clone(): StreamingHash {\n    return new StreamingHash(\n      this.crypto,\n      this.crypto.cloneBlake3State(this.state),\n    );\n  }\n}\n\nexport type ShortHash = `shortHash_z${string}`;\nexport const shortHashLength = 19;\n\nexport type Encrypted<\n  T extends JsonValue,\n  N extends JsonValue,\n> = `encrypted_U${string}` & { __type: T; __nOnceMaterial: N };\n\nexport type KeySecret = `keySecret_z${string}`;\nexport type KeyID = `key_z${string}`;\n\nexport const secretSeedLength = 32;\n", "import { base58 } from \"@scure/base\";\nimport { CoID } from \"./coValue.js\";\nimport { RawAccountID } from \"./coValues/account.js\";\nimport { shortHashLength } from \"./crypto/crypto.js\";\nimport { RawGroup } from \"./exports.js\";\n\nexport type RawCoID = `co_z${string}`;\nexport type ParentGroupReference = `parent_${CoID<RawGroup>}`;\nexport type ChildGroupReference = `child_${CoID<RawGroup>}`;\n\nexport function isRawCoID(id: unknown): id is RawCoID {\n  return typeof id === \"string\" && id.startsWith(\"co_z\");\n}\n\nexport function rawCoIDtoBytes(id: RawCoID): Uint8Array {\n  return base58.decode(id.substring(\"co_z\".length));\n}\n\nexport function rawCoIDfromBytes(bytes: Uint8Array): RawCoID {\n  return `co_z${base58.encode(bytes.slice(0, shortHashLength))}` as RawCoID;\n}\n\nexport type TransactionID = { sessionID: SessionID; txIndex: number };\n\nexport type AgentID = `sealer_z${string}/signer_z${string}`;\n\nexport function isAgentID(id: string): id is AgentID {\n  return (\n    typeof id === \"string\" &&\n    id.startsWith(\"sealer_\") &&\n    id.includes(\"/signer_\")\n  );\n}\n\nexport type SessionID = `${RawAccountID | AgentID}_session_z${string}`;\n\nexport function isParentGroupReference(\n  key: string,\n): key is ParentGroupReference {\n  return key.startsWith(\"parent_\");\n}\n\nexport function getParentGroupId(key: ParentGroupReference): CoID<RawGroup> {\n  return key.slice(\"parent_\".length) as CoID<RawGroup>;\n}\n\nexport function isChildGroupReference(key: string): key is ChildGroupReference {\n  return key.startsWith(\"child_\");\n}\n\nexport function getChildGroupId(key: ChildGroupReference): CoID<RawGroup> {\n  return key.slice(\"child_\".length) as CoID<RawGroup>;\n}\n\nexport function getGroupDependentKey(key: unknown) {\n  if (typeof key !== \"string\") return undefined;\n\n  if (isParentGroupReference(key)) {\n    return getParentGroupId(key);\n  } else if (key.startsWith(\"co_\")) {\n    return key as RawCoID;\n  }\n\n  return undefined;\n}\n\nexport function getGroupDependentKeyList(keys: unknown[]) {\n  const groupDependentKeys: RawCoID[] = [];\n\n  for (const key of keys) {\n    const value = getGroupDependentKey(key);\n\n    if (value) {\n      groupDependentKeys.push(value);\n    }\n  }\n\n  return groupDependentKeys;\n}\n", "import { type RawCoValue, expectMap } from \"../coValue.js\";\nimport { RawGroup } from \"../coValues/group.js\";\n\nexport function expectGroup(content: RawCoValue): RawGroup {\n  const map = expectMap(content);\n  if (map.core.header.ruleset.type !== \"group\") {\n    throw new Error(\"Expected group ruleset in group\");\n  }\n\n  if (!(map instanceof RawGroup)) {\n    throw new Error(\"Expected group\");\n  }\n\n  return map;\n}\n", "import { base58 } from \"@scure/base\";\nimport { CoID } from \"../coValue.js\";\nimport { CoValueUniqueness } from \"../coValueCore.js\";\nimport { Encrypted, KeyID, KeySecret, Sealed } from \"../crypto/crypto.js\";\nimport {\n  AgentID,\n  ChildGroupReference,\n  ParentGroupReference,\n  getChildGroupId,\n  getParentGroupId,\n  isAgentID,\n  isChildGroupReference,\n  isParentGroupReference,\n} from \"../ids.js\";\nimport { JsonObject } from \"../jsonValue.js\";\nimport { logger } from \"../logger.js\";\nimport { AccountRole, Role } from \"../permissions.js\";\nimport { expectGroup } from \"../typeUtils/expectGroup.js\";\nimport {\n  ControlledAccountOrAgent,\n  RawAccount,\n  RawAccountID,\n} from \"./account.js\";\nimport { RawCoList } from \"./coList.js\";\nimport { RawCoMap } from \"./coMap.js\";\nimport { RawCoPlainText } from \"./coPlainText.js\";\nimport { RawBinaryCoStream, RawCoStream } from \"./coStream.js\";\n\nexport const EVERYONE = \"everyone\" as const;\nexport type Everyone = \"everyone\";\n\nexport type ParentGroupReferenceRole =\n  | \"revoked\"\n  | \"extend\"\n  | \"reader\"\n  | \"writer\"\n  | \"admin\";\n\nexport type GroupShape = {\n  profile: CoID<RawCoMap> | null;\n  root: CoID<RawCoMap> | null;\n  [key: RawAccountID | AgentID]: Role;\n  [EVERYONE]?: Role;\n  readKey?: KeyID;\n  [writeKeyFor: `writeKeyFor_${RawAccountID | AgentID}`]: KeyID;\n  [revelationFor: `${KeyID}_for_${RawAccountID | AgentID}`]: Sealed<KeySecret>;\n  [revelationFor: `${KeyID}_for_${Everyone}`]: KeySecret;\n  [oldKeyForNewKey: `${KeyID}_for_${KeyID}`]: Encrypted<\n    KeySecret,\n    { encryptedID: KeyID; encryptingID: KeyID }\n  >;\n  [parent: ParentGroupReference]: ParentGroupReferenceRole;\n  [child: ChildGroupReference]: \"revoked\" | \"extend\";\n};\n\n/** A `Group` is a scope for permissions of its members (`\"reader\" | \"writer\" | \"admin\"`), applying to objects owned by that group.\n *\n *  A `Group` object exposes methods for permission management and allows you to create new CoValues owned by that group.\n *\n *  (Internally, a `Group` is also just a `CoMap`, mapping member accounts to roles and containing some\n *  state management for making cryptographic keys available to current members)\n *\n *  @example\n *  You typically get a group from a CoValue that you already have loaded:\n *\n *  ```typescript\n *  const group = coMap.group;\n *  ```\n *\n *  @example\n *  Or, you can create a new group with a `LocalNode`:\n *\n *  ```typescript\n *  const localNode.createGroup();\n *  ```\n * */\nexport class RawGroup<\n  Meta extends JsonObject | null = JsonObject | null,\n> extends RawCoMap<GroupShape, Meta> {\n  /**\n   * Returns the current role of a given account.\n   *\n   * @category 1. Role reading\n   */\n  roleOf(accountID: RawAccountID | typeof EVERYONE): Role | undefined {\n    return this.roleOfInternal(accountID);\n  }\n\n  /**\n   *  This is a performance-critical function, micro-optimizing it is important\n   *\n   *  Avoid to add objects/array allocations in this function\n   */\n  /** @internal */\n  roleOfInternal(\n    accountID: RawAccountID | AgentID | typeof EVERYONE,\n  ): Role | undefined {\n    let roleHere = this.get(accountID);\n\n    if (roleHere === \"revoked\") {\n      roleHere = undefined;\n    }\n\n    let roleInfo: Role | undefined = roleHere;\n\n    for (const key of Object.keys(this.ops)) {\n      if (!isParentGroupReference(key)) continue;\n\n      const group = this.getParentGroupFromKey(key, this.atTimeFilter);\n\n      if (!group) continue;\n\n      const role = this.get(key) ?? \"extend\";\n      const parentRole = group.roleOfInternal(accountID);\n\n      if (!isInheritableRole(parentRole)) {\n        continue;\n      }\n\n      const roleToInherit = role !== \"extend\" ? role : parentRole;\n\n      if (isMorePermissiveAndShouldInherit(roleToInherit, roleInfo)) {\n        roleInfo = roleToInherit;\n      }\n    }\n\n    if (!roleInfo && accountID !== \"everyone\") {\n      const everyoneRole = this.get(\"everyone\");\n\n      if (everyoneRole && everyoneRole !== \"revoked\") return everyoneRole;\n    }\n\n    return roleInfo;\n  }\n\n  getParentGroupFromKey(key: ParentGroupReference, atTime?: number) {\n    if (this.get(key) === \"revoked\") {\n      return null;\n    }\n\n    const parent = this.core.node.expectCoValueLoaded(\n      getParentGroupId(key),\n      \"Expected parent group to be loaded\",\n    );\n\n    const group = expectGroup(parent.getCurrentContent());\n\n    if (atTime) {\n      return group.atTime(atTime);\n    } else {\n      return group;\n    }\n  }\n\n  getParentGroups(atTime?: number) {\n    const groups: RawGroup[] = [];\n\n    for (const key of Object.keys(this.ops)) {\n      if (!isParentGroupReference(key)) continue;\n\n      const group = this.getParentGroupFromKey(key, atTime);\n\n      if (group) {\n        if (atTime) {\n          groups.push(group.atTime(atTime));\n        } else {\n          groups.push(group);\n        }\n      }\n    }\n\n    return groups;\n  }\n\n  loadAllChildGroups() {\n    const requests: Promise<unknown>[] = [];\n    const store = this.core.node.coValuesStore;\n    const peers = this.core.node.syncManager.getServerAndStoragePeers();\n\n    for (const key of this.keys()) {\n      if (!isChildGroupReference(key)) {\n        continue;\n      }\n\n      const id = getChildGroupId(key);\n      const child = store.get(id);\n\n      if (\n        child.highLevelState === \"unknown\" ||\n        child.highLevelState === \"unavailable\"\n      ) {\n        child.loadFromPeers(peers).catch(() => {\n          logger.error(`Failed to load child group ${id}`);\n        });\n      }\n\n      requests.push(\n        child.getCoValue().then((coValue) => {\n          if (coValue === \"unavailable\") {\n            throw new Error(`Child group ${child.id} is unavailable`);\n          }\n\n          // Recursively load child groups\n          return expectGroup(coValue.getCurrentContent()).loadAllChildGroups();\n        }),\n      );\n    }\n\n    return Promise.all(requests);\n  }\n\n  getChildGroups() {\n    const groups: RawGroup[] = [];\n\n    for (const key of this.keys()) {\n      if (isChildGroupReference(key)) {\n        // Check if the child group reference is revoked\n        if (this.get(key) === \"revoked\") {\n          continue;\n        }\n\n        const child = this.core.node.expectCoValueLoaded(\n          getChildGroupId(key),\n          \"Expected child group to be loaded\",\n        );\n        groups.push(expectGroup(child.getCurrentContent()));\n      }\n    }\n\n    return groups;\n  }\n\n  /**\n   * Returns the role of the current account in the group.\n   *\n   * @category 1. Role reading\n   */\n  myRole(): Role | undefined {\n    return this.roleOfInternal(this.core.node.account.id);\n  }\n\n  /**\n   * Directly grants a new member a role in the group. The current account must be an\n   * admin to be able to do so. Throws otherwise.\n   *\n   * @category 2. Role changing\n   */\n  addMember(\n    account: RawAccount | ControlledAccountOrAgent | Everyone,\n    role: Role,\n  ) {\n    this.addMemberInternal(account, role);\n  }\n\n  /** @internal */\n  addMemberInternal(\n    account: RawAccount | ControlledAccountOrAgent | AgentID | Everyone,\n    role: Role,\n  ) {\n    if (account === EVERYONE) {\n      if (!(role === \"reader\" || role === \"writer\" || role === \"writeOnly\")) {\n        throw new Error(\n          \"Can't make everyone something other than reader, writer or writeOnly\",\n        );\n      }\n      const currentReadKey = this.core.getCurrentReadKey();\n\n      if (!currentReadKey.secret) {\n        throw new Error(\"Can't add member without read key secret\");\n      }\n\n      const previousRole = this.get(account);\n\n      this.set(account, role, \"trusting\");\n\n      if (this.get(account) !== role) {\n        throw new Error(\"Failed to set role\");\n      }\n\n      if (role === \"writeOnly\") {\n        if (previousRole === \"reader\" || previousRole === \"writer\") {\n          this.rotateReadKey();\n        }\n\n        this.delete(`${currentReadKey.id}_for_${EVERYONE}`);\n      } else {\n        this.set(\n          `${currentReadKey.id}_for_${EVERYONE}`,\n          currentReadKey.secret,\n          \"trusting\",\n        );\n      }\n\n      return;\n    }\n\n    const memberKey = typeof account === \"string\" ? account : account.id;\n    const agent =\n      typeof account === \"string\" ? account : account.currentAgentID();\n\n    /**\n     * WriteOnly members can only see their own changes.\n     *\n     * We don't want to reveal the readKey to them so we create a new one specifically for them and also reveal it to everyone else with a reader or higher-capability role (but crucially not to other writer-only members)\n     * to everyone else.\n     *\n     * To never reveal the readKey to writeOnly members we also create a dedicated writeKey for the\n     * invite.\n     */\n    if (role === \"writeOnly\" || role === \"writeOnlyInvite\") {\n      const previousRole = this.get(memberKey);\n\n      if (\n        previousRole === \"reader\" ||\n        previousRole === \"writer\" ||\n        previousRole === \"admin\"\n      ) {\n        this.rotateReadKey();\n      }\n\n      this.set(memberKey, role, \"trusting\");\n      this.internalCreateWriteOnlyKeyForMember(memberKey, agent);\n    } else {\n      const currentReadKey = this.core.getCurrentReadKey();\n\n      if (!currentReadKey.secret) {\n        throw new Error(\"Can't add member without read key secret\");\n      }\n\n      this.set(memberKey, role, \"trusting\");\n\n      if (this.get(memberKey) !== role) {\n        throw new Error(\"Failed to set role\");\n      }\n\n      this.storeKeyRevelationForMember(\n        memberKey,\n        agent,\n        currentReadKey.id,\n        currentReadKey.secret,\n      );\n\n      for (const keyID of this.getWriteOnlyKeys()) {\n        const secret = this.core.getReadKey(keyID);\n\n        if (!secret) {\n          logger.error(\"Can't find key \" + keyID);\n          continue;\n        }\n\n        this.storeKeyRevelationForMember(memberKey, agent, keyID, secret);\n      }\n    }\n  }\n\n  internalCreateWriteOnlyKeyForMember(\n    memberKey: RawAccountID | AgentID,\n    agent: AgentID,\n  ) {\n    const writeKeyForNewMember = this.core.crypto.newRandomKeySecret();\n\n    this.set(`writeKeyFor_${memberKey}`, writeKeyForNewMember.id, \"trusting\");\n\n    this.storeKeyRevelationForMember(\n      memberKey,\n      agent,\n      writeKeyForNewMember.id,\n      writeKeyForNewMember.secret,\n    );\n\n    for (const otherMemberKey of this.getMemberKeys()) {\n      const memberRole = this.get(otherMemberKey);\n\n      if (\n        memberRole === \"reader\" ||\n        memberRole === \"writer\" ||\n        memberRole === \"admin\" ||\n        memberRole === \"readerInvite\" ||\n        memberRole === \"writerInvite\" ||\n        memberRole === \"adminInvite\"\n      ) {\n        const otherMemberAgent = this.core.node\n          .resolveAccountAgent(\n            otherMemberKey,\n            \"Expected member agent to be loaded\",\n          )\n          ._unsafeUnwrap({ withStackTrace: true });\n\n        this.storeKeyRevelationForMember(\n          otherMemberKey,\n          otherMemberAgent,\n          writeKeyForNewMember.id,\n          writeKeyForNewMember.secret,\n        );\n      }\n    }\n  }\n\n  private storeKeyRevelationForMember(\n    memberKey: RawAccountID | AgentID,\n    agent: AgentID,\n    keyID: KeyID,\n    secret: KeySecret,\n  ) {\n    this.set(\n      `${keyID}_for_${memberKey}`,\n      this.core.crypto.seal({\n        message: secret,\n        from: this.core.node.account.currentSealerSecret(),\n        to: this.core.crypto.getAgentSealerID(agent),\n        nOnceMaterial: {\n          in: this.id,\n          tx: this.core.nextTransactionID(),\n        },\n      }),\n      \"trusting\",\n    );\n  }\n\n  private getWriteOnlyKeys() {\n    const keys: KeyID[] = [];\n\n    for (const key of this.keys()) {\n      if (key.startsWith(\"writeKeyFor_\")) {\n        keys.push(\n          this.get(key as `writeKeyFor_${RawAccountID | AgentID}`) as KeyID,\n        );\n      }\n    }\n\n    return keys;\n  }\n\n  getCurrentReadKeyId() {\n    if (this.myRole() === \"writeOnly\") {\n      const accountId = this.core.node.account.id;\n\n      const key = this.get(`writeKeyFor_${accountId}`) as KeyID;\n\n      // When everyone is writeOnly, we need to create a writeOnly key for the current account if missing\n      if (!key && this.get(\"everyone\") === \"writeOnly\") {\n        this.internalCreateWriteOnlyKeyForMember(\n          accountId,\n          this.core.node.account.currentAgentID(),\n        );\n\n        return this.get(`writeKeyFor_${accountId}`) as KeyID;\n      }\n\n      return key;\n    }\n\n    return this.get(\"readKey\");\n  }\n\n  getMemberKeys(): (RawAccountID | AgentID)[] {\n    return this.keys().filter((key): key is RawAccountID | AgentID => {\n      return key.startsWith(\"co_\") || isAgentID(key);\n    });\n  }\n\n  getAllMemberKeysSet() {\n    const memberKeys = new Set(this.getMemberKeys());\n\n    for (const group of this.getParentGroups()) {\n      for (const key of group.getAllMemberKeysSet()) {\n        memberKeys.add(key);\n      }\n    }\n\n    return memberKeys;\n  }\n\n  /** @internal */\n  rotateReadKey(removedMemberKey?: RawAccountID | AgentID | \"everyone\") {\n    const memberKeys = this.getMemberKeys().filter(\n      (key) => key !== removedMemberKey,\n    );\n\n    const currentlyPermittedReaders = memberKeys.filter((key) => {\n      const role = this.get(key);\n      return (\n        role === \"admin\" ||\n        role === \"writer\" ||\n        role === \"reader\" ||\n        role === \"adminInvite\" ||\n        role === \"writerInvite\" ||\n        role === \"readerInvite\"\n      );\n    });\n\n    const writeOnlyMembers = memberKeys.filter((key) => {\n      const role = this.get(key);\n      return role === \"writeOnly\" || role === \"writeOnlyInvite\";\n    });\n\n    // Get these early, so we fail fast if they are unavailable\n    const parentGroups = this.getParentGroups();\n    const childGroups = this.getChildGroups();\n\n    const maybeCurrentReadKey = this.core.getCurrentReadKey();\n\n    if (!maybeCurrentReadKey.secret) {\n      throw new Error(\"Can't rotate read key secret we don't have access to\");\n    }\n\n    const currentReadKey = {\n      id: maybeCurrentReadKey.id,\n      secret: maybeCurrentReadKey.secret,\n    };\n\n    const newReadKey = this.core.crypto.newRandomKeySecret();\n\n    for (const readerID of currentlyPermittedReaders) {\n      const agent = this.core.node\n        .resolveAccountAgent(\n          readerID,\n          \"Expected to know currently permitted reader\",\n        )\n        ._unsafeUnwrap({ withStackTrace: true });\n\n      this.storeKeyRevelationForMember(\n        readerID,\n        agent,\n        newReadKey.id,\n        newReadKey.secret,\n      );\n    }\n\n    /**\n     * If there are some writeOnly members we need to rotate their keys\n     * and reveal them to the other non-writeOnly members\n     */\n    for (const writeOnlyMemberID of writeOnlyMembers) {\n      const agent = this.core.node\n        .resolveAccountAgent(\n          writeOnlyMemberID,\n          \"Expected to know writeOnly member\",\n        )\n        ._unsafeUnwrap({ withStackTrace: true });\n\n      const writeOnlyKey = this.core.crypto.newRandomKeySecret();\n\n      this.storeKeyRevelationForMember(\n        writeOnlyMemberID,\n        agent,\n        writeOnlyKey.id,\n        writeOnlyKey.secret,\n      );\n      this.set(`writeKeyFor_${writeOnlyMemberID}`, writeOnlyKey.id, \"trusting\");\n\n      for (const readerID of currentlyPermittedReaders) {\n        const agent = this.core.node\n          .resolveAccountAgent(\n            readerID,\n            \"Expected to know currently permitted reader\",\n          )\n          ._unsafeUnwrap({ withStackTrace: true });\n\n        this.storeKeyRevelationForMember(\n          readerID,\n          agent,\n          writeOnlyKey.id,\n          writeOnlyKey.secret,\n        );\n      }\n    }\n\n    this.set(\n      `${currentReadKey.id}_for_${newReadKey.id}`,\n      this.core.crypto.encryptKeySecret({\n        encrypting: newReadKey,\n        toEncrypt: currentReadKey,\n      }).encrypted,\n      \"trusting\",\n    );\n\n    this.set(\"readKey\", newReadKey.id, \"trusting\");\n\n    /**\n     * The new read key needs to be revealed to the parent groups\n     *\n     * This way the members from the parent groups can still have access to this group\n     */\n    for (const parent of parentGroups) {\n      const { id: parentReadKeyID, secret: parentReadKeySecret } =\n        parent.core.getCurrentReadKey();\n\n      if (!parentReadKeySecret) {\n        throw new Error(\n          \"Can't reveal new child key to parent where we don't have access to the parent read key\",\n        );\n      }\n\n      this.set(\n        `${newReadKey.id}_for_${parentReadKeyID}`,\n        this.core.crypto.encryptKeySecret({\n          encrypting: {\n            id: parentReadKeyID,\n            secret: parentReadKeySecret,\n          },\n          toEncrypt: newReadKey,\n        }).encrypted,\n        \"trusting\",\n      );\n    }\n\n    for (const child of childGroups) {\n      // Since child references are mantained only for the key rotation,\n      // circular references are skipped here because it's more performant\n      // than always checking for circular references in childs inside the permission checks\n      if (child.isSelfExtension(this)) {\n        continue;\n      }\n\n      child.rotateReadKey(removedMemberKey);\n    }\n  }\n\n  /** Detect circular references in group inheritance */\n  isSelfExtension(parent: RawGroup) {\n    if (parent.id === this.id) {\n      return true;\n    }\n\n    const childGroups = this.getChildGroups();\n\n    for (const child of childGroups) {\n      if (child.isSelfExtension(parent)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  extend(\n    parent: RawGroup,\n    role: \"reader\" | \"writer\" | \"admin\" | \"inherit\" = \"inherit\",\n  ) {\n    if (this.isSelfExtension(parent)) {\n      return;\n    }\n\n    if (this.myRole() !== \"admin\") {\n      throw new Error(\n        \"To extend a group, the current account must be an admin in the child group\",\n      );\n    }\n\n    if (\n      parent.myRole() !== \"admin\" &&\n      parent.myRole() !== \"writer\" &&\n      parent.myRole() !== \"reader\" &&\n      parent.myRole() !== \"writeOnly\"\n    ) {\n      throw new Error(\n        \"To extend a group, the current account must be a member of the parent group\",\n      );\n    }\n\n    const value = role === \"inherit\" ? \"extend\" : role;\n\n    this.set(`parent_${parent.id}`, value, \"trusting\");\n    parent.set(`child_${this.id}`, \"extend\", \"trusting\");\n\n    const { id: parentReadKeyID, secret: parentReadKeySecret } =\n      parent.core.getCurrentReadKey();\n    if (!parentReadKeySecret) {\n      throw new Error(\"Can't extend group without parent read key secret\");\n    }\n\n    const { id: childReadKeyID, secret: childReadKeySecret } =\n      this.core.getCurrentReadKey();\n    if (!childReadKeySecret) {\n      throw new Error(\"Can't extend group without child read key secret\");\n    }\n\n    this.set(\n      `${childReadKeyID}_for_${parentReadKeyID}`,\n      this.core.crypto.encryptKeySecret({\n        encrypting: {\n          id: parentReadKeyID,\n          secret: parentReadKeySecret,\n        },\n        toEncrypt: {\n          id: childReadKeyID,\n          secret: childReadKeySecret,\n        },\n      }).encrypted,\n      \"trusting\",\n    );\n  }\n\n  async revokeExtend(parent: RawGroup) {\n    if (this.myRole() !== \"admin\") {\n      throw new Error(\n        \"To unextend a group, the current account must be an admin in the child group\",\n      );\n    }\n\n    if (\n      parent.myRole() !== \"admin\" &&\n      parent.myRole() !== \"writer\" &&\n      parent.myRole() !== \"reader\" &&\n      parent.myRole() !== \"writeOnly\"\n    ) {\n      throw new Error(\n        \"To unextend a group, the current account must be a member of the parent group\",\n      );\n    }\n\n    if (\n      !this.get(`parent_${parent.id}`) ||\n      this.get(`parent_${parent.id}`) === \"revoked\"\n    ) {\n      return;\n    }\n\n    // Set the parent key on the child group to `revoked`\n    this.set(`parent_${parent.id}`, \"revoked\", \"trusting\");\n\n    // Set the child key on the parent group to `revoked`\n    parent.set(`child_${this.id}`, \"revoked\", \"trusting\");\n\n    await this.loadAllChildGroups();\n\n    // Rotate the keys on the child group\n    this.rotateReadKey();\n  }\n\n  /**\n   * Strips the specified member of all roles (preventing future writes in\n   *  the group and owned values) and rotates the read encryption key for that group\n   * (preventing reads of new content in the group and owned values)\n   *\n   * @category 2. Role changing\n   */\n  async removeMember(\n    account: RawAccount | ControlledAccountOrAgent | Everyone,\n  ) {\n    // Ensure all child groups are loaded before removing a member\n    await this.loadAllChildGroups();\n\n    this.removeMemberInternal(account);\n  }\n\n  /** @internal */\n  removeMemberInternal(\n    account: RawAccount | ControlledAccountOrAgent | AgentID | Everyone,\n  ) {\n    const memberKey = typeof account === \"string\" ? account : account.id;\n\n    this.rotateReadKey(memberKey);\n    this.set(memberKey, \"revoked\", \"trusting\");\n  }\n\n  /**\n   * Creates an invite for new members to indirectly join the group,\n   * allowing them to grant themselves the specified role with the InviteSecret\n   * (a string starting with \"inviteSecret_\") - use `LocalNode.acceptInvite()` for this purpose.\n   *\n   * @category 2. Role changing\n   */\n  createInvite(role: AccountRole): InviteSecret {\n    const secretSeed = this.core.crypto.newRandomSecretSeed();\n\n    const inviteSecret = this.core.crypto.agentSecretFromSecretSeed(secretSeed);\n    const inviteID = this.core.crypto.getAgentID(inviteSecret);\n\n    this.addMemberInternal(inviteID, `${role}Invite` as Role);\n\n    return inviteSecretFromSecretSeed(secretSeed);\n  }\n\n  /**\n   * Creates a new `CoMap` within this group, with the specified specialized\n   * `CoMap` type `M` and optional static metadata.\n   *\n   * @category 3. Value creation\n   */\n  createMap<M extends RawCoMap>(\n    init?: M[\"_shape\"],\n    meta?: M[\"headerMeta\"],\n    initPrivacy: \"trusting\" | \"private\" = \"private\",\n    uniqueness: CoValueUniqueness = this.core.crypto.createdNowUnique(),\n  ): M {\n    const map = this.core.node\n      .createCoValue({\n        type: \"comap\",\n        ruleset: {\n          type: \"ownedByGroup\",\n          group: this.id,\n        },\n        meta: meta || null,\n        ...uniqueness,\n      })\n      .getCurrentContent() as M;\n\n    if (init) {\n      map.assign(init, initPrivacy);\n    }\n\n    return map;\n  }\n\n  /**\n   * Creates a new `CoList` within this group, with the specified specialized\n   * `CoList` type `L` and optional static metadata.\n   *\n   * @category 3. Value creation\n   */\n  createList<L extends RawCoList>(\n    init?: L[\"_item\"][],\n    meta?: L[\"headerMeta\"],\n    initPrivacy: \"trusting\" | \"private\" = \"private\",\n    uniqueness: CoValueUniqueness = this.core.crypto.createdNowUnique(),\n  ): L {\n    const list = this.core.node\n      .createCoValue({\n        type: \"colist\",\n        ruleset: {\n          type: \"ownedByGroup\",\n          group: this.id,\n        },\n        meta: meta || null,\n        ...uniqueness,\n      })\n      .getCurrentContent() as L;\n\n    if (init?.length) {\n      list.appendItems(init, undefined, initPrivacy);\n    }\n\n    return list;\n  }\n\n  /**\n   * Creates a new `CoPlainText` within this group, with the specified specialized\n   * `CoPlainText` type `T` and optional static metadata.\n   *\n   * @category 3. Value creation\n   */\n  createPlainText<T extends RawCoPlainText>(\n    init?: string,\n    meta?: T[\"headerMeta\"],\n    initPrivacy: \"trusting\" | \"private\" = \"private\",\n  ): T {\n    const text = this.core.node\n      .createCoValue({\n        type: \"coplaintext\",\n        ruleset: {\n          type: \"ownedByGroup\",\n          group: this.id,\n        },\n        meta: meta || null,\n        ...this.core.crypto.createdNowUnique(),\n      })\n      .getCurrentContent() as T;\n\n    if (init) {\n      text.insertAfter(0, init, initPrivacy);\n    }\n\n    return text;\n  }\n\n  /** @category 3. Value creation */\n  createStream<C extends RawCoStream>(\n    meta?: C[\"headerMeta\"],\n    uniqueness: CoValueUniqueness = this.core.crypto.createdNowUnique(),\n  ): C {\n    return this.core.node\n      .createCoValue({\n        type: \"costream\",\n        ruleset: {\n          type: \"ownedByGroup\",\n          group: this.id,\n        },\n        meta: meta || null,\n        ...uniqueness,\n      })\n      .getCurrentContent() as C;\n  }\n\n  /** @category 3. Value creation */\n  createBinaryStream<C extends RawBinaryCoStream>(\n    meta: C[\"headerMeta\"] = { type: \"binary\" },\n    uniqueness: CoValueUniqueness = this.core.crypto.createdNowUnique(),\n  ): C {\n    return this.core.node\n      .createCoValue({\n        type: \"costream\",\n        ruleset: {\n          type: \"ownedByGroup\",\n          group: this.id,\n        },\n        meta: meta,\n        ...uniqueness,\n      })\n      .getCurrentContent() as C;\n  }\n}\n\nexport function isInheritableRole(\n  roleInParent: Role | undefined,\n): roleInParent is \"revoked\" | \"admin\" | \"writer\" | \"reader\" {\n  return (\n    roleInParent === \"revoked\" ||\n    roleInParent === \"admin\" ||\n    roleInParent === \"writer\" ||\n    roleInParent === \"reader\"\n  );\n}\n\nfunction isMorePermissiveAndShouldInherit(\n  roleInParent: \"revoked\" | \"admin\" | \"writer\" | \"reader\",\n  roleInChild: Role | undefined,\n) {\n  if (roleInParent === \"revoked\") {\n    return true;\n  }\n\n  if (roleInParent === \"admin\") {\n    return !roleInChild || roleInChild !== \"admin\";\n  }\n\n  if (roleInParent === \"writer\") {\n    return (\n      !roleInChild || roleInChild === \"reader\" || roleInChild === \"writeOnly\"\n    );\n  }\n\n  if (roleInParent === \"reader\") {\n    return !roleInChild;\n  }\n\n  // writeOnly can't be inherited\n  if (roleInParent === \"writeOnly\") {\n    return false;\n  }\n\n  return false;\n}\n\nexport type InviteSecret = `inviteSecret_z${string}`;\n\nfunction inviteSecretFromSecretSeed(secretSeed: Uint8Array): InviteSecret {\n  return `inviteSecret_z${base58.encode(secretSeed)}`;\n}\n\nexport function secretSeedFromInviteSecret(inviteSecret: InviteSecret) {\n  if (!inviteSecret.startsWith(\"inviteSecret_z\")) {\n    throw new Error(\"Invalid invite secret\");\n  }\n\n  return base58.decode(inviteSecret.slice(\"inviteSecret_z\".length));\n}\n", "import { CoID, RawCoValue } from \"../coValue.js\";\nimport {\n  CoValueCore,\n  CoValueHeader,\n  CoValueUniqueness,\n} from \"../coValueCore.js\";\nimport {\n  AgentSecret,\n  CryptoProvider,\n  SealerID,\n  SealerSecret,\n  SignerID,\n  SignerSecret,\n} from \"../crypto/crypto.js\";\nimport { AgentID } from \"../ids.js\";\nimport { JsonObject } from \"../jsonValue.js\";\nimport { LocalNode } from \"../localNode.js\";\nimport { logger } from \"../logger.js\";\nimport type { AccountRole } from \"../permissions.js\";\nimport { RawCoMap } from \"./coMap.js\";\nimport { InviteSecret, RawGroup } from \"./group.js\";\n\nexport function accountHeaderForInitialAgentSecret(\n  agentSecret: AgentSecret,\n  crypto: CryptoProvider,\n): CoValueHeader {\n  const agent = crypto.getAgentID(agentSecret);\n  return {\n    type: \"comap\",\n    ruleset: { type: \"group\", initialAdmin: agent },\n    meta: {\n      type: \"account\",\n    },\n    createdAt: null,\n    uniqueness: null,\n  };\n}\n\nexport type InvalidAccountAgentIDError = {\n  type: \"InvalidAccountAgentID\";\n  reason: string;\n};\n\nexport class RawAccount<\n  Meta extends AccountMeta = AccountMeta,\n> extends RawGroup<Meta> {\n  _cachedCurrentAgentID: AgentID | undefined;\n\n  currentAgentID(): AgentID {\n    if (this._cachedCurrentAgentID) {\n      return this._cachedCurrentAgentID;\n    }\n\n    const agents = this.keys()\n      .filter((k): k is AgentID => k.startsWith(\"sealer_\"))\n      .sort(\n        (a, b) =>\n          (this.lastEditAt(a)?.at.getTime() || 0) -\n          (this.lastEditAt(b)?.at.getTime() || 0),\n      );\n\n    if (agents.length !== 1) {\n      logger.warn(\"Account has \" + agents.length + \" agents\", { id: this.id });\n    }\n\n    this._cachedCurrentAgentID = agents[0];\n\n    return agents[0]!;\n  }\n\n  createInvite(_: AccountRole): InviteSecret {\n    throw new Error(\"Cannot create invite from an account\");\n  }\n}\n\nexport interface ControlledAccountOrAgent {\n  id: RawAccountID | AgentID;\n  agentSecret: AgentSecret;\n\n  currentAgentID: () => AgentID;\n  currentSignerID: () => SignerID;\n  currentSignerSecret: () => SignerSecret;\n  currentSealerID: () => SealerID;\n  currentSealerSecret: () => SealerSecret;\n}\n\n/** @hidden */\nexport class RawControlledAccount<Meta extends AccountMeta = AccountMeta>\n  extends RawAccount<Meta>\n  implements ControlledAccountOrAgent\n{\n  agentSecret: AgentSecret;\n  crypto: CryptoProvider;\n\n  constructor(core: CoValueCore, agentSecret: AgentSecret) {\n    super(core);\n\n    this.agentSecret = agentSecret;\n    this.crypto = core.node.crypto;\n  }\n\n  /**\n   * Creates a new group (with the current account as the group's first admin).\n   * @category 1. High-level\n   */\n  createGroup(\n    uniqueness: CoValueUniqueness = this.core.crypto.createdNowUnique(),\n  ) {\n    return this.core.node.createGroup(uniqueness);\n  }\n\n  async acceptInvite<T extends RawCoValue>(\n    groupOrOwnedValueID: CoID<T>,\n    inviteSecret: InviteSecret,\n  ): Promise<void> {\n    return this.core.node.acceptInvite(groupOrOwnedValueID, inviteSecret);\n  }\n\n  currentAgentID(): AgentID {\n    if (this._cachedCurrentAgentID) {\n      return this._cachedCurrentAgentID;\n    }\n    const agentID = this.crypto.getAgentID(this.agentSecret);\n    this._cachedCurrentAgentID = agentID;\n    return agentID;\n  }\n\n  currentSignerID() {\n    return this.crypto.getAgentSignerID(this.currentAgentID());\n  }\n\n  currentSignerSecret(): SignerSecret {\n    return this.crypto.getAgentSignerSecret(this.agentSecret);\n  }\n\n  currentSealerID() {\n    return this.crypto.getAgentSealerID(this.currentAgentID());\n  }\n\n  currentSealerSecret(): SealerSecret {\n    return this.crypto.getAgentSealerSecret(this.agentSecret);\n  }\n}\n\nexport class ControlledAgent implements ControlledAccountOrAgent {\n  constructor(\n    public agentSecret: AgentSecret,\n    public crypto: CryptoProvider,\n  ) {}\n\n  get id(): AgentID {\n    return this.crypto.getAgentID(this.agentSecret);\n  }\n\n  currentAgentID() {\n    return this.crypto.getAgentID(this.agentSecret);\n  }\n\n  currentSignerID() {\n    return this.crypto.getAgentSignerID(this.currentAgentID());\n  }\n\n  currentSignerSecret(): SignerSecret {\n    return this.crypto.getAgentSignerSecret(this.agentSecret);\n  }\n\n  currentSealerID() {\n    return this.crypto.getAgentSealerID(this.currentAgentID());\n  }\n\n  currentSealerSecret(): SealerSecret {\n    return this.crypto.getAgentSealerSecret(this.agentSecret);\n  }\n}\n\nexport type AccountMeta = { type: \"account\" };\nexport type RawAccountID = CoID<RawAccount>;\n\nexport type ProfileShape = {\n  name: string;\n};\n\nexport class RawProfile<\n  Shape extends ProfileShape = ProfileShape,\n  Meta extends JsonObject | null = JsonObject | null,\n> extends RawCoMap<Shape, Meta> {}\n\nexport type RawAccountMigration<Meta extends AccountMeta = AccountMeta> = (\n  account: RawControlledAccount<Meta>,\n  localNode: LocalNode,\n  creationProps?: { name: string },\n) => void | Promise<void>;\n", "import { CoValueCore } from \"../coValueCore.js\";\nimport { JsonObject } from \"../jsonValue.js\";\nimport { DeletionOpPayload, OpID, RawCoList } from \"./coList.js\";\n\ndeclare const navigator:\n  | {\n      language: string;\n    }\n  | undefined;\n\nexport type StringifiedOpID = string & { __stringifiedOpID: true };\n\nexport function stringifyOpID(opID: OpID): StringifiedOpID {\n  return `${opID.sessionID}:${opID.txIndex}:${opID.changeIdx}` as StringifiedOpID;\n}\n\ntype PlaintextIdxMapping = {\n  opIDbeforeIdx: OpID[];\n  opIDafterIdx: OpID[];\n  idxAfterOpID: { [opID: StringifiedOpID]: number };\n  idxBeforeOpID: { [opID: StringifiedOpID]: number };\n};\n\n/**\n * A collaborative plain text implementation that supports grapheme-accurate editing.\n *\n * Locale support:\n * - Locale can be specified in the meta field when creating the text: `{ meta: { locale: \"ja-JP\" } }`\n * - If no locale is specified, falls back to browser's locale (`navigator.language`)\n * - If browser locale is not available, defaults to 'en'\n *\n * @example\n * ```typescript\n * // With specific locale\n * const textJa = node.createCoValue({\n *   type: \"coplaintext\",\n *   ruleset: { type: \"unsafeAllowAll\" },\n *   meta: { locale: \"ja-JP\" },\n *   ...Crypto.createdNowUnique(),\n * });\n *\n * // Using browser locale\n * const text = node.createCoValue({\n *   type: \"coplaintext\",\n *   ruleset: { type: \"unsafeAllowAll\" },\n *   meta: null,\n *   ...Crypto.createdNowUnique(),\n * });\n * ```\n */\nexport class RawCoPlainText<\n  Meta extends JsonObject | null = JsonObject | null,\n> extends RawCoList<string, Meta> {\n  /** @category 6. Meta */\n  type = \"coplaintext\" as const;\n\n  private _segmenter: Intl.Segmenter;\n\n  _cachedMapping: WeakMap<\n    NonNullable<typeof this._cachedEntries>,\n    PlaintextIdxMapping\n  >;\n\n  constructor(core: CoValueCore) {\n    super(core);\n    this._cachedMapping = new WeakMap();\n    if (!Intl.Segmenter) {\n      throw new Error(\n        \"Intl.Segmenter is not supported. Use a polyfill to get coPlainText support in Jazz. (eg. https://formatjs.github.io/docs/polyfills/intl-segmenter/)\",\n      );\n    }\n\n    // Use locale from meta if provided, fallback to browser locale, or 'en' as last resort\n    const effectiveLocale =\n      (core.header.meta &&\n      typeof core.header.meta === \"object\" &&\n      \"locale\" in core.header.meta\n        ? (core.header.meta.locale as string)\n        : undefined) ||\n      (typeof navigator !== \"undefined\" ? navigator.language : \"en\");\n\n    this._segmenter = new Intl.Segmenter(effectiveLocale, {\n      granularity: \"grapheme\",\n    });\n  }\n\n  get mapping() {\n    const entries = this.entries();\n    let mapping = this._cachedMapping.get(entries);\n    if (mapping) {\n      return mapping;\n    }\n\n    mapping = {\n      opIDbeforeIdx: [],\n      opIDafterIdx: [],\n      idxAfterOpID: {},\n      idxBeforeOpID: {},\n    };\n\n    let idxBefore = 0;\n\n    for (const entry of entries) {\n      const idxAfter = idxBefore + entry.value.length;\n\n      mapping.opIDafterIdx[idxBefore] = entry.opID;\n      mapping.opIDbeforeIdx[idxAfter] = entry.opID;\n      mapping.idxAfterOpID[stringifyOpID(entry.opID)] = idxAfter;\n      mapping.idxBeforeOpID[stringifyOpID(entry.opID)] = idxBefore;\n\n      idxBefore = idxAfter;\n    }\n\n    this._cachedMapping.set(entries, mapping);\n    return mapping;\n  }\n\n  toString() {\n    return this.entries()\n      .map((entry) => entry.value)\n      .join(\"\");\n  }\n\n  /**\n   * Inserts `text` before the character at index `idx`.\n   * If idx is 0, inserts at the start of the text.\n   *\n   * @param idx - The index of the character to insert before\n   * @param text - The text to insert\n   * @param privacy - Whether the operation should be private or trusting\n   * @category 2. Editing\n   */\n  insertBefore(\n    idx: number,\n    text: string,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ) {\n    const graphemes = [...this._segmenter.segment(text)].map((g) => g.segment);\n\n    if (idx === 0) {\n      // For insertions at start, prepend each character in reverse\n      for (const grapheme of graphemes.reverse()) {\n        this.prepend(grapheme, 0, privacy);\n      }\n    } else {\n      // For other insertions, append after the previous character\n      this.appendItems(graphemes, idx - 1, privacy);\n    }\n  }\n\n  /**\n   * Inserts `text` after the character at index `idx`.\n   *\n   * @param idx - The index of the character to insert after\n   * @param text - The text to insert\n   * @param privacy - Whether the operation should be private or trusting\n   * @category 2. Editing\n   */\n  insertAfter(\n    idx: number,\n    text: string,\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ) {\n    const graphemes = [...this._segmenter.segment(text)].map((g) => g.segment);\n    this.appendItems(graphemes, idx, privacy);\n  }\n\n  deleteRange(\n    { from, to }: { from: number; to: number },\n    privacy: \"private\" | \"trusting\" = \"private\",\n  ) {\n    const ops: DeletionOpPayload[] = [];\n    for (let idx = from; idx < to; ) {\n      const insertion = this.mapping.opIDafterIdx[idx];\n      if (!insertion) {\n        throw new Error(\"Invalid idx to delete \" + idx);\n      }\n      ops.push({\n        op: \"del\",\n        insertion,\n      });\n      let nextIdx = idx + 1;\n      while (!this.mapping.opIDbeforeIdx[nextIdx] && nextIdx < to) {\n        nextIdx++;\n      }\n      idx = nextIdx;\n    }\n    this.core.makeTransaction(ops, privacy);\n    this.processNewTransactions();\n  }\n}\n", "import { RawUnknownCoValue } from \"./coValue.js\";\nimport type { CoValueCore } from \"./coValueCore.js\";\nimport { RawAccount, RawControlledAccount } from \"./coValues/account.js\";\nimport { RawCoList } from \"./coValues/coList.js\";\nimport { RawCoMap } from \"./coValues/coMap.js\";\nimport { RawCoPlainText } from \"./coValues/coPlainText.js\";\nimport { RawBinaryCoStream, RawCoStream } from \"./coValues/coStream.js\";\nimport { RawGroup } from \"./coValues/group.js\";\n\nexport function coreToCoValue(\n  core: CoValueCore,\n  options?: { ignorePrivateTransactions: true },\n) {\n  if (core.header.type === \"comap\") {\n    if (core.header.ruleset.type === \"group\") {\n      if (\n        core.header.meta?.type === \"account\" &&\n        !options?.ignorePrivateTransactions\n      ) {\n        if (core.id === core.node.account.id) {\n          return new RawControlledAccount(core, core.node.account.agentSecret);\n        } else {\n          return new RawAccount(core);\n        }\n      } else {\n        return new RawGroup(core, options);\n      }\n    } else {\n      return new RawCoMap(core);\n    }\n  } else if (core.header.type === \"coplaintext\") {\n    return new RawCoPlainText(core);\n  } else if (core.header.type === \"colist\") {\n    return new RawCoList(core);\n  } else if (core.header.type === \"costream\") {\n    if (core.header.meta && core.header.meta.type === \"binary\") {\n      return new RawBinaryCoStream(core);\n    } else {\n      return new RawCoStream(core);\n    }\n  } else {\n    return new RawUnknownCoValue(core);\n  }\n}\n", "import { CoID } from \"./coValue.js\";\nimport { CoValueCore, Transaction } from \"./coValueCore.js\";\nimport { RawAccount, RawAccountID, RawProfile } from \"./coValues/account.js\";\nimport { MapOpPayload } from \"./coValues/coMap.js\";\nimport {\n  EVERYONE,\n  Everyone,\n  ParentGroupReferenceRole,\n  RawGroup,\n  isInheritableRole,\n} from \"./coValues/group.js\";\nimport { KeyID } from \"./crypto/crypto.js\";\nimport {\n  AgentID,\n  ParentGroupReference,\n  RawCoID,\n  SessionID,\n  TransactionID,\n  getParentGroupId,\n} from \"./ids.js\";\nimport { parseJSON } from \"./jsonStringify.js\";\nimport { JsonValue } from \"./jsonValue.js\";\nimport { logger } from \"./logger.js\";\nimport { CoValueKnownState } from \"./sync.js\";\nimport { accountOrAgentIDfromSessionID } from \"./typeUtils/accountOrAgentIDfromSessionID.js\";\nimport { expectGroup } from \"./typeUtils/expectGroup.js\";\n\nexport type PermissionsDef =\n  | { type: \"group\"; initialAdmin: RawAccountID | AgentID }\n  | { type: \"ownedByGroup\"; group: RawCoID }\n  | { type: \"unsafeAllowAll\" };\n\nexport type AccountRole = \"reader\" | \"writer\" | \"admin\" | \"writeOnly\";\n\nexport type Role =\n  | AccountRole\n  | \"revoked\"\n  | \"adminInvite\"\n  | \"writerInvite\"\n  | \"readerInvite\"\n  | \"writeOnlyInvite\";\n\ntype ValidTransactionsResult = { txID: TransactionID; tx: Transaction };\ntype MemberState = { [agent: RawAccountID | AgentID]: Role; [EVERYONE]?: Role };\n\nlet logPermissionErrors = true;\n\nexport function disablePermissionErrors() {\n  logPermissionErrors = false;\n}\n\nfunction logPermissionError(\n  message: string,\n  attributes?: Record<string, JsonValue>,\n) {\n  if (logPermissionErrors === false) {\n    return;\n  }\n\n  logger.debug(\"Permission error: \" + message, attributes);\n}\n\nexport function determineValidTransactions(\n  coValue: CoValueCore,\n  knownTransactions?: CoValueKnownState[\"sessions\"],\n): { txID: TransactionID; tx: Transaction }[] {\n  if (coValue.header.ruleset.type === \"group\") {\n    const initialAdmin = coValue.header.ruleset.initialAdmin;\n    if (!initialAdmin) {\n      throw new Error(\"Group must have initialAdmin\");\n    }\n\n    return determineValidTransactionsForGroup(coValue, initialAdmin)\n      .validTransactions;\n  } else if (coValue.header.ruleset.type === \"ownedByGroup\") {\n    const groupContent = expectGroup(\n      coValue.node\n        .expectCoValueLoaded(\n          coValue.header.ruleset.group,\n          \"Determining valid transaction in owned object but its group wasn't loaded\",\n        )\n        .getCurrentContent(),\n    );\n\n    if (groupContent.type !== \"comap\") {\n      throw new Error(\"Group must be a map\");\n    }\n\n    const validTransactions: ValidTransactionsResult[] = [];\n\n    for (const [sessionID, sessionLog] of coValue.sessionLogs.entries()) {\n      const transactor = accountOrAgentIDfromSessionID(sessionID);\n      const knownTransactionsForSession = knownTransactions?.[sessionID] ?? -1;\n\n      sessionLog.transactions.forEach((tx, txIndex) => {\n        if (knownTransactionsForSession >= txIndex) {\n          return;\n        }\n\n        const groupAtTime = groupContent.atTime(tx.madeAt);\n        const effectiveTransactor = agentInAccountOrMemberInGroup(\n          transactor,\n          groupAtTime,\n        );\n\n        if (!effectiveTransactor) {\n          return;\n        }\n\n        const transactorRoleAtTxTime =\n          groupAtTime.roleOfInternal(effectiveTransactor);\n\n        if (\n          transactorRoleAtTxTime !== \"admin\" &&\n          transactorRoleAtTxTime !== \"writer\" &&\n          transactorRoleAtTxTime !== \"writeOnly\"\n        ) {\n          return;\n        }\n\n        validTransactions.push({ txID: { sessionID, txIndex }, tx });\n      });\n    }\n\n    return validTransactions;\n  } else if (coValue.header.ruleset.type === \"unsafeAllowAll\") {\n    const validTransactions: ValidTransactionsResult[] = [];\n\n    for (const [sessionID, sessionLog] of coValue.sessionLogs.entries()) {\n      const knownTransactionsForSession = knownTransactions?.[sessionID] ?? -1;\n\n      sessionLog.transactions.forEach((tx, txIndex) => {\n        if (knownTransactionsForSession >= txIndex) {\n          return;\n        }\n\n        validTransactions.push({ txID: { sessionID, txIndex }, tx });\n      });\n    }\n    return validTransactions;\n  } else {\n    throw new Error(\n      \"Unknown ruleset type \" +\n        (coValue.header.ruleset as { type: string }).type,\n    );\n  }\n}\n\nfunction isHigherRole(a: Role, b: Role | undefined) {\n  if (a === undefined || a === \"revoked\") return false;\n  if (b === undefined || b === \"revoked\") return true;\n  if (b === \"admin\") return false;\n  if (a === \"admin\") return true;\n\n  return a === \"writer\" && b === \"reader\";\n}\n\nfunction resolveMemberStateFromParentReference(\n  coValue: CoValueCore,\n  memberState: MemberState,\n  parentReference: ParentGroupReference,\n  roleMapping: ParentGroupReferenceRole,\n  extendChain: Set<CoValueCore[\"id\"]>,\n) {\n  const parentGroup = coValue.node.expectCoValueLoaded(\n    getParentGroupId(parentReference),\n    \"Expected parent group to be loaded\",\n  );\n\n  if (parentGroup.header.ruleset.type !== \"group\") {\n    return;\n  }\n\n  // Skip circular references\n  if (extendChain.has(parentGroup.id)) {\n    return;\n  }\n\n  const initialAdmin = parentGroup.header.ruleset.initialAdmin;\n\n  if (!initialAdmin) {\n    throw new Error(\"Group must have initialAdmin\");\n  }\n\n  extendChain.add(parentGroup.id);\n\n  const { memberState: parentGroupMemberState } =\n    determineValidTransactionsForGroup(parentGroup, initialAdmin, extendChain);\n\n  for (const agent of Object.keys(parentGroupMemberState) as Array<\n    keyof MemberState\n  >) {\n    const parentRole = parentGroupMemberState[agent];\n    const currentRole = memberState[agent];\n\n    if (isInheritableRole(parentRole)) {\n      if (roleMapping !== \"extend\" && isHigherRole(roleMapping, currentRole)) {\n        memberState[agent] = roleMapping;\n      } else if (isHigherRole(parentRole, currentRole)) {\n        memberState[agent] = parentRole;\n      }\n    }\n  }\n}\n\nfunction determineValidTransactionsForGroup(\n  coValue: CoValueCore,\n  initialAdmin: RawAccountID | AgentID,\n  extendChain?: Set<CoValueCore[\"id\"]>,\n): { validTransactions: ValidTransactionsResult[]; memberState: MemberState } {\n  const allTransactionsSorted: {\n    sessionID: SessionID;\n    txIndex: number;\n    tx: Transaction;\n  }[] = [];\n\n  for (const [sessionID, sessionLog] of coValue.sessionLogs.entries()) {\n    sessionLog.transactions.forEach((tx, txIndex) => {\n      allTransactionsSorted.push({ sessionID, txIndex, tx });\n    });\n  }\n\n  allTransactionsSorted.sort((a, b) => {\n    return a.tx.madeAt - b.tx.madeAt;\n  });\n\n  const memberState: MemberState = {};\n  const writeOnlyKeys: Record<RawAccountID | AgentID, KeyID> = {};\n  const validTransactions: ValidTransactionsResult[] = [];\n\n  const keyRevelations = new Set<string>();\n  const writeKeys = new Set<string>();\n\n  for (const { sessionID, txIndex, tx } of allTransactionsSorted) {\n    const transactor = accountOrAgentIDfromSessionID(sessionID);\n\n    if (tx.privacy === \"private\") {\n      if (memberState[transactor] === \"admin\") {\n        validTransactions.push({\n          txID: { sessionID, txIndex },\n          tx,\n        });\n        continue;\n      } else {\n        logPermissionError(\n          \"Only admins can make private transactions in groups\",\n        );\n        continue;\n      }\n    }\n\n    let changes;\n\n    try {\n      changes = parseJSON(tx.changes);\n    } catch (e) {\n      logPermissionError(\"Invalid JSON in transaction\", {\n        id: coValue.id,\n        tx,\n      });\n      continue;\n    }\n\n    const change = changes[0] as\n      | MapOpPayload<RawAccountID | AgentID | Everyone, Role>\n      | MapOpPayload<\"readKey\", JsonValue>\n      | MapOpPayload<\"profile\", CoID<RawProfile>>\n      | MapOpPayload<`parent_${CoID<RawGroup>}`, CoID<RawGroup>>\n      | MapOpPayload<`child_${CoID<RawGroup>}`, CoID<RawGroup>>;\n\n    if (changes.length !== 1) {\n      logPermissionError(\"Group transaction must have exactly one change\");\n      continue;\n    }\n\n    if (change.op !== \"set\") {\n      logPermissionError(\"Group transaction must set a role or readKey\");\n      continue;\n    }\n\n    if (change.key === \"readKey\") {\n      if (memberState[transactor] !== \"admin\") {\n        logPermissionError(\"Only admins can set readKeys\");\n        continue;\n      }\n\n      validTransactions.push({ txID: { sessionID, txIndex }, tx });\n      continue;\n    } else if (change.key === \"profile\") {\n      if (memberState[transactor] !== \"admin\") {\n        logPermissionError(\"Only admins can set profile\");\n        continue;\n      }\n\n      validTransactions.push({ txID: { sessionID, txIndex }, tx });\n      continue;\n    } else if (\n      isKeyForKeyField(change.key) ||\n      isKeyForAccountField(change.key)\n    ) {\n      if (\n        memberState[transactor] !== \"admin\" &&\n        memberState[transactor] !== \"adminInvite\" &&\n        memberState[transactor] !== \"writerInvite\" &&\n        memberState[transactor] !== \"readerInvite\" &&\n        memberState[transactor] !== \"writeOnlyInvite\" &&\n        !isOwnWriteKeyRevelation(change.key, transactor, writeOnlyKeys)\n      ) {\n        logPermissionError(\"Only admins can reveal keys\");\n        continue;\n      }\n\n      /**\n       * We don't want to give the ability to invite members to override\n       * key revelations, otherwise they could hide a key revelation to any user\n       * blocking them from accessing the group.\n       */\n      if (\n        keyRevelations.has(change.key) &&\n        memberState[transactor] !== \"admin\"\n      ) {\n        logPermissionError(\n          \"Key revelation already exists and can't be overridden by invite\",\n        );\n        continue;\n      }\n\n      keyRevelations.add(change.key);\n\n      // TODO: check validity of agents who the key is revealed to?\n      validTransactions.push({ txID: { sessionID, txIndex }, tx });\n      continue;\n    } else if (isParentExtension(change.key)) {\n      if (memberState[transactor] !== \"admin\") {\n        logPermissionError(\"Only admins can set parent extensions\");\n        continue;\n      }\n\n      extendChain = extendChain ?? new Set([]);\n\n      resolveMemberStateFromParentReference(\n        coValue,\n        memberState,\n        change.key,\n        change.value as ParentGroupReferenceRole,\n        extendChain,\n      );\n\n      // Circular reference detected, drop all the transactions involved\n      if (extendChain.has(coValue.id)) {\n        logPermissionError(\n          \"Circular extend detected, dropping the transaction\",\n        );\n        continue;\n      }\n\n      validTransactions.push({ txID: { sessionID, txIndex }, tx });\n      continue;\n    } else if (isChildExtension(change.key)) {\n      if (\n        memberState[transactor] !== \"admin\" &&\n        memberState[transactor] !== \"writer\" &&\n        memberState[transactor] !== \"reader\" &&\n        memberState[transactor] !== \"writeOnly\"\n      ) {\n        logPermissionError(\n          \"Only admins, writers, readers and writeOnly can set child extensions\",\n        );\n        continue;\n      }\n\n      validTransactions.push({ txID: { sessionID, txIndex }, tx });\n      continue;\n    } else if (isWriteKeyForMember(change.key)) {\n      const memberKey = getAccountOrAgentFromWriteKeyForMember(change.key);\n\n      if (\n        memberState[transactor] !== \"admin\" &&\n        memberState[transactor] !== \"writeOnlyInvite\" &&\n        memberKey !== transactor\n      ) {\n        logPermissionError(\"Only admins can set writeKeys\");\n        continue;\n      }\n\n      writeOnlyKeys[memberKey] = change.value as KeyID;\n\n      /**\n       * writeOnlyInvite need to be able to set writeKeys because every new writeOnly\n       * member comes with their own write key.\n       *\n       * We don't want to give the ability to invite members to override\n       * write keys, otherwise they could hide a write key to other writeOnly users\n       * blocking them from accessing the group.\n       */\n      if (writeKeys.has(change.key) && memberState[transactor] !== \"admin\") {\n        logPermissionError(\n          \"Write key already exists and can't be overridden by invite\",\n        );\n        continue;\n      }\n\n      writeKeys.add(change.key);\n\n      validTransactions.push({ txID: { sessionID, txIndex }, tx });\n      continue;\n    }\n\n    const affectedMember = change.key;\n    const assignedRole = change.value;\n\n    if (\n      change.value !== \"admin\" &&\n      change.value !== \"writer\" &&\n      change.value !== \"reader\" &&\n      change.value !== \"writeOnly\" &&\n      change.value !== \"revoked\" &&\n      change.value !== \"adminInvite\" &&\n      change.value !== \"writerInvite\" &&\n      change.value !== \"readerInvite\" &&\n      change.value !== \"writeOnlyInvite\"\n    ) {\n      logPermissionError(\"Group transaction must set a valid role\");\n      continue;\n    }\n\n    if (\n      affectedMember === EVERYONE &&\n      !(\n        change.value === \"reader\" ||\n        change.value === \"writer\" ||\n        change.value === \"writeOnly\" ||\n        change.value === \"revoked\"\n      )\n    ) {\n      logPermissionError(\n        \"Everyone can only be set to reader, writer, writeOnly or revoked\",\n      );\n      continue;\n    }\n\n    const isFirstSelfAppointment =\n      !memberState[transactor] &&\n      transactor === initialAdmin &&\n      change.op === \"set\" &&\n      change.key === transactor &&\n      change.value === \"admin\";\n\n    if (!isFirstSelfAppointment) {\n      if (memberState[transactor] === \"admin\") {\n        if (\n          memberState[affectedMember] === \"admin\" &&\n          affectedMember !== transactor &&\n          assignedRole !== \"admin\"\n        ) {\n          logPermissionError(\"Admins can only demote themselves.\");\n          continue;\n        }\n      } else if (memberState[transactor] === \"adminInvite\") {\n        if (change.value !== \"admin\") {\n          logPermissionError(\"AdminInvites can only create admins.\");\n          continue;\n        }\n      } else if (memberState[transactor] === \"writerInvite\") {\n        if (change.value !== \"writer\") {\n          logPermissionError(\"WriterInvites can only create writers.\");\n          continue;\n        }\n      } else if (memberState[transactor] === \"readerInvite\") {\n        if (change.value !== \"reader\") {\n          logPermissionError(\"ReaderInvites can only create reader.\");\n          continue;\n        }\n      } else if (memberState[transactor] === \"writeOnlyInvite\") {\n        if (change.value !== \"writeOnly\") {\n          logPermissionError(\"WriteOnlyInvites can only create writeOnly.\");\n          continue;\n        }\n      } else {\n        logPermissionError(\n          \"Group transaction must be made by current admin or invite\",\n        );\n        continue;\n      }\n    }\n\n    memberState[affectedMember] = change.value;\n    validTransactions.push({ txID: { sessionID, txIndex }, tx });\n  }\n\n  return { validTransactions, memberState };\n}\n\nfunction agentInAccountOrMemberInGroup(\n  transactor: RawAccountID | AgentID,\n  groupAtTime: RawGroup,\n): RawAccountID | AgentID | undefined {\n  if (transactor === groupAtTime.id && groupAtTime instanceof RawAccount) {\n    return groupAtTime.currentAgentID();\n  }\n  return transactor;\n}\n\nexport function isWriteKeyForMember(\n  co: string,\n): co is `writeKeyFor_${RawAccountID | AgentID}` {\n  return co.startsWith(\"writeKeyFor_\");\n}\n\nexport function getAccountOrAgentFromWriteKeyForMember(\n  co: `writeKeyFor_${RawAccountID | AgentID}`,\n): RawAccountID | AgentID {\n  return co.slice(\"writeKeyFor_\".length) as RawAccountID | AgentID;\n}\n\nexport function isKeyForKeyField(co: string): co is `${KeyID}_for_${KeyID}` {\n  return co.startsWith(\"key_\") && co.includes(\"_for_key\");\n}\n\nexport function isKeyForAccountField(\n  co: string,\n): co is `${KeyID}_for_${RawAccountID | AgentID}` {\n  return (\n    (co.startsWith(\"key_\") &&\n      (co.includes(\"_for_sealer\") || co.includes(\"_for_co\"))) ||\n    co.includes(\"_for_everyone\")\n  );\n}\n\nfunction isParentExtension(key: string): key is `parent_${CoID<RawGroup>}` {\n  return key.startsWith(\"parent_\");\n}\n\nfunction isChildExtension(key: string): key is `child_${CoID<RawGroup>}` {\n  return key.startsWith(\"child_\");\n}\n\nfunction isOwnWriteKeyRevelation(\n  key: `${KeyID}_for_${string}`,\n  memberKey: RawAccountID | AgentID,\n  writeOnlyKeys: Record<RawAccountID | AgentID, KeyID>,\n): key is `${KeyID}_for_${RawAccountID | AgentID}` {\n  if (Object.keys(writeOnlyKeys).length === 0) {\n    return false;\n  }\n\n  const keyID = key.slice(0, key.indexOf(\"_for_\"));\n\n  return writeOnlyKeys[memberKey] === keyID;\n}\n", "import { type CoValueHeader } from \"./coValueCore.js\";\n\n/**\n * The priority of a `CoValue` determines how much priority is given\n * to its content messages.\n *\n * The priority value is handled as weight in the weighed round robin algorithm\n * used to determine the order in which messages are sent.\n *\n * Loosely follows the HTTP urgency range and order, but limited to 3 values:\n *  - https://www.rfc-editor.org/rfc/rfc9218.html#name-urgency\n */\nexport const CO_VALUE_PRIORITY = {\n  HIGH: 0,\n  MEDIUM: 3,\n  LOW: 6,\n} as const;\n\nexport type CoValuePriority = 0 | 3 | 6;\n\nexport function getPriorityFromHeader(\n  header: CoValueHeader | undefined | boolean,\n): CoValuePriority {\n  if (typeof header === \"boolean\" || !header) {\n    return CO_VALUE_PRIORITY.MEDIUM;\n  }\n\n  if (header.meta?.type === \"account\") {\n    return CO_VALUE_PRIORITY.HIGH;\n  }\n\n  if (header.ruleset.type === \"group\") {\n    return CO_VALUE_PRIORITY.HIGH;\n  }\n\n  if (header.type === \"costream\" && header.meta?.type === \"binary\") {\n    return CO_VALUE_PRIORITY.LOW;\n  }\n\n  return CO_VALUE_PRIORITY.MEDIUM;\n}\n", "import { Result, err, ok } from \"neverthrow\";\nimport { AnyRawCoValue, RawCoValue } from \"./coValue.js\";\nimport { ControlledAccountOrAgent, RawAccountID } from \"./coValues/account.js\";\nimport { RawGroup } from \"./coValues/group.js\";\nimport { coreToCoValue } from \"./coreToCoValue.js\";\nimport {\n  CryptoProvider,\n  Encrypted,\n  Hash,\n  KeyID,\n  KeySecret,\n  Signature,\n  SignerID,\n  StreamingHash,\n} from \"./crypto/crypto.js\";\nimport {\n  RawCoID,\n  SessionID,\n  TransactionID,\n  getGroupDependentKeyList,\n  getParentGroupId,\n  isParentGroupReference,\n} from \"./ids.js\";\nimport { Stringified, parseJSON, stableStringify } from \"./jsonStringify.js\";\nimport { JsonObject, JsonValue } from \"./jsonValue.js\";\nimport { LocalNode, ResolveAccountAgentError } from \"./localNode.js\";\nimport { logger } from \"./logger.js\";\nimport {\n  PermissionsDef as RulesetDef,\n  determineValidTransactions,\n  isKeyForKeyField,\n} from \"./permissions.js\";\nimport { getPriorityFromHeader } from \"./priority.js\";\nimport { CoValueKnownState, NewContentMessage } from \"./sync.js\";\nimport { accountOrAgentIDfromSessionID } from \"./typeUtils/accountOrAgentIDfromSessionID.js\";\nimport { expectGroup } from \"./typeUtils/expectGroup.js\";\nimport { isAccountID } from \"./typeUtils/isAccountID.js\";\n\n/**\n    In order to not block other concurrently syncing CoValues we introduce a maximum size of transactions,\n    since they are the smallest unit of progress that can be synced within a CoValue.\n    This is particularly important for storing binary data in CoValues, since they are likely to be at least on the order of megabytes.\n    This also means that we want to keep signatures roughly after each MAX_RECOMMENDED_TX size chunk,\n    to be able to verify partially loaded CoValues or CoValues that are still being created (like a video live stream).\n**/\nexport const MAX_RECOMMENDED_TX_SIZE = 100 * 1024;\n\nexport type CoValueHeader = {\n  type: AnyRawCoValue[\"type\"];\n  ruleset: RulesetDef;\n  meta: JsonObject | null;\n} & CoValueUniqueness;\n\nexport type CoValueUniqueness = {\n  uniqueness: JsonValue;\n  createdAt?: `2${string}` | null;\n};\n\nexport function idforHeader(\n  header: CoValueHeader,\n  crypto: CryptoProvider,\n): RawCoID {\n  const hash = crypto.shortHash(header);\n  return `co_z${hash.slice(\"shortHash_z\".length)}`;\n}\n\ntype SessionLog = {\n  transactions: Transaction[];\n  lastHash?: Hash;\n  streamingHash: StreamingHash;\n  signatureAfter: { [txIdx: number]: Signature | undefined };\n  lastSignature: Signature;\n};\n\nexport type PrivateTransaction = {\n  privacy: \"private\";\n  madeAt: number;\n  keyUsed: KeyID;\n  encryptedChanges: Encrypted<JsonValue[], { in: RawCoID; tx: TransactionID }>;\n};\n\nexport type TrustingTransaction = {\n  privacy: \"trusting\";\n  madeAt: number;\n  changes: Stringified<JsonValue[]>;\n};\n\nexport type Transaction = PrivateTransaction | TrustingTransaction;\n\nexport type DecryptedTransaction = {\n  txID: TransactionID;\n  changes: JsonValue[];\n  madeAt: number;\n};\n\nconst readKeyCache = new WeakMap<CoValueCore, { [id: KeyID]: KeySecret }>();\n\nexport class CoValueCore {\n  id: RawCoID;\n  node: LocalNode;\n  crypto: CryptoProvider;\n  header: CoValueHeader;\n  _sessionLogs: Map<SessionID, SessionLog>;\n  _cachedContent?: RawCoValue;\n  listeners: Set<(content?: RawCoValue) => void> = new Set();\n  _decryptionCache: {\n    [key: Encrypted<JsonValue[], JsonValue>]: JsonValue[] | undefined;\n  } = {};\n  _cachedKnownState?: CoValueKnownState;\n  _cachedDependentOn?: RawCoID[];\n  _cachedNewContentSinceEmpty?: NewContentMessage[] | undefined;\n  _currentAsyncAddTransaction?: Promise<void>;\n\n  constructor(\n    header: CoValueHeader,\n    node: LocalNode,\n    internalInitSessions: Map<SessionID, SessionLog> = new Map(),\n  ) {\n    this.crypto = node.crypto;\n    this.id = idforHeader(header, node.crypto);\n    this.header = header;\n    this._sessionLogs = internalInitSessions;\n    this.node = node;\n  }\n\n  groupInvalidationSubscription?: () => void;\n\n  subscribeToGroupInvalidation() {\n    if (this.groupInvalidationSubscription) {\n      return;\n    }\n\n    const header = this.header;\n\n    if (header.ruleset.type == \"ownedByGroup\") {\n      const groupId = header.ruleset.group;\n      const entry = this.node.coValuesStore.get(groupId);\n\n      if (entry.isAvailable()) {\n        this.groupInvalidationSubscription = entry.core.subscribe(\n          (_groupUpdate) => {\n            this._cachedContent = undefined;\n            this.notifyUpdate(\"immediate\");\n          },\n          false,\n        );\n      } else {\n        logger.error(\"CoValueCore: Owner group not available\", {\n          id: this.id,\n          groupId,\n        });\n      }\n    }\n  }\n\n  get sessionLogs(): Map<SessionID, SessionLog> {\n    return this._sessionLogs;\n  }\n\n  testWithDifferentAccount(\n    account: ControlledAccountOrAgent,\n    currentSessionID: SessionID,\n  ): CoValueCore {\n    const newNode = this.node.testWithDifferentAccount(\n      account,\n      currentSessionID,\n    );\n\n    return newNode.expectCoValueLoaded(this.id);\n  }\n\n  knownState(): CoValueKnownState {\n    if (this._cachedKnownState) {\n      return this._cachedKnownState;\n    } else {\n      const knownState = this.knownStateUncached();\n      this._cachedKnownState = knownState;\n      return knownState;\n    }\n  }\n\n  /** @internal */\n  knownStateUncached(): CoValueKnownState {\n    const sessions: CoValueKnownState[\"sessions\"] = {};\n\n    for (const [sessionID, sessionLog] of this.sessionLogs.entries()) {\n      sessions[sessionID] = sessionLog.transactions.length;\n    }\n\n    return {\n      id: this.id,\n      header: true,\n      sessions,\n    };\n  }\n\n  get meta(): JsonValue {\n    return this.header?.meta ?? null;\n  }\n\n  nextTransactionID(): TransactionID {\n    // This is an ugly hack to get a unique but stable session ID for editing the current account\n    const sessionID =\n      this.header.meta?.type === \"account\"\n        ? (this.node.currentSessionID.replace(\n            this.node.account.id,\n            this.node.account.currentAgentID(),\n          ) as SessionID)\n        : this.node.currentSessionID;\n\n    return {\n      sessionID,\n      txIndex: this.sessionLogs.get(sessionID)?.transactions.length || 0,\n    };\n  }\n\n  tryAddTransactions(\n    sessionID: SessionID,\n    newTransactions: Transaction[],\n    givenExpectedNewHash: Hash | undefined,\n    newSignature: Signature,\n    skipVerify: boolean = false,\n    givenNewStreamingHash?: StreamingHash,\n  ): Result<true, TryAddTransactionsError> {\n    return this.node\n      .resolveAccountAgent(\n        accountOrAgentIDfromSessionID(sessionID),\n        \"Expected to know signer of transaction\",\n      )\n      .andThen((agent) => {\n        const signerID = this.crypto.getAgentSignerID(agent);\n\n        if (\n          skipVerify === true &&\n          givenNewStreamingHash &&\n          givenExpectedNewHash\n        ) {\n          this.doAddTransactions(\n            sessionID,\n            newTransactions,\n            newSignature,\n            givenExpectedNewHash,\n            givenNewStreamingHash,\n            \"immediate\",\n          );\n        } else {\n          const { expectedNewHash, newStreamingHash } =\n            this.expectedNewHashAfter(sessionID, newTransactions);\n\n          if (\n            givenExpectedNewHash &&\n            givenExpectedNewHash !== expectedNewHash\n          ) {\n            return err({\n              type: \"InvalidHash\",\n              id: this.id,\n              expectedNewHash,\n              givenExpectedNewHash,\n            } satisfies InvalidHashError);\n          }\n\n          if (!this.crypto.verify(newSignature, expectedNewHash, signerID)) {\n            return err({\n              type: \"InvalidSignature\",\n              id: this.id,\n              newSignature,\n              sessionID,\n              signerID,\n            } satisfies InvalidSignatureError);\n          }\n\n          this.doAddTransactions(\n            sessionID,\n            newTransactions,\n            newSignature,\n            expectedNewHash,\n            newStreamingHash,\n            \"immediate\",\n          );\n        }\n\n        return ok(true as const);\n      });\n  }\n\n  private doAddTransactions(\n    sessionID: SessionID,\n    newTransactions: Transaction[],\n    newSignature: Signature,\n    expectedNewHash: Hash,\n    newStreamingHash: StreamingHash,\n    notifyMode: \"immediate\" | \"deferred\",\n  ) {\n    if (this.node.crashed) {\n      throw new Error(\"Trying to add transactions after node is crashed\");\n    }\n    const transactions = this.sessionLogs.get(sessionID)?.transactions ?? [];\n\n    for (const tx of newTransactions) {\n      transactions.push(tx);\n    }\n\n    const signatureAfter =\n      this.sessionLogs.get(sessionID)?.signatureAfter ?? {};\n\n    const lastInbetweenSignatureIdx = Object.keys(signatureAfter).reduce(\n      (max, idx) => (parseInt(idx) > max ? parseInt(idx) : max),\n      -1,\n    );\n\n    const sizeOfTxsSinceLastInbetweenSignature = transactions\n      .slice(lastInbetweenSignatureIdx + 1)\n      .reduce(\n        (sum, tx) =>\n          sum +\n          (tx.privacy === \"private\"\n            ? tx.encryptedChanges.length\n            : tx.changes.length),\n        0,\n      );\n\n    if (sizeOfTxsSinceLastInbetweenSignature > MAX_RECOMMENDED_TX_SIZE) {\n      signatureAfter[transactions.length - 1] = newSignature;\n    }\n\n    this._sessionLogs.set(sessionID, {\n      transactions,\n      lastHash: expectedNewHash,\n      streamingHash: newStreamingHash,\n      lastSignature: newSignature,\n      signatureAfter: signatureAfter,\n    });\n\n    if (\n      this._cachedContent &&\n      \"processNewTransactions\" in this._cachedContent &&\n      typeof this._cachedContent.processNewTransactions === \"function\"\n    ) {\n      this._cachedContent.processNewTransactions();\n    } else {\n      this._cachedContent = undefined;\n    }\n\n    this._cachedKnownState = undefined;\n    this._cachedDependentOn = undefined;\n    this._cachedNewContentSinceEmpty = undefined;\n\n    this.notifyUpdate(notifyMode);\n  }\n\n  deferredUpdates = 0;\n  nextDeferredNotify: Promise<void> | undefined;\n\n  notifyUpdate(notifyMode: \"immediate\" | \"deferred\") {\n    if (this.listeners.size === 0) {\n      return;\n    }\n\n    if (notifyMode === \"immediate\") {\n      const content = this.getCurrentContent();\n      for (const listener of this.listeners) {\n        try {\n          listener(content);\n        } catch (e) {\n          logger.error(\"Error in listener for coValue \" + this.id, { err: e });\n        }\n      }\n    } else {\n      if (!this.nextDeferredNotify) {\n        this.nextDeferredNotify = new Promise((resolve) => {\n          setTimeout(() => {\n            this.nextDeferredNotify = undefined;\n            this.deferredUpdates = 0;\n            const content = this.getCurrentContent();\n            for (const listener of this.listeners) {\n              try {\n                listener(content);\n              } catch (e) {\n                logger.error(\"Error in listener for coValue \" + this.id, {\n                  err: e,\n                });\n              }\n            }\n            resolve();\n          }, 0);\n        });\n      }\n      this.deferredUpdates++;\n    }\n  }\n\n  subscribe(\n    listener: (content?: RawCoValue) => void,\n    immediateInvoke = true,\n  ): () => void {\n    this.listeners.add(listener);\n\n    if (immediateInvoke) {\n      listener(this.getCurrentContent());\n    }\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  expectedNewHashAfter(\n    sessionID: SessionID,\n    newTransactions: Transaction[],\n  ): { expectedNewHash: Hash; newStreamingHash: StreamingHash } {\n    const streamingHash =\n      this.sessionLogs.get(sessionID)?.streamingHash.clone() ??\n      new StreamingHash(this.crypto);\n\n    for (const transaction of newTransactions) {\n      streamingHash.update(transaction);\n    }\n\n    return {\n      expectedNewHash: streamingHash.digest(),\n      newStreamingHash: streamingHash,\n    };\n  }\n\n  makeTransaction(\n    changes: JsonValue[],\n    privacy: \"private\" | \"trusting\",\n  ): boolean {\n    const madeAt = Date.now();\n\n    let transaction: Transaction;\n\n    if (privacy === \"private\") {\n      const { secret: keySecret, id: keyID } = this.getCurrentReadKey();\n\n      if (!keySecret) {\n        throw new Error(\"Can't make transaction without read key secret\");\n      }\n\n      const encrypted = this.crypto.encryptForTransaction(changes, keySecret, {\n        in: this.id,\n        tx: this.nextTransactionID(),\n      });\n\n      this._decryptionCache[encrypted] = changes;\n\n      transaction = {\n        privacy: \"private\",\n        madeAt,\n        keyUsed: keyID,\n        encryptedChanges: encrypted,\n      };\n    } else {\n      transaction = {\n        privacy: \"trusting\",\n        madeAt,\n        changes: stableStringify(changes),\n      };\n    }\n\n    // This is an ugly hack to get a unique but stable session ID for editing the current account\n    const sessionID =\n      this.header.meta?.type === \"account\"\n        ? (this.node.currentSessionID.replace(\n            this.node.account.id,\n            this.node.account.currentAgentID(),\n          ) as SessionID)\n        : this.node.currentSessionID;\n\n    const { expectedNewHash, newStreamingHash } = this.expectedNewHashAfter(\n      sessionID,\n      [transaction],\n    );\n\n    const signature = this.crypto.sign(\n      this.node.account.currentSignerSecret(),\n      expectedNewHash,\n    );\n\n    const success = this.tryAddTransactions(\n      sessionID,\n      [transaction],\n      expectedNewHash,\n      signature,\n      true,\n      newStreamingHash,\n    )._unsafeUnwrap({ withStackTrace: true });\n\n    if (success) {\n      this.node.syncManager.recordTransactionsSize([transaction], \"local\");\n      void this.node.syncManager.requestCoValueSync(this);\n    }\n\n    return success;\n  }\n\n  getCurrentContent(options?: {\n    ignorePrivateTransactions: true;\n  }): RawCoValue {\n    if (!options?.ignorePrivateTransactions && this._cachedContent) {\n      return this._cachedContent;\n    }\n\n    this.subscribeToGroupInvalidation();\n\n    const newContent = coreToCoValue(this, options);\n\n    if (!options?.ignorePrivateTransactions) {\n      this._cachedContent = newContent;\n    }\n\n    return newContent;\n  }\n\n  getValidTransactions(options?: {\n    ignorePrivateTransactions: boolean;\n    knownTransactions?: CoValueKnownState[\"sessions\"];\n  }): DecryptedTransaction[] {\n    const validTransactions = determineValidTransactions(\n      this,\n      options?.knownTransactions,\n    );\n\n    const allTransactions: DecryptedTransaction[] = [];\n\n    for (const { txID, tx } of validTransactions) {\n      if (options?.knownTransactions?.[txID.sessionID]! >= txID.txIndex) {\n        continue;\n      }\n\n      if (tx.privacy === \"trusting\") {\n        allTransactions.push({\n          txID,\n          madeAt: tx.madeAt,\n          changes: parseJSON(tx.changes),\n        });\n        continue;\n      }\n\n      if (options?.ignorePrivateTransactions) {\n        continue;\n      }\n\n      const readKey = this.getReadKey(tx.keyUsed);\n\n      if (!readKey) {\n        continue;\n      }\n\n      let decryptedChanges = this._decryptionCache[tx.encryptedChanges];\n\n      if (!decryptedChanges) {\n        const decryptedString = this.crypto.decryptRawForTransaction(\n          tx.encryptedChanges,\n          readKey,\n          {\n            in: this.id,\n            tx: txID,\n          },\n        );\n        decryptedChanges = decryptedString && parseJSON(decryptedString);\n        this._decryptionCache[tx.encryptedChanges] = decryptedChanges;\n      }\n\n      if (!decryptedChanges) {\n        logger.error(\"Failed to decrypt transaction despite having key\", {\n          err: new Error(\"Failed to decrypt transaction despite having key\"),\n        });\n        continue;\n      }\n\n      allTransactions.push({\n        txID,\n        madeAt: tx.madeAt,\n        changes: decryptedChanges,\n      });\n    }\n\n    return allTransactions;\n  }\n\n  getValidSortedTransactions(options?: {\n    ignorePrivateTransactions: boolean;\n    knownTransactions: CoValueKnownState[\"sessions\"];\n  }): DecryptedTransaction[] {\n    const allTransactions = this.getValidTransactions(options);\n\n    allTransactions.sort(this.compareTransactions);\n\n    return allTransactions;\n  }\n\n  compareTransactions(\n    a: Pick<DecryptedTransaction, \"madeAt\" | \"txID\">,\n    b: Pick<DecryptedTransaction, \"madeAt\" | \"txID\">,\n  ) {\n    return (\n      a.madeAt - b.madeAt ||\n      (a.txID.sessionID === b.txID.sessionID\n        ? 0\n        : a.txID.sessionID < b.txID.sessionID\n          ? -1\n          : 1) ||\n      a.txID.txIndex - b.txID.txIndex\n    );\n  }\n\n  getCurrentReadKey(): { secret: KeySecret | undefined; id: KeyID } {\n    if (this.header.ruleset.type === \"group\") {\n      const content = expectGroup(this.getCurrentContent());\n\n      const currentKeyId = content.getCurrentReadKeyId();\n\n      if (!currentKeyId) {\n        throw new Error(\"No readKey set\");\n      }\n\n      const secret = this.getReadKey(currentKeyId);\n\n      return {\n        secret: secret,\n        id: currentKeyId,\n      };\n    } else if (this.header.ruleset.type === \"ownedByGroup\") {\n      return this.node\n        .expectCoValueLoaded(this.header.ruleset.group)\n        .getCurrentReadKey();\n    } else {\n      throw new Error(\n        \"Only groups or values owned by groups have read secrets\",\n      );\n    }\n  }\n\n  getReadKey(keyID: KeyID): KeySecret | undefined {\n    let key = readKeyCache.get(this)?.[keyID];\n    if (!key) {\n      key = this.getUncachedReadKey(keyID);\n      if (key) {\n        let cache = readKeyCache.get(this);\n        if (!cache) {\n          cache = {};\n          readKeyCache.set(this, cache);\n        }\n        cache[keyID] = key;\n      }\n    }\n    return key;\n  }\n\n  getUncachedReadKey(keyID: KeyID): KeySecret | undefined {\n    if (this.header.ruleset.type === \"group\") {\n      const content = expectGroup(\n        this.getCurrentContent({ ignorePrivateTransactions: true }),\n      );\n\n      const keyForEveryone = content.get(`${keyID}_for_everyone`);\n      if (keyForEveryone) return keyForEveryone;\n\n      // Try to find key revelation for us\n      const lookupAccountOrAgentID =\n        this.header.meta?.type === \"account\"\n          ? this.node.account.currentAgentID()\n          : this.node.account.id;\n\n      const lastReadyKeyEdit = content.lastEditAt(\n        `${keyID}_for_${lookupAccountOrAgentID}`,\n      );\n\n      if (lastReadyKeyEdit?.value) {\n        const revealer = lastReadyKeyEdit.by;\n        const revealerAgent = this.node\n          .resolveAccountAgent(revealer, \"Expected to know revealer\")\n          ._unsafeUnwrap({ withStackTrace: true });\n\n        const secret = this.crypto.unseal(\n          lastReadyKeyEdit.value,\n          this.node.account.currentSealerSecret(),\n          this.crypto.getAgentSealerID(revealerAgent),\n          {\n            in: this.id,\n            tx: lastReadyKeyEdit.tx,\n          },\n        );\n\n        if (secret) {\n          return secret as KeySecret;\n        }\n      }\n\n      // Try to find indirect revelation through previousKeys\n\n      for (const co of content.keys()) {\n        if (isKeyForKeyField(co) && co.startsWith(keyID)) {\n          const encryptingKeyID = co.split(\"_for_\")[1] as KeyID;\n          const encryptingKeySecret = this.getReadKey(encryptingKeyID);\n\n          if (!encryptingKeySecret) {\n            continue;\n          }\n\n          const encryptedPreviousKey = content.get(co)!;\n\n          const secret = this.crypto.decryptKeySecret(\n            {\n              encryptedID: keyID,\n              encryptingID: encryptingKeyID,\n              encrypted: encryptedPreviousKey,\n            },\n            encryptingKeySecret,\n          );\n\n          if (secret) {\n            return secret as KeySecret;\n          } else {\n            logger.warn(\n              `Encrypting ${encryptingKeyID} key didn't decrypt ${keyID}`,\n            );\n          }\n        }\n      }\n\n      // try to find revelation to parent group read keys\n      for (const co of content.keys()) {\n        if (isParentGroupReference(co)) {\n          const parentGroupID = getParentGroupId(co);\n          const parentGroup = this.node.expectCoValueLoaded(\n            parentGroupID,\n            \"Expected parent group to be loaded\",\n          );\n\n          const parentKeys = this.findValidParentKeys(\n            keyID,\n            content,\n            parentGroup,\n          );\n\n          for (const parentKey of parentKeys) {\n            const revelationForParentKey = content.get(\n              `${keyID}_for_${parentKey.id}`,\n            );\n\n            if (revelationForParentKey) {\n              const secret = parentGroup.crypto.decryptKeySecret(\n                {\n                  encryptedID: keyID,\n                  encryptingID: parentKey.id,\n                  encrypted: revelationForParentKey,\n                },\n                parentKey.secret,\n              );\n\n              if (secret) {\n                return secret as KeySecret;\n              } else {\n                logger.warn(\n                  `Encrypting parent ${parentKey.id} key didn't decrypt ${keyID}`,\n                );\n              }\n            }\n          }\n        }\n      }\n\n      return undefined;\n    } else if (this.header.ruleset.type === \"ownedByGroup\") {\n      return this.node\n        .expectCoValueLoaded(this.header.ruleset.group)\n        .getReadKey(keyID);\n    } else {\n      throw new Error(\n        \"Only groups or values owned by groups have read secrets\",\n      );\n    }\n  }\n\n  findValidParentKeys(keyID: KeyID, group: RawGroup, parentGroup: CoValueCore) {\n    const validParentKeys: { id: KeyID; secret: KeySecret }[] = [];\n\n    for (const co of group.keys()) {\n      if (isKeyForKeyField(co) && co.startsWith(keyID)) {\n        const encryptingKeyID = co.split(\"_for_\")[1] as KeyID;\n        const encryptingKeySecret = parentGroup.getReadKey(encryptingKeyID);\n\n        if (!encryptingKeySecret) {\n          continue;\n        }\n\n        validParentKeys.push({\n          id: encryptingKeyID,\n          secret: encryptingKeySecret,\n        });\n      }\n    }\n\n    return validParentKeys;\n  }\n\n  getGroup(): RawGroup {\n    if (this.header.ruleset.type !== \"ownedByGroup\") {\n      throw new Error(\"Only values owned by groups have groups\");\n    }\n\n    return expectGroup(\n      this.node\n        .expectCoValueLoaded(this.header.ruleset.group)\n        .getCurrentContent(),\n    );\n  }\n\n  getTx(txID: TransactionID): Transaction | undefined {\n    return this.sessionLogs.get(txID.sessionID)?.transactions[txID.txIndex];\n  }\n\n  newContentSince(\n    knownState: CoValueKnownState | undefined,\n  ): NewContentMessage[] | undefined {\n    const isKnownStateEmpty = !knownState?.header && !knownState?.sessions;\n\n    if (isKnownStateEmpty && this._cachedNewContentSinceEmpty) {\n      return this._cachedNewContentSinceEmpty;\n    }\n\n    let currentPiece: NewContentMessage = {\n      action: \"content\",\n      id: this.id,\n      header: knownState?.header ? undefined : this.header,\n      priority: getPriorityFromHeader(this.header),\n      new: {},\n    };\n\n    const pieces = [currentPiece];\n\n    const sentState: CoValueKnownState[\"sessions\"] = {};\n\n    let pieceSize = 0;\n\n    let sessionsTodoAgain: Set<SessionID> | undefined | \"first\" = \"first\";\n\n    while (sessionsTodoAgain === \"first\" || sessionsTodoAgain?.size || 0 > 0) {\n      if (sessionsTodoAgain === \"first\") {\n        sessionsTodoAgain = undefined;\n      }\n      const sessionsTodo = sessionsTodoAgain ?? this.sessionLogs.keys();\n\n      for (const sessionIDKey of sessionsTodo) {\n        const sessionID = sessionIDKey as SessionID;\n        const log = this.sessionLogs.get(sessionID)!;\n        const knownStateForSessionID = knownState?.sessions[sessionID];\n        const sentStateForSessionID = sentState[sessionID];\n        const nextKnownSignatureIdx = getNextKnownSignatureIdx(\n          log,\n          knownStateForSessionID,\n          sentStateForSessionID,\n        );\n\n        const firstNewTxIdx =\n          sentStateForSessionID ?? knownStateForSessionID ?? 0;\n        const afterLastNewTxIdx =\n          nextKnownSignatureIdx === undefined\n            ? log.transactions.length\n            : nextKnownSignatureIdx + 1;\n\n        const nNewTx = Math.max(0, afterLastNewTxIdx - firstNewTxIdx);\n\n        if (nNewTx === 0) {\n          sessionsTodoAgain?.delete(sessionID);\n          continue;\n        }\n\n        if (afterLastNewTxIdx < log.transactions.length) {\n          if (!sessionsTodoAgain) {\n            sessionsTodoAgain = new Set();\n          }\n          sessionsTodoAgain.add(sessionID);\n        }\n\n        const oldPieceSize = pieceSize;\n        for (let txIdx = firstNewTxIdx; txIdx < afterLastNewTxIdx; txIdx++) {\n          const tx = log.transactions[txIdx]!;\n          pieceSize +=\n            tx.privacy === \"private\"\n              ? tx.encryptedChanges.length\n              : tx.changes.length;\n        }\n\n        if (pieceSize >= MAX_RECOMMENDED_TX_SIZE) {\n          currentPiece = {\n            action: \"content\",\n            id: this.id,\n            header: undefined,\n            new: {},\n            priority: getPriorityFromHeader(this.header),\n          };\n          pieces.push(currentPiece);\n          pieceSize = pieceSize - oldPieceSize;\n        }\n\n        let sessionEntry = currentPiece.new[sessionID];\n        if (!sessionEntry) {\n          sessionEntry = {\n            after: sentStateForSessionID ?? knownStateForSessionID ?? 0,\n            newTransactions: [],\n            lastSignature: \"WILL_BE_REPLACED\" as Signature,\n          };\n          currentPiece.new[sessionID] = sessionEntry;\n        }\n\n        for (let txIdx = firstNewTxIdx; txIdx < afterLastNewTxIdx; txIdx++) {\n          const tx = log.transactions[txIdx]!;\n          sessionEntry.newTransactions.push(tx);\n        }\n\n        sessionEntry.lastSignature =\n          nextKnownSignatureIdx === undefined\n            ? log.lastSignature!\n            : log.signatureAfter[nextKnownSignatureIdx]!;\n\n        sentState[sessionID] =\n          (sentStateForSessionID ?? knownStateForSessionID ?? 0) + nNewTx;\n      }\n    }\n\n    const piecesWithContent = pieces.filter(\n      (piece) => Object.keys(piece.new).length > 0 || piece.header,\n    );\n\n    if (piecesWithContent.length === 0) {\n      return undefined;\n    }\n\n    if (isKnownStateEmpty) {\n      this._cachedNewContentSinceEmpty = piecesWithContent;\n    }\n\n    return piecesWithContent;\n  }\n\n  getDependedOnCoValues(): RawCoID[] {\n    if (this._cachedDependentOn) {\n      return this._cachedDependentOn;\n    } else {\n      const dependentOn = this.getDependedOnCoValuesUncached();\n      this._cachedDependentOn = dependentOn;\n      return dependentOn;\n    }\n  }\n\n  /** @internal */\n  getDependedOnCoValuesUncached(): RawCoID[] {\n    return this.header.ruleset.type === \"group\"\n      ? getGroupDependentKeyList(expectGroup(this.getCurrentContent()).keys())\n      : this.header.ruleset.type === \"ownedByGroup\"\n        ? [\n            this.header.ruleset.group,\n            ...new Set(\n              [...this.sessionLogs.keys()]\n                .map((sessionID) =>\n                  accountOrAgentIDfromSessionID(sessionID as SessionID),\n                )\n                .filter(\n                  (session): session is RawAccountID =>\n                    isAccountID(session) && session !== this.id,\n                ),\n            ),\n          ]\n        : [];\n  }\n\n  waitForSync(options?: {\n    timeout?: number;\n  }) {\n    return this.node.syncManager.waitForSync(this.id, options?.timeout);\n  }\n}\n\nfunction getNextKnownSignatureIdx(\n  log: SessionLog,\n  knownStateForSessionID?: number,\n  sentStateForSessionID?: number,\n) {\n  return Object.keys(log.signatureAfter)\n    .map(Number)\n    .sort((a, b) => a - b)\n    .find(\n      (idx) => idx >= (sentStateForSessionID ?? knownStateForSessionID ?? -1),\n    );\n}\n\nexport type InvalidHashError = {\n  type: \"InvalidHash\";\n  id: RawCoID;\n  expectedNewHash: Hash;\n  givenExpectedNewHash: Hash;\n};\n\nexport type InvalidSignatureError = {\n  type: \"InvalidSignature\";\n  id: RawCoID;\n  newSignature: Signature;\n  sessionID: SessionID;\n  signerID: SignerID;\n};\n\nexport type TryAddTransactionsError =\n  | ResolveAccountAgentError\n  | InvalidHashError\n  | InvalidSignatureError;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Updates to this file should also be replicated to @opentelemetry/core too.\n\n/**\n * - globalThis (New standard)\n * - self (Will return the current window instance for supported browsers)\n * - window (fallback for older browser implementations)\n * - global (NodeJS implementation)\n * - <object> (When all else fails)\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef\nexport const _globalThis: typeof globalThis =\n  typeof globalThis === 'object'\n    ? globalThis\n    : typeof self === 'object'\n    ? self\n    : typeof window === 'object'\n    ? window\n    : typeof global === 'object'\n    ? global\n    : ({} as typeof globalThis);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.9.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Baggage, BaggageEntry } from '../types';\n\nexport class BaggageImpl implements Baggage {\n  private _entries: Map<string, BaggageEntry>;\n\n  constructor(entries?: Map<string, BaggageEntry>) {\n    this._entries = entries ? new Map(entries) : new Map();\n  }\n\n  getEntry(key: string): BaggageEntry | undefined {\n    const entry = this._entries.get(key);\n    if (!entry) {\n      return undefined;\n    }\n\n    return Object.assign({}, entry);\n  }\n\n  getAllEntries(): [string, BaggageEntry][] {\n    return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);\n  }\n\n  setEntry(key: string, entry: BaggageEntry): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.set(key, entry);\n    return newBaggage;\n  }\n\n  removeEntry(key: string): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.delete(key);\n    return newBaggage;\n  }\n\n  removeEntries(...keys: string[]): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    for (const key of keys) {\n      newBaggage._entries.delete(key);\n    }\n    return newBaggage;\n  }\n\n  clear(): BaggageImpl {\n    return new BaggageImpl();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Symbol used to make BaggageEntryMetadata an opaque type\n */\nexport const baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagAPI } from '../api/diag';\nimport { BaggageImpl } from './internal/baggage-impl';\nimport { baggageEntryMetadataSymbol } from './internal/symbol';\nimport { Baggage, BaggageEntry, BaggageEntryMetadata } from './types';\n\nconst diag = DiagAPI.instance();\n\n/**\n * Create a new Baggage with optional entries\n *\n * @param entries An array of baggage entries the new baggage should contain\n */\nexport function createBaggage(\n  entries: Record<string, BaggageEntry> = {}\n): Baggage {\n  return new BaggageImpl(new Map(Object.entries(entries)));\n}\n\n/**\n * Create a serializable BaggageEntryMetadata object from a string.\n *\n * @param str string metadata. Format is currently not defined by the spec and has no special meaning.\n *\n */\nexport function baggageEntryMetadataFromString(\n  str: string\n): BaggageEntryMetadata {\n  if (typeof str !== 'string') {\n    diag.error(\n      `Cannot create baggage metadata from unknown type: ${typeof str}`\n    );\n    str = '';\n  }\n\n  return {\n    __TYPE__: baggageEntryMetadataSymbol,\n    toString() {\n      return str;\n    },\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter } from './Meter';\nimport {\n  BatchObservableCallback,\n  Counter,\n  Gauge,\n  Histogram,\n  MetricAttributes,\n  MetricOptions,\n  Observable,\n  ObservableCallback,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n  UpDownCounter,\n} from './Metric';\n\n/**\n * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses\n * constant NoopMetrics for all of its methods.\n */\nexport class NoopMeter implements Meter {\n  constructor() {}\n\n  /**\n   * @see {@link Meter.createGauge}\n   */\n  createGauge(_name: string, _options?: MetricOptions): Gauge {\n    return NOOP_GAUGE_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createHistogram}\n   */\n  createHistogram(_name: string, _options?: MetricOptions): Histogram {\n    return NOOP_HISTOGRAM_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createCounter}\n   */\n  createCounter(_name: string, _options?: MetricOptions): Counter {\n    return NOOP_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createUpDownCounter}\n   */\n  createUpDownCounter(_name: string, _options?: MetricOptions): UpDownCounter {\n    return NOOP_UP_DOWN_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableGauge}\n   */\n  createObservableGauge(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableGauge {\n    return NOOP_OBSERVABLE_GAUGE_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableCounter}\n   */\n  createObservableCounter(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableCounter {\n    return NOOP_OBSERVABLE_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableUpDownCounter}\n   */\n  createObservableUpDownCounter(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableUpDownCounter {\n    return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.addBatchObservableCallback}\n   */\n  addBatchObservableCallback(\n    _callback: BatchObservableCallback,\n    _observables: Observable[]\n  ): void {}\n\n  /**\n   * @see {@link Meter.removeBatchObservableCallback}\n   */\n  removeBatchObservableCallback(_callback: BatchObservableCallback): void {}\n}\n\nexport class NoopMetric {}\n\nexport class NoopCounterMetric extends NoopMetric implements Counter {\n  add(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopUpDownCounterMetric\n  extends NoopMetric\n  implements UpDownCounter\n{\n  add(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopGaugeMetric extends NoopMetric implements Gauge {\n  record(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopHistogramMetric extends NoopMetric implements Histogram {\n  record(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopObservableMetric {\n  addCallback(_callback: ObservableCallback) {}\n\n  removeCallback(_callback: ObservableCallback) {}\n}\n\nexport class NoopObservableCounterMetric\n  extends NoopObservableMetric\n  implements ObservableCounter {}\n\nexport class NoopObservableGaugeMetric\n  extends NoopObservableMetric\n  implements ObservableGauge {}\n\nexport class NoopObservableUpDownCounterMetric\n  extends NoopObservableMetric\n  implements ObservableUpDownCounter {}\n\nexport const NOOP_METER = new NoopMeter();\n\n// Synchronous instruments\nexport const NOOP_COUNTER_METRIC = new NoopCounterMetric();\nexport const NOOP_GAUGE_METRIC = new NoopGaugeMetric();\nexport const NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();\nexport const NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();\n\n// Asynchronous instruments\nexport const NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();\nexport const NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();\nexport const NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =\n  new NoopObservableUpDownCounterMetric();\n\n/**\n * Create a no-op Meter\n */\nexport function createNoopMeter(): Meter {\n  return NOOP_METER;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes, AttributeValue } from '../common/Attributes';\nimport { Context } from '../context/types';\nimport { BatchObservableResult, ObservableResult } from './ObservableResult';\n\n/**\n * Advisory options influencing aggregation configuration parameters.\n * @experimental\n */\nexport interface MetricAdvice {\n  /**\n   * Hint the explicit bucket boundaries for SDK if the metric is been\n   * aggregated with a HistogramAggregator.\n   */\n  explicitBucketBoundaries?: number[];\n}\n\n/**\n * Options needed for metric creation\n */\nexport interface MetricOptions {\n  /**\n   * The description of the Metric.\n   * @default ''\n   */\n  description?: string;\n\n  /**\n   * The unit of the Metric values.\n   * @default ''\n   */\n  unit?: string;\n\n  /**\n   * Indicates the type of the recorded value.\n   * @default {@link ValueType.DOUBLE}\n   */\n  valueType?: ValueType;\n\n  /**\n   * The advice influencing aggregation configuration parameters.\n   * @experimental\n   */\n  advice?: MetricAdvice;\n}\n\n/** The Type of value. It describes how the data is reported. */\nexport enum ValueType {\n  INT,\n  DOUBLE,\n}\n\n/**\n * Counter is the most common synchronous instrument. This instrument supports\n * an `Add(increment)` function for reporting a sum, and is restricted to\n * non-negative increments. The default aggregation is Sum, as for any additive\n * instrument.\n *\n * Example uses for Counter:\n * <ol>\n *   <li> count the number of bytes received. </li>\n *   <li> count the number of requests completed. </li>\n *   <li> count the number of accounts created. </li>\n *   <li> count the number of checkpoints run. </li>\n *   <li> count the number of 5xx errors. </li>\n * <ol>\n */\nexport interface Counter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs must not be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface UpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs may be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Gauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Histogram<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement. Value of the measurement must not be negative.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\n/**\n * @deprecated please use {@link Attributes}\n */\nexport type MetricAttributes = Attributes;\n\n/**\n * @deprecated please use {@link AttributeValue}\n */\nexport type MetricAttributeValue = AttributeValue;\n\n/**\n * The observable callback for Observable instruments.\n */\nexport type ObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: ObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\n/**\n * The observable callback for a batch of Observable instruments.\n */\nexport type BatchObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: BatchObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\nexport interface Observable<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Sets up a function that will be called whenever a metric collection is initiated.\n   *\n   * If the function is already in the list of callbacks for this Observable, the function is not added a second time.\n   */\n  addCallback(callback: ObservableCallback<AttributesTypes>): void;\n\n  /**\n   * Removes a callback previously registered with {@link Observable.addCallback}.\n   */\n  removeCallback(callback: ObservableCallback<AttributesTypes>): void;\n}\n\nexport type ObservableCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableUpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableGauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\n\n/**\n * Injects `Context` into and extracts it from carriers that travel\n * in-band across process boundaries. Encoding is expected to conform to the\n * HTTP Header Field semantics. Values are often encoded as RPC/HTTP request\n * headers.\n *\n * The carrier of propagated data on both the client (injector) and server\n * (extractor) side is usually an object such as http headers. Propagation is\n * usually implemented via library-specific request interceptors, where the\n * client-side injects values and the server-side extracts them.\n */\nexport interface TextMapPropagator<Carrier = any> {\n  /**\n   * Injects values from a given `Context` into a carrier.\n   *\n   * OpenTelemetry defines a common set of format values (TextMapPropagator),\n   * and each has an expected `carrier` type.\n   *\n   * @param context the Context from which to extract values to transmit over\n   *     the wire.\n   * @param carrier the carrier of propagation fields, such as http request\n   *     headers.\n   * @param setter an optional {@link TextMapSetter}. If undefined, values will be\n   *     set by direct object assignment.\n   */\n  inject(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier>\n  ): void;\n\n  /**\n   * Given a `Context` and a carrier, extract context values from a\n   * carrier and return a new context, created from the old context, with the\n   * extracted values.\n   *\n   * @param context the Context from which to extract values to transmit over\n   *     the wire.\n   * @param carrier the carrier of propagation fields, such as http request\n   *     headers.\n   * @param getter an optional {@link TextMapGetter}. If undefined, keys will be all\n   *     own properties, and keys will be accessed by direct object access.\n   */\n  extract(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier>\n  ): Context;\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  fields(): string[];\n}\n\n/**\n * A setter is specified by the caller to define a specific method\n * to set key/value pairs on the carrier within a propagator.\n */\nexport interface TextMapSetter<Carrier = any> {\n  /**\n   * Callback used to set a key/value pair on an object.\n   *\n   * Should be called by the propagator each time a key/value pair\n   * should be set, and should set that key/value pair on the propagator.\n   *\n   * @param carrier object or class which carries key/value pairs\n   * @param key string key to modify\n   * @param value value to be set to the key on the carrier\n   */\n  set(carrier: Carrier, key: string, value: string): void;\n}\n\n/**\n * A getter is specified by the caller to define a specific method\n * to get the value of a key from a carrier.\n */\nexport interface TextMapGetter<Carrier = any> {\n  /**\n   * Get a list of all keys available on the carrier.\n   *\n   * @param carrier\n   */\n  keys(carrier: Carrier): string[];\n\n  /**\n   * Get the value of a specific key from the carrier.\n   *\n   * @param carrier\n   * @param key\n   */\n  get(carrier: Carrier, key: string): undefined | string | string[];\n}\n\nexport const defaultTextMapGetter: TextMapGetter = {\n  get(carrier, key) {\n    if (carrier == null) {\n      return undefined;\n    }\n    return carrier[key];\n  },\n\n  keys(carrier) {\n    if (carrier == null) {\n      return [];\n    }\n    return Object.keys(carrier);\n  },\n};\n\nexport const defaultTextMapSetter: TextMapSetter = {\n  set(carrier, key, value) {\n    if (carrier == null) {\n      return;\n    }\n\n    carrier[key] = value;\n  },\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes } from './attributes';\nimport { TraceState } from './trace_state';\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<SpanAttributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';\nconst VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;\nconst VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;\nconst VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);\nconst VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nconst INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\n\n/**\n * Key is opaque string up to 256 characters printable. It MUST begin with a\n * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,\n * underscores _, dashes -, asterisks *, and forward slashes /.\n * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the\n * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.\n * see https://www.w3.org/TR/trace-context/#key\n */\nexport function validateKey(key: string): boolean {\n  return VALID_KEY_REGEX.test(key);\n}\n\n/**\n * Value is opaque string up to 256 characters printable ASCII RFC0020\n * characters (i.e., the range 0x20 to 0x7E) except comma , and =.\n */\nexport function validateValue(value: string): boolean {\n  return (\n    VALID_VALUE_BASE_REGEX.test(value) &&\n    !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value)\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TraceState } from '../trace_state';\nimport { validateKey, validateValue } from './tracestate-validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceStateImpl implements TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceStateImpl {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceStateImpl {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceStateImpl {\n    const traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ContextAPI } from './api/context';\n/** Entrypoint for context API */\nexport const context = ContextAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { DiagAPI } from './api/diag';\n/**\n * Entrypoint for Diag API.\n * Defines Diagnostic handler used for internal diagnostic logging operations.\n * The default provides a Noop DiagLogger implementation which may be changed via the\n * diag.setLogger(logger: DiagLogger) function.\n */\nexport const diag = DiagAPI.instance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter, MeterOptions } from './Meter';\nimport { MeterProvider } from './MeterProvider';\nimport { NOOP_METER } from './NoopMeter';\n\n/**\n * An implementation of the {@link MeterProvider} which returns an impotent Meter\n * for all calls to `getMeter`\n */\nexport class NoopMeterProvider implements MeterProvider {\n  getMeter(_name: string, _version?: string, _options?: MeterOptions): Meter {\n    return NOOP_METER;\n  }\n}\n\nexport const NOOP_METER_PROVIDER = new NoopMeterProvider();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter, MeterOptions } from '../metrics/Meter';\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { NOOP_METER_PROVIDER } from '../metrics/NoopMeterProvider';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'metrics';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Metrics API\n */\nexport class MetricsAPI {\n  private static _instance?: MetricsAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Metrics API */\n  public static getInstance(): MetricsAPI {\n    if (!this._instance) {\n      this._instance = new MetricsAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global meter provider.\n   * Returns true if the meter provider was successfully registered, else false.\n   */\n  public setGlobalMeterProvider(provider: MeterProvider): boolean {\n    return registerGlobal(API_NAME, provider, DiagAPI.instance());\n  }\n\n  /**\n   * Returns the global meter provider.\n   */\n  public getMeterProvider(): MeterProvider {\n    return getGlobal(API_NAME) || NOOP_METER_PROVIDER;\n  }\n\n  /**\n   * Returns a meter from the global meter provider.\n   */\n  public getMeter(\n    name: string,\n    version?: string,\n    options?: MeterOptions\n  ): Meter {\n    return this.getMeterProvider().getMeter(name, version, options);\n  }\n\n  /** Remove the global meter provider */\n  public disable(): void {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { MetricsAPI } from './api/metrics';\n/** Entrypoint for metrics API */\nexport const metrics = MetricsAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { TextMapPropagator } from './TextMapPropagator';\n\n/**\n * No-op implementations of {@link TextMapPropagator}.\n */\nexport class NoopTextMapPropagator implements TextMapPropagator {\n  /** Noop inject function does nothing */\n  inject(_context: Context, _carrier: unknown): void {}\n  /** Noop extract function does nothing and returns the input context */\n  extract(context: Context, _carrier: unknown): Context {\n    return context;\n  }\n  fields(): string[] {\n    return [];\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Baggage } from './types';\n\n/**\n * Baggage key\n */\nconst BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');\n\n/**\n * Retrieve the current baggage from the given context\n *\n * @param {Context} Context that manage all context values\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getBaggage(context: Context): Baggage | undefined {\n  return (context.getValue(BAGGAGE_KEY) as Baggage) || undefined;\n}\n\n/**\n * Retrieve the current baggage from the active/current context\n *\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getActiveBaggage(): Baggage | undefined {\n  return getBaggage(ContextAPI.getInstance().active());\n}\n\n/**\n * Store a baggage in the given context\n *\n * @param {Context} Context that manage all context values\n * @param {Baggage} baggage that will be set in the actual context\n */\nexport function setBaggage(context: Context, baggage: Baggage): Context {\n  return context.setValue(BAGGAGE_KEY, baggage);\n}\n\n/**\n * Delete the baggage stored in the given context\n *\n * @param {Context} Context that manage all context values\n */\nexport function deleteBaggage(context: Context): Context {\n  return context.deleteValue(BAGGAGE_KEY);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { NoopTextMapPropagator } from '../propagation/NoopTextMapPropagator';\nimport {\n  defaultTextMapGetter,\n  defaultTextMapSetter,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n} from '../propagation/TextMapPropagator';\nimport {\n  getBaggage,\n  getActiveBaggage,\n  setBaggage,\n  deleteBaggage,\n} from '../baggage/context-helpers';\nimport { createBaggage } from '../baggage/utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'propagation';\nconst NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Propagation API\n */\nexport class PropagationAPI {\n  private static _instance?: PropagationAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Propagator API */\n  public static getInstance(): PropagationAPI {\n    if (!this._instance) {\n      this._instance = new PropagationAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current propagator.\n   *\n   * @returns true if the propagator was successfully registered, else false\n   */\n  public setGlobalPropagator(propagator: TextMapPropagator): boolean {\n    return registerGlobal(API_NAME, propagator, DiagAPI.instance());\n  }\n\n  /**\n   * Inject context into a carrier to be propagated inter-process\n   *\n   * @param context Context carrying tracing data to inject\n   * @param carrier carrier to inject context into\n   * @param setter Function used to set values on the carrier\n   */\n  public inject<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier> = defaultTextMapSetter\n  ): void {\n    return this._getGlobalPropagator().inject(context, carrier, setter);\n  }\n\n  /**\n   * Extract context from a carrier\n   *\n   * @param context Context which the newly created context will inherit from\n   * @param carrier Carrier to extract context from\n   * @param getter Function used to extract keys from a carrier\n   */\n  public extract<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier> = defaultTextMapGetter\n  ): Context {\n    return this._getGlobalPropagator().extract(context, carrier, getter);\n  }\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  public fields(): string[] {\n    return this._getGlobalPropagator().fields();\n  }\n\n  /** Remove the global propagator */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n\n  public createBaggage = createBaggage;\n\n  public getBaggage = getBaggage;\n\n  public getActiveBaggage = getActiveBaggage;\n\n  public setBaggage = setBaggage;\n\n  public deleteBaggage = deleteBaggage;\n\n  private _getGlobalPropagator(): TextMapPropagator {\n    return getGlobal(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { PropagationAPI } from './api/propagation';\n/** Entrypoint for propagation API */\nexport const propagation = PropagationAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n", "import { RawCoID, SessionID } from \"./ids.js\";\nimport {\n  CoValueKnownState,\n  combinedKnownStates,\n  emptyKnownState,\n} from \"./sync.js\";\n\nexport class PeerKnownStates {\n  private coValues = new Map<RawCoID, CoValueKnownState>();\n\n  updateHeader(id: RawCoID, header: boolean) {\n    const knownState = this.coValues.get(id) ?? emptyKnownState(id);\n    knownState.header = header;\n    this.coValues.set(id, knownState);\n    this.triggerUpdate(id);\n  }\n\n  combineWith(id: RawCoID, value: CoValueKnownState) {\n    const knownState = this.coValues.get(id) ?? emptyKnownState(id);\n    this.coValues.set(id, combinedKnownStates(knownState, value));\n    this.triggerUpdate(id);\n  }\n\n  updateSessionCounter(id: RawCoID, sessionId: SessionID, value: number) {\n    const knownState = this.coValues.get(id) ?? emptyKnownState(id);\n    const currentValue = knownState.sessions[sessionId] || 0;\n    knownState.sessions[sessionId] = Math.max(currentValue, value);\n\n    this.coValues.set(id, knownState);\n    this.triggerUpdate(id);\n  }\n\n  set(id: RawCoID, knownState: CoValueKnownState | \"empty\") {\n    this.coValues.set(\n      id,\n      knownState === \"empty\" ? emptyKnownState(id) : knownState,\n    );\n    this.triggerUpdate(id);\n  }\n\n  get(id: RawCoID) {\n    return this.coValues.get(id);\n  }\n\n  has(id: RawCoID) {\n    return this.coValues.has(id);\n  }\n\n  clone() {\n    const clone = new PeerKnownStates();\n    clone.coValues = new Map(this.coValues);\n    return clone;\n  }\n\n  listeners = new Set<(id: RawCoID, knownState: CoValueKnownState) => void>();\n\n  triggerUpdate(id: RawCoID) {\n    this.trigger(id, this.coValues.get(id) ?? emptyKnownState(id));\n  }\n\n  private trigger(id: RawCoID, knownState: CoValueKnownState) {\n    for (const listener of this.listeners) {\n      listener(id, knownState);\n    }\n  }\n\n  subscribe(listener: (id: RawCoID, knownState: CoValueKnownState) => void) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n}\n\nexport type ReadonlyPeerKnownStates = Pick<\n  PeerKnownStates,\n  \"get\" | \"has\" | \"clone\" | \"subscribe\"\n>;\n", "import { Counter, ValueType, metrics } from \"@opentelemetry/api\";\nimport { CO_VALUE_PRIORITY, type CoValuePriority } from \"./priority.js\";\nimport type { SyncMessage } from \"./sync.js\";\n\n/**\n * Since we have a fixed range of priority values (0-7) we can create a fixed array of queues.\n */\ntype Tuple<T, N extends number, A extends unknown[] = []> = A extends {\n  length: N;\n}\n  ? A\n  : Tuple<T, N, [...A, T]>;\n\ntype QueueTuple = Tuple<LinkedList<SyncMessage>, 3>;\n\ntype LinkedListNode<T> = {\n  value: T;\n  next: LinkedListNode<T> | undefined;\n};\n\n/**\n * Using a linked list to make the shift operation O(1) instead of O(n)\n * as our queues can grow very large when the system is under pressure.\n */\nexport class LinkedList<T> {\n  constructor(private meter?: QueueMeter) {}\n\n  head: LinkedListNode<T> | undefined = undefined;\n  tail: LinkedListNode<T> | undefined = undefined;\n  length = 0;\n\n  push(value: T) {\n    const node = { value, next: undefined };\n\n    if (this.head === undefined) {\n      this.head = node;\n      this.tail = node;\n    } else if (this.tail) {\n      this.tail.next = node;\n      this.tail = node;\n    } else {\n      throw new Error(\"LinkedList is corrupted\");\n    }\n\n    this.length++;\n    this.meter?.push();\n  }\n\n  shift() {\n    if (!this.head) {\n      return undefined;\n    }\n\n    const node = this.head;\n    const value = node.value;\n    this.head = node.next;\n    node.next = undefined;\n\n    if (this.head === undefined) {\n      this.tail = undefined;\n    }\n\n    this.length--;\n\n    this.meter?.pull();\n    return value;\n  }\n}\n\nclass QueueMeter {\n  private pullCounter: Counter;\n  private pushCounter: Counter;\n\n  constructor(\n    prefix: string,\n    private attrs?: Record<string, string | number>,\n  ) {\n    this.pullCounter = metrics\n      .getMeter(\"cojosn\")\n      .createCounter(`${prefix}.pulled`, {\n        description: \"Number of messages pulled from the queue\",\n        valueType: ValueType.INT,\n        unit: \"1\",\n      });\n    this.pushCounter = metrics\n      .getMeter(\"cojosn\")\n      .createCounter(`${prefix}.pushed`, {\n        description: \"Number of messages pushed to the queue\",\n        valueType: ValueType.INT,\n        unit: \"1\",\n      });\n\n    /**\n     * This makes sure that those metrics are generated (and emitted) as soon as the queue is created.\n     * This is to avoid edge cases where one series reset is delayed, which would cause spikes or dips\n     * when queried - and it also more correctly represents the actual state of the queue after a restart.\n     */\n    this.pullCounter.add(0, this.attrs);\n    this.pushCounter.add(0, this.attrs);\n  }\n\n  public pull() {\n    this.pullCounter.add(1, this.attrs);\n  }\n\n  public push() {\n    this.pushCounter.add(1, this.attrs);\n  }\n}\n\nfunction meteredList<T>(attrs?: Record<string, string | number>) {\n  return new LinkedList<T>(new QueueMeter(\"jazz.messagequeue\", attrs));\n}\n\nconst PRIORITY_TO_QUEUE_INDEX = {\n  [CO_VALUE_PRIORITY.HIGH]: 0,\n  [CO_VALUE_PRIORITY.MEDIUM]: 1,\n  [CO_VALUE_PRIORITY.LOW]: 2,\n} as const;\n\nexport class PriorityBasedMessageQueue {\n  private queues: QueueTuple;\n\n  constructor(\n    private defaultPriority: CoValuePriority,\n    /**\n     * Optional attributes to be added to the generated metrics.\n     * By default the metrics will have the priority as an attribute.\n     */\n    attrs?: Record<string, string | number>,\n  ) {\n    this.queues = [\n      meteredList({ priority: CO_VALUE_PRIORITY.HIGH, ...attrs }),\n      meteredList({ priority: CO_VALUE_PRIORITY.MEDIUM, ...attrs }),\n      meteredList({ priority: CO_VALUE_PRIORITY.LOW, ...attrs }),\n    ];\n  }\n\n  private getQueue(priority: CoValuePriority) {\n    return this.queues[PRIORITY_TO_QUEUE_INDEX[priority]];\n  }\n\n  public push(msg: SyncMessage) {\n    const priority = \"priority\" in msg ? msg.priority : this.defaultPriority;\n\n    this.getQueue(priority).push(msg);\n  }\n\n  public pull() {\n    const priority = this.queues.findIndex((queue) => queue.length > 0);\n\n    return this.queues[priority]?.shift();\n  }\n}\n", "import { PeerKnownStates, ReadonlyPeerKnownStates } from \"./PeerKnownStates.js\";\nimport { PriorityBasedMessageQueue } from \"./PriorityBasedMessageQueue.js\";\nimport { RawCoID, SessionID } from \"./ids.js\";\nimport { logger } from \"./logger.js\";\nimport { CO_VALUE_PRIORITY } from \"./priority.js\";\nimport { CoValueKnownState, Peer, SyncMessage } from \"./sync.js\";\n\nexport class PeerState {\n  private queue: PriorityBasedMessageQueue;\n\n  constructor(\n    private peer: Peer,\n    knownStates: ReadonlyPeerKnownStates | undefined,\n  ) {\n    /**\n     * We set as default priority HIGH to handle all the messages without a\n     * priority property as HIGH priority.\n     *\n     * This way we consider all the non-content messsages as HIGH priority.\n     */\n    this.queue = new PriorityBasedMessageQueue(CO_VALUE_PRIORITY.HIGH, {\n      peerRole: peer.role,\n    });\n\n    this._knownStates = knownStates?.clone() ?? new PeerKnownStates();\n\n    // We assume that exchanges with storage peers are always successful\n    // hence we don't need to differentiate between knownStates and optimisticKnownStates\n    if (peer.role === \"storage\") {\n      this._optimisticKnownStates = \"assumeInfallible\";\n    } else {\n      this._optimisticKnownStates =\n        knownStates?.clone() ?? new PeerKnownStates();\n    }\n  }\n\n  /**\n   * Here we to collect all the known states that a given peer has told us about.\n   *\n   * This can be used to safely track the sync state of a coValue in a given peer.\n   */\n  readonly _knownStates: PeerKnownStates;\n\n  get knownStates(): ReadonlyPeerKnownStates {\n    return this._knownStates;\n  }\n\n  /**\n   * This one collects the known states \"optimistically\".\n   * We use it to keep track of the content we have sent to a given peer.\n   *\n   * The main difference with knownState is that this is updated when the content is sent to the peer without\n   * waiting for any acknowledgement from the peer.\n   */\n  readonly _optimisticKnownStates: PeerKnownStates | \"assumeInfallible\";\n\n  get optimisticKnownStates(): ReadonlyPeerKnownStates {\n    if (this._optimisticKnownStates === \"assumeInfallible\") {\n      return this.knownStates;\n    }\n\n    return this._optimisticKnownStates;\n  }\n\n  readonly toldKnownState: Set<RawCoID> = new Set();\n\n  updateHeader(id: RawCoID, header: boolean) {\n    this._knownStates.updateHeader(id, header);\n\n    if (this._optimisticKnownStates !== \"assumeInfallible\") {\n      this._optimisticKnownStates.updateHeader(id, header);\n    }\n  }\n\n  combineWith(id: RawCoID, value: CoValueKnownState) {\n    this._knownStates.combineWith(id, value);\n\n    if (this._optimisticKnownStates !== \"assumeInfallible\") {\n      this._optimisticKnownStates.combineWith(id, value);\n    }\n  }\n\n  combineOptimisticWith(id: RawCoID, value: CoValueKnownState) {\n    if (this._optimisticKnownStates === \"assumeInfallible\") {\n      this._knownStates.combineWith(id, value);\n    } else {\n      this._optimisticKnownStates.combineWith(id, value);\n    }\n  }\n\n  updateSessionCounter(id: RawCoID, sessionId: SessionID, value: number) {\n    this._knownStates.updateSessionCounter(id, sessionId, value);\n\n    if (this._optimisticKnownStates !== \"assumeInfallible\") {\n      this._optimisticKnownStates.updateSessionCounter(id, sessionId, value);\n    }\n  }\n\n  setKnownState(id: RawCoID, knownState: CoValueKnownState | \"empty\") {\n    this._knownStates.set(id, knownState);\n\n    if (this._optimisticKnownStates !== \"assumeInfallible\") {\n      this._optimisticKnownStates.set(id, knownState);\n    }\n  }\n\n  setOptimisticKnownState(\n    id: RawCoID,\n    knownState: CoValueKnownState | \"empty\",\n  ) {\n    if (this._optimisticKnownStates === \"assumeInfallible\") {\n      this._knownStates.set(id, knownState);\n    } else {\n      this._optimisticKnownStates.set(id, knownState);\n    }\n  }\n\n  get id() {\n    return this.peer.id;\n  }\n\n  get role() {\n    return this.peer.role;\n  }\n\n  get priority() {\n    return this.peer.priority;\n  }\n\n  get crashOnClose() {\n    return this.peer.crashOnClose;\n  }\n\n  shouldRetryUnavailableCoValues() {\n    return this.peer.role === \"server\";\n  }\n\n  isServerOrStoragePeer() {\n    return this.peer.role === \"server\" || this.peer.role === \"storage\";\n  }\n\n  private processing = false;\n  public closed = false;\n\n  async processQueue() {\n    if (this.processing) {\n      return;\n    }\n\n    this.processing = true;\n\n    let msg: SyncMessage | undefined;\n    while ((msg = this.queue.pull())) {\n      if (this.closed) {\n        break;\n      }\n\n      // Awaiting the push to send one message at a time\n      // This way when the peer is \"under pressure\" we can enqueue all\n      // the coming messages and organize them by priority\n      try {\n        await this.peer.outgoing.push(msg);\n      } catch (e) {\n        logger.error(\"Error sending message\", {\n          err: e,\n          action: msg.action,\n          id: msg.id,\n          peerId: this.id,\n          peerRole: this.role,\n        });\n      }\n    }\n\n    this.processing = false;\n  }\n\n  pushOutgoingMessage(msg: SyncMessage) {\n    if (this.closed) {\n      return;\n    }\n\n    this.queue.push(msg);\n\n    void this.processQueue();\n  }\n\n  isProcessing() {\n    return this.processing;\n  }\n\n  get incoming() {\n    if (this.closed) {\n      return (async function* () {\n        yield \"Disconnected\" as const;\n      })();\n    }\n\n    return this.peer.incoming;\n  }\n\n  closeListeners = new Set<() => void>();\n\n  addCloseListener(listener: () => void) {\n    if (this.closed) {\n      listener();\n      return () => {};\n    }\n\n    this.closeListeners.add(listener);\n\n    return () => {\n      this.closeListeners.delete(listener);\n    };\n  }\n\n  emitClose() {\n    for (const listener of this.closeListeners) {\n      listener();\n    }\n\n    this.closeListeners.clear();\n  }\n\n  gracefulShutdown() {\n    logger.debug(\"Gracefully closing\", {\n      peerId: this.id,\n      peerRole: this.role,\n    });\n    this.peer.outgoing.close();\n    this.closed = true;\n    this.emitClose();\n  }\n\n  async processIncomingMessages(callback: (msg: SyncMessage) => void) {\n    if (this.closed) {\n      throw new Error(\"Peer is closed\");\n    }\n\n    const processIncomingMessages = async () => {\n      for await (const msg of this.incoming) {\n        if (this.closed) {\n          return;\n        }\n\n        if (msg === \"Disconnected\") {\n          return;\n        }\n\n        if (msg === \"PingTimeout\") {\n          logger.error(\"Ping timeout from peer\", {\n            peerId: this.id,\n            peerRole: this.role,\n          });\n          return;\n        }\n\n        callback(msg);\n      }\n    };\n\n    return processIncomingMessages();\n  }\n}\n", "import { RawCoID } from \"./ids.js\";\nimport {\n  CoValueKnownState,\n  PeerID,\n  SyncManager,\n  emptyKnownState,\n} from \"./sync.js\";\n\nexport type SyncState = {\n  uploaded: boolean;\n};\n\nexport type GlobalSyncStateListenerCallback = (\n  peerId: PeerID,\n  knownState: CoValueKnownState,\n  sync: SyncState,\n) => void;\n\nexport type PeerSyncStateListenerCallback = (\n  knownState: CoValueKnownState,\n  sync: SyncState,\n) => void;\n\nexport class SyncStateManager {\n  constructor(private syncManager: SyncManager) {}\n\n  private listeners = new Set<GlobalSyncStateListenerCallback>();\n  private listenersByPeers = new Map<\n    PeerID,\n    Set<PeerSyncStateListenerCallback>\n  >();\n\n  subscribeToUpdates(listener: GlobalSyncStateListenerCallback) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  subscribeToPeerUpdates(\n    peerId: PeerID,\n    listener: PeerSyncStateListenerCallback,\n  ) {\n    const listeners = this.listenersByPeers.get(peerId) ?? new Set();\n\n    if (listeners.size === 0) {\n      this.listenersByPeers.set(peerId, listeners);\n    }\n\n    listeners.add(listener);\n\n    return () => {\n      listeners.delete(listener);\n    };\n  }\n\n  getCurrentSyncState(peerId: PeerID, id: RawCoID) {\n    // Build a lazy sync state object to process the isUploaded info\n    // only when requested\n    const syncState = {} as SyncState;\n\n    const getIsUploaded = () =>\n      this.getIsCoValueFullyUploadedIntoPeer(peerId, id);\n\n    Object.defineProperties(syncState, {\n      uploaded: {\n        enumerable: true,\n        get: getIsUploaded,\n      },\n    });\n\n    return syncState;\n  }\n\n  triggerUpdate(peerId: PeerID, id: RawCoID) {\n    const peer = this.syncManager.peers[peerId];\n\n    if (!peer) {\n      return;\n    }\n\n    const peerListeners = this.listenersByPeers.get(peer.id);\n\n    // If we don't have any active listeners do nothing\n    if (!peerListeners?.size && !this.listeners.size) {\n      return;\n    }\n\n    const knownState = peer.knownStates.get(id) ?? emptyKnownState(id);\n    const syncState = this.getCurrentSyncState(peerId, id);\n\n    for (const listener of this.listeners) {\n      listener(peerId, knownState, syncState);\n    }\n\n    if (!peerListeners) return;\n\n    for (const listener of peerListeners) {\n      listener(knownState, syncState);\n    }\n  }\n\n  private getKnownStateSessions(peerId: PeerID, id: RawCoID) {\n    const peer = this.syncManager.peers[peerId];\n\n    if (!peer) {\n      return undefined;\n    }\n\n    const peerSessions = peer.knownStates.get(id)?.sessions;\n\n    if (!peerSessions) {\n      return undefined;\n    }\n\n    const entry = this.syncManager.local.coValuesStore.get(id);\n\n    if (!entry.isAvailable()) {\n      return undefined;\n    }\n\n    const coValue = entry.core;\n    const coValueSessions = coValue.knownState().sessions;\n\n    return {\n      peer: peerSessions,\n      coValue: coValueSessions,\n    };\n  }\n\n  private getIsCoValueFullyUploadedIntoPeer(peerId: PeerID, id: RawCoID) {\n    const sessions = this.getKnownStateSessions(peerId, id);\n\n    if (!sessions) {\n      return false;\n    }\n\n    return getIsUploaded(sessions.coValue, sessions.peer);\n  }\n}\n\nfunction getIsUploaded(\n  from: Record<string, number>,\n  to: Record<string, number>,\n) {\n  for (const sessionId of Object.keys(from)) {\n    if (from[sessionId] !== to[sessionId]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import { Histogram, ValueType, metrics } from \"@opentelemetry/api\";\nimport { PeerState } from \"./PeerState.js\";\nimport { SyncStateManager } from \"./SyncStateManager.js\";\nimport { CoValueHeader, Transaction } from \"./coValueCore.js\";\nimport { CoValueCore } from \"./coValueCore.js\";\nimport { CoValueState } from \"./coValueState.js\";\nimport { Signature } from \"./crypto/crypto.js\";\nimport { RawCoID, SessionID } from \"./ids.js\";\nimport { LocalNode } from \"./localNode.js\";\nimport { logger } from \"./logger.js\";\nimport { CoValuePriority } from \"./priority.js\";\n\nexport type CoValueKnownState = {\n  id: RawCoID;\n  header: boolean;\n  sessions: { [sessionID: SessionID]: number };\n};\n\nexport function emptyKnownState(id: RawCoID): CoValueKnownState {\n  return {\n    id,\n    header: false,\n    sessions: {},\n  };\n}\n\nexport type SyncMessage =\n  | LoadMessage\n  | KnownStateMessage\n  | NewContentMessage\n  | DoneMessage;\n\nexport type LoadMessage = {\n  action: \"load\";\n} & CoValueKnownState;\n\nexport type KnownStateMessage = {\n  action: \"known\";\n  isCorrection?: boolean;\n  asDependencyOf?: RawCoID;\n} & CoValueKnownState;\n\nexport type NewContentMessage = {\n  action: \"content\";\n  id: RawCoID;\n  header?: CoValueHeader;\n  priority: CoValuePriority;\n  new: {\n    [sessionID: SessionID]: SessionNewContent;\n  };\n};\n\nexport type SessionNewContent = {\n  after: number;\n  newTransactions: Transaction[];\n  lastSignature: Signature;\n};\nexport type DoneMessage = {\n  action: \"done\";\n  id: RawCoID;\n};\n\nexport type PeerID = string;\n\nexport type DisconnectedError = \"Disconnected\";\n\nexport type PingTimeoutError = \"PingTimeout\";\n\nexport type IncomingSyncStream = AsyncIterable<\n  SyncMessage | DisconnectedError | PingTimeoutError\n>;\nexport type OutgoingSyncQueue = {\n  push: (msg: SyncMessage) => Promise<unknown>;\n  close: () => void;\n};\n\nexport interface Peer {\n  id: PeerID;\n  incoming: IncomingSyncStream;\n  outgoing: OutgoingSyncQueue;\n  role: \"server\" | \"client\" | \"storage\";\n  priority?: number;\n  crashOnClose: boolean;\n  deletePeerStateOnClose?: boolean;\n}\n\nexport function combinedKnownStates(\n  stateA: CoValueKnownState,\n  stateB: CoValueKnownState,\n): CoValueKnownState {\n  const sessionStates: CoValueKnownState[\"sessions\"] = {};\n\n  const allSessions = new Set([\n    ...Object.keys(stateA.sessions),\n    ...Object.keys(stateB.sessions),\n  ] as SessionID[]);\n\n  for (const sessionID of allSessions) {\n    const stateAValue = stateA.sessions[sessionID];\n    const stateBValue = stateB.sessions[sessionID];\n\n    sessionStates[sessionID] = Math.max(stateAValue || 0, stateBValue || 0);\n  }\n\n  return {\n    id: stateA.id,\n    header: stateA.header || stateB.header,\n    sessions: sessionStates,\n  };\n}\n\nexport class SyncManager {\n  peers: { [key: PeerID]: PeerState } = {};\n  local: LocalNode;\n\n  peersCounter = metrics.getMeter(\"cojson\").createUpDownCounter(\"jazz.peers\", {\n    description: \"Amount of connected peers\",\n    valueType: ValueType.INT,\n    unit: \"peer\",\n  });\n  private transactionsSizeHistogram: Histogram;\n\n  constructor(local: LocalNode) {\n    this.local = local;\n    this.syncState = new SyncStateManager(this);\n\n    this.transactionsSizeHistogram = metrics\n      .getMeter(\"cojson\")\n      .createHistogram(\"jazz.transactions.size\", {\n        description: \"The size of transactions in a covalue\",\n        unit: \"bytes\",\n        valueType: ValueType.INT,\n      });\n  }\n\n  syncState: SyncStateManager;\n\n  peersInPriorityOrder(): PeerState[] {\n    return Object.values(this.peers).sort((a, b) => {\n      const aPriority = a.priority || 0;\n      const bPriority = b.priority || 0;\n\n      return bPriority - aPriority;\n    });\n  }\n\n  getPeers(): PeerState[] {\n    return Object.values(this.peers);\n  }\n\n  getServerAndStoragePeers(excludePeerId?: PeerID): PeerState[] {\n    return this.peersInPriorityOrder().filter(\n      (peer) =>\n        peer.isServerOrStoragePeer() &&\n        peer.id !== excludePeerId &&\n        !peer.closed,\n    );\n  }\n\n  handleSyncMessage(msg: SyncMessage, peer: PeerState) {\n    if (this.local.coValuesStore.get(msg.id).isErroredInPeer(peer.id)) {\n      logger.warn(\n        `Skipping message ${msg.action} on errored coValue ${msg.id} from peer ${peer.id}`,\n      );\n      return;\n    } else if (msg.id === undefined || msg.id === null) {\n      logger.warn(\"Received sync message with undefined id\", {\n        msg,\n      });\n      return;\n    } else if (!msg.id.startsWith(\"co_z\")) {\n      logger.warn(\"Received sync message with invalid id\", {\n        msg,\n      });\n      return;\n    }\n\n    // TODO: validate\n    switch (msg.action) {\n      case \"load\":\n        return this.handleLoad(msg, peer);\n      case \"known\":\n        if (msg.isCorrection) {\n          return this.handleCorrection(msg, peer);\n        } else {\n          return this.handleKnownState(msg, peer);\n        }\n      case \"content\":\n        return this.handleNewContent(msg, peer);\n      case \"done\":\n        return this.handleUnsubscribe(msg);\n      default:\n        throw new Error(\n          `Unknown message type ${(msg as { action: \"string\" }).action}`,\n        );\n    }\n  }\n\n  sendNewContentIncludingDependencies(id: RawCoID, peer: PeerState) {\n    const coValue = this.local.expectCoValueLoaded(id);\n\n    coValue\n      .getDependedOnCoValues()\n      .map((id) => this.sendNewContentIncludingDependencies(id, peer));\n\n    const newContentPieces = coValue.newContentSince(\n      peer.optimisticKnownStates.get(id),\n    );\n\n    if (newContentPieces) {\n      for (const piece of newContentPieces) {\n        this.trySendToPeer(peer, piece);\n      }\n\n      peer.toldKnownState.add(id);\n      peer.combineOptimisticWith(id, coValue.knownState());\n    } else if (!peer.toldKnownState.has(id)) {\n      this.trySendToPeer(peer, {\n        action: \"known\",\n        ...coValue.knownState(),\n      });\n\n      peer.toldKnownState.add(id);\n    }\n  }\n\n  startPeerReconciliation(peer: PeerState) {\n    const coValuesOrderedByDependency: CoValueCore[] = [];\n\n    const gathered = new Set<string>();\n\n    const buildOrderedCoValueList = (coValue: CoValueCore) => {\n      if (gathered.has(coValue.id)) {\n        return;\n      }\n\n      gathered.add(coValue.id);\n\n      for (const id of coValue.getDependedOnCoValues()) {\n        const entry = this.local.coValuesStore.get(id);\n\n        if (entry.isAvailable()) {\n          buildOrderedCoValueList(entry.core);\n        }\n      }\n\n      coValuesOrderedByDependency.push(coValue);\n    };\n\n    for (const entry of this.local.coValuesStore.getValues()) {\n      if (!entry.isAvailable()) {\n        // If the coValue is unavailable and we never tried this peer\n        // we try to load it from the peer\n        if (!peer.toldKnownState.has(entry.id)) {\n          peer.toldKnownState.add(entry.id);\n          this.trySendToPeer(peer, {\n            action: \"load\",\n            header: false,\n            id: entry.id,\n            sessions: {},\n          });\n        }\n      } else {\n        const coValue = entry.core;\n\n        // Build the list of coValues ordered by dependency\n        // so we can send the load message in the correct order\n        buildOrderedCoValueList(coValue);\n      }\n\n      // Fill the missing known states with empty known states\n      if (!peer.optimisticKnownStates.has(entry.id)) {\n        peer.setOptimisticKnownState(entry.id, \"empty\");\n      }\n    }\n\n    for (const coValue of coValuesOrderedByDependency) {\n      /**\n       * We send the load messages to:\n       * - Subscribe to the coValue updates\n       * - Start the sync process in case we or the other peer\n       *   lacks some transactions\n       */\n      peer.toldKnownState.add(coValue.id);\n      this.trySendToPeer(peer, {\n        action: \"load\",\n        ...coValue.knownState(),\n      });\n    }\n  }\n\n  async addPeer(peer: Peer) {\n    const prevPeer = this.peers[peer.id];\n\n    if (prevPeer && !prevPeer.closed) {\n      prevPeer.gracefulShutdown();\n    }\n\n    const peerState = new PeerState(peer, prevPeer?.knownStates);\n    this.peers[peer.id] = peerState;\n\n    this.peersCounter.add(1, { role: peer.role });\n\n    const unsubscribeFromKnownStatesUpdates = peerState.knownStates.subscribe(\n      (id) => {\n        this.syncState.triggerUpdate(peer.id, id);\n      },\n    );\n\n    if (peerState.isServerOrStoragePeer()) {\n      void this.startPeerReconciliation(peerState);\n    }\n\n    peerState\n      .processIncomingMessages((msg) => {\n        this.handleSyncMessage(msg, peerState);\n      })\n      .then(() => {\n        if (peer.crashOnClose) {\n          logger.error(\"Unexepcted close from peer\", {\n            peerId: peer.id,\n            peerRole: peer.role,\n          });\n          this.local.crashed = new Error(\"Unexpected close from peer\");\n          throw new Error(\"Unexpected close from peer\");\n        }\n      })\n      .catch((e) => {\n        logger.error(\"Error processing messages from peer\", {\n          err: e,\n          peerId: peer.id,\n          peerRole: peer.role,\n        });\n\n        if (peer.crashOnClose) {\n          this.local.crashed = e;\n          throw new Error(e);\n        }\n      })\n      .finally(() => {\n        peerState.gracefulShutdown();\n        unsubscribeFromKnownStatesUpdates();\n        this.peersCounter.add(-1, { role: peer.role });\n\n        if (peer.deletePeerStateOnClose && this.peers[peer.id] === peerState) {\n          delete this.peers[peer.id];\n        }\n      });\n  }\n\n  trySendToPeer(peer: PeerState, msg: SyncMessage) {\n    return peer.pushOutgoingMessage(msg);\n  }\n\n  /**\n   * Handles the load message from a peer.\n   *\n   * Differences with the known state message:\n   * - The load message triggers the CoValue loading process on the other peer\n   * - The peer known state is stored as-is instead of being merged\n   * - The load message always replies with a known state message\n   */\n  handleLoad(msg: LoadMessage, peer: PeerState) {\n    /**\n     * We use the msg sessions as source of truth for the known states\n     *\n     * This way we can track part of the data loss that may occur when the other peer is restarted\n     *\n     */\n    peer.setKnownState(msg.id, knownStateIn(msg));\n    const entry = this.local.coValuesStore.get(msg.id);\n\n    if (\n      entry.highLevelState === \"unknown\" ||\n      entry.highLevelState === \"unavailable\"\n    ) {\n      const eligiblePeers = this.getServerAndStoragePeers(peer.id);\n\n      if (eligiblePeers.length === 0) {\n        // We don't have any eligible peers to load the coValue from\n        // so we send a known state back to the sender to let it know\n        // that the coValue is unavailable\n        peer.toldKnownState.add(msg.id);\n\n        this.trySendToPeer(peer, {\n          action: \"known\",\n          id: msg.id,\n          header: false,\n          sessions: {},\n        });\n\n        return;\n      } else {\n        // Should move the state to loading\n        this.local.loadCoValueCore(msg.id, peer.id).catch((e) => {\n          logger.error(\"Error loading coValue in handleLoad\", { err: e });\n        });\n      }\n    }\n\n    if (entry.highLevelState === \"loading\") {\n      // We need to return from handleLoad immediately and wait for the CoValue to be loaded\n      // in a new task, otherwise we might block further incoming content messages that would\n      // resolve the CoValue as available. This can happen when we receive fresh\n      // content from a client, but we are a server with our own upstream server(s)\n      entry\n        .getCoValue()\n        .then(async (value) => {\n          if (value === \"unavailable\") {\n            peer.toldKnownState.add(msg.id);\n\n            this.trySendToPeer(peer, {\n              action: \"known\",\n              id: msg.id,\n              header: false,\n              sessions: {},\n            });\n\n            return;\n          }\n\n          this.sendNewContentIncludingDependencies(msg.id, peer);\n        })\n        .catch((e) => {\n          logger.error(\"Error loading coValue in handleLoad loading state\", {\n            err: e,\n          });\n        });\n    } else if (entry.isAvailable()) {\n      this.sendNewContentIncludingDependencies(msg.id, peer);\n    } else {\n      this.trySendToPeer(peer, {\n        action: \"known\",\n        id: msg.id,\n        header: false,\n        sessions: {},\n      });\n    }\n  }\n\n  handleKnownState(msg: KnownStateMessage, peer: PeerState) {\n    const entry = this.local.coValuesStore.get(msg.id);\n\n    peer.combineWith(msg.id, knownStateIn(msg));\n\n    // The header is a boolean value that tells us if the other peer do have information about the header.\n    // If it's false in this point it means that the coValue is unavailable on the other peer.\n    const availableOnPeer = peer.optimisticKnownStates.get(msg.id)?.header;\n\n    if (!availableOnPeer) {\n      entry.markNotFoundInPeer(peer.id);\n    }\n\n    if (entry.isAvailable()) {\n      this.sendNewContentIncludingDependencies(msg.id, peer);\n    }\n  }\n\n  recordTransactionsSize(newTransactions: Transaction[], source: string) {\n    for (const tx of newTransactions) {\n      const txLength =\n        tx.privacy === \"private\"\n          ? tx.encryptedChanges.length\n          : tx.changes.length;\n\n      this.transactionsSizeHistogram.record(txLength, {\n        source,\n      });\n    }\n  }\n\n  handleNewContent(msg: NewContentMessage, peer: PeerState) {\n    const entry = this.local.coValuesStore.get(msg.id);\n\n    let coValue: CoValueCore;\n\n    if (!entry.isAvailable()) {\n      if (!msg.header) {\n        this.trySendToPeer(peer, {\n          action: \"known\",\n          isCorrection: true,\n          id: msg.id,\n          header: false,\n          sessions: {},\n        });\n        return;\n      }\n\n      peer.updateHeader(msg.id, true);\n\n      coValue = new CoValueCore(msg.header, this.local);\n\n      entry.markAvailable(coValue, peer.id);\n    } else {\n      coValue = entry.core;\n    }\n\n    let invalidStateAssumed = false;\n\n    for (const [sessionID, newContentForSession] of Object.entries(msg.new) as [\n      SessionID,\n      SessionNewContent,\n    ][]) {\n      const ourKnownTxIdx =\n        coValue.sessionLogs.get(sessionID)?.transactions.length;\n      const theirFirstNewTxIdx = newContentForSession.after;\n\n      if ((ourKnownTxIdx || 0) < theirFirstNewTxIdx) {\n        invalidStateAssumed = true;\n        continue;\n      }\n\n      const alreadyKnownOffset = ourKnownTxIdx\n        ? ourKnownTxIdx - theirFirstNewTxIdx\n        : 0;\n\n      const newTransactions =\n        newContentForSession.newTransactions.slice(alreadyKnownOffset);\n\n      if (newTransactions.length === 0) {\n        continue;\n      }\n\n      const result = coValue.tryAddTransactions(\n        sessionID,\n        newTransactions,\n        undefined,\n        newContentForSession.lastSignature,\n      );\n\n      if (result.isErr()) {\n        logger.error(\"Failed to add transactions\", {\n          peerId: peer.id,\n          peerRole: peer.role,\n          id: msg.id,\n          err: result.error,\n        });\n        entry.markErrored(peer.id, result.error);\n        continue;\n      }\n\n      this.recordTransactionsSize(newTransactions, peer.role);\n\n      peer.updateSessionCounter(\n        msg.id,\n        sessionID,\n        newContentForSession.after +\n          newContentForSession.newTransactions.length,\n      );\n    }\n\n    if (invalidStateAssumed) {\n      this.trySendToPeer(peer, {\n        action: \"known\",\n        isCorrection: true,\n        ...coValue.knownState(),\n      });\n      peer.toldKnownState.add(msg.id);\n    } else {\n      /**\n       * We are sending a known state message to the peer to acknowledge the\n       * receipt of the new content.\n       *\n       * This way the sender knows that the content has been received and applied\n       * and can update their peer's knownState accordingly.\n       */\n      this.trySendToPeer(peer, {\n        action: \"known\",\n        ...coValue.knownState(),\n      });\n      peer.toldKnownState.add(msg.id);\n    }\n\n    /**\n     * We do send a correction/ack message before syncing to give an immediate\n     * response to the peers that are waiting for confirmation that a coValue is\n     * fully synced\n     */\n    this.requestCoValueSync(coValue);\n  }\n\n  handleCorrection(msg: KnownStateMessage, peer: PeerState) {\n    peer.setKnownState(msg.id, knownStateIn(msg));\n\n    return this.sendNewContentIncludingDependencies(msg.id, peer);\n  }\n\n  handleUnsubscribe(_msg: DoneMessage) {}\n\n  requestedSyncs = new Map<RawCoID, Promise<void>>();\n\n  async requestCoValueSync(coValue: CoValueCore) {\n    const promise = this.requestedSyncs.get(coValue.id);\n\n    if (promise) {\n      return promise;\n    } else {\n      const promise = new Promise<void>((resolve) => {\n        queueMicrotask(() => {\n          this.requestedSyncs.delete(coValue.id);\n          this.syncCoValue(coValue);\n          resolve();\n        });\n      });\n\n      this.requestedSyncs.set(coValue.id, promise);\n      return promise;\n    }\n  }\n\n  async syncCoValue(coValue: CoValueCore) {\n    const entry = this.local.coValuesStore.get(coValue.id);\n\n    for (const peer of this.peersInPriorityOrder()) {\n      if (peer.closed) continue;\n      if (entry.isErroredInPeer(peer.id)) continue;\n\n      // Only subscribed CoValues are synced to clients\n      if (\n        peer.role === \"client\" &&\n        !peer.optimisticKnownStates.has(coValue.id)\n      ) {\n        continue;\n      }\n\n      this.sendNewContentIncludingDependencies(coValue.id, peer);\n    }\n\n    for (const peer of this.getPeers()) {\n      this.syncState.triggerUpdate(peer.id, coValue.id);\n    }\n  }\n\n  async waitForSyncWithPeer(peerId: PeerID, id: RawCoID, timeout: number) {\n    const { syncState } = this;\n    const currentSyncState = syncState.getCurrentSyncState(peerId, id);\n\n    const isTheConditionAlreadyMet = currentSyncState.uploaded;\n\n    if (isTheConditionAlreadyMet) {\n      return true;\n    }\n\n    return new Promise((resolve, reject) => {\n      const unsubscribe = this.syncState.subscribeToPeerUpdates(\n        peerId,\n        (knownState, syncState) => {\n          if (syncState.uploaded && knownState.id === id) {\n            resolve(true);\n            unsubscribe?.();\n            clearTimeout(timeoutId);\n          }\n        },\n      );\n\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Timeout waiting for sync on ${peerId}/${id}`));\n        unsubscribe?.();\n      }, timeout);\n    });\n  }\n\n  async waitForSync(id: RawCoID, timeout = 30_000) {\n    const peers = this.getPeers();\n\n    return Promise.all(\n      peers.map((peer) => this.waitForSyncWithPeer(peer.id, id, timeout)),\n    );\n  }\n\n  async waitForAllCoValuesSync(timeout = 60_000) {\n    const coValues = this.local.coValuesStore.getValues();\n    const validCoValues = Array.from(coValues).filter(\n      (coValue) =>\n        coValue.highLevelState === \"available\" ||\n        coValue.highLevelState === \"loading\",\n    );\n\n    return Promise.all(\n      validCoValues.map((coValue) => this.waitForSync(coValue.id, timeout)),\n    );\n  }\n\n  gracefulShutdown() {\n    for (const peer of Object.values(this.peers)) {\n      peer.gracefulShutdown();\n    }\n  }\n}\n\nfunction knownStateIn(msg: LoadMessage | KnownStateMessage) {\n  return {\n    id: msg.id,\n    header: msg.header,\n    sessions: msg.sessions,\n  };\n}\n", "import { ValueType } from \"@opentelemetry/api\";\nimport { UpDownCounter, metrics } from \"@opentelemetry/api\";\nimport { PeerState } from \"./PeerState.js\";\nimport { CoValueCore, TryAddTransactionsError } from \"./coValueCore.js\";\nimport { RawCoID } from \"./ids.js\";\nimport { logger } from \"./logger.js\";\nimport { PeerID, emptyKnownState } from \"./sync.js\";\n\nexport const CO_VALUE_LOADING_CONFIG = {\n  MAX_RETRIES: 2,\n  TIMEOUT: 30_000,\n};\n\nexport class CoValueState {\n  private peers = new Map<\n    PeerID,\n    | { type: \"unknown\" | \"pending\" | \"available\" | \"unavailable\" }\n    | {\n        type: \"errored\";\n        error: TryAddTransactionsError;\n      }\n  >();\n\n  core: CoValueCore | null = null;\n  id: RawCoID;\n\n  private listeners: Set<(state: CoValueState) => void> = new Set();\n  private counter: UpDownCounter;\n\n  constructor(id: RawCoID) {\n    this.id = id;\n\n    this.counter = metrics\n      .getMeter(\"cojson\")\n      .createUpDownCounter(\"jazz.covalues.loaded\", {\n        description: \"The number of covalues in the system\",\n        unit: \"covalue\",\n        valueType: ValueType.INT,\n      });\n\n    this.updateCounter(null);\n  }\n\n  get highLevelState() {\n    if (this.core) {\n      return \"available\";\n    } else if (this.peers.size === 0) {\n      return \"unknown\";\n    }\n\n    for (const peer of this.peers.values()) {\n      if (peer.type === \"pending\") {\n        return \"loading\";\n      } else if (peer.type === \"unknown\") {\n        return \"unknown\";\n      }\n    }\n\n    return \"unavailable\";\n  }\n\n  isErroredInPeer(peerId: PeerID) {\n    return this.peers.get(peerId)?.type === \"errored\";\n  }\n\n  isAvailable(): this is { type: \"available\"; core: CoValueCore } {\n    return !!this.core;\n  }\n\n  addListener(listener: (state: CoValueState) => void) {\n    this.listeners.add(listener);\n    listener(this);\n  }\n\n  removeListener(listener: (state: CoValueState) => void) {\n    this.listeners.delete(listener);\n  }\n\n  private notifyListeners() {\n    for (const listener of this.listeners) {\n      listener(this);\n    }\n  }\n\n  async getCoValue() {\n    if (this.core) {\n      return this.core;\n    }\n\n    if (this.highLevelState === \"unavailable\") {\n      return \"unavailable\";\n    }\n\n    return new Promise<CoValueCore | \"unavailable\">((resolve) => {\n      const listener = (state: CoValueState) => {\n        if (state.core) {\n          resolve(state.core);\n          this.removeListener(listener);\n        } else if (state.highLevelState === \"unavailable\") {\n          resolve(\"unavailable\");\n          this.removeListener(listener);\n        }\n      };\n\n      this.addListener(listener);\n    });\n  }\n\n  async loadFromPeers(peers: PeerState[]) {\n    if (peers.length === 0) {\n      return;\n    }\n\n    const peersToActuallyLoadFrom = [];\n    for (const peer of peers) {\n      const currentState = this.peers.get(peer.id);\n\n      if (\n        currentState?.type === \"available\" ||\n        currentState?.type === \"pending\"\n      ) {\n        continue;\n      }\n\n      if (currentState?.type === \"errored\") {\n        continue;\n      }\n\n      if (currentState?.type === \"unavailable\") {\n        if (peer.shouldRetryUnavailableCoValues()) {\n          this.markPending(peer.id);\n          peersToActuallyLoadFrom.push(peer);\n        }\n\n        continue;\n      }\n\n      if (!currentState || currentState?.type === \"unknown\") {\n        this.markPending(peer.id);\n        peersToActuallyLoadFrom.push(peer);\n      }\n    }\n\n    for (const peer of peersToActuallyLoadFrom) {\n      if (peer.closed) {\n        this.markNotFoundInPeer(peer.id);\n        continue;\n      }\n\n      peer.pushOutgoingMessage({\n        action: \"load\",\n        ...(this.core ? this.core.knownState() : emptyKnownState(this.id)),\n      });\n\n      /**\n       * Use a very long timeout for storage peers, because under pressure\n       * they may take a long time to consume the messages queue\n       *\n       * TODO: Track errors on storage and do not rely on timeout\n       */\n      const timeoutDuration =\n        peer.role === \"storage\"\n          ? CO_VALUE_LOADING_CONFIG.TIMEOUT * 10\n          : CO_VALUE_LOADING_CONFIG.TIMEOUT;\n\n      const waitingForPeer = new Promise<void>((resolve) => {\n        const markNotFound = () => {\n          if (this.peers.get(peer.id)?.type === \"pending\") {\n            this.markNotFoundInPeer(peer.id);\n          }\n        };\n\n        const timeout = setTimeout(markNotFound, timeoutDuration);\n        const removeCloseListener = peer.addCloseListener(markNotFound);\n\n        const listener = (state: CoValueState) => {\n          const peerState = state.peers.get(peer.id);\n          if (\n            state.isAvailable() || // might have become available from another peer e.g. through handleNewContent\n            peerState?.type === \"available\" ||\n            peerState?.type === \"errored\" ||\n            peerState?.type === \"unavailable\"\n          ) {\n            state.removeListener(listener);\n            removeCloseListener();\n            clearTimeout(timeout);\n            resolve();\n          }\n        };\n\n        this.addListener(listener);\n      });\n\n      await waitingForPeer;\n    }\n  }\n\n  private updateCounter(previousState: string | null) {\n    const newState = this.highLevelState;\n\n    if (previousState !== newState) {\n      if (previousState) {\n        this.counter.add(-1, { state: previousState });\n      }\n      this.counter.add(1, { state: newState });\n    }\n  }\n\n  markNotFoundInPeer(peerId: PeerID) {\n    const previousState = this.highLevelState;\n    this.peers.set(peerId, { type: \"unavailable\" });\n    this.updateCounter(previousState);\n    this.notifyListeners();\n  }\n\n  // TODO: rename to \"provided\"\n  markAvailable(coValue: CoValueCore, fromPeerId: PeerID) {\n    const previousState = this.highLevelState;\n    this.core = coValue;\n    this.peers.set(fromPeerId, { type: \"available\" });\n    this.updateCounter(previousState);\n    this.notifyListeners();\n  }\n\n  internalMarkMagicallyAvailable(coValue: CoValueCore) {\n    const previousState = this.highLevelState;\n    this.core = coValue;\n    this.updateCounter(previousState);\n    this.notifyListeners();\n  }\n\n  markErrored(peerId: PeerID, error: TryAddTransactionsError) {\n    const previousState = this.highLevelState;\n    this.peers.set(peerId, { type: \"errored\", error });\n    this.updateCounter(previousState);\n    this.notifyListeners();\n  }\n\n  private markPending(peerId: PeerID) {\n    const previousState = this.highLevelState;\n    this.peers.set(peerId, { type: \"pending\" });\n    this.updateCounter(previousState);\n    this.notifyListeners();\n  }\n}\n", "import { CoValueCore } from \"./coValueCore.js\";\nimport { CoValueState } from \"./coValueState.js\";\nimport { RawCoID } from \"./ids.js\";\nimport { PeerID } from \"./sync.js\";\n\nexport class CoValuesStore {\n  coValues = new Map<RawCoID, CoValueState>();\n\n  get(id: RawCoID) {\n    let entry = this.coValues.get(id);\n\n    if (!entry) {\n      entry = new CoValueState(id);\n      this.coValues.set(id, entry);\n    }\n\n    return entry;\n  }\n\n  markAsAvailable(id: RawCoID, coValue: CoValueCore, fromPeerId: PeerID) {\n    const entry = this.get(id);\n    entry.markAvailable(coValue, fromPeerId);\n  }\n\n  internalMarkMagicallyAvailable(id: RawCoID, coValue: CoValueCore) {\n    const entry = this.get(id);\n    entry.internalMarkMagicallyAvailable(coValue);\n  }\n\n  getEntries() {\n    return this.coValues.entries();\n  }\n\n  getValues() {\n    return this.coValues.values();\n  }\n\n  getKeys() {\n    return this.coValues.keys();\n  }\n}\n", "import { Result, ResultAsync, err, ok, okAsync } from \"neverthrow\";\nimport { CoValuesStore } from \"./CoValuesStore.js\";\nimport { CoID } from \"./coValue.js\";\nimport { RawCoValue } from \"./coValue.js\";\nimport {\n  CoValueCore,\n  CoValueHeader,\n  CoValueUniqueness,\n} from \"./coValueCore.js\";\nimport {\n  AccountMeta,\n  ControlledAccountOrAgent,\n  ControlledAgent,\n  InvalidAccountAgentIDError,\n  RawProfile as Profile,\n  RawAccount,\n  RawAccountID,\n  RawAccountMigration,\n  RawControlledAccount,\n  RawProfile,\n  accountHeaderForInitialAgentSecret,\n} from \"./coValues/account.js\";\nimport {\n  InviteSecret,\n  RawGroup,\n  secretSeedFromInviteSecret,\n} from \"./coValues/group.js\";\nimport { AgentSecret, CryptoProvider } from \"./crypto/crypto.js\";\nimport { AgentID, RawCoID, SessionID, isAgentID } from \"./ids.js\";\nimport { logger } from \"./logger.js\";\nimport { Peer, PeerID, SyncManager } from \"./sync.js\";\nimport { expectGroup } from \"./typeUtils/expectGroup.js\";\n\n/** A `LocalNode` represents a local view of a set of loaded `CoValue`s, from the perspective of a particular account (or primitive cryptographic agent).\n\nA `LocalNode` can have peers that it syncs to, for example some form of local persistence, or a sync server, such as `cloud.jazz.tools` (Jazz Cloud).\n\n@example\nYou typically get hold of a `LocalNode` using `jazz-react`'s `useJazz()`:\n\n```typescript\nconst { localNode } = useJazz();\n```\n*/\nexport class LocalNode {\n  /** @internal */\n  crypto: CryptoProvider;\n  /** @internal */\n  coValuesStore = new CoValuesStore();\n  /** @category 3. Low-level */\n  account: ControlledAccountOrAgent;\n  /** @category 3. Low-level */\n  currentSessionID: SessionID;\n  /** @category 3. Low-level */\n  syncManager = new SyncManager(this);\n\n  crashed: Error | undefined = undefined;\n\n  /** @category 3. Low-level */\n  constructor(\n    account: ControlledAccountOrAgent,\n    currentSessionID: SessionID,\n    crypto: CryptoProvider,\n  ) {\n    this.account = account;\n    this.currentSessionID = currentSessionID;\n    this.crypto = crypto;\n  }\n\n  /** @category 2. Node Creation */\n  static async withNewlyCreatedAccount<Meta extends AccountMeta = AccountMeta>({\n    creationProps,\n    peersToLoadFrom,\n    migration,\n    crypto,\n    initialAgentSecret = crypto.newRandomAgentSecret(),\n  }: {\n    creationProps: { name: string };\n    peersToLoadFrom?: Peer[];\n    migration?: RawAccountMigration<Meta>;\n    crypto: CryptoProvider;\n    initialAgentSecret?: AgentSecret;\n  }): Promise<{\n    node: LocalNode;\n    accountID: RawAccountID;\n    accountSecret: AgentSecret;\n    sessionID: SessionID;\n  }> {\n    const throwawayAgent = crypto.newRandomAgentSecret();\n    const setupNode = new LocalNode(\n      new ControlledAgent(throwawayAgent, crypto),\n      crypto.newRandomSessionID(crypto.getAgentID(throwawayAgent)),\n      crypto,\n    );\n\n    const account = setupNode.createAccount(initialAgentSecret);\n\n    const nodeWithAccount = account.core.node.testWithDifferentAccount(\n      account,\n      crypto.newRandomSessionID(account.id),\n    );\n\n    const accountOnNodeWithAccount =\n      nodeWithAccount.account as RawControlledAccount<Meta>;\n\n    if (peersToLoadFrom) {\n      for (const peer of peersToLoadFrom) {\n        nodeWithAccount.syncManager.addPeer(peer);\n      }\n    }\n\n    if (migration) {\n      await migration(accountOnNodeWithAccount, nodeWithAccount, creationProps);\n    } else {\n      const profileGroup = accountOnNodeWithAccount.createGroup();\n      profileGroup.addMember(\"everyone\", \"reader\");\n      const profile = profileGroup.createMap<Profile>({\n        name: creationProps.name,\n      });\n      accountOnNodeWithAccount.set(\"profile\", profile.id, \"trusting\");\n    }\n\n    const controlledAccount = new RawControlledAccount(\n      accountOnNodeWithAccount.core,\n      accountOnNodeWithAccount.agentSecret,\n    );\n\n    nodeWithAccount.account = controlledAccount;\n    nodeWithAccount.coValuesStore.internalMarkMagicallyAvailable(\n      controlledAccount.id,\n      controlledAccount.core,\n    );\n    controlledAccount.core._cachedContent = undefined;\n\n    if (!controlledAccount.get(\"profile\")) {\n      throw new Error(\"Must set account profile in initial migration\");\n    }\n\n    // we shouldn't need this, but it fixes account data not syncing for new accounts\n    function syncAllCoValuesAfterCreateAccount() {\n      for (const coValueEntry of nodeWithAccount.coValuesStore.getValues()) {\n        if (coValueEntry.isAvailable()) {\n          void nodeWithAccount.syncManager.requestCoValueSync(\n            coValueEntry.core,\n          );\n        }\n      }\n    }\n\n    syncAllCoValuesAfterCreateAccount();\n\n    setTimeout(syncAllCoValuesAfterCreateAccount, 500);\n\n    return {\n      node: nodeWithAccount,\n      accountID: accountOnNodeWithAccount.id,\n      accountSecret: accountOnNodeWithAccount.agentSecret,\n      sessionID: nodeWithAccount.currentSessionID,\n    };\n  }\n\n  /** @category 2. Node Creation */\n  static async withLoadedAccount<Meta extends AccountMeta = AccountMeta>({\n    accountID,\n    accountSecret,\n    sessionID,\n    peersToLoadFrom,\n    crypto,\n    migration,\n  }: {\n    accountID: RawAccountID;\n    accountSecret: AgentSecret;\n    sessionID: SessionID | undefined;\n    peersToLoadFrom: Peer[];\n    crypto: CryptoProvider;\n    migration?: RawAccountMigration<Meta>;\n  }): Promise<LocalNode> {\n    try {\n      const loadingNode = new LocalNode(\n        new ControlledAgent(accountSecret, crypto),\n        crypto.newRandomSessionID(accountID),\n        crypto,\n      );\n\n      for (const peer of peersToLoadFrom) {\n        loadingNode.syncManager.addPeer(peer);\n      }\n\n      const accountPromise = loadingNode.load(accountID);\n\n      const account = await accountPromise;\n\n      if (account === \"unavailable\") {\n        throw new Error(\"Account unavailable from all peers\");\n      }\n\n      const controlledAccount = new RawControlledAccount(\n        account.core,\n        accountSecret,\n      );\n\n      // since this is all synchronous, we can just swap out nodes for the SyncManager\n      const node = loadingNode.testWithDifferentAccount(\n        controlledAccount,\n        sessionID || crypto.newRandomSessionID(accountID),\n      );\n      node.syncManager = loadingNode.syncManager;\n      node.syncManager.local = node;\n\n      controlledAccount.core.node = node;\n      node.coValuesStore.internalMarkMagicallyAvailable(\n        accountID,\n        controlledAccount.core,\n      );\n      controlledAccount.core._cachedContent = undefined;\n\n      const profileID = account.get(\"profile\");\n      if (!profileID) {\n        throw new Error(\"Account has no profile\");\n      }\n      const profile = await node.load(profileID);\n\n      if (profile === \"unavailable\") {\n        throw new Error(\"Profile unavailable from all peers\");\n      }\n\n      if (migration) {\n        await migration(controlledAccount as RawControlledAccount<Meta>, node);\n        node.account = new RawControlledAccount(\n          controlledAccount.core,\n          controlledAccount.agentSecret,\n        );\n      }\n\n      return node;\n    } catch (e) {\n      logger.error(\"Error withLoadedAccount\", { err: e });\n      throw e;\n    }\n  }\n\n  /** @internal */\n  createCoValue(header: CoValueHeader): CoValueCore {\n    if (this.crashed) {\n      throw new Error(\"Trying to create CoValue after node has crashed\", {\n        cause: this.crashed,\n      });\n    }\n\n    const coValue = new CoValueCore(header, this);\n    this.coValuesStore.internalMarkMagicallyAvailable(coValue.id, coValue);\n\n    void this.syncManager.requestCoValueSync(coValue);\n\n    return coValue;\n  }\n\n  /** @internal */\n  async loadCoValueCore(\n    id: RawCoID,\n    skipLoadingFromPeer?: PeerID,\n  ): Promise<CoValueCore | \"unavailable\"> {\n    if (this.crashed) {\n      throw new Error(\"Trying to load CoValue after node has crashed\", {\n        cause: this.crashed,\n      });\n    }\n\n    let retries = 0;\n\n    while (true) {\n      const entry = this.coValuesStore.get(id);\n\n      if (\n        entry.highLevelState === \"unknown\" ||\n        entry.highLevelState === \"unavailable\"\n      ) {\n        const peers =\n          this.syncManager.getServerAndStoragePeers(skipLoadingFromPeer);\n\n        if (peers.length === 0) {\n          return \"unavailable\";\n        }\n\n        entry.loadFromPeers(peers).catch((e) => {\n          logger.error(\"Error loading from peers\", {\n            id,\n            err: e,\n          });\n        });\n      }\n\n      const result = await entry.getCoValue();\n\n      if (result !== \"unavailable\" || retries >= 1) {\n        return result;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 300));\n\n      retries++;\n    }\n  }\n\n  /**\n   * Loads a CoValue's content, syncing from peers as necessary and resolving the returned\n   * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`\n   * for listening to subsequent updates to the CoValue.\n   *\n   * @category 3. Low-level\n   */\n  async load<T extends RawCoValue>(id: CoID<T>): Promise<T | \"unavailable\"> {\n    if (!id) {\n      throw new Error(\"Trying to load CoValue with undefined id\");\n    }\n\n    if (!id.startsWith(\"co_z\")) {\n      throw new Error(`Trying to load CoValue with invalid id ${id}`);\n    }\n\n    const core = await this.loadCoValueCore(id);\n\n    if (core === \"unavailable\") {\n      return \"unavailable\";\n    }\n\n    return core.getCurrentContent() as T;\n  }\n\n  getLoaded<T extends RawCoValue>(id: CoID<T>): T | undefined {\n    const entry = this.coValuesStore.get(id);\n\n    if (entry.isAvailable()) {\n      return entry.core.getCurrentContent() as T;\n    }\n\n    return undefined;\n  }\n\n  /** @category 3. Low-level */\n  subscribe<T extends RawCoValue>(\n    id: CoID<T>,\n    callback: (update: T | \"unavailable\") => void,\n  ): () => void {\n    let stopped = false;\n    let unsubscribe!: () => void;\n\n    this.load(id)\n      .then((coValue) => {\n        if (stopped) {\n          return;\n        }\n        if (coValue === \"unavailable\") {\n          callback(\"unavailable\");\n          return;\n        }\n        unsubscribe = coValue.subscribe(callback);\n      })\n      .catch((e) => {\n        logger.error(\"Subscription error\", {\n          id,\n          err: e,\n        });\n      });\n\n    return () => {\n      stopped = true;\n      unsubscribe?.();\n    };\n  }\n\n  /** @deprecated Use Account.acceptInvite instead */\n  async acceptInvite<T extends RawCoValue>(\n    groupOrOwnedValueID: CoID<T>,\n    inviteSecret: InviteSecret,\n  ): Promise<void> {\n    const groupOrOwnedValue = await this.load(groupOrOwnedValueID);\n\n    if (groupOrOwnedValue === \"unavailable\") {\n      throw new Error(\n        \"Trying to accept invite: Group/owned value unavailable from all peers\",\n      );\n    }\n\n    if (groupOrOwnedValue.core.header.ruleset.type === \"ownedByGroup\") {\n      return this.acceptInvite(\n        groupOrOwnedValue.core.header.ruleset.group as CoID<RawGroup>,\n        inviteSecret,\n      );\n    } else if (groupOrOwnedValue.core.header.ruleset.type !== \"group\") {\n      throw new Error(\"Can only accept invites to groups\");\n    }\n\n    const group = expectGroup(groupOrOwnedValue);\n\n    const inviteAgentSecret = this.crypto.agentSecretFromSecretSeed(\n      secretSeedFromInviteSecret(inviteSecret),\n    );\n    const inviteAgentID = this.crypto.getAgentID(inviteAgentSecret);\n\n    const inviteRole = await new Promise((resolve, reject) => {\n      group.subscribe((groupUpdate) => {\n        const role = groupUpdate.get(inviteAgentID);\n        if (role) {\n          resolve(role);\n        }\n      });\n      setTimeout(\n        () => reject(new Error(\"Couldn't find invite before timeout\")),\n        2000,\n      );\n    });\n\n    if (!inviteRole) {\n      throw new Error(\"No invite found\");\n    }\n\n    const existingRole = group.get(this.account.id);\n\n    if (\n      existingRole === \"admin\" ||\n      (existingRole === \"writer\" && inviteRole === \"writerInvite\") ||\n      (existingRole === \"writer\" && inviteRole === \"reader\") ||\n      (existingRole === \"reader\" && inviteRole === \"readerInvite\") ||\n      (existingRole && inviteRole === \"writeOnlyInvite\")\n    ) {\n      logger.debug(\"Not accepting invite that would replace or downgrade role\");\n      return;\n    }\n\n    const groupAsInvite = expectGroup(\n      group.core\n        .testWithDifferentAccount(\n          new ControlledAgent(inviteAgentSecret, this.crypto),\n          this.crypto.newRandomSessionID(inviteAgentID),\n        )\n        .getCurrentContent(),\n    );\n\n    groupAsInvite.addMemberInternal(\n      this.account,\n      inviteRole === \"adminInvite\"\n        ? \"admin\"\n        : inviteRole === \"writerInvite\"\n          ? \"writer\"\n          : inviteRole === \"writeOnlyInvite\"\n            ? \"writeOnly\"\n            : \"reader\",\n    );\n\n    group.core._sessionLogs = groupAsInvite.core.sessionLogs;\n    group.core._cachedContent = undefined;\n\n    for (const groupListener of group.core.listeners) {\n      groupListener(group.core.getCurrentContent());\n    }\n  }\n\n  /** @internal */\n  expectCoValueLoaded(id: RawCoID, expectation?: string): CoValueCore {\n    const entry = this.coValuesStore.get(id);\n\n    if (!entry.isAvailable()) {\n      throw new Error(\n        `${expectation ? expectation + \": \" : \"\"}CoValue ${id} not yet loaded. Current state: ${JSON.stringify(entry)}`,\n      );\n    }\n    return entry.core;\n  }\n\n  /** @internal */\n  expectProfileLoaded(id: RawAccountID, expectation?: string): RawProfile {\n    const account = this.expectCoValueLoaded(id, expectation);\n    const profileID = expectGroup(account.getCurrentContent()).get(\"profile\");\n    if (!profileID) {\n      throw new Error(\n        `${expectation ? expectation + \": \" : \"\"}Account ${id} has no profile`,\n      );\n    }\n    return this.expectCoValueLoaded(\n      profileID,\n      expectation,\n    ).getCurrentContent() as RawProfile;\n  }\n\n  /** @internal */\n  createAccount(\n    agentSecret = this.crypto.newRandomAgentSecret(),\n  ): RawControlledAccount {\n    const accountAgentID = this.crypto.getAgentID(agentSecret);\n    const account = expectGroup(\n      this.createCoValue(\n        accountHeaderForInitialAgentSecret(agentSecret, this.crypto),\n      )\n        .testWithDifferentAccount(\n          new ControlledAgent(agentSecret, this.crypto),\n          this.crypto.newRandomSessionID(accountAgentID),\n        )\n        .getCurrentContent(),\n    );\n\n    account.set(accountAgentID, \"admin\", \"trusting\");\n\n    const readKey = this.crypto.newRandomKeySecret();\n\n    const sealed = this.crypto.seal({\n      message: readKey.secret,\n      from: this.crypto.getAgentSealerSecret(agentSecret),\n      to: this.crypto.getAgentSealerID(accountAgentID),\n      nOnceMaterial: {\n        in: account.id,\n        tx: account.core.nextTransactionID(),\n      },\n    });\n\n    account.set(`${readKey.id}_for_${accountAgentID}`, sealed, \"trusting\");\n\n    account.set(\"readKey\", readKey.id, \"trusting\");\n\n    const accountOnThisNode = this.expectCoValueLoaded(account.id);\n\n    accountOnThisNode._sessionLogs = new Map(account.core.sessionLogs);\n\n    accountOnThisNode._cachedContent = undefined;\n\n    return new RawControlledAccount(accountOnThisNode, agentSecret);\n  }\n\n  /** @internal */\n  resolveAccountAgent(\n    id: RawAccountID | AgentID,\n    expectation?: string,\n  ): Result<AgentID, ResolveAccountAgentError> {\n    if (isAgentID(id)) {\n      return ok(id);\n    }\n\n    let coValue: CoValueCore;\n\n    try {\n      coValue = this.expectCoValueLoaded(id, expectation);\n    } catch (e) {\n      return err({\n        type: \"ErrorLoadingCoValueCore\",\n        expectation,\n        id,\n        error: e,\n      } satisfies LoadCoValueCoreError);\n    }\n\n    if (\n      coValue.header.type !== \"comap\" ||\n      coValue.header.ruleset.type !== \"group\" ||\n      !coValue.header.meta ||\n      !(\"type\" in coValue.header.meta) ||\n      coValue.header.meta.type !== \"account\"\n    ) {\n      return err({\n        type: \"UnexpectedlyNotAccount\",\n        expectation,\n        id,\n      } satisfies UnexpectedlyNotAccountError);\n    }\n\n    return ok((coValue.getCurrentContent() as RawAccount).currentAgentID());\n  }\n\n  resolveAccountAgentAsync(\n    id: RawAccountID | AgentID,\n    expectation?: string,\n  ): ResultAsync<AgentID, ResolveAccountAgentError> {\n    if (isAgentID(id)) {\n      return okAsync(id);\n    }\n\n    return ResultAsync.fromPromise(\n      this.loadCoValueCore(id),\n      (e) =>\n        ({\n          type: \"ErrorLoadingCoValueCore\",\n          expectation,\n          id,\n          error: e,\n        }) satisfies LoadCoValueCoreError,\n    ).andThen((coValue) => {\n      if (coValue === \"unavailable\") {\n        return err({\n          type: \"AccountUnavailableFromAllPeers\" as const,\n          expectation,\n          id,\n        } satisfies AccountUnavailableFromAllPeersError);\n      }\n\n      if (\n        coValue.header.type !== \"comap\" ||\n        coValue.header.ruleset.type !== \"group\" ||\n        !coValue.header.meta ||\n        !(\"type\" in coValue.header.meta) ||\n        coValue.header.meta.type !== \"account\"\n      ) {\n        return err({\n          type: \"UnexpectedlyNotAccount\" as const,\n          expectation,\n          id,\n        } satisfies UnexpectedlyNotAccountError);\n      }\n\n      return ok((coValue.getCurrentContent() as RawAccount).currentAgentID());\n    });\n  }\n\n  /**\n   * @deprecated use Account.createGroup() instead\n   */\n  createGroup(\n    uniqueness: CoValueUniqueness = this.crypto.createdNowUnique(),\n  ): RawGroup {\n    const groupCoValue = this.createCoValue({\n      type: \"comap\",\n      ruleset: { type: \"group\", initialAdmin: this.account.id },\n      meta: null,\n      ...uniqueness,\n    });\n\n    const group = expectGroup(groupCoValue.getCurrentContent());\n\n    group.set(this.account.id, \"admin\", \"trusting\");\n\n    const readKey = this.crypto.newRandomKeySecret();\n\n    group.set(\n      `${readKey.id}_for_${this.account.id}`,\n      this.crypto.seal({\n        message: readKey.secret,\n        from: this.account.currentSealerSecret(),\n        to: this.account.currentSealerID(),\n        nOnceMaterial: {\n          in: groupCoValue.id,\n          tx: groupCoValue.nextTransactionID(),\n        },\n      }),\n      \"trusting\",\n    );\n\n    group.set(\"readKey\", readKey.id, \"trusting\");\n\n    return group;\n  }\n\n  /** @internal */\n  testWithDifferentAccount(\n    account: ControlledAccountOrAgent,\n    currentSessionID: SessionID,\n  ): LocalNode {\n    const newNode = new LocalNode(account, currentSessionID, this.crypto);\n\n    const coValuesToCopy = Array.from(this.coValuesStore.getEntries());\n\n    while (coValuesToCopy.length > 0) {\n      const [coValueID, entry] = coValuesToCopy[coValuesToCopy.length - 1]!;\n\n      if (!entry.isAvailable()) {\n        coValuesToCopy.pop();\n        continue;\n      } else {\n        const allDepsCopied = entry.core\n          .getDependedOnCoValues()\n          .every((dep) => newNode.coValuesStore.get(dep).isAvailable());\n\n        if (!allDepsCopied) {\n          // move to end of queue\n          coValuesToCopy.unshift(coValuesToCopy.pop()!);\n          continue;\n        }\n\n        const newCoValue = new CoValueCore(\n          entry.core.header,\n          newNode,\n          new Map(entry.core.sessionLogs),\n        );\n\n        newNode.coValuesStore.internalMarkMagicallyAvailable(\n          coValueID,\n          newCoValue,\n        );\n\n        coValuesToCopy.pop();\n      }\n    }\n\n    if (account instanceof RawControlledAccount) {\n      // To make sure that when we edit the account, we're modifying the correct sessions\n      const accountInNode = new RawControlledAccount(\n        newNode.expectCoValueLoaded(account.id),\n        account.agentSecret,\n      );\n      if (accountInNode.core.node !== newNode) {\n        throw new Error(\"Account's node is not the new node\");\n      }\n      newNode.account = accountInNode;\n    }\n\n    return newNode;\n  }\n\n  gracefulShutdown() {\n    this.syncManager.gracefulShutdown();\n  }\n}\n\nexport type LoadCoValueCoreError = {\n  type: \"ErrorLoadingCoValueCore\";\n  error: unknown;\n  expectation?: string;\n  id: RawAccountID;\n};\n\nexport type AccountUnavailableFromAllPeersError = {\n  type: \"AccountUnavailableFromAllPeers\";\n  expectation?: string;\n  id: RawAccountID;\n};\n\nexport type UnexpectedlyNotAccountError = {\n  type: \"UnexpectedlyNotAccount\";\n  expectation?: string;\n  id: RawAccountID;\n};\n\nexport type ResolveAccountAgentError =\n  | InvalidAccountAgentIDError\n  | LoadCoValueCoreError\n  | AccountUnavailableFromAllPeersError\n  | UnexpectedlyNotAccountError;\n", "/**\n * Exposes the promise executor callbacks (resolve, reject).\n */\nexport default class Deferred<A> {\n  promise: Promise<A>;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (value) => {\n        resolve(value);\n        return this.promise;\n      };\n      this.reject = (reason) => {\n        reject(reason);\n        return this.promise;\n      };\n    });\n  }\n}\n\nexport default interface Deferred<A> {\n  resolve(value: A | PromiseLike<A>): Promise<A>;\n  reject(reason?: string | Error): Promise<A>;\n}\n", ";(function() { // closure for web browsers\n\nfunction Item (data, prev, next) {\n  this.next = next\n  if (next) next.prev = this\n  this.prev = prev\n  if (prev) prev.next = this\n  this.data = data\n}\n\nfunction FastList () {\n  if (!(this instanceof FastList)) return new FastList\n  this._head = null\n  this._tail = null\n  this.length = 0\n}\n\nFastList.prototype =\n{ push: function (data) {\n    this._tail = new Item(data, this._tail, null)\n    if (!this._head) this._head = this._tail\n    this.length ++\n  }\n\n, pop: function () {\n    if (this.length === 0) return undefined\n    var t = this._tail\n    this._tail = t.prev\n    if (t.prev) {\n      t.prev = this._tail.next = null\n    }\n    this.length --\n    if (this.length === 1) this._head = this._tail\n    else if (this.length === 0) this._head = this._tail = null\n    return t.data\n  }\n\n, unshift: function (data) {\n    this._head = new Item(data, null, this._head)\n    if (!this._tail) this._tail = this._head\n    this.length ++\n  }\n\n, shift: function () {\n    if (this.length === 0) return undefined\n    var h = this._head\n    this._head = h.next\n    if (h.next) {\n      h.next = this._head.prev = null\n    }\n    this.length --\n    if (this.length === 1) this._tail = this._head\n    else if (this.length === 0) this._head = this._tail = null\n    return h.data\n  }\n\n, item: function (n) {\n    if (n < 0) n = this.length + n\n    var h = this._head\n    while (n-- > 0 && h) h = h.next\n    return h ? h.data : undefined\n  }\n\n, slice: function (n, m) {\n    if (!n) n = 0\n    if (!m) m = this.length\n    if (m < 0) m = this.length + m\n    if (n < 0) n = this.length + n\n\n    if (m === n) {\n      return []\n    }\n\n    if (m < n) {\n      throw new Error(\"invalid offset: \"+n+\",\"+m+\" (length=\"+this.length+\")\")\n    }\n\n    var len = m - n\n      , ret = new Array(len)\n      , i = 0\n      , h = this._head\n    while (n-- > 0 && h) h = h.next\n    while (i < len && h) {\n      ret[i++] = h.data\n      h = h.next\n    }\n    return ret\n  }\n\n, drop: function () {\n    FastList.call(this)\n  }\n\n, forEach: function (fn, thisp) {\n    var p = this._head\n      , i = 0\n      , len = this.length\n    while (i < len && p) {\n      fn.call(thisp || this, p.data, i, this)\n      p = p.next\n      i ++\n    }\n  }\n\n, map: function (fn, thisp) {\n    var n = new FastList()\n    this.forEach(function (v, i, me) {\n      n.push(fn.call(thisp || me, v, i, me))\n    })\n    return n\n  }\n\n, filter: function (fn, thisp) {\n    var n = new FastList()\n    this.forEach(function (v, i, me) {\n      if (fn.call(thisp || me, v, i, me)) n.push(v)\n    })\n    return n\n  }\n\n, reduce: function (fn, val, thisp) {\n    var i = 0\n      , p = this._head\n      , len = this.length\n    if (!val) {\n      i = 1\n      val = p && p.data\n      p = p && p.next\n    }\n    while (i < len && p) {\n      val = fn.call(thisp || this, val, p.data, this)\n      i ++\n      p = p.next\n    }\n    return val\n  }\n}\n\nif (\"undefined\" !== typeof(exports)) module.exports = FastList\nelse if (\"function\" === typeof(define) && define.amd) {\n  define(\"FastList\", function() { return FastList })\n} else (function () { return this })().FastList = FastList\n\n})()\n", "import fastList from 'fast-list';\n\n/**\n * First-in, first-out (FIFO) buffer (queue) with default item values.\n * Optionally circular based on {@link Buffer.limit}.\n * Can be switched to LIFO with {@link Buffer#reverse}.\n */\nexport default class Buffer<A> {\n  #list: fastList.List<A>;\n  #reversed = false;\n  length = 0;\n\n  constructor(\n    /** The length after which the buffer becomes circular, i.e., discards oldest items. */\n    readonly limit = Infinity,\n  ) {\n    this.#list = new fastList();\n  }\n  /**\n   * Add an item to the end of the buffer.\n   */\n  enqueue(value: A): void {\n    const list = this.#list;\n    if (list.length === this.limit) {\n      // Discard oldest item\n      list.shift();\n    } else {\n      this.length += 1;\n    }\n    list.push(value);\n  }\n  /**\n   * Return the oldest item from the buffer.\n   */\n  dequeue(): A {\n    if (this.length === 0) {\n      throw Error('Buffer is empty');\n    }\n    this.length -= 1;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#reversed ? this.#list.pop()! : this.#list.shift()!;\n  }\n\n  clear(): void {\n    this.length = 0;\n    this.#list.drop();\n  }\n\n  forEach(f: (value: A) => void): void {\n    this.#list.forEach(f);\n  }\n\n  reverse() {\n    this.#reversed = true;\n    return this;\n  }\n\n  [Symbol.iterator]() {\n    return {\n      next: () => {\n        return this.length > 0\n          ? {\n              value: this.dequeue(),\n              done: false as const,\n            }\n          : {\n              done: true as const,\n              value: undefined,\n            };\n      },\n      [Symbol.iterator]() {\n        return this;\n      },\n    };\n  }\n\n  static from<A>(iterable: Iterable<A>, limit: number) {\n    const buffer = new Buffer<A>(limit);\n    for (const value of iterable) {\n      buffer.enqueue(value);\n    }\n    return buffer;\n  }\n}\n", "export interface Returnable<A> extends AsyncIterableIterator<A> {\n  return(value?: A): Promise<IteratorResult<A>>;\n}\n\nexport interface PushAdapter<A> extends AsyncIterableIterator<A> {\n  push(value: A): Promise<IteratorResult<A>>;\n  wrap(onReturn?: () => void): AsyncIterableIterator<A>;\n}\n\n/** The result returned from closed iterators. */\nexport const doneResult = Object.freeze({\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  value: undefined!,\n  done: true,\n});\n\nexport const donePromise = Promise.resolve(doneResult);\n", "import { PushAdapter } from './common';\n\nexport type EventMap = GlobalEventHandlersEventMap;\n\n// TODO add overloads for special event targets (Window, Document)\n/**\n * Convert DOM events to an async iterable iterator.\n */\nconst fromDom =\n  <T extends keyof EventMap>(init: () => PushAdapter<EventMap[T]>) =>\n  (\n    type: T,\n    target: Target<T>,\n    options?: boolean | AddEventListenerOptions,\n  ): AsyncIterableIterator<EventMap[T]> => {\n    const adapter = init();\n    const listener = (event: EventMap[T]) => void adapter.push(event);\n    target.addEventListener(type, listener, options);\n    return adapter.wrap(() => target.removeEventListener(type, listener, options));\n  };\n\nexport type Listener<T extends keyof EventMap> = (e: EventMap[T]) => void;\n\nexport type Target<\n  T extends keyof EventMap,\n  L = Listener<T>,\n  O = boolean | AddEventListenerOptions,\n> = EventTarget & {\n  addEventListener(type: T, listener: L, options?: O): void;\n  removeEventListener(type: T, listener: L, options?: O): void;\n};\n\nexport default fromDom;\n", "import { PushAdapter } from './common';\n\n// TODO implement strict-event-emitter-types support\n/**\n * Convert node EventEmitter events to an async iterable iterator.\n */\nconst fromEmitter =\n  <Event>(init: () => PushAdapter<Event>) =>\n  (type: string | symbol, emitter: NodeJS.EventEmitter): AsyncIterableIterator<Event> => {\n    const adapter = init();\n    const listener = (event: Event) => void adapter.push(event);\n    emitter.addListener(type, listener);\n    return adapter.wrap(() => void emitter.removeListener(type, listener));\n  };\n\nexport default fromEmitter;\n", "import Channel from './Channel';\nimport { PushAdapter } from '../common';\n\n/**\n * Multicasts pushed values to a variable number of async iterable iterators\n * as receivers or subscribers.\n *\n * Does not buffer pushed values; if no receivers are registered, pushed\n * values are silently discarded.\n */\nexport default class Multicast<A> implements AsyncIterable<A> {\n  onStart?(): void;\n  onStop?(): void;\n\n  readonly receivers: Set<PushAdapter<A>> = new Set();\n\n  constructor(private readonly init: () => PushAdapter<A> = () => new Channel()) {}\n\n  /**\n   * Pushes a value to all registered receivers.\n   */\n  push(value: A): this {\n    this.receivers.forEach((balancer) => balancer.push(value));\n    return this;\n  }\n\n  /**\n   * Creates and registers a receiver.\n   */\n  [Symbol.asyncIterator](): AsyncIterableIterator<A> {\n    const producer = this.init();\n    const { receivers } = this;\n    receivers.add(producer);\n    if (this.onStart && receivers.size === 1) {\n      this.onStart();\n    }\n    return producer.wrap(() => {\n      receivers.delete(producer);\n      if (this.onStop && receivers.size === 0) {\n        this.onStop();\n      }\n    });\n  }\n}\n", "import Deferred from '../Deferred';\nimport { PushAdapter, doneResult } from '../common';\nimport fromDom from '../fromDom';\nimport fromEmitter from '../fromEmitter';\n\nexport default class LastResult<A> implements PushAdapter<A> {\n  private buffer: Deferred<IteratorResult<A>> = new Deferred();\n  private closed = false;\n  private resolved = false;\n  private requested = false;\n\n  static fromDom = fromDom(() => new LastResult());\n  static fromEmitter = fromEmitter(() => new LastResult());\n\n  push(value: A, done = false): Promise<IteratorResult<A>> {\n    if (this.closed) {\n      throw Error('Iterator closed');\n    }\n    const result = {\n      value,\n      done,\n    };\n    if (this.resolved === false) {\n      this.resolved = true;\n    } else {\n      this.buffer = new Deferred();\n      this.resolved = false;\n    }\n    this.requested = false;\n    this.buffer.resolve(result);\n    return this.buffer.promise;\n  }\n\n  async next(): Promise<IteratorResult<A>> {\n    if (this.closed) {\n      return doneResult;\n    }\n    this.requested = true;\n    return this.buffer.promise;\n  }\n\n  async return(value?: A): Promise<IteratorResult<A>> {\n    this.closed = true;\n    if (!this.resolved && this.requested) {\n      this.buffer.resolve(doneResult);\n    }\n    return Promise.resolve({\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      value: value!,\n      done: true,\n    });\n  }\n\n  wrap(onReturn?: () => void) {\n    const wrapped = {\n      next: () => this.next(),\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      return: (value?: A) => {\n        if (onReturn) {\n          onReturn();\n        }\n        return this.return(value);\n      },\n    };\n    return wrapped;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\n", "import Deferred from '../Deferred';\nimport Buffer from '../Buffer';\nimport { PushAdapter, doneResult } from '../common';\nimport fromDom from '../fromDom';\nimport fromEmitter from '../fromEmitter';\n\n/**\n * Async iterable iterator with a non-optional return method.\n */\nexport interface WrappedBalancer<A> extends AsyncIterableIterator<A> {\n  // TODO the result can be undefined as well\n  return(value?: A): Promise<IteratorResult<A>>;\n  throw?: undefined;\n}\n\nexport interface Unpushed<A> {\n  result: IteratorResult<A>;\n  defer: Deferred<IteratorResult<A>>;\n}\n/**\n * Balances a push queue with a pull queue, also known as a\n * dropping-buffer channel, since the queues are FIFO and\n * can be set to be bounded, i.e., to drop the oldest enqueued\n * values if the limit is exceeded. The channel is unbounded\n * by default.\n */\nexport default class Channel<A> implements PushAdapter<A> {\n  /** Pushed results waiting for pulls to resolve */\n  readonly pushBuffer: Buffer<Unpushed<A>>;\n  /** Unresolved pulls waiting for results to be pushed */\n  readonly pullBuffer: Buffer<Deferred<IteratorResult<A>>>;\n  /** Determines whether new values can be pushed or pulled */\n  private closed = false;\n\n  static fromDom = fromDom(() => new Channel());\n  static fromEmitter = fromEmitter(() => new Channel());\n\n  constructor(\n    /** Limit (bounds) after which the oldest buffered value is dropped. */\n    limit = Infinity,\n  ) {\n    this.pushBuffer = new Buffer(limit);\n    this.pullBuffer = new Buffer(limit);\n  }\n\n  /**\n   * Pull a promise of the next result.\n   */\n  next(): Promise<IteratorResult<A>> {\n    if (this.closed) {\n      return Promise.resolve(doneResult);\n    }\n    if (this.pushBuffer.length === 0) {\n      const defer = new Deferred<IteratorResult<A>>();\n      // Buffer the pull to be resolved later\n      this.pullBuffer.enqueue(defer);\n      // Return the buffered promise that will be resolved and dequeued when a value is pushed\n      return defer.promise;\n    }\n    const { result, defer } = this.pushBuffer.dequeue();\n    defer.resolve(result);\n    if (result.done) {\n      this.close();\n    }\n    return defer.promise;\n  }\n\n  /**\n   * Push the next result value.\n   *\n   * @param value - Result\n   * @param done - If true, closes the balancer when this result is resolved\n   * @throws Throws if the balancer is already closed\n   */\n  push(value: A, done = false): Promise<IteratorResult<A>> {\n    if (this.closed) {\n      return Promise.resolve(doneResult);\n    }\n    const result = {\n      value,\n      done,\n    };\n    if (this.pullBuffer.length > 0) {\n      return this.pullBuffer.dequeue().resolve(result);\n    }\n    const defer = new Deferred<IteratorResult<A>>();\n    this.pushBuffer.enqueue({ result, defer });\n    return defer.promise;\n  }\n\n  /**\n   * Returns itself, since {@link Channel} already implements the iterator protocol.\n   */\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  /**\n   * Closes the balancer; clears the queues and makes {@link Channel#next} only\n   * return `doneResult`.\n   *\n   * @param value - The result value to be returned\n   */\n  async return(value?: A): Promise<IteratorResult<A>> {\n    this.close();\n    return {\n      done: true,\n      // TODO: fix assertion\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      value: value!, // asserting as non-undefined because the TS lib types are incorrect\n    };\n  }\n\n  close(): void {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    // Clear the queues\n    this.pushBuffer.forEach(({ defer: { resolve } }) => void resolve(doneResult));\n    this.pushBuffer.clear();\n    this.pullBuffer.forEach(({ resolve }) => void resolve(doneResult));\n    this.pullBuffer.clear();\n  }\n\n  /**\n   * Convert {@link Channel} to a generic async iterable iterator to hide implementation details.\n   *\n   * @param onReturn - Optional callback for when the iterator is closed with {@link Channel#return}\n   * @throws Throws if called when closed\n   */\n  wrap(onReturn?: () => void): WrappedBalancer<A> {\n    if (this.closed) {\n      throw Error('Balancer is closed');\n    }\n    return {\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      next: () => this.next(),\n      return: async (value?: A) => {\n        if (onReturn) {\n          onReturn();\n        }\n        return this.return(value);\n      },\n    };\n  }\n}\n", "import { Channel } from \"queueueue\";\nimport { Peer, PeerID, SyncMessage } from \"./sync.js\";\nexport { Channel } from \"queueueue\";\n\nexport function connectedPeers(\n  peer1id: PeerID,\n  peer2id: PeerID,\n  {\n    trace = false,\n    peer1role = \"client\",\n    peer2role = \"client\",\n    crashOnClose = false,\n  }: {\n    trace?: boolean;\n    peer1role?: Peer[\"role\"];\n    peer2role?: Peer[\"role\"];\n    crashOnClose?: boolean;\n  } = {},\n): [Peer, Peer] {\n  const [from1to2Rx, from1to2Tx] = newQueuePair(\n    trace ? { traceAs: `${peer1id} -> ${peer2id}` } : undefined,\n  );\n  const [from2to1Rx, from2to1Tx] = newQueuePair(\n    trace ? { traceAs: `${peer2id} -> ${peer1id}` } : undefined,\n  );\n\n  const peer2AsPeer: Peer = {\n    id: peer2id,\n    incoming: from2to1Rx,\n    outgoing: from1to2Tx,\n    role: peer2role,\n    crashOnClose: crashOnClose,\n  };\n\n  const peer1AsPeer: Peer = {\n    id: peer1id,\n    incoming: from1to2Rx,\n    outgoing: from2to1Tx,\n    role: peer1role,\n    crashOnClose: crashOnClose,\n  };\n\n  return [peer1AsPeer, peer2AsPeer];\n}\n\nexport function newQueuePair(\n  options: { traceAs?: string } = {},\n): [AsyncIterable<SyncMessage>, Channel<SyncMessage>] {\n  const channel = new Channel<SyncMessage>();\n\n  if (options.traceAs) {\n    return [\n      (async function* () {\n        for await (const msg of channel) {\n          console.debug(\n            options.traceAs,\n            JSON.stringify(\n              msg,\n              (k, v) =>\n                k === \"changes\" || k === \"encryptedChanges\"\n                  ? v.slice(0, 20) + \"...\"\n                  : v,\n              2,\n            ),\n          );\n          yield msg;\n        }\n      })(),\n      channel,\n    ];\n  } else {\n    return [channel.wrap(), channel];\n  }\n}\n", "import { base64URLtoBytes, bytesToBase64url } from \"./base64url.js\";\nimport { type RawCoValue } from \"./coValue.js\";\nimport {\n  CoValueCore,\n  type CoValueUniqueness,\n  MAX_RECOMMENDED_TX_SIZE,\n  idforHeader,\n} from \"./coValueCore.js\";\nimport {\n  ControlledAgent,\n  RawAccount,\n  RawControlledAccount,\n  RawProfile,\n  accountHeaderForInitialAgentSecret,\n} from \"./coValues/account.js\";\nimport { OpID, RawCoList } from \"./coValues/coList.js\";\nimport { RawCoMap } from \"./coValues/coMap.js\";\nimport { RawCoPlainText, stringifyOpID } from \"./coValues/coPlainText.js\";\nimport {\n  BinaryStreamItem,\n  BinaryStreamStart,\n  CoStreamItem,\n  RawBinaryCoStream,\n  RawCoStream,\n} from \"./coValues/coStream.js\";\nimport { EVERYONE, RawGroup } from \"./coValues/group.js\";\nimport type { Everyone } from \"./coValues/group.js\";\nimport {\n  CryptoProvider,\n  StreamingHash,\n  secretSeedLength,\n  shortHashLength,\n} from \"./crypto/crypto.js\";\nimport {\n  getGroupDependentKey,\n  getGroupDependentKeyList,\n  isRawCoID,\n  rawCoIDfromBytes,\n  rawCoIDtoBytes,\n} from \"./ids.js\";\nimport { Stringified, parseJSON, stableStringify } from \"./jsonStringify.js\";\nimport { LocalNode } from \"./localNode.js\";\nimport type { AccountRole, Role } from \"./permissions.js\";\nimport { Channel, connectedPeers } from \"./streamUtils.js\";\nimport { accountOrAgentIDfromSessionID } from \"./typeUtils/accountOrAgentIDfromSessionID.js\";\nimport { expectGroup } from \"./typeUtils/expectGroup.js\";\nimport { isAccountID } from \"./typeUtils/isAccountID.js\";\n\nimport type { AnyRawCoValue, CoID } from \"./coValue.js\";\nimport type {\n  AccountMeta,\n  RawAccountID,\n  RawAccountMigration,\n} from \"./coValues/account.js\";\nimport type {\n  BinaryCoStreamMeta,\n  BinaryStreamInfo,\n} from \"./coValues/coStream.js\";\nimport type { InviteSecret } from \"./coValues/group.js\";\nimport type { AgentSecret } from \"./crypto/crypto.js\";\nimport type { AgentID, RawCoID, SessionID } from \"./ids.js\";\nimport type { JsonObject, JsonValue } from \"./jsonValue.js\";\nimport type * as Media from \"./media.js\";\nimport { disablePermissionErrors } from \"./permissions.js\";\nimport type {\n  IncomingSyncStream,\n  OutgoingSyncQueue,\n  Peer,\n  SyncMessage,\n} from \"./sync.js\";\nimport {\n  DisconnectedError,\n  PingTimeoutError,\n  emptyKnownState,\n} from \"./sync.js\";\n\ntype Value = JsonValue | AnyRawCoValue;\n\nimport { CO_VALUE_LOADING_CONFIG } from \"./coValueState.js\";\nimport { logger } from \"./logger.js\";\nimport { getPriorityFromHeader } from \"./priority.js\";\n\n/** @hidden */\nexport const cojsonInternals = {\n  connectedPeers,\n  rawCoIDtoBytes,\n  rawCoIDfromBytes,\n  secretSeedLength,\n  shortHashLength,\n  expectGroup,\n  base64URLtoBytes,\n  bytesToBase64url,\n  parseJSON,\n  stableStringify,\n  accountOrAgentIDfromSessionID,\n  isAccountID,\n  accountHeaderForInitialAgentSecret,\n  idforHeader,\n  StreamingHash,\n  Channel,\n  getPriorityFromHeader,\n  getGroupDependentKeyList,\n  getGroupDependentKey,\n  disablePermissionErrors,\n  CO_VALUE_LOADING_CONFIG,\n};\n\nexport {\n  LocalNode,\n  RawGroup,\n  Role,\n  EVERYONE,\n  Everyone,\n  RawCoMap,\n  RawCoList,\n  RawCoStream,\n  RawBinaryCoStream,\n  RawCoValue,\n  RawCoID,\n  CoID,\n  AnyRawCoValue,\n  RawAccount,\n  RawAccountID,\n  AccountMeta,\n  RawAccountMigration,\n  RawProfile as Profile,\n  SessionID,\n  Media,\n  CoValueCore,\n  ControlledAgent,\n  RawControlledAccount,\n  MAX_RECOMMENDED_TX_SIZE,\n  JsonObject,\n  JsonValue,\n  Peer,\n  BinaryStreamInfo,\n  BinaryCoStreamMeta,\n  AgentID,\n  AgentSecret,\n  InviteSecret,\n  CryptoProvider,\n  SyncMessage,\n  isRawCoID,\n  emptyKnownState,\n  RawCoPlainText,\n  stringifyOpID,\n  logger,\n  base64URLtoBytes,\n  bytesToBase64url,\n};\n\nexport type {\n  Value,\n  IncomingSyncStream,\n  OutgoingSyncQueue,\n  DisconnectedError,\n  PingTimeoutError,\n  CoValueUniqueness,\n  Stringified,\n  CoStreamItem,\n  BinaryStreamItem,\n  BinaryStreamStart,\n  OpID,\n  AccountRole,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace CojsonInternalTypes {\n  export type CoValueKnownState = import(\"./sync.js\").CoValueKnownState;\n  export type CoJsonValue<T> = import(\"./jsonValue.js\").CoJsonValue<T>;\n  export type DoneMessage = import(\"./sync.js\").DoneMessage;\n  export type KnownStateMessage = import(\"./sync.js\").KnownStateMessage;\n  export type LoadMessage = import(\"./sync.js\").LoadMessage;\n  export type NewContentMessage = import(\"./sync.js\").NewContentMessage;\n  export type SessionNewContent = import(\"./sync.js\").SessionNewContent;\n  export type CoValueHeader = import(\"./coValueCore.js\").CoValueHeader;\n  export type Transaction = import(\"./coValueCore.js\").Transaction;\n  export type TransactionID = import(\"./ids.js\").TransactionID;\n  export type Signature = import(\"./crypto/crypto.js\").Signature;\n  export type RawCoID = import(\"./ids.js\").RawCoID;\n  export type ProfileShape = import(\"./coValues/account.js\").ProfileShape;\n  export type SealerSecret = import(\"./crypto/crypto.js\").SealerSecret;\n  export type SignerID = import(\"./crypto/crypto.js\").SignerID;\n  export type SignerSecret = import(\"./crypto/crypto.js\").SignerSecret;\n  export type JsonObject = import(\"./jsonValue.js\").JsonObject;\n}\n", "import type { Account } from \"../coValues/account.js\";\n\nclass ActiveAccountContext {\n  private activeAccount: Account | null = null;\n  private guestMode: boolean = false;\n\n  set(account: Account | null) {\n    this.activeAccount = account;\n    this.guestMode = false;\n  }\n\n  setGuestMode() {\n    this.activeAccount = null;\n    this.guestMode = true;\n  }\n\n  maybeGet() {\n    return this.activeAccount;\n  }\n\n  get() {\n    if (!this.activeAccount) {\n      if (this.guestMode) {\n        throw new Error(\n          \"Something that expects a full active account was called in guest mode.\",\n        );\n      }\n\n      throw new Error(\"No active account\");\n    }\n\n    return this.activeAccount;\n  }\n}\n\nexport type { ActiveAccountContext };\n\nexport const activeAccountContext = new ActiveAccountContext();\n", "import { LocalNode } from \"cojson\";\n\nexport class AnonymousJazzAgent {\n  _type = \"Anonymous\" as const;\n  constructor(public node: LocalNode) {}\n}\n", "import type {\n  CoValueUniqueness,\n  CojsonInternalTypes,\n  RawCoValue,\n} from \"cojson\";\nimport { RawAccount } from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport { AnonymousJazzAgent } from \"../implementation/anonymousJazzAgent.js\";\nimport {\n  Ref,\n  SubscriptionScope,\n  inspect,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\nimport { type Account } from \"./account.js\";\nimport {\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  fulfillsDepth,\n} from \"./deepLoading.js\";\nimport { type Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\n/** @category Abstract interfaces */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface CoValueClass<Value extends CoValue = CoValue> {\n  /** @ignore */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]): Value;\n}\n\nexport interface CoValueFromRaw<V extends CoValue> {\n  fromRaw(raw: V[\"_raw\"]): V;\n}\n\n/** @category Abstract interfaces */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface CoValue {\n  /** @category Content */\n  readonly id: ID<this>;\n  /** @category Type Helpers */\n  _type: string;\n  /** @category Collaboration */\n  _owner: Account | Group;\n  /** @category Internals */\n  _raw: RawCoValue;\n  /** @internal */\n  readonly _loadedAs: Account | AnonymousJazzAgent;\n  /** @category Stringifying & Inspection */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(key?: string, seenAbove?: ID<CoValue>[]): any[] | object | string;\n  /** @category Stringifying & Inspection */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [inspect](): any;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isCoValue(value: any): value is CoValue {\n  return value && value._type !== undefined;\n}\n\nexport function isCoValueClass<V extends CoValue>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n): value is CoValueClass<V> & CoValueFromRaw<V> {\n  return typeof value === \"function\" && value.fromRaw !== undefined;\n}\n\n/**\n * IDs are unique identifiers for `CoValue`s.\n * Can be used with a type argument to refer to a specific `CoValue` type.\n *\n * @example\n *\n * ```ts\n * type AccountID = ID<Account>;\n * ```\n *\n * @category CoValues\n */\nexport type ID<T> = CojsonInternalTypes.RawCoID & IDMarker<T>;\n\ntype IDMarker<out T> = { __type(_: never): T };\n\n/** @internal */\nexport class CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: string;\n  declare _raw: RawCoValue;\n  /** @category Internals */\n  declare _instanceID: string;\n\n  get _owner(): Account | Group {\n    const owner =\n      this._raw.group instanceof RawAccount\n        ? RegisteredSchemas[\"Account\"].fromRaw(this._raw.group)\n        : RegisteredSchemas[\"Group\"].fromRaw(this._raw.group);\n\n    const subScope = subscriptionsScopes.get(this);\n    if (subScope) {\n      subScope.onRefAccessedOrSet(this.id, owner.id);\n      subscriptionsScopes.set(owner, subScope);\n    }\n\n    return owner;\n  }\n\n  /** @private */\n  get _loadedAs() {\n    const rawAccount = this._raw.core.node.account;\n\n    if (rawAccount instanceof RawAccount) {\n      return coValuesCache.get(rawAccount, () =>\n        RegisteredSchemas[\"Account\"].fromRaw(rawAccount),\n      );\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(..._args: any) {\n    Object.defineProperty(this, \"_instanceID\", {\n      value: `instance-${Math.random().toString(36).slice(2)}`,\n      enumerable: false,\n    });\n  }\n\n  /** @category Internals */\n  static fromRaw<V extends CoValue>(this: CoValueClass<V>, raw: RawCoValue): V {\n    return new this({ fromRaw: raw });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): object | any[] | string {\n    return {\n      id: this.id,\n      type: this._type,\n      error: \"unknown CoValue class\",\n    };\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /** @category Type Helpers */\n  castAs<Cl extends CoValueClass & CoValueFromRaw<CoValue>>(\n    cl: Cl,\n  ): InstanceType<Cl> {\n    const casted = cl.fromRaw(this._raw) as InstanceType<Cl>;\n    const subscriptionScope = subscriptionsScopes.get(this);\n    if (subscriptionScope) {\n      subscriptionsScopes.set(casted, subscriptionScope);\n    }\n    return casted;\n  }\n}\n\nexport function loadCoValueWithoutMe<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options?: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs?: Account | AnonymousJazzAgent;\n  },\n): Promise<Resolved<V, R> | null> {\n  return loadCoValue(cls, id, {\n    ...options,\n    loadAs: options?.loadAs ?? activeAccountContext.get(),\n  });\n}\n\nexport function loadCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs: Account | AnonymousJazzAgent;\n  },\n): Promise<Resolved<V, R> | null> {\n  return new Promise((resolve) => {\n    subscribeToCoValue<V, R>(\n      cls,\n      id,\n      {\n        resolve: options.resolve,\n        loadAs: options.loadAs,\n        onUnavailable: () => {\n          resolve(null);\n        },\n        onUnauthorized: () => {\n          resolve(null);\n        },\n      },\n      (value, unsubscribe) => {\n        resolve(value);\n        unsubscribe();\n      },\n    );\n  });\n}\n\nexport async function ensureCoValueLoaded<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  existing: V,\n  options?: { resolve?: RefsToResolveStrict<V, R> } | undefined,\n): Promise<Resolved<V, R>> {\n  const response = await loadCoValue(\n    existing.constructor as CoValueClass<V>,\n    existing.id,\n    {\n      loadAs: existing._loadedAs,\n      resolve: options?.resolve,\n    },\n  );\n\n  if (!response) {\n    throw new Error(\"Failed to deeply load CoValue \" + existing.id);\n  }\n\n  return response;\n}\n\ntype SubscribeListener<V extends CoValue, R extends RefsToResolve<V>> = (\n  value: Resolved<V, R>,\n  unsubscribe: () => void,\n) => void;\n\nexport type SubscribeListenerOptions<\n  V extends CoValue,\n  R extends RefsToResolve<V>,\n> = {\n  resolve?: RefsToResolveStrict<V, R>;\n  loadAs?: Account | AnonymousJazzAgent;\n  onUnauthorized?: () => void;\n  onUnavailable?: () => void;\n};\n\nexport type SubscribeRestArgs<V extends CoValue, R extends RefsToResolve<V>> =\n  | [options: SubscribeListenerOptions<V, R>, listener: SubscribeListener<V, R>]\n  | [listener: SubscribeListener<V, R>];\n\nexport function parseSubscribeRestArgs<\n  V extends CoValue,\n  R extends RefsToResolve<V>,\n>(\n  args: SubscribeRestArgs<V, R>,\n): {\n  options: SubscribeListenerOptions<V, R>;\n  listener: SubscribeListener<V, R>;\n} {\n  if (args.length === 2) {\n    if (\n      typeof args[0] === \"object\" &&\n      args[0] &&\n      typeof args[1] === \"function\"\n    ) {\n      return {\n        options: {\n          resolve: args[0].resolve,\n          loadAs: args[0].loadAs,\n          onUnauthorized: args[0].onUnauthorized,\n          onUnavailable: args[0].onUnavailable,\n        },\n        listener: args[1],\n      };\n    } else {\n      throw new Error(\"Invalid arguments\");\n    }\n  } else {\n    if (typeof args[0] === \"function\") {\n      return { options: {}, listener: args[0] };\n    } else {\n      throw new Error(\"Invalid arguments\");\n    }\n  }\n}\n\nexport function subscribeToCoValueWithoutMe<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: SubscribeListenerOptions<V, R>,\n  listener: SubscribeListener<V, R>,\n) {\n  return subscribeToCoValue(\n    cls,\n    id,\n    {\n      ...options,\n      loadAs: options.loadAs ?? activeAccountContext.get(),\n    },\n    listener,\n  );\n}\n\nexport function subscribeToCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs: Account | AnonymousJazzAgent;\n    onUnavailable?: () => void;\n    onUnauthorized?: (errorPath: string[]) => void;\n    syncResolution?: boolean;\n  },\n  listener: SubscribeListener<V, R>,\n): () => void {\n  const ref = new Ref(id, options.loadAs, { ref: cls, optional: false });\n\n  let unsubscribed = false;\n  let unsubscribe: (() => void) | undefined;\n\n  function subscribe() {\n    const value = ref.getValueWithoutAccessCheck();\n\n    if (!value) {\n      options.onUnavailable?.();\n      return;\n    }\n\n    if (unsubscribed) return;\n\n    const subscription = new SubscriptionScope(\n      value,\n      cls as CoValueClass<V> & CoValueFromRaw<V>,\n      (update, subscription) => {\n        if (subscription.syncResolution) return;\n\n        if (!ref.hasReadAccess()) {\n          console.error(\n            \"Not enough permissions to load / subscribe to CoValue\",\n            id,\n          );\n          options.onUnauthorized?.([]);\n          return;\n        }\n\n        let result;\n\n        try {\n          subscription.syncResolution = true;\n          result = fulfillsDepth(options.resolve, update);\n        } catch (e) {\n          console.error(\n            \"Failed to load / subscribe to CoValue\",\n            e,\n            e instanceof Error ? e.stack : undefined,\n          );\n          options.onUnavailable?.();\n          return;\n        } finally {\n          subscription.syncResolution = false;\n        }\n\n        if (result.status === \"unauthorized\") {\n          console.error(\n            \"Not enough permissions to load / subscribe to CoValue\",\n            id,\n            \"on path\",\n            result.path.join(\".\"),\n            \"unaccessible value:\",\n            result.id,\n          );\n          options.onUnauthorized?.(result.path);\n          return;\n        }\n\n        if (result.status === \"fulfilled\") {\n          listener(update as Resolved<V, R>, subscription.unsubscribeAll);\n        }\n      },\n    );\n\n    unsubscribe = subscription.unsubscribeAll;\n  }\n\n  const sync = options.syncResolution ? ref.syncLoad() : undefined;\n\n  if (sync) {\n    subscribe();\n  } else {\n    ref\n      .load()\n      .then(() => subscribe())\n      .catch((e) => {\n        console.error(\n          \"Failed to load / subscribe to CoValue\",\n          e,\n          e instanceof Error ? e.stack : undefined,\n        );\n        options.onUnavailable?.();\n      });\n  }\n\n  return function unsubscribeAtAnyPoint() {\n    unsubscribed = true;\n    unsubscribe && unsubscribe();\n  };\n}\n\nexport function createCoValueObservable<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(initialValue: undefined | null = undefined) {\n  let currentValue: Resolved<V, R> | undefined | null = initialValue;\n  let subscriberCount = 0;\n\n  function subscribe(\n    cls: CoValueClass<V>,\n    id: ID<CoValue>,\n    options: {\n      loadAs: Account | AnonymousJazzAgent;\n      resolve?: RefsToResolveStrict<V, R>;\n      onUnavailable?: () => void;\n      onUnauthorized?: () => void;\n      syncResolution?: boolean;\n    },\n    listener: () => void,\n  ) {\n    subscriberCount++;\n\n    const unsubscribe = subscribeToCoValue(\n      cls,\n      id,\n      {\n        loadAs: options.loadAs,\n        resolve: options.resolve,\n        onUnavailable: () => {\n          currentValue = null;\n          options.onUnavailable?.();\n        },\n        onUnauthorized: () => {\n          currentValue = null;\n          options.onUnauthorized?.();\n        },\n        syncResolution: options.syncResolution,\n      },\n      (value) => {\n        currentValue = value;\n        listener();\n      },\n    );\n\n    return () => {\n      unsubscribe();\n      subscriberCount--;\n      if (subscriberCount === 0) {\n        currentValue = undefined;\n      }\n    };\n  }\n\n  const observable = {\n    getCurrentValue: () => currentValue,\n    subscribe,\n  };\n\n  return observable;\n}\n\nexport function subscribeToExistingCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  existing: V,\n  options:\n    | {\n        resolve?: RefsToResolveStrict<V, R>;\n        onUnavailable?: () => void;\n        onUnauthorized?: () => void;\n      }\n    | undefined,\n  listener: SubscribeListener<V, R>,\n): () => void {\n  return subscribeToCoValue(\n    existing.constructor as CoValueClass<V>,\n    existing.id,\n    {\n      loadAs: existing._loadedAs,\n      resolve: options?.resolve,\n      onUnavailable: options?.onUnavailable,\n      onUnauthorized: options?.onUnauthorized,\n    },\n    listener,\n  );\n}\n\nexport function isAccountInstance(instance: unknown): instance is Account {\n  if (typeof instance !== \"object\" || instance === null) {\n    return false;\n  }\n\n  return \"_type\" in instance && instance._type === \"Account\";\n}\n\nexport function isAnonymousAgentInstance(\n  instance: unknown,\n): instance is AnonymousJazzAgent {\n  if (typeof instance !== \"object\" || instance === null) {\n    return false;\n  }\n\n  return \"_type\" in instance && instance._type === \"Anonymous\";\n}\n\nexport function parseCoValueCreateOptions(\n  options:\n    | {\n        owner?: Account | Group;\n        unique?: CoValueUniqueness[\"uniqueness\"];\n      }\n    | Account\n    | Group\n    | undefined,\n) {\n  const Group = RegisteredSchemas[\"Group\"];\n\n  if (!options) {\n    return { owner: Group.create(), uniqueness: undefined };\n  }\n\n  if (\"_type\" in options) {\n    if (options._type === \"Account\" || options._type === \"Group\") {\n      return { owner: options, uniqueness: undefined };\n    }\n  }\n\n  const uniqueness = options.unique\n    ? { uniqueness: options.unique }\n    : undefined;\n\n  return {\n    owner: options.owner ?? Group.create(),\n    uniqueness,\n  };\n}\n\nexport function parseGroupCreateOptions(\n  options:\n    | {\n        owner?: Account;\n      }\n    | Account\n    | undefined,\n) {\n  if (!options) {\n    return { owner: activeAccountContext.get() };\n  }\n\n  return \"_type\" in options && isAccountInstance(options)\n    ? { owner: options }\n    : { owner: options.owner ?? activeAccountContext.get() };\n}\n", "export const inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nexport type inspect = typeof inspect;\n", "export type JazzToolsSymbol = SchemaInit | ItemsSym | MembersSym;\n\nexport const SchemaInit = \"$SchemaInit$\";\nexport type SchemaInit = typeof SchemaInit;\n\nexport const ItemsSym = \"$items$\";\nexport type ItemsSym = typeof ItemsSym;\n\nexport const MembersSym = \"$members$\";\nexport type MembersSym = typeof MembersSym;\n", "import { JsonValue, RawCoList, SessionID } from \"cojson\";\nimport { ItemsSym, type Ref, RefEncoded, UnCo } from \"../internal.js\";\nimport { type Account } from \"./account.js\";\nimport { type CoFeed, CoFeedEntry } from \"./coFeed.js\";\nimport { type CoList } from \"./coList.js\";\nimport { type CoKeys, type CoMap } from \"./coMap.js\";\nimport { type CoValue, type ID } from \"./interfaces.js\";\n\nfunction hasRefValue(value: CoValue, key: string | number) {\n  return Boolean(\n    (\n      value as unknown as {\n        _refs: { [key: string]: Ref<CoValue> | undefined };\n      }\n    )._refs?.[key],\n  );\n}\n\nfunction hasReadAccess(value: CoValue, key: string | number) {\n  return Boolean(\n    (\n      value as unknown as {\n        _refs: { [key: string]: Ref<CoValue> | undefined };\n      }\n    )._refs?.[key]?.hasReadAccess(),\n  );\n}\n\nfunction isOptionalField(value: CoValue, key: string): boolean {\n  return (\n    ((value as CoMap)._schema[key] as RefEncoded<CoValue>)?.optional ?? false\n  );\n}\n\ntype FulfillsDepthResult =\n  | {\n      status: \"fulfilled\" | \"unfulfilled\";\n    }\n  | {\n      status: \"unauthorized\";\n      path: string[];\n      id: JsonValue;\n    };\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function fulfillsDepth(depth: any, value: CoValue): FulfillsDepthResult {\n  if (depth === true || depth === undefined) {\n    return {\n      status: \"fulfilled\",\n    };\n  }\n\n  if (\n    value._type === \"CoMap\" ||\n    value._type === \"Group\" ||\n    value._type === \"Account\"\n  ) {\n    const map = value as CoMap;\n\n    if (\"$each\" in depth) {\n      const result: FulfillsDepthResult = { status: \"fulfilled\" };\n\n      for (const [key, item] of Object.entries(value)) {\n        const rawValue = map._raw.get(key);\n\n        if (rawValue !== undefined && rawValue !== null) {\n          if (!item) {\n            if (hasReadAccess(map, key)) {\n              result.status = \"unfulfilled\";\n              continue;\n            } else {\n              return {\n                status: \"unauthorized\",\n                path: [key],\n                id: rawValue,\n              };\n            }\n          }\n\n          const innerResult = fulfillsDepth(depth.$each, item);\n\n          if (innerResult.status === \"unfulfilled\") {\n            result.status = \"unfulfilled\";\n          } else if (\n            innerResult.status === \"unauthorized\" &&\n            !isOptionalField(value, ItemsSym)\n          ) {\n            innerResult.path.unshift(key);\n\n            return innerResult; // If any item is unauthorized, the whole thing is unauthorized\n          }\n        } else if (!isOptionalField(value, ItemsSym)) {\n          return {\n            status: \"unfulfilled\",\n          };\n        }\n      }\n\n      return result;\n    } else {\n      const result: FulfillsDepthResult = { status: \"fulfilled\" };\n\n      for (const key of Object.keys(depth)) {\n        const rawValue = map._raw.get(key);\n\n        if (rawValue === undefined || rawValue === null) {\n          if (!map._schema?.[key]) {\n            // Field not defined in schema\n            if (map._schema?.[ItemsSym]) {\n              // CoMap.Record\n              if (isOptionalField(map, ItemsSym)) {\n                continue;\n              } else {\n                // All fields are required, so the returned type is not optional and we must comply\n                throw new Error(\n                  `The ref ${key} requested on ${map.constructor.name} is missing`,\n                );\n              }\n            } else {\n              // Field not defined in CoMap schema\n              throw new Error(\n                `The ref ${key} requested on ${map.constructor.name} is not defined in the schema`,\n              );\n            }\n          } else if (isOptionalField(map, key)) {\n            continue;\n          } else {\n            // Field is required but has never been set\n            throw new Error(\n              `The ref ${key} on ${map.constructor.name} is required but missing`,\n            );\n          }\n        } else {\n          const item = (value as Record<string, any>)[key];\n\n          if (!item) {\n            if (hasReadAccess(map, key)) {\n              result.status = \"unfulfilled\";\n              continue;\n            } else {\n              return {\n                status: \"unauthorized\",\n                path: [key],\n                id: rawValue,\n              };\n            }\n          }\n\n          const innerResult = fulfillsDepth(depth[key], item);\n\n          if (innerResult.status === \"unfulfilled\") {\n            result.status = \"unfulfilled\";\n          } else if (\n            innerResult.status === \"unauthorized\" &&\n            !isOptionalField(value, key)\n          ) {\n            innerResult.path.unshift(key);\n\n            return innerResult; // If any item is unauthorized, the whole thing is unauthorized\n          }\n        }\n      }\n\n      return result;\n    }\n  } else if (value._type === \"CoList\") {\n    if (\"$each\" in depth) {\n      const result: FulfillsDepthResult = { status: \"fulfilled\" };\n      const list = value as CoList;\n\n      for (const [key, item] of (value as CoList).entries()) {\n        const rawValue = list._raw.get(key);\n\n        if (!rawValue) {\n          if (isOptionalField(value, ItemsSym)) {\n            continue;\n          }\n\n          // Throw an error and mark this as unavailable\n          throw new Error(\n            `The ref ${key} on ${list.constructor.name} is required but missing`,\n          );\n        }\n\n        if (hasRefValue(value, key)) {\n          if (!item) {\n            if (hasReadAccess(value, key)) {\n              result.status = \"unfulfilled\";\n              continue;\n            } else {\n              return {\n                status: \"unauthorized\",\n                path: [key.toString()],\n                id: (value._raw as RawCoList).get(key) ?? \"undefined\",\n              };\n            }\n          }\n\n          const innerResult = fulfillsDepth(depth.$each, item);\n\n          if (innerResult.status === \"unfulfilled\") {\n            result.status = \"unfulfilled\";\n          } else if (\n            innerResult.status === \"unauthorized\" &&\n            !isOptionalField(value, ItemsSym)\n          ) {\n            innerResult.path.unshift(key.toString());\n\n            return innerResult; // If any item is unauthorized, the whole thing is unauthorized\n          }\n        } else if (!isOptionalField(value, ItemsSym)) {\n          return {\n            status: \"unfulfilled\",\n          };\n        }\n      }\n\n      return result;\n    }\n\n    return {\n      status: \"fulfilled\",\n    };\n  } else if (value._type === \"CoStream\") {\n    if (\"$each\" in depth) {\n      const result: FulfillsDepthResult = { status: \"fulfilled\" };\n\n      for (const item of Object.values((value as CoFeed).perSession)) {\n        if (item.ref) {\n          if (!item.value) {\n            if (item.ref.hasReadAccess()) {\n              result.status = \"unfulfilled\";\n              continue;\n            } else {\n              return {\n                status: \"unauthorized\",\n                path: [item.ref.id],\n                id: item.ref.id,\n              };\n            }\n          }\n\n          const innerResult = fulfillsDepth(depth.$each, item.value);\n\n          if (innerResult.status === \"unfulfilled\") {\n            result.status = \"unfulfilled\";\n          } else if (\n            innerResult.status === \"unauthorized\" &&\n            !isOptionalField(value, ItemsSym)\n          ) {\n            innerResult.path.unshift(item.ref.id);\n\n            return innerResult; // If any item is unauthorized, the whole thing is unauthorized\n          }\n        } else if (!isOptionalField(value, ItemsSym)) {\n          return {\n            status: \"unfulfilled\",\n          };\n        }\n      }\n\n      return result;\n    }\n\n    return {\n      status: \"fulfilled\",\n    };\n  } else if (\n    value._type === \"BinaryCoStream\" ||\n    value._type === \"CoPlainText\"\n  ) {\n    return {\n      status: \"fulfilled\",\n    };\n  } else {\n    console.error(value);\n    throw new Error(\"Unexpected value type: \" + value._type);\n  }\n}\n\ntype UnCoNotNull<T> = UnCo<Exclude<T, null>>;\nexport type Clean<T> = UnCo<NonNullable<T>>;\n\nexport type RefsToResolve<\n  V,\n  DepthLimit extends number = 10,\n  CurrentDepth extends number[] = [],\n> =\n  | boolean\n  | (DepthLimit extends CurrentDepth[\"length\"]\n      ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        any\n      : // Basically V extends CoList - but if we used that we'd introduce circularity into the definition of CoList itself\n        V extends Array<infer Item>\n        ?\n            | {\n                $each: RefsToResolve<\n                  UnCoNotNull<Item>,\n                  DepthLimit,\n                  [0, ...CurrentDepth]\n                >;\n              }\n            | boolean\n        : // Basically V extends CoMap | Group | Account - but if we used that we'd introduce circularity into the definition of CoMap itself\n          V extends { _type: \"CoMap\" | \"Group\" | \"Account\" }\n          ?\n              | {\n                  [Key in CoKeys<V> as Clean<V[Key]> extends CoValue\n                    ? Key\n                    : never]?: RefsToResolve<\n                    Clean<V[Key]>,\n                    DepthLimit,\n                    [0, ...CurrentDepth]\n                  >;\n                }\n              | (ItemsSym extends keyof V\n                  ? {\n                      $each: RefsToResolve<\n                        Clean<V[ItemsSym]>,\n                        DepthLimit,\n                        [0, ...CurrentDepth]\n                      >;\n                    }\n                  : never)\n              | boolean\n          : V extends {\n                _type: \"CoStream\";\n                byMe: CoFeedEntry<infer Item> | undefined;\n              }\n            ?\n                | {\n                    $each: RefsToResolve<\n                      UnCoNotNull<Item>,\n                      DepthLimit,\n                      [0, ...CurrentDepth]\n                    >;\n                  }\n                | boolean\n            : boolean);\n\nexport type RefsToResolveStrict<T, V> = V extends RefsToResolve<T>\n  ? RefsToResolve<T>\n  : V;\n\nexport type Resolved<T, R extends RefsToResolve<T> | undefined> = DeeplyLoaded<\n  T,\n  R,\n  10,\n  []\n>;\n\nexport type DeeplyLoaded<\n  V,\n  Depth,\n  DepthLimit extends number = 10,\n  CurrentDepth extends number[] = [],\n> = DepthLimit extends CurrentDepth[\"length\"]\n  ? V\n  : Depth extends boolean | undefined // Checking against boolean instead of true because the inference from RefsToResolveStrict transforms true into boolean\n    ? V\n    : // Basically V extends CoList - but if we used that we'd introduce circularity into the definition of CoList itself\n      [V] extends [Array<infer Item>]\n      ? UnCoNotNull<Item> extends CoValue\n        ? Depth extends { $each: infer ItemDepth }\n          ? // Deeply loaded CoList\n            (UnCoNotNull<Item> &\n              DeeplyLoaded<\n                UnCoNotNull<Item>,\n                ItemDepth,\n                DepthLimit,\n                [0, ...CurrentDepth]\n              >)[] &\n              V // the CoList base type needs to be intersected after so that built-in methods return the correct narrowed array type\n          : never\n        : V\n      : // Basically V extends CoMap | Group | Account - but if we used that we'd introduce circularity into the definition of CoMap itself\n        [V] extends [{ _type: \"CoMap\" | \"Group\" | \"Account\" }]\n        ? ItemsSym extends keyof V\n          ? Depth extends { $each: infer ItemDepth }\n            ? // Deeply loaded Record-like CoMap\n              {\n                [key: string]: DeeplyLoaded<\n                  Clean<V[ItemsSym]>,\n                  ItemDepth,\n                  DepthLimit,\n                  [0, ...CurrentDepth]\n                >;\n              } & V // same reason as in CoList\n            : never\n          : keyof Depth extends never // Depth = {}\n            ? V\n            : // Deeply loaded CoMap\n              {\n                -readonly [Key in keyof Depth]-?: Key extends CoKeys<V>\n                  ? Clean<V[Key]> extends CoValue\n                    ?\n                        | DeeplyLoaded<\n                            Clean<V[Key]>,\n                            Depth[Key],\n                            DepthLimit,\n                            [0, ...CurrentDepth]\n                          >\n                        | (undefined extends V[Key] ? undefined : never)\n                    : never\n                  : never;\n              } & V // same reason as in CoList\n        : [V] extends [\n              {\n                _type: \"CoStream\";\n                byMe: CoFeedEntry<infer Item> | undefined;\n              },\n            ]\n          ? // Deeply loaded CoStream\n            {\n              byMe?: { value: UnCoNotNull<Item> };\n              inCurrentSession?: { value: UnCoNotNull<Item> };\n              perSession: {\n                [key: SessionID]: { value: UnCoNotNull<Item> };\n              };\n            } & { [key: ID<Account>]: { value: UnCoNotNull<Item> } } & V // same reason as in CoList\n          : [V] extends [\n                {\n                  _type: \"BinaryCoStream\";\n                },\n              ]\n            ? V\n            : [V] extends [\n                  {\n                    _type: \"CoPlainText\";\n                  },\n                ]\n              ? V\n              : never;\n", "import { type CoID, RawAccount, type RawCoValue, RawGroup } from \"cojson\";\nimport { type Account } from \"../coValues/account.js\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  ID,\n  RefEncoded,\n  UnCo,\n} from \"../internal.js\";\nimport {\n  instantiateRefEncoded,\n  isRefEncoded,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\n\nconst TRACE_ACCESSES = false;\n\nexport class Ref<out V extends CoValue> {\n  constructor(\n    readonly id: ID<V>,\n    readonly controlledAccount: Account | AnonymousJazzAgent,\n    readonly schema: RefEncoded<V>,\n  ) {\n    if (!isRefEncoded(schema)) {\n      throw new Error(\"Ref must be constructed with a ref schema\");\n    }\n  }\n\n  private getNode() {\n    return \"node\" in this.controlledAccount\n      ? this.controlledAccount.node\n      : this.controlledAccount._raw.core.node;\n  }\n\n  hasReadAccess() {\n    const node = this.getNode();\n\n    const raw = node.getLoaded(this.id as unknown as CoID<RawCoValue>);\n\n    if (!raw) {\n      return true;\n    }\n\n    if (raw instanceof RawAccount || raw instanceof RawGroup) {\n      return true;\n    }\n\n    const group = raw.core.getGroup();\n\n    if (group instanceof RawAccount) {\n      if (node.account.id !== group.id) {\n        return false;\n      }\n    } else if (group.myRole() === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getValueWithoutAccessCheck() {\n    const node = this.getNode();\n    const raw = node.getLoaded(this.id as unknown as CoID<RawCoValue>);\n\n    if (raw) {\n      return coValuesCache.get(raw, () =>\n        instantiateRefEncoded(this.schema, raw),\n      );\n    } else {\n      return null;\n    }\n  }\n\n  get value() {\n    if (!this.hasReadAccess()) {\n      return null;\n    }\n\n    return this.getValueWithoutAccessCheck();\n  }\n\n  private async loadHelper(): Promise<V | \"unavailable\"> {\n    const node =\n      \"node\" in this.controlledAccount\n        ? this.controlledAccount.node\n        : this.controlledAccount._raw.core.node;\n    const raw = await node.load(this.id as unknown as CoID<RawCoValue>);\n    if (raw === \"unavailable\") {\n      return \"unavailable\";\n    } else {\n      return new Ref(this.id, this.controlledAccount, this.schema).value!;\n    }\n  }\n\n  syncLoad(): V | undefined {\n    const node =\n      \"node\" in this.controlledAccount\n        ? this.controlledAccount.node\n        : this.controlledAccount._raw.core.node;\n\n    const entry = node.coValuesStore.get(\n      this.id as unknown as CoID<RawCoValue>,\n    );\n\n    if (entry.highLevelState === \"available\") {\n      return new Ref(this.id, this.controlledAccount, this.schema).value!;\n    }\n\n    return undefined;\n  }\n\n  async load(): Promise<V | undefined> {\n    const result = await this.loadHelper();\n    if (result === \"unavailable\") {\n      return undefined;\n    } else {\n      return result;\n    }\n  }\n\n  accessFrom(fromScopeValue: CoValue, key: string | number | symbol): V | null {\n    const subScope = subscriptionsScopes.get(fromScopeValue);\n\n    subScope?.onRefAccessedOrSet(fromScopeValue.id, this.id);\n    TRACE_ACCESSES &&\n      console.log(subScope?.scopeID, \"accessing\", fromScopeValue, key, this.id);\n\n    if (this.value && subScope) {\n      subscriptionsScopes.set(this.value, subScope);\n    }\n\n    if (subScope) {\n      const cached = subScope.cachedValues[this.id];\n      if (cached) {\n        TRACE_ACCESSES && console.log(\"cached\", cached);\n        return cached as V;\n      } else if (this.value !== null) {\n        const freshValueInstance = instantiateRefEncoded(\n          this.schema,\n          this.value._raw,\n        );\n        TRACE_ACCESSES && console.log(\"freshValueInstance\", freshValueInstance);\n        subScope.cachedValues[this.id] = freshValueInstance;\n        subscriptionsScopes.set(freshValueInstance, subScope);\n        return freshValueInstance as V;\n      } else {\n        return null;\n      }\n    } else {\n      return this.value;\n    }\n  }\n}\n\nexport function makeRefs<Keys extends string | number>(\n  getIdForKey: (key: Keys) => ID<CoValue> | undefined,\n  getKeysWithIds: () => Keys[],\n  controlledAccount: Account | AnonymousJazzAgent,\n  refSchemaForKey: (key: Keys) => RefEncoded<CoValue>,\n): { [K in Keys]: Ref<CoValue> } & {\n  [Symbol.iterator]: () => IterableIterator<Ref<CoValue>>;\n  length: number;\n} {\n  const refs = {} as { [K in Keys]: Ref<CoValue> } & {\n    [Symbol.iterator]: () => IterableIterator<Ref<CoValue>>;\n    length: number;\n  };\n  return new Proxy(refs, {\n    get(_target, key) {\n      if (key === Symbol.iterator) {\n        return function* () {\n          for (const key of getKeysWithIds()) {\n            yield new Ref(\n              getIdForKey(key)!,\n              controlledAccount,\n              refSchemaForKey(key),\n            );\n          }\n        };\n      }\n      if (typeof key === \"symbol\") return undefined;\n      if (key === \"length\") {\n        return getKeysWithIds().length;\n      }\n      const id = getIdForKey(key as Keys);\n      if (!id) return undefined;\n      return new Ref(\n        id as ID<CoValue>,\n        controlledAccount,\n        refSchemaForKey(key as Keys),\n      );\n    },\n    ownKeys() {\n      return getKeysWithIds().map((key) => key.toString());\n    },\n    getOwnPropertyDescriptor(target, key) {\n      const id = getIdForKey(key as Keys);\n      if (id) {\n        return {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n        };\n      } else {\n        return Reflect.getOwnPropertyDescriptor(target, key);\n      }\n    },\n  });\n}\n\nexport type RefIfCoValue<V> = NonNullable<V> extends CoValue\n  ? Ref<UnCo<NonNullable<V>>>\n  : never;\n", "import { RawCoValue } from \"cojson\";\nimport { CoValue } from \"../internal.js\";\n\nconst weakMap = new WeakMap<RawCoValue, CoValue>();\n\nexport const coValuesCache = {\n  get: <V extends CoValue>(raw: RawCoValue, compute: () => V) => {\n    const cached = weakMap.get(raw);\n    if (cached) {\n      return cached as V;\n    }\n    const computed = compute();\n    weakMap.set(raw, computed);\n    return computed;\n  },\n};\n", "import type { JsonValue, RawCoValue } from \"cojson\";\nimport { CojsonInternalTypes } from \"cojson\";\nimport {\n  type CoValue,\n  type CoValueClass,\n  CoValueFromRaw,\n  ItemsSym,\n  JazzToolsSymbol,\n  SchemaInit,\n  isCoValueClass,\n} from \"../internal.js\";\n\n/** @category Schema definition */\nexport const Encoders = {\n  Date: {\n    encode: (value: Date) => value.toISOString(),\n    decode: (value: JsonValue) => new Date(value as string),\n  },\n  OptionalDate: {\n    encode: (value: Date | undefined) => value?.toISOString() || null,\n    decode: (value: JsonValue) =>\n      value === null ? undefined : new Date(value as string),\n  },\n};\n\nexport type CoMarker = { readonly __co: unique symbol };\n/** @category Schema definition */\nexport type co<T> = T | (T & CoMarker);\nexport type IfCo<C, R> = C extends infer _A | infer B\n  ? B extends CoMarker\n    ? R extends JazzToolsSymbol // Exclude symbol properties like co.items from the refs/init types\n      ? never\n      : R\n    : never\n  : never;\nexport type UnCo<T> = T extends co<infer A> ? A : T;\n\nconst optional = {\n  ref: optionalRef,\n  json<T extends CojsonInternalTypes.CoJsonValue<T>>(): co<T | undefined> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  encoded<T>(arg: OptionalEncoder<T>): co<T | undefined> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: { encoded: arg } satisfies Schema } as any;\n  },\n  string: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<string | undefined>,\n  number: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<number | undefined>,\n  boolean: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<boolean | undefined>,\n  null: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<null | undefined>,\n  Date: {\n    [SchemaInit]: { encoded: Encoders.OptionalDate } satisfies Schema,\n  } as unknown as co<Date | undefined>,\n  literal<T extends (string | number | boolean)[]>(\n    ..._lit: T\n  ): co<T[number] | undefined> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n};\n\n/** @category Schema definition */\nexport const co = {\n  string: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<string>,\n  number: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<number>,\n  boolean: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<boolean>,\n  null: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<null>,\n  Date: {\n    [SchemaInit]: { encoded: Encoders.Date } satisfies Schema,\n  } as unknown as co<Date>,\n  literal<T extends (string | number | boolean)[]>(..._lit: T): co<T[number]> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  json<T extends CojsonInternalTypes.CoJsonValue<T>>(): co<T> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  encoded<T>(arg: Encoder<T>): co<T> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: { encoded: arg } satisfies Schema } as any;\n  },\n  ref,\n  items: ItemsSym as ItemsSym,\n  optional,\n};\n\nfunction optionalRef<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n): co<InstanceType<C> | null | undefined> {\n  return ref(arg, { optional: true });\n}\n\nfunction ref<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options?: never,\n): co<InstanceType<C> | null>;\nfunction ref<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options: { optional: true },\n): co<InstanceType<C> | null | undefined>;\nfunction ref<\n  C extends CoValueClass,\n  Options extends { optional?: boolean } | undefined,\n>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options?: Options,\n): Options extends { optional: true }\n  ? co<InstanceType<C> | null | undefined>\n  : co<InstanceType<C> | null> {\n  return {\n    [SchemaInit]: {\n      ref: arg,\n      optional: options?.optional || false,\n    } satisfies Schema,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } as any;\n}\n\nexport type JsonEncoded = \"json\";\nexport type EncodedAs<V> = { encoded: Encoder<V> | OptionalEncoder<V> };\nexport type RefEncoded<V extends CoValue> = {\n  ref: CoValueClass<V> | ((raw: RawCoValue) => CoValueClass<V>);\n  optional: boolean;\n};\n\nexport function isRefEncoded<V extends CoValue>(\n  schema: Schema,\n): schema is RefEncoded<V> {\n  return (\n    typeof schema === \"object\" &&\n    \"ref\" in schema &&\n    \"optional\" in schema &&\n    typeof schema.ref === \"function\"\n  );\n}\n\nexport function instantiateRefEncoded<V extends CoValue>(\n  schema: RefEncoded<V>,\n  raw: RawCoValue,\n): V {\n  return isCoValueClass<V>(schema.ref)\n    ? schema.ref.fromRaw(raw)\n    : (schema.ref as (raw: RawCoValue) => CoValueClass<V> & CoValueFromRaw<V>)(\n        raw,\n      ).fromRaw(raw);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Schema = JsonEncoded | RefEncoded<CoValue> | EncodedAs<any>;\n\nexport type SchemaFor<Field> = NonNullable<Field> extends CoValue\n  ? RefEncoded<NonNullable<Field>>\n  : NonNullable<Field> extends JsonValue\n    ? JsonEncoded\n    : EncodedAs<NonNullable<Field>>;\n\nexport type Encoder<V> = {\n  encode: (value: V) => JsonValue;\n  decode: (value: JsonValue) => V;\n};\nexport type OptionalEncoder<V> =\n  | Encoder<V>\n  | {\n      encode: (value: V | undefined) => JsonValue;\n      decode: (value: JsonValue) => V | undefined;\n    };\n", "import type { CoValueCore, LocalNode, RawCoValue } from \"cojson\";\nimport { type Account } from \"../coValues/account.js\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  CoValueFromRaw,\n  ID,\n} from \"../internal.js\";\n\nexport const subscriptionsScopes = new WeakMap<\n  CoValue,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  SubscriptionScope<any>\n>();\n\nexport class SubscriptionScope<Root extends CoValue> {\n  scopeID: string = `scope-${Math.random().toString(36).slice(2)}`;\n  subscriber: Account | AnonymousJazzAgent;\n  entries = new Map<\n    ID<CoValue>,\n    | { state: \"loading\"; immediatelyUnsub?: boolean }\n    | { state: \"loaded\"; rawUnsub: () => void }\n  >();\n  rootEntry: {\n    state: \"loaded\";\n    value: RawCoValue;\n    rawUnsub: () => void;\n  };\n  scheduleUpdate: () => void;\n  scheduledUpdate: boolean = false;\n  cachedValues: { [id: ID<CoValue>]: CoValue } = {};\n  parents: { [id: ID<CoValue>]: Set<ID<CoValue>> } = {};\n  syncResolution: boolean = false;\n\n  constructor(\n    root: Root,\n    rootSchema: CoValueClass<Root> & CoValueFromRaw<Root>,\n    onUpdate: (newRoot: Root, scope: SubscriptionScope<Root>) => void,\n  ) {\n    this.rootEntry = {\n      state: \"loaded\" as const,\n      value: root._raw,\n      rawUnsub: () => {}, // placeholder\n    };\n    this.entries.set(root.id, this.rootEntry);\n\n    subscriptionsScopes.set(root, this);\n\n    this.subscriber = root._loadedAs;\n\n    this.scheduleUpdate = () => {\n      const value = rootSchema.fromRaw(this.rootEntry.value) as Root;\n      subscriptionsScopes.set(value, this);\n      onUpdate(value, this);\n    };\n\n    this.rootEntry.rawUnsub = root._raw.core.subscribe(\n      (rawUpdate: RawCoValue | undefined) => {\n        if (!rawUpdate) return;\n        this.rootEntry.value = rawUpdate;\n        this.scheduleUpdate();\n      },\n    );\n  }\n\n  onRefAccessedOrSet(\n    fromId: ID<CoValue>,\n    accessedOrSetId: ID<CoValue> | undefined,\n  ) {\n    // console.log(\"onRefAccessedOrSet\", this.scopeID, accessedOrSetId);\n    if (!accessedOrSetId) {\n      return;\n    }\n\n    this.parents[accessedOrSetId] = this.parents[accessedOrSetId] || new Set();\n    this.parents[accessedOrSetId]!.add(fromId);\n\n    if (!this.entries.has(accessedOrSetId)) {\n      const loadingEntry = {\n        state: \"loading\",\n        immediatelyUnsub: false,\n      } as const;\n      this.entries.set(accessedOrSetId, loadingEntry);\n      const node =\n        this.subscriber._type === \"Account\"\n          ? this.subscriber._raw.core.node\n          : this.subscriber.node;\n\n      loadCoValue(\n        node,\n        accessedOrSetId,\n        (core) => {\n          if (\n            loadingEntry.state === \"loading\" &&\n            loadingEntry.immediatelyUnsub\n          ) {\n            return;\n          }\n          if (core !== \"unavailable\") {\n            const entry = {\n              state: \"loaded\" as const,\n              rawUnsub: () => {}, // placeholder\n            };\n            this.entries.set(accessedOrSetId, entry);\n\n            const rawUnsub = core.subscribe((rawUpdate) => {\n              if (!rawUpdate) return;\n\n              this.invalidate(accessedOrSetId);\n              this.scheduleUpdate();\n            });\n\n            entry.rawUnsub = rawUnsub;\n          }\n        },\n        this.syncResolution,\n      );\n    }\n  }\n\n  invalidate(id: ID<CoValue>, seen: Set<ID<CoValue>> = new Set()) {\n    if (seen.has(id)) return;\n\n    delete this.cachedValues[id];\n    seen.add(id);\n    for (const parent of this.parents[id] || []) {\n      this.invalidate(parent, seen);\n    }\n  }\n\n  unsubscribeAll = () => {\n    for (const entry of this.entries.values()) {\n      if (entry.state === \"loaded\") {\n        entry.rawUnsub();\n      } else {\n        entry.immediatelyUnsub = true;\n      }\n    }\n    this.entries.clear();\n  };\n}\n\n/**\n * Loads a CoValue from the node and calls the callback with the result.\n\n * If the CoValue is already loaded, the callback is called synchronously.\n * If the CoValue is not loaded, the callback is called asynchronously.\n */\nfunction loadCoValue(\n  node: LocalNode,\n  id: ID<CoValue>,\n  callback: (value: CoValueCore | \"unavailable\") => void,\n  syncResolution: boolean,\n) {\n  const entry = node.coValuesStore.get(id);\n\n  if (entry.isAvailable() && syncResolution) {\n    callback(entry.core);\n  } else {\n    void node.loadCoValueCore(id).then((core) => {\n      callback(core);\n    });\n  }\n}\n", "import {\n  AgentSecret,\n  CoID,\n  ControlledAgent,\n  CryptoProvider,\n  LocalNode,\n  Peer,\n  RawAccount,\n  RawAccountID,\n  SessionID,\n} from \"cojson\";\nimport { AuthSecretStorage } from \"../auth/AuthSecretStorage.js\";\nimport { type Account, type AccountClass } from \"../coValues/account.js\";\nimport { RegisteredSchemas } from \"../coValues/registeredSchemas.js\";\nimport type { ID } from \"../internal.js\";\nimport { AuthCredentials, NewAccountProps } from \"../types.js\";\nimport { activeAccountContext } from \"./activeAccountContext.js\";\nimport { AnonymousJazzAgent } from \"./anonymousJazzAgent.js\";\n\nexport type Credentials = {\n  accountID: ID<Account>;\n  secret: AgentSecret;\n};\n\ntype SessionProvider = (\n  accountID: ID<Account>,\n  crypto: CryptoProvider,\n) => Promise<{ sessionID: SessionID; sessionDone: () => void }>;\n\nexport type AuthResult =\n  | {\n      type: \"existing\";\n      username?: string;\n      credentials: Credentials;\n      saveCredentials?: (credentials: Credentials) => Promise<void>;\n      onSuccess: () => void;\n      onError: (error: string | Error) => void;\n      logOut: () => Promise<void>;\n    }\n  | {\n      type: \"new\";\n      creationProps: {\n        name: string;\n        anonymous?: boolean;\n        other?: Record<string, unknown>;\n      };\n      initialSecret?: AgentSecret;\n      saveCredentials: (credentials: Credentials) => Promise<void>;\n      onSuccess: () => void;\n      onError: (error: string | Error) => void;\n      logOut: () => Promise<void>;\n    };\n\nexport async function randomSessionProvider(\n  accountID: ID<Account>,\n  crypto: CryptoProvider,\n) {\n  return {\n    sessionID: crypto.newRandomSessionID(accountID as unknown as RawAccountID),\n    sessionDone: () => {},\n  };\n}\n\nexport type JazzContextWithAccount<Acc extends Account> = {\n  node: LocalNode;\n  account: Acc;\n  done: () => void;\n  logOut: () => Promise<void>;\n};\n\nexport type JazzContextWithAgent = {\n  agent: AnonymousJazzAgent;\n  done: () => void;\n  logOut: () => Promise<void>;\n};\n\nexport type JazzContext<Acc extends Account> =\n  | JazzContextWithAccount<Acc>\n  | JazzContextWithAgent;\n\nexport async function createJazzContextFromExistingCredentials<\n  Acc extends Account,\n>({\n  credentials,\n  peersToLoadFrom,\n  crypto,\n  AccountSchema: PropsAccountSchema,\n  sessionProvider,\n  onLogOut,\n}: {\n  credentials: Credentials;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  AccountSchema?: AccountClass<Acc>;\n  sessionProvider: SessionProvider;\n  onLogOut?: () => void;\n}): Promise<JazzContextWithAccount<Acc>> {\n  const { sessionID, sessionDone } = await sessionProvider(\n    credentials.accountID,\n    crypto,\n  );\n\n  const CurrentAccountSchema =\n    PropsAccountSchema ??\n    (RegisteredSchemas[\"Account\"] as unknown as AccountClass<Acc>);\n\n  const node = await LocalNode.withLoadedAccount({\n    accountID: credentials.accountID as unknown as CoID<RawAccount>,\n    accountSecret: credentials.secret,\n    sessionID: sessionID,\n    peersToLoadFrom: peersToLoadFrom,\n    crypto: crypto,\n    migration: async (rawAccount, _node, creationProps) => {\n      const account = new CurrentAccountSchema({\n        fromRaw: rawAccount,\n      }) as Acc;\n      activeAccountContext.set(account);\n\n      await account.applyMigration(creationProps);\n    },\n  });\n\n  const account = CurrentAccountSchema.fromNode(node);\n  activeAccountContext.set(account);\n\n  return {\n    node,\n    account,\n    done: () => {\n      node.gracefulShutdown();\n      sessionDone();\n    },\n    logOut: async () => {\n      node.gracefulShutdown();\n      sessionDone();\n      await onLogOut?.();\n    },\n  };\n}\n\nexport async function createJazzContextForNewAccount<Acc extends Account>({\n  creationProps,\n  initialAgentSecret,\n  peersToLoadFrom,\n  crypto,\n  AccountSchema: PropsAccountSchema,\n  onLogOut,\n}: {\n  creationProps: { name: string };\n  initialAgentSecret?: AgentSecret;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  AccountSchema?: AccountClass<Acc>;\n  onLogOut?: () => Promise<void>;\n}): Promise<JazzContextWithAccount<Acc>> {\n  const CurrentAccountSchema =\n    PropsAccountSchema ??\n    (RegisteredSchemas[\"Account\"] as unknown as AccountClass<Acc>);\n\n  const { node } = await LocalNode.withNewlyCreatedAccount({\n    creationProps,\n    peersToLoadFrom,\n    crypto,\n    initialAgentSecret,\n    migration: async (rawAccount, _node, creationProps) => {\n      const account = new CurrentAccountSchema({\n        fromRaw: rawAccount,\n      }) as Acc;\n      activeAccountContext.set(account);\n\n      await account.applyMigration(creationProps);\n    },\n  });\n\n  const account = CurrentAccountSchema.fromNode(node);\n  activeAccountContext.set(account);\n\n  return {\n    node,\n    account,\n    done: () => {\n      node.gracefulShutdown();\n    },\n    logOut: async () => {\n      node.gracefulShutdown();\n      await onLogOut?.();\n    },\n  };\n}\n\nexport async function createJazzContext<Acc extends Account>(options: {\n  credentials?: AuthCredentials;\n  newAccountProps?: NewAccountProps;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  defaultProfileName?: string;\n  AccountSchema?: AccountClass<Acc>;\n  sessionProvider: SessionProvider;\n  authSecretStorage: AuthSecretStorage;\n}) {\n  const crypto = options.crypto;\n\n  let context: JazzContextWithAccount<Acc>;\n\n  const authSecretStorage = options.authSecretStorage;\n\n  await authSecretStorage.migrate();\n\n  const credentials = options.credentials ?? (await authSecretStorage.get());\n\n  if (credentials && !options.newAccountProps) {\n    context = await createJazzContextFromExistingCredentials({\n      credentials: {\n        accountID: credentials.accountID,\n        secret: credentials.accountSecret,\n      },\n      peersToLoadFrom: options.peersToLoadFrom,\n      crypto,\n      AccountSchema: options.AccountSchema,\n      sessionProvider: options.sessionProvider,\n      onLogOut: () => {\n        authSecretStorage.clearWithoutNotify();\n      },\n    });\n  } else {\n    const secretSeed = options.crypto.newRandomSecretSeed();\n\n    const initialAgentSecret =\n      options.newAccountProps?.secret ??\n      crypto.agentSecretFromSecretSeed(secretSeed);\n\n    const creationProps = options.newAccountProps?.creationProps ?? {\n      name: options.defaultProfileName ?? \"Anonymous user\",\n    };\n\n    context = await createJazzContextForNewAccount({\n      creationProps,\n      initialAgentSecret,\n      peersToLoadFrom: options.peersToLoadFrom,\n      crypto,\n      AccountSchema: options.AccountSchema,\n      onLogOut: async () => {\n        await authSecretStorage.clearWithoutNotify();\n      },\n    });\n\n    if (!options.newAccountProps) {\n      await authSecretStorage.setWithoutNotify({\n        accountID: context.account.id,\n        secretSeed,\n        accountSecret: context.node.account.agentSecret,\n        provider: \"anonymous\",\n      });\n    }\n  }\n\n  return {\n    ...context,\n    authSecretStorage,\n  };\n}\n\nexport async function createAnonymousJazzContext({\n  peersToLoadFrom,\n  crypto,\n}: {\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n}): Promise<JazzContextWithAgent> {\n  const agentSecret = crypto.newRandomAgentSecret();\n  const rawAgent = new ControlledAgent(agentSecret, crypto);\n\n  const node = new LocalNode(\n    rawAgent,\n    crypto.newRandomSessionID(rawAgent.id),\n    crypto,\n  );\n\n  for (const peer of peersToLoadFrom) {\n    node.syncManager.addPeer(peer);\n  }\n\n  activeAccountContext.setGuestMode();\n\n  return {\n    agent: new AnonymousJazzAgent(node),\n    done: () => {},\n    logOut: async () => {},\n  };\n}\n", "import type { Account } from \"./account.js\";\nimport type { CoMap } from \"./coMap.js\";\nimport type { Group } from \"./group.js\";\n\n/**\n * Regisering schemas into this Record to avoid circular dependencies.\n */\nexport const RegisteredSchemas = {} as {\n  Account: typeof Account;\n  Group: typeof Group;\n  CoMap: typeof CoMap;\n};\n", "/* istanbul ignore file -- @preserve */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ItemsSym } from \"./symbols.js\";\n\n(globalThis as any).devtoolsFormatters = [\n  {\n    header: (object: any) => {\n      if (object._type === \"CoMap\") {\n        return [\"div\", {}, [\"span\", {}, object.constructor.name]];\n      } else if (object._type === \"CoList\") {\n        return [\n          \"div\",\n          {},\n          [\"span\", {}, object.constructor.name + \"(\" + object.length + \") \"],\n        ];\n      } else if (object._type === \"Account\") {\n        return [\n          \"div\",\n          {},\n          [\n            \"span\",\n            {},\n            object.constructor.name +\n              \"(\" +\n              object._refs.profile.value?.name +\n              (object.isMe ? \" ME\" : \"\") +\n              \")\",\n          ],\n        ];\n      } else {\n        return null;\n      }\n    },\n    hasBody: function () {\n      return true;\n    },\n    body: function (object: any) {\n      if (object._type === \"CoMap\" || object._type === \"Account\") {\n        return [\n          \"div\",\n          { style: \"margin-left: 15px\" },\n          [\"div\", \"id: \", [\"object\", { object: object.id }]],\n          ...Object.entries(object).map(([k, v]) => [\n            \"div\",\n            { style: \"white-space: nowrap;\" },\n            [\"span\", { style: \"font-weight: bold; opacity: 0.6\" }, k, \": \"],\n            [\"object\", { object: v }],\n            ...(typeof object._schema[k] === \"function\"\n              ? v === null\n                ? [\n                    [\n                      \"span\",\n                      { style: \"opacity: 0.5\" },\n                      ` (pending ${object._schema[k].name} `,\n                      [\"object\", { object: object._refs[k] }],\n                      \")\",\n                    ],\n                  ]\n                : []\n              : []),\n          ]),\n        ];\n      } else if (object._type === \"CoList\") {\n        return [\n          \"div\",\n          { style: \"margin-left: 15px\" },\n          [\"div\", \"id: \", [\"object\", { object: object.id }]],\n          ...(object as any[]).map((v, i) => [\n            \"div\",\n            { style: \"white-space: nowrap;\" },\n            [\"span\", { style: \"font-weight: bold; opacity: 0.6\" }, i, \": \"],\n            [\"object\", { object: v }],\n            ...(typeof object._schema[ItemsSym] === \"function\"\n              ? v === null\n                ? [\n                    [\n                      \"span\",\n                      { style: \"opacity: 0.5\" },\n                      ` (pending ${object._schema[ItemsSym].name} `,\n                      [\"object\", { object: object._refs[i] }],\n                      \")\",\n                    ],\n                  ]\n                : []\n              : []),\n          ]),\n        ];\n      }\n    },\n  },\n];\n", "import {\n  CoID,\n  InviteSecret,\n  RawAccount,\n  RawCoMap,\n  RawControlledAccount,\n  SessionID,\n} from \"cojson\";\nimport { CoStreamItem, RawCoStream } from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport { type Account } from \"./account.js\";\nimport { CoValue, CoValueClass, ID, loadCoValue } from \"./interfaces.js\";\n\nexport type InboxInvite = `${CoID<MessagesStream>}/${InviteSecret}`;\ntype TxKey = `${SessionID}/${number}`;\n\ntype MessagesStream = RawCoStream<CoID<InboxMessage<CoValue, any>>>;\ntype FailedMessagesStream = RawCoStream<{\n  errors: string[];\n  value: CoID<InboxMessage<CoValue, any>>;\n}>;\ntype TxKeyStream = RawCoStream<TxKey>;\nexport type InboxRoot = RawCoMap<{\n  messages: CoID<MessagesStream>;\n  processed: CoID<TxKeyStream>;\n  failed: CoID<FailedMessagesStream>;\n  inviteLink: InboxInvite;\n}>;\n\nexport function createInboxRoot(account: Account) {\n  if (!account.isLocalNodeOwner) {\n    throw new Error(\"Account is not controlled\");\n  }\n\n  const rawAccount = account._raw as RawControlledAccount;\n\n  const group = rawAccount.createGroup();\n  const messagesFeed = group.createStream<MessagesStream>();\n\n  const inboxRoot = rawAccount.createMap<InboxRoot>();\n  const processedFeed = rawAccount.createStream<TxKeyStream>();\n  const failedFeed = rawAccount.createStream<FailedMessagesStream>();\n\n  const inviteLink =\n    `${messagesFeed.id}/${group.createInvite(\"writeOnly\")}` as const;\n\n  inboxRoot.set(\"messages\", messagesFeed.id);\n  inboxRoot.set(\"processed\", processedFeed.id);\n  inboxRoot.set(\"failed\", failedFeed.id);\n\n  return {\n    id: inboxRoot.id,\n    inviteLink,\n  };\n}\n\ntype InboxMessage<I extends CoValue, O extends CoValue | undefined> = RawCoMap<{\n  payload: ID<I>;\n  result: ID<O> | undefined;\n  processed: boolean;\n  error: string | undefined;\n}>;\n\nasync function createInboxMessage<\n  I extends CoValue,\n  O extends CoValue | undefined,\n>(payload: I, inboxOwner: RawAccount) {\n  const group = payload._raw.group;\n\n  if (group instanceof RawAccount) {\n    throw new Error(\"Inbox messages should be owned by a group\");\n  }\n\n  group.addMember(inboxOwner, \"writer\");\n\n  const message = group.createMap<InboxMessage<I, O>>({\n    payload: payload.id,\n    result: undefined,\n    processed: false,\n    error: undefined,\n  });\n\n  await payload._raw.core.waitForSync();\n  await message.core.waitForSync();\n\n  return message;\n}\n\nexport class Inbox {\n  account: Account;\n  messages: MessagesStream;\n  processed: TxKeyStream;\n  failed: FailedMessagesStream;\n  root: InboxRoot;\n  processing = new Set<`${SessionID}/${number}`>();\n\n  private constructor(\n    account: Account,\n    root: InboxRoot,\n    messages: MessagesStream,\n    processed: TxKeyStream,\n    failed: FailedMessagesStream,\n  ) {\n    this.account = account;\n    this.root = root;\n    this.messages = messages;\n    this.processed = processed;\n    this.failed = failed;\n  }\n\n  subscribe<I extends CoValue, O extends CoValue | undefined>(\n    Schema: CoValueClass<I>,\n    callback: (\n      message: I,\n      senderAccountID: ID<Account>,\n    ) => Promise<O | undefined | void>,\n    options: { retries?: number } = {},\n  ) {\n    const processed = new Set<`${SessionID}/${number}`>();\n    const failed = new Map<`${SessionID}/${number}`, string[]>();\n    const node = this.account._raw.core.node;\n\n    this.processed.subscribe((stream) => {\n      for (const items of Object.values(stream.items)) {\n        for (const item of items) {\n          processed.add(item.value as TxKey);\n        }\n      }\n    });\n\n    const { account } = this;\n    const { retries = 3 } = options;\n\n    let failTimer: ReturnType<typeof setTimeout> | number | undefined =\n      undefined;\n\n    const clearFailTimer = () => {\n      clearTimeout(failTimer);\n      failTimer = undefined;\n    };\n\n    const handleNewMessages = (stream: MessagesStream) => {\n      clearFailTimer(); // Stop the failure timers, we're going to process the failed entries anyway\n\n      for (const [sessionID, items] of Object.entries(stream.items) as [\n        SessionID,\n        CoStreamItem<CoID<InboxMessage<I, O>>>[],\n      ][]) {\n        const accountID = getAccountIDfromSessionID(sessionID);\n\n        if (!accountID) {\n          console.warn(\"Received message from unknown account\", sessionID);\n          continue;\n        }\n\n        for (const item of items) {\n          const txKey = `${sessionID}/${item.tx.txIndex}` as const;\n\n          if (!processed.has(txKey) && !this.processing.has(txKey)) {\n            this.processing.add(txKey);\n\n            const id = item.value;\n\n            node\n              .load(id)\n              .then((message) => {\n                if (message === \"unavailable\") {\n                  return Promise.reject(\n                    new Error(\"Unable to load inbox message \" + id),\n                  );\n                }\n\n                return loadCoValue(Schema, message.get(\"payload\") as ID<I>, {\n                  loadAs: account,\n                });\n              })\n              .then((value) => {\n                if (!value) {\n                  return Promise.reject(\n                    new Error(\"Unable to load inbox message \" + id),\n                  );\n                }\n\n                return callback(value, accountID);\n              })\n              .then((result) => {\n                const inboxMessage = node\n                  .expectCoValueLoaded(item.value)\n                  .getCurrentContent() as RawCoMap;\n\n                if (result) {\n                  inboxMessage.set(\"result\", result.id);\n                }\n\n                inboxMessage.set(\"processed\", true);\n\n                this.processed.push(txKey);\n                this.processing.delete(txKey);\n              })\n              .catch((error) => {\n                console.error(\"Error processing inbox message\", error);\n                this.processing.delete(txKey);\n                const errors = failed.get(txKey) ?? [];\n\n                const stringifiedError = String(error);\n                errors.push(stringifiedError);\n\n                let inboxMessage: RawCoMap | undefined;\n\n                try {\n                  inboxMessage = node\n                    .expectCoValueLoaded(item.value)\n                    .getCurrentContent() as RawCoMap;\n\n                  inboxMessage.set(\"error\", stringifiedError);\n                } catch (error) {}\n\n                if (errors.length > retries) {\n                  inboxMessage?.set(\"processed\", true);\n                  this.processed.push(txKey);\n                  this.failed.push({ errors, value: item.value });\n                } else {\n                  failed.set(txKey, errors);\n                  if (!failTimer) {\n                    failTimer = setTimeout(\n                      () => handleNewMessages(stream),\n                      100,\n                    );\n                  }\n                }\n              });\n          }\n        }\n      }\n    };\n\n    const unsubscribe = this.messages.subscribe(handleNewMessages);\n\n    return () => {\n      unsubscribe();\n      clearFailTimer();\n    };\n  }\n\n  static async load(account: Account) {\n    const profile = account.profile;\n\n    if (!profile) {\n      throw new Error(\"Account profile should already be loaded\");\n    }\n\n    if (!profile.inbox) {\n      throw new Error(\"The account has not set up their inbox\");\n    }\n\n    const node = account._raw.core.node;\n\n    const root = await node.load(profile.inbox as CoID<InboxRoot>);\n\n    if (root === \"unavailable\") {\n      throw new Error(\"Inbox not found\");\n    }\n\n    const [messages, processed, failed] = await Promise.all([\n      node.load(root.get(\"messages\")!),\n      node.load(root.get(\"processed\")!),\n      node.load(root.get(\"failed\")!),\n    ]);\n\n    if (\n      messages === \"unavailable\" ||\n      processed === \"unavailable\" ||\n      failed === \"unavailable\"\n    ) {\n      throw new Error(\"Inbox not found\");\n    }\n\n    return new Inbox(account, root, messages, processed, failed);\n  }\n}\n\nexport class InboxSender<I extends CoValue, O extends CoValue | undefined> {\n  currentAccount: Account;\n  owner: RawAccount;\n  messages: MessagesStream;\n\n  private constructor(\n    currentAccount: Account,\n    owner: RawAccount,\n    messages: MessagesStream,\n  ) {\n    this.currentAccount = currentAccount;\n    this.owner = owner;\n    this.messages = messages;\n  }\n\n  getOwnerAccount() {\n    return this.owner;\n  }\n\n  async sendMessage(\n    message: I,\n  ): Promise<O extends CoValue ? ID<O> : undefined> {\n    const inboxMessage = await createInboxMessage<I, O>(message, this.owner);\n\n    this.messages.push(inboxMessage.id);\n\n    return new Promise((resolve, reject) => {\n      inboxMessage.subscribe((message) => {\n        if (message.get(\"processed\")) {\n          const error = message.get(\"error\");\n          if (error) {\n            reject(new Error(error));\n          } else {\n            resolve(\n              message.get(\"result\") as O extends CoValue ? ID<O> : undefined,\n            );\n          }\n        }\n      });\n    });\n  }\n\n  static async load<\n    I extends CoValue,\n    O extends CoValue | undefined = undefined,\n  >(inboxOwnerID: ID<Account>, currentAccount?: Account) {\n    currentAccount ||= activeAccountContext.get();\n\n    const node = currentAccount._raw.core.node;\n\n    const inboxOwnerRaw = await node.load(\n      inboxOwnerID as unknown as CoID<RawAccount>,\n    );\n\n    if (inboxOwnerRaw === \"unavailable\") {\n      throw new Error(\"Failed to load the inbox owner\");\n    }\n\n    const inboxOwnerProfileRaw = await node.load(inboxOwnerRaw.get(\"profile\")!);\n\n    if (inboxOwnerProfileRaw === \"unavailable\") {\n      throw new Error(\"Failed to load the inbox owner profile\");\n    }\n\n    if (\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"reader\" &&\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"writer\" &&\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"admin\"\n    ) {\n      throw new Error(\n        \"Insufficient permissions to access the inbox, make sure its user profile is publicly readable.\",\n      );\n    }\n\n    const inboxInvite = inboxOwnerProfileRaw.get(\"inboxInvite\");\n\n    if (!inboxInvite) {\n      throw new Error(\"The user has not set up their inbox\");\n    }\n\n    const id = await acceptInvite(inboxInvite as InboxInvite, currentAccount);\n\n    const messages = await node.load(id);\n\n    if (messages === \"unavailable\") {\n      throw new Error(\"Inbox not found\");\n    }\n\n    return new InboxSender<I, O>(currentAccount, inboxOwnerRaw, messages);\n  }\n}\n\nasync function acceptInvite(invite: string, account?: Account) {\n  account ||= activeAccountContext.get();\n\n  const id = invite.slice(0, invite.indexOf(\"/\")) as CoID<MessagesStream>;\n\n  const inviteSecret = invite.slice(invite.indexOf(\"/\") + 1) as InviteSecret;\n\n  if (!id?.startsWith(\"co_z\") || !inviteSecret.startsWith(\"inviteSecret_\")) {\n    throw new Error(\"Invalid inbox ticket\");\n  }\n\n  if (!account.isLocalNodeOwner) {\n    throw new Error(\"Account is not controlled\");\n  }\n\n  await (account._raw as RawControlledAccount).acceptInvite(id, inviteSecret);\n\n  return id;\n}\n\nfunction getAccountIDfromSessionID(sessionID: SessionID) {\n  const until = sessionID.indexOf(\"_session\");\n  const accountID = sessionID.slice(0, until);\n\n  if (accountID.startsWith(\"co_z\")) {\n    return accountID as ID<Account>;\n  }\n\n  return;\n}\n", "import {\n  AgentID,\n  type CoValueUniqueness,\n  CojsonInternalTypes,\n  type JsonValue,\n  RawAccountID,\n  type RawCoMap,\n  cojsonInternals,\n} from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  ID,\n  IfCo,\n  RefEncoded,\n  RefIfCoValue,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  co,\n} from \"../internal.js\";\nimport {\n  CoValueBase,\n  ItemsSym,\n  Ref,\n  SchemaInit,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  makeRefs,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { type Account } from \"./account.js\";\nimport { type Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\ntype CoMapEdit<V> = {\n  value?: V;\n  ref?: RefIfCoValue<V>;\n  by?: RegisteredAccount;\n  madeAt: Date;\n  key?: string;\n};\n\ntype LastAndAllCoMapEdits<V> = CoMapEdit<V> & { all: CoMapEdit<V>[] };\n\nexport type Simplify<A> = {\n  [K in keyof A]: A[K];\n} extends infer B\n  ? B\n  : never;\n\n/**\n * CoMaps are collaborative versions of plain objects, mapping string-like keys to values.\n *\n * @categoryDescription Declaration\n * Declare your own CoMap schemas by subclassing `CoMap` and assigning field schemas with `co`.\n *\n * Optional `co.ref(...)` fields must be marked with `{ optional: true }`.\n *\n * ```ts\n * import { co, CoMap } from \"jazz-tools\";\n *\n * class Person extends CoMap {\n *   name = co.string;\n *   age = co.number;\n *   pet = co.ref(Animal);\n *   car = co.ref(Car, { optional: true });\n * }\n * ```\n *\n * @categoryDescription Content\n * You can access properties you declare on a `CoMap` (using `co`) as if they were normal properties on a plain object, using dot notation, `Object.keys()`, etc.\n *\n * ```ts\n * person.name;\n * person[\"age\"];\n * person.age = 42;\n * person.pet?.name;\n * Object.keys(person);\n * // => [\"name\", \"age\", \"pet\"]\n * ```\n *\n * @category CoValues\n *  */\nexport class CoMap extends CoValueBase implements CoValue {\n  /**\n   * The ID of this `CoMap`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoMap\";\n  static {\n    this.prototype._type = \"CoMap\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoMap;\n\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema() {\n    return (this.constructor as typeof CoMap)._schema as {\n      [key: string]: Schema;\n    } & { [ItemsSym]?: Schema };\n  }\n\n  /**\n   * If property `prop` is a `co.ref(...)`, you can use `coMaps._refs.prop` to access\n   * the `Ref` instead of the potentially loaded/null value.\n   *\n   * This allows you to always get the ID or load the value manually.\n   *\n   * @example\n   * ```ts\n   * person._refs.pet.id; // => ID<Animal>\n   * person._refs.pet.value;\n   * // => Animal | null\n   * const pet = await person._refs.pet.load();\n   * ```\n   *\n   * @category Content\n   **/\n  get _refs(): {\n    [Key in CoKeys<this>]: IfCo<this[Key], RefIfCoValue<this[Key]>>;\n  } {\n    return makeRefs<CoKeys<this>>(\n      (key) => this._raw.get(key as string) as unknown as ID<CoValue>,\n      () => {\n        const keys = this._raw.keys().filter((key) => {\n          const schema =\n            this._schema[key as keyof typeof this._schema] ||\n            (this._schema[ItemsSym] as Schema | undefined);\n          return schema && schema !== \"json\" && isRefEncoded(schema);\n        }) as CoKeys<this>[];\n\n        return keys;\n      },\n      this._loadedAs,\n      (key) =>\n        (this._schema[key] || this._schema[ItemsSym]) as RefEncoded<CoValue>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) as any;\n  }\n\n  /** @internal */\n  public getEditFromRaw(\n    target: CoMap,\n    rawEdit: {\n      by: RawAccountID | AgentID;\n      tx: CojsonInternalTypes.TransactionID;\n      at: Date;\n      value?: JsonValue | undefined;\n    },\n    descriptor: Schema,\n    key: string,\n  ) {\n    return {\n      value:\n        descriptor === \"json\"\n          ? rawEdit.value\n          : \"encoded\" in descriptor\n            ? rawEdit.value === null || rawEdit.value === undefined\n              ? rawEdit.value\n              : descriptor.encoded.decode(rawEdit.value)\n            : new Ref(\n                rawEdit.value as ID<CoValue>,\n                target._loadedAs,\n                descriptor,\n              ).accessFrom(target, \"_edits.\" + key + \".value\"),\n      ref:\n        descriptor !== \"json\" && isRefEncoded(descriptor)\n          ? new Ref(rawEdit.value as ID<CoValue>, target._loadedAs, descriptor)\n          : undefined,\n      by:\n        rawEdit.by &&\n        new Ref<Account>(rawEdit.by as ID<Account>, target._loadedAs, {\n          ref: RegisteredSchemas[\"Account\"],\n          optional: false,\n        }).accessFrom(target, \"_edits.\" + key + \".by\"),\n      madeAt: rawEdit.at,\n      key,\n    };\n  }\n\n  /** @category Collaboration */\n  get _edits() {\n    const map = this;\n    return new Proxy(\n      {},\n      {\n        get(_target, key) {\n          const rawEdit = map._raw.lastEditAt(key as string);\n          if (!rawEdit) return undefined;\n\n          const descriptor = map._schema[\n            key as keyof typeof map._schema\n          ] as Schema;\n\n          return {\n            ...map.getEditFromRaw(map, rawEdit, descriptor, key as string),\n            get all() {\n              return [...map._raw.editsAt(key as string)].map((rawEdit) =>\n                map.getEditFromRaw(map, rawEdit, descriptor, key as string),\n              );\n            },\n          };\n        },\n        ownKeys(_target) {\n          return map._raw.keys();\n        },\n        getOwnPropertyDescriptor(target, key) {\n          return {\n            value: Reflect.get(target, key),\n            writable: false,\n            enumerable: true,\n            configurable: true,\n          };\n        },\n      },\n    ) as {\n      [Key in CoKeys<this>]: IfCo<this[Key], LastAndAllCoMapEdits<this[Key]>>;\n    };\n  }\n\n  /** @internal */\n  constructor(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options: { fromRaw: RawCoMap } | undefined,\n  ) {\n    super();\n\n    if (options) {\n      if (\"fromRaw\" in options) {\n        Object.defineProperties(this, {\n          id: {\n            value: options.fromRaw.id as unknown as ID<this>,\n            enumerable: false,\n          },\n          _raw: { value: options.fromRaw, enumerable: false },\n        });\n      } else {\n        throw new Error(\"Invalid CoMap constructor arguments\");\n      }\n    }\n\n    return new Proxy(this, CoMapProxyHandler as ProxyHandler<this>);\n  }\n\n  /**\n   * Create a new CoMap with the given initial values and owner.\n   *\n   * The owner (a Group or Account) determines access rights to the CoMap.\n   *\n   * The CoMap will immediately be persisted and synced to connected peers.\n   *\n   * @example\n   * ```ts\n   * const person = Person.create({\n   *   name: \"Alice\",\n   *   age: 42,\n   *   pet: cat,\n   * }, { owner: friendGroup });\n   * ```\n   *\n   * @category Creation\n   **/\n  static create<M extends CoMap>(\n    this: CoValueClass<M>,\n    init: Simplify<CoMapInit<M>>,\n    options?:\n      | {\n          owner: Account | Group;\n          unique?: CoValueUniqueness[\"uniqueness\"];\n        }\n      | Account\n      | Group,\n  ) {\n    const instance = new this();\n\n    const { owner, uniqueness } = parseCoValueCreateOptions(options);\n    const raw = instance.rawFromInit(init, owner, uniqueness);\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n    return instance;\n  }\n\n  /**\n   * Return a JSON representation of the `CoMap`\n   * @category Content\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(_key?: string, processedValues?: ID<CoValue>[]): any {\n    const result = {\n      id: this.id,\n      _type: this._type,\n    } as Record<string, any>;\n\n    for (const key of this._raw.keys()) {\n      const tKey = key as CoKeys<this>;\n      const descriptor = (this._schema[tKey] ||\n        this._schema[ItemsSym]) as Schema;\n\n      if (!descriptor) {\n        continue;\n      }\n\n      if (descriptor == \"json\" || \"encoded\" in descriptor) {\n        result[key] = this._raw.get(key);\n      } else if (isRefEncoded(descriptor)) {\n        const id = this._raw.get(key) as ID<CoValue>;\n\n        if (processedValues?.includes(id) || id === this.id) {\n          result[key] = { _circular: id };\n          continue;\n        }\n\n        const ref = this[tKey];\n\n        if (\n          ref &&\n          typeof ref === \"object\" &&\n          \"toJSON\" in ref &&\n          typeof ref.toJSON === \"function\"\n        ) {\n          const jsonedRef = ref.toJSON(tKey, [\n            ...(processedValues || []),\n            this.id,\n          ]);\n          result[key] = jsonedRef;\n        }\n      } else {\n        result[key] = undefined;\n      }\n    }\n\n    return result;\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /**\n   * Create a new `RawCoMap` from an initialization object\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawFromInit<Fields extends object = Record<string, any>>(\n    init: Simplify<CoMapInit<Fields>> | undefined,\n    owner: Account | Group,\n    uniqueness?: CoValueUniqueness,\n  ) {\n    const rawOwner = owner._raw;\n\n    const rawInit = {} as {\n      [key in keyof Fields]: JsonValue | undefined;\n    };\n\n    if (init)\n      for (const key of Object.keys(init) as (keyof Fields)[]) {\n        const initValue = init[key as keyof typeof init];\n\n        const descriptor = (this._schema[key as keyof typeof this._schema] ||\n          this._schema[ItemsSym]) as Schema;\n\n        if (!descriptor) {\n          continue;\n        }\n\n        if (descriptor === \"json\") {\n          rawInit[key] = initValue as JsonValue;\n        } else if (isRefEncoded(descriptor)) {\n          if (initValue) {\n            rawInit[key] = (initValue as unknown as CoValue).id;\n          }\n        } else if (\"encoded\" in descriptor) {\n          rawInit[key] = descriptor.encoded.encode(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            initValue as any,\n          );\n        }\n      }\n\n    return rawOwner.createMap(rawInit, null, \"private\", uniqueness);\n  }\n\n  /**\n   * Declare a Record-like CoMap schema, by extending `CoMap.Record(...)` and passing the value schema using `co`. Keys are always `string`.\n   *\n   * @example\n   * ```ts\n   * import { co, CoMap } from \"jazz-tools\";\n   *\n   * class ColorToFruitMap extends CoMap.Record(\n   *  co.ref(Fruit)\n   * ) {}\n   *\n   * // assume we have map: ColorToFruitMap\n   * // and strawberry: Fruit\n   * map[\"red\"] = strawberry;\n   * ```\n   *\n   * @category Declaration\n   */\n  static Record<Value>(value: IfCo<Value, Value>) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n    class RecordLikeCoMap extends CoMap {\n      [ItemsSym] = value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n    interface RecordLikeCoMap extends Record<string, Value> {}\n\n    return RecordLikeCoMap;\n  }\n\n  /**\n   * Load a `CoMap` with a given ID, as a given account.\n   *\n   * `depth` specifies which (if any) fields that reference other CoValues to load as well before resolving.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * @example\n   * ```ts\n   * const person = await Person.load(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   { pet: {} }\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static load<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    options?: {\n      resolve?: RefsToResolveStrict<M, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<M, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Load and subscribe to a `CoMap` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * `depth` specifies which (if any) fields that reference other CoValues to load as well before calling `listener` for the first time.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @example\n   * ```ts\n   * const unsub = Person.subscribe(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   { pet: {} },\n   *   (person) => console.log(person)\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    options: SubscribeListenerOptions<M, R>,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    ...args: SubscribeRestArgs<M, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<M, R>(this, id, options, listener);\n  }\n\n  static findUnique<M extends CoMap>(\n    this: CoValueClass<M>,\n    unique: CoValueUniqueness[\"uniqueness\"],\n    ownerID: ID<Account> | ID<Group>,\n    as?: Account | Group | AnonymousJazzAgent,\n  ) {\n    as ||= activeAccountContext.get();\n\n    const header = {\n      type: \"comap\" as const,\n      ruleset: {\n        type: \"ownedByGroup\" as const,\n        group: ownerID,\n      },\n      meta: null,\n      uniqueness: unique,\n    };\n    const crypto =\n      as._type === \"Anonymous\" ? as.node.crypto : as._raw.core.crypto;\n    return cojsonInternals.idforHeader(header, crypto) as ID<M>;\n  }\n\n  /**\n   * Given an already loaded `CoMap`, ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoMap.load()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * @category Subscription & Loading\n   */\n  ensureLoaded<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: M,\n    options: { resolve: RefsToResolveStrict<M, R> },\n  ): Promise<Resolved<M, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * Given an already loaded `CoMap`, subscribe to updates to the `CoMap` and ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoMap.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: M,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: M,\n    options: { resolve?: RefsToResolveStrict<M, R> },\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: M,\n    ...args: SubscribeRestArgs<M, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue<M, R>(this, options, listener);\n  }\n\n  applyDiff<N extends Partial<CoMapInit<this>>>(newValues: N) {\n    for (const key in newValues) {\n      if (Object.prototype.hasOwnProperty.call(newValues, key)) {\n        const tKey = key as keyof typeof newValues & keyof this;\n        const descriptor = (this._schema[tKey as string] ||\n          this._schema[ItemsSym]) as Schema;\n\n        if (tKey in this._schema) {\n          const newValue = newValues[tKey];\n          const currentValue = (this as unknown as N)[tKey];\n\n          if (descriptor === \"json\" || \"encoded\" in descriptor) {\n            if (currentValue !== newValue) {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (this as any)[tKey] = newValue;\n            }\n          } else if (isRefEncoded(descriptor)) {\n            const currentId = (currentValue as CoValue | undefined)?.id;\n            const newId = (newValue as CoValue | undefined)?.id;\n            if (currentId !== newId) {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (this as any)[tKey] = newValue;\n            }\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Wait for the `CoMap` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\nexport type CoKeys<Map extends object> = Exclude<\n  keyof Map & string,\n  keyof CoMap\n>;\n\n/**\n * Force required ref fields to be non nullable\n *\n * Considering that:\n * - Optional refs are typed as co<InstanceType<CoValueClass> | null | undefined>\n * - Required refs are typed as co<InstanceType<CoValueClass> | null>\n *\n * This type works in two steps:\n * - Remove the null from both types\n * - Then we check if the input type accepts undefined, if positive we put the null union back\n *\n * So the optional refs stays unchanged while we safely remove the null union\n * from required refs\n *\n * This way required refs can be marked as required in the CoMapInit while\n * staying a nullable property for value access.\n *\n * Example:\n *\n * const map = MyCoMap.create({\n *   requiredRef: NestedMap.create({}) // null is not valid here\n * })\n *\n * map.requiredRef // this value is still nullable\n */\ntype ForceRequiredRef<V> = V extends co<InstanceType<CoValueClass> | null>\n  ? NonNullable<V>\n  : V extends co<InstanceType<CoValueClass> | undefined>\n    ? V | null\n    : V;\n\nexport type CoMapInit<Map extends object> = {\n  [Key in CoKeys<Map> as undefined extends Map[Key]\n    ? never\n    : IfCo<Map[Key], Key>]: ForceRequiredRef<Map[Key]>;\n} & {\n  [Key in CoKeys<Map> as IfCo<Map[Key], Key>]?: ForceRequiredRef<Map[Key]>;\n};\n\n// TODO: cache handlers per descriptor for performance?\nconst CoMapProxyHandler: ProxyHandler<CoMap> = {\n  get(target, key, receiver) {\n    if (key === \"_schema\") {\n      return Reflect.get(target, key);\n    } else if (key in target) {\n      return Reflect.get(target, key, receiver);\n    } else {\n      const schema = target._schema;\n\n      if (!schema) {\n        return undefined;\n      }\n\n      const descriptor = (schema[key as keyof CoMap[\"_schema\"]] ||\n        schema[ItemsSym]) as Schema;\n      if (descriptor && typeof key === \"string\") {\n        const raw = target._raw.get(key);\n\n        if (descriptor === \"json\") {\n          return raw;\n        } else if (\"encoded\" in descriptor) {\n          return raw === undefined ? undefined : descriptor.encoded.decode(raw);\n        } else if (isRefEncoded(descriptor)) {\n          return raw === undefined\n            ? undefined\n            : new Ref(\n                raw as unknown as ID<CoValue>,\n                target._loadedAs,\n                descriptor,\n              ).accessFrom(receiver, key);\n        }\n      } else {\n        return undefined;\n      }\n    }\n  },\n  set(target, key, value, receiver) {\n    if (\n      (typeof key === \"string\" || ItemsSym) &&\n      typeof value === \"object\" &&\n      value !== null &&\n      SchemaInit in value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] = value[SchemaInit];\n      return true;\n    }\n\n    const descriptor = (target._schema[key as keyof CoMap[\"_schema\"]] ||\n      target._schema[ItemsSym]) as Schema;\n    if (descriptor && typeof key === \"string\") {\n      if (descriptor === \"json\") {\n        target._raw.set(key, value);\n      } else if (\"encoded\" in descriptor) {\n        target._raw.set(key, descriptor.encoded.encode(value));\n      } else if (isRefEncoded(descriptor)) {\n        if (value === null) {\n          if (descriptor.optional) {\n            target._raw.set(key, null);\n          } else {\n            throw new Error(`Cannot set required reference ${key} to null`);\n          }\n        } else if (value?.id) {\n          target._raw.set(key, value.id);\n          subscriptionsScopes\n            .get(target)\n            ?.onRefAccessedOrSet(target.id, value.id);\n        } else {\n          throw new Error(\n            `Cannot set reference ${key} to a non-CoValue. Got ${value}`,\n          );\n        }\n      }\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, attributes) {\n    if (\n      \"value\" in attributes &&\n      typeof attributes.value === \"object\" &&\n      SchemaInit in attributes.value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key as string] =\n        attributes.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, attributes);\n    }\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target).filter((k) => k !== ItemsSym);\n    // for (const key of Reflect.ownKeys(target._schema)) {\n    //     if (key !== ItemsSym && !keys.includes(key)) {\n    //         keys.push(key);\n    //     }\n    // }\n    for (const key of target._raw.keys()) {\n      if (!keys.includes(key)) {\n        keys.push(key);\n      }\n    }\n\n    return keys;\n  },\n  getOwnPropertyDescriptor(target, key) {\n    if (key in target) {\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    } else {\n      const descriptor = (target._schema[key as keyof CoMap[\"_schema\"]] ||\n        target._schema[ItemsSym]) as Schema;\n      if (descriptor || key in target._raw.latest) {\n        return {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n        };\n      }\n    }\n  },\n  has(target, key) {\n    const descriptor = (target._schema?.[key as keyof CoMap[\"_schema\"]] ||\n      target._schema?.[ItemsSym]) as Schema;\n\n    if (target._raw && typeof key === \"string\" && descriptor) {\n      return target._raw.get(key) !== undefined;\n    } else {\n      return Reflect.has(target, key);\n    }\n  },\n  deleteProperty(target, key) {\n    const descriptor = (target._schema[key as keyof CoMap[\"_schema\"]] ||\n      target._schema[ItemsSym]) as Schema;\n    if (typeof key === \"string\" && descriptor) {\n      target._raw.delete(key);\n      return true;\n    } else {\n      return Reflect.deleteProperty(target, key);\n    }\n  },\n};\n\nRegisteredSchemas[\"CoMap\"] = CoMap;\n", "import { CoID } from \"cojson\";\nimport { CoValueClass, co } from \"../internal.js\";\nimport { Account } from \"./account.js\";\nimport { CoMap, CoMapInit, Simplify } from \"./coMap.js\";\nimport { Group } from \"./group.js\";\nimport { InboxInvite, InboxRoot } from \"./inbox.js\";\n\n/** @category Identity & Permissions */\nexport class Profile extends CoMap {\n  name = co.string;\n  inbox = co.optional.json<CoID<InboxRoot>>();\n  inboxInvite = co.optional.json<InboxInvite>();\n\n  override get _owner(): Group {\n    return super._owner as Group;\n  }\n\n  /**\n   * Creates a new profile with the given initial values and owner.\n   *\n   * The owner (a Group) determines access rights to the Profile.\n   *\n   * @category Creation\n   */\n  static override create<M extends CoMap>(\n    this: CoValueClass<M>,\n    init: Simplify<CoMapInit<M>>,\n    options?:\n      | {\n          owner: Group;\n        }\n      | Group,\n  ) {\n    const owner =\n      options !== undefined && \"owner\" in options ? options.owner : options;\n\n    // We add some guardrails to ensure that the owner of a profile is a group\n    if ((owner as Group | Account | undefined)?._type === \"Account\") {\n      throw new Error(\"Profiles should be owned by a group\");\n    }\n\n    return super.create<M>(init, options);\n  }\n}\n", "import {\n  AgentSecret,\n  CoID,\n  CryptoProvider,\n  Everyone,\n  InviteSecret,\n  LocalNode,\n  Peer,\n  RawAccount,\n  RawCoMap,\n  RawCoValue,\n  RawControlledAccount,\n  Role,\n  SessionID,\n  cojsonInternals,\n} from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport {\n  AnonymousJazzAgent,\n  type CoValue,\n  CoValueBase,\n  CoValueClass,\n  ID,\n  Ref,\n  type RefEncoded,\n  RefIfCoValue,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  type Schema,\n  SchemaInit,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  ensureCoValueLoaded,\n  inspect,\n  loadCoValue,\n  loadCoValueWithoutMe,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { type CoMap } from \"./coMap.js\";\nimport { type Group } from \"./group.js\";\nimport { createInboxRoot } from \"./inbox.js\";\nimport { Profile } from \"./profile.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\nexport type AccountCreationProps = {\n  name: string;\n  onboarding?: boolean;\n};\n\n/** @category Identity & Permissions */\nexport class Account extends CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"Account\";\n  declare _raw: RawAccount | RawControlledAccount;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  get _schema(): {\n    profile: Schema;\n    root: Schema;\n  } {\n    return (this.constructor as typeof Account)._schema;\n  }\n  static {\n    this._schema = {\n      profile: {\n        ref: () => Profile,\n        optional: false,\n      } satisfies RefEncoded<Profile>,\n      root: {\n        ref: () => RegisteredSchemas[\"CoMap\"],\n        optional: true,\n      } satisfies RefEncoded<CoMap>,\n    };\n  }\n\n  get _owner(): Account {\n    return this as Account;\n  }\n  get _loadedAs(): Account | AnonymousJazzAgent {\n    if (this.isLocalNodeOwner) return this;\n\n    const rawAccount = this._raw.core.node.account;\n\n    if (rawAccount instanceof RawAccount) {\n      return coValuesCache.get(rawAccount, () => Account.fromRaw(rawAccount));\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  declare profile: Profile | null;\n  declare root: CoMap | null;\n\n  get _refs(): {\n    profile: RefIfCoValue<Profile> | undefined;\n    root: RefIfCoValue<CoMap> | undefined;\n  } {\n    const profileID = this._raw.get(\"profile\") as unknown as\n      | ID<NonNullable<this[\"profile\"]>>\n      | undefined;\n    const rootID = this._raw.get(\"root\") as unknown as\n      | ID<NonNullable<this[\"root\"]>>\n      | undefined;\n\n    return {\n      profile:\n        profileID &&\n        (new Ref(\n          profileID,\n          this._loadedAs,\n          this._schema.profile as RefEncoded<\n            NonNullable<this[\"profile\"]> & CoValue\n          >,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any as RefIfCoValue<this[\"profile\"]>),\n      root:\n        rootID &&\n        (new Ref(\n          rootID,\n          this._loadedAs,\n          this._schema.root as RefEncoded<NonNullable<this[\"root\"]> & CoValue>,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any as RefIfCoValue<this[\"root\"]>),\n    };\n  }\n\n  /**\n   * Whether this account is the currently active account.\n   */\n  get isMe() {\n    return activeAccountContext.get().id === this.id;\n  }\n\n  /**\n   * Whether this account is the owner of the local node.\n   */\n  isLocalNodeOwner: boolean;\n  sessionID: SessionID | undefined;\n\n  constructor(options: { fromRaw: RawAccount | RawControlledAccount }) {\n    super();\n    if (!(\"fromRaw\" in options)) {\n      throw new Error(\"Can only construct account from raw or with .create()\");\n    }\n    this.isLocalNodeOwner =\n      options.fromRaw.id == options.fromRaw.core.node.account.id;\n\n    Object.defineProperties(this, {\n      id: {\n        value: options.fromRaw.id,\n        enumerable: false,\n      },\n      _raw: { value: options.fromRaw, enumerable: false },\n      _type: { value: \"Account\", enumerable: false },\n    });\n\n    if (this.isLocalNodeOwner) {\n      this.sessionID = options.fromRaw.core.node.currentSessionID;\n    }\n\n    return new Proxy(this, AccountAndGroupProxyHandler as ProxyHandler<this>);\n  }\n\n  myRole(): \"admin\" | undefined {\n    if (this.isLocalNodeOwner) {\n      return \"admin\";\n    }\n  }\n\n  getRoleOf(member: Everyone | ID<Account> | \"me\") {\n    if (member === \"me\") {\n      return this.isMe ? \"admin\" : undefined;\n    }\n\n    if (member === this.id) {\n      return \"admin\";\n    }\n\n    return undefined;\n  }\n\n  getParentGroups(): Array<Group> {\n    return [];\n  }\n\n  get members(): Array<{\n    id: ID<RegisteredAccount> | \"everyone\";\n    role: Role;\n    ref: Ref<RegisteredAccount> | undefined;\n    account: RegisteredAccount | null | undefined;\n  }> {\n    const ref = new Ref<RegisteredAccount>(this.id, this._loadedAs, {\n      ref: () => this.constructor as typeof Account,\n      optional: false,\n    });\n\n    return [{ id: this.id, role: \"admin\", ref, account: this }];\n  }\n\n  canRead(value: CoValue) {\n    const role = value._owner.getRoleOf(this.id);\n\n    return (\n      role === \"admin\" ||\n      role === \"writer\" ||\n      role === \"reader\" ||\n      role === \"writeOnly\"\n    );\n  }\n\n  canWrite(value: CoValue) {\n    const role = value._owner.getRoleOf(this.id);\n\n    return role === \"admin\" || role === \"writer\" || role === \"writeOnly\";\n  }\n\n  canAdmin(value: CoValue) {\n    return value._owner.getRoleOf(this.id) === \"admin\";\n  }\n\n  async acceptInvite<V extends CoValue>(\n    valueID: ID<V>,\n    inviteSecret: InviteSecret,\n    coValueClass: CoValueClass<V>,\n  ): Promise<Resolved<V, true> | null> {\n    if (!this.isLocalNodeOwner) {\n      throw new Error(\"Only a controlled account can accept invites\");\n    }\n\n    await (this._raw as RawControlledAccount).acceptInvite(\n      valueID as unknown as CoID<RawCoValue>,\n      inviteSecret,\n    );\n\n    return loadCoValue(coValueClass, valueID, {\n      loadAs: this,\n    });\n  }\n\n  /** @private */\n  static async create<A extends Account>(\n    this: CoValueClass<A> & typeof Account,\n    options: {\n      creationProps: { name: string };\n      initialAgentSecret?: AgentSecret;\n      peersToLoadFrom?: Peer[];\n      crypto: CryptoProvider;\n    },\n  ): Promise<A> {\n    const { node } = await LocalNode.withNewlyCreatedAccount({\n      ...options,\n      migration: async (rawAccount, _node, creationProps) => {\n        const account = new this({\n          fromRaw: rawAccount,\n        }) as A;\n\n        await account.applyMigration?.(creationProps);\n      },\n    });\n\n    return this.fromNode(node) as A;\n  }\n\n  static getMe<A extends Account>(this: CoValueClass<A> & typeof Account) {\n    return activeAccountContext.get() as A;\n  }\n\n  static async createAs<A extends Account>(\n    this: CoValueClass<A> & typeof Account,\n    as: Account,\n    options: {\n      creationProps: { name: string };\n    },\n  ) {\n    // TODO: is there a cleaner way to do this?\n    const connectedPeers = cojsonInternals.connectedPeers(\n      \"creatingAccount\",\n      \"createdAccount\",\n      { peer1role: \"server\", peer2role: \"client\" },\n    );\n\n    as._raw.core.node.syncManager.addPeer(connectedPeers[1]);\n\n    const account = await this.create<A>({\n      creationProps: options.creationProps,\n      crypto: as._raw.core.node.crypto,\n      peersToLoadFrom: [connectedPeers[0]],\n    });\n\n    await account.waitForAllCoValuesSync();\n\n    return account;\n  }\n\n  static fromNode<A extends Account>(\n    this: CoValueClass<A>,\n    node: LocalNode,\n  ): A {\n    return new this({\n      fromRaw: node.account as RawControlledAccount,\n    }) as A;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): object | any[] {\n    return {\n      id: this.id,\n      _type: this._type,\n    };\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  async applyMigration(creationProps?: AccountCreationProps) {\n    await this.migrate(creationProps);\n\n    // if the user has not defined a profile themselves, we create one\n    if (this.profile === undefined && creationProps) {\n      const profileGroup = RegisteredSchemas[\"Group\"].create({ owner: this });\n\n      this.profile = Profile.create({ name: creationProps.name }, profileGroup);\n      this.profile._owner.addMember(\"everyone\", \"reader\");\n    } else if (this.profile && creationProps) {\n      if (this.profile._owner._type !== \"Group\") {\n        throw new Error(\"Profile must be owned by a Group\", {\n          cause: `The profile of the account \"${this.id}\" was created with an Account as owner, which is not allowed.`,\n        });\n      }\n    }\n\n    const node = this._raw.core.node;\n    const profile = node\n      .expectCoValueLoaded(this._raw.get(\"profile\")!)\n      .getCurrentContent() as RawCoMap;\n\n    if (!profile.get(\"inbox\")) {\n      const inboxRoot = createInboxRoot(this);\n      profile.set(\"inbox\", inboxRoot.id);\n      profile.set(\"inboxInvite\", inboxRoot.inviteLink);\n    }\n  }\n\n  // Placeholder method for subclasses to override\n  migrate(creationProps?: AccountCreationProps) {\n    creationProps; // To avoid unused parameter warning\n  }\n\n  /** @category Subscription & Loading */\n  static load<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    options?: {\n      resolve?: RefsToResolveStrict<A, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<A, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /** @category Subscription & Loading */\n  static subscribe<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    options: SubscribeListenerOptions<A, R>,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    ...args: SubscribeRestArgs<A, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<A, R>(this, id, options, listener);\n  }\n\n  /** @category Subscription & Loading */\n  ensureLoaded<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    options: { resolve: RefsToResolveStrict<A, R> },\n  ): Promise<Resolved<A, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /** @category Subscription & Loading */\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    options: { resolve?: RefsToResolveStrict<A, R> },\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    ...args: SubscribeRestArgs<A, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `Account` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.waitForSync(options);\n  }\n\n  /**\n   * Wait for all the available `CoValues` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForAllCoValuesSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.node.syncManager.waitForAllCoValuesSync(\n      options?.timeout,\n    );\n  }\n}\n\nexport const AccountAndGroupProxyHandler: ProxyHandler<Account | Group> = {\n  get(target, key, receiver) {\n    if (key === \"profile\") {\n      const ref = target._refs.profile;\n      return ref\n        ? ref.accessFrom(receiver, \"profile\")\n        : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (undefined as any);\n    } else if (key === \"root\") {\n      const ref = target._refs.root;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return ref ? ref.accessFrom(receiver, \"root\") : (undefined as any);\n    } else {\n      return Reflect.get(target, key, receiver);\n    }\n  },\n  set(target, key, value, receiver) {\n    if (\n      (key === \"profile\" || key === \"root\") &&\n      typeof value === \"object\" &&\n      SchemaInit in value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] = value[SchemaInit];\n      return true;\n    } else if (key === \"profile\") {\n      if (value) {\n        target._raw.set(\n          \"profile\",\n          value.id as unknown as CoID<RawCoMap>,\n          \"trusting\",\n        );\n      }\n      subscriptionsScopes\n        .get(receiver)\n        ?.onRefAccessedOrSet(target.id, value.id);\n      return true;\n    } else if (key === \"root\") {\n      if (value) {\n        target._raw.set(\"root\", value.id as unknown as CoID<RawCoMap>);\n      }\n      subscriptionsScopes\n        .get(receiver)\n        ?.onRefAccessedOrSet(target.id, value.id);\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    if (\n      (key === \"profile\" || key === \"root\") &&\n      typeof descriptor.value === \"object\" &&\n      SchemaInit in descriptor.value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] =\n        descriptor.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, descriptor);\n    }\n  },\n};\n\n/** @category Identity & Permissions */\nexport function isControlledAccount(account: Account): account is Account & {\n  isLocalNodeOwner: true;\n  sessionID: SessionID;\n  _raw: RawControlledAccount;\n} {\n  return account.isLocalNodeOwner;\n}\n\nexport type AccountClass<Acc extends Account> = CoValueClass<Acc> & {\n  fromNode: (typeof Account)[\"fromNode\"];\n};\n\nRegisteredSchemas[\"Account\"] = Account;\n", "/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport type {\n  AgentID,\n  BinaryStreamInfo,\n  CojsonInternalTypes,\n  JsonValue,\n  RawAccountID,\n  RawBinaryCoStream,\n  RawCoStream,\n  SessionID,\n} from \"cojson\";\nimport { MAX_RECOMMENDED_TX_SIZE, cojsonInternals } from \"cojson\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  ID,\n  IfCo,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SchemaFor,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  UnCo,\n} from \"../internal.js\";\nimport {\n  CoValueBase,\n  ItemsSym,\n  Ref,\n  SchemaInit,\n  co,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { type Account } from \"./account.js\";\nimport { type Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\n/** @deprecated Use CoFeedEntry instead */\nexport type CoStreamEntry<Item> = CoFeedEntry<Item>;\n\nexport type CoFeedEntry<Item> = SingleCoFeedEntry<Item> & {\n  all: IterableIterator<SingleCoFeedEntry<Item>>;\n};\n\n/** @deprecated Use SingleCoFeedEntry instead */\nexport type SingleCoStreamEntry<Item> = SingleCoFeedEntry<Item>;\n\nexport type SingleCoFeedEntry<Item> = {\n  value: NonNullable<Item> extends CoValue ? NonNullable<Item> | null : Item;\n  ref: NonNullable<Item> extends CoValue ? Ref<NonNullable<Item>> : never;\n  by?: RegisteredAccount | null;\n  madeAt: Date;\n  tx: CojsonInternalTypes.TransactionID;\n};\n\n/** @deprecated Use CoFeed instead */\nexport { CoFeed as CoStream };\n\n/**\n * CoFeeds are collaborative logs of data.\n *\n * @categoryDescription Content\n * They are similar to `CoList`s, but with a few key differences:\n * - They are append-only\n * - They consist of several internal append-only logs, one per account session (tab, device, app instance, etc.)\n * - They expose those as a per-account aggregated view (default) or a precise per-session view\n *\n * ```ts\n * favDog.push(\"Poodle\");\n * favDog.push(\"Schnowzer\");\n * ```\n *\n * @category CoValues\n */\nexport class CoFeed<Item = any> extends CoValueBase implements CoValue {\n  /**\n   * Declare a `CoFeed` by subclassing `CoFeed.Of(...)` and passing the item schema using a `co` primitive or a `co.ref`.\n   *\n   * @example\n   * ```ts\n   * class ColorFeed extends CoFeed.Of(co.string) {}\n   * class AnimalFeed extends CoFeed.Of(co.ref(Animal)) {}\n   * ```\n   *\n   * @category Declaration\n   */\n  static Of<Item>(item: IfCo<Item, Item>): typeof CoFeed<Item> {\n    return class CoFeedOf extends CoFeed<Item> {\n      [co.items] = item;\n    };\n  }\n\n  /**\n   * The ID of this `CoFeed`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoStream\";\n  static {\n    this.prototype._type = \"CoStream\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoStream;\n\n  /** @internal This is only a marker type and doesn't exist at runtime */\n  [ItemsSym]!: Item;\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema(): {\n    [ItemsSym]: SchemaFor<Item>;\n  } {\n    return (this.constructor as typeof CoFeed)._schema;\n  }\n\n  /**\n   * The per-account view of this `CoFeed`\n   *\n   * @example\n   * ```ts\n   * // Access entries directly by account ID\n   * const aliceEntries = feed[aliceAccount.id];\n   * console.log(aliceEntries.value); // Latest value from Alice\n   *\n   * // Iterate through all accounts' entries\n   * for (const [accountId, entries] of Object.entries(feed)) {\n   *   console.log(`Latest entry from ${accountId}:`, entries.value);\n   *\n   *   // Access all entries from this account\n   *   for (const entry of entries.all) {\n   *     console.log(`Entry made at ${entry.madeAt}:`, entry.value);\n   *   }\n   * }\n   * ```\n   *\n   * @category Content\n   */\n  [key: ID<Account>]: CoFeedEntry<Item>;\n\n  /**\n   * The current account's view of this `CoFeed`\n   * @category Content\n   */\n  get byMe(): CoFeedEntry<Item> | undefined {\n    if (this._loadedAs._type === \"Account\") {\n      return this[this._loadedAs.id];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * The per-session view of this `CoFeed`\n   * @category Content\n   */\n  perSession!: {\n    [key: SessionID]: CoFeedEntry<Item>;\n  };\n\n  /**\n   * The current session's view of this `CoFeed`\n   *\n   * This is a shortcut for `this.perSession` where the session ID is the current session ID.\n   *\n   * @category Content\n   */\n  get inCurrentSession(): CoFeedEntry<Item> | undefined {\n    if (this._loadedAs._type === \"Account\") {\n      return this.perSession[this._loadedAs.sessionID!];\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(\n    options:\n      | { init: Item[]; owner: Account | Group }\n      | { fromRaw: RawCoStream },\n  ) {\n    super();\n\n    if (options && \"fromRaw\" in options) {\n      Object.defineProperties(this, {\n        id: {\n          value: options.fromRaw.id,\n          enumerable: false,\n        },\n        _raw: { value: options.fromRaw, enumerable: false },\n      });\n    }\n\n    return new Proxy(this, CoStreamProxyHandler as ProxyHandler<this>);\n  }\n\n  /**\n   * Create a new `CoFeed`\n   * @category Creation\n   */\n  static create<S extends CoFeed>(\n    this: CoValueClass<S>,\n    init: S extends CoFeed<infer Item> ? UnCo<Item>[] : never,\n    options?: { owner: Account | Group } | Account | Group,\n  ) {\n    const { owner } = parseCoValueCreateOptions(options);\n    const instance = new this({ init, owner });\n    const raw = owner._raw.createStream();\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    if (init) {\n      instance.push(...init);\n    }\n    return instance;\n  }\n\n  /**\n   * Push items to this `CoFeed`\n   *\n   * Items are appended to the current session's log. Each session (tab, device, app instance)\n   * maintains its own append-only log, which is then aggregated into the per-account view.\n   *\n   * @example\n   * ```ts\n   * // Adds items to current session's log\n   * feed.push(\"item1\", \"item2\");\n   *\n   * // View items from current session\n   * console.log(feed.inCurrentSession);\n   *\n   * // View aggregated items from all sessions for current account\n   * console.log(feed.byMe);\n   * ```\n   *\n   * @category Content\n   */\n  push(...items: Item[]) {\n    for (const item of items) {\n      this.pushItem(item);\n    }\n  }\n\n  private pushItem(item: Item) {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n\n    if (itemDescriptor === \"json\") {\n      this._raw.push(item as JsonValue);\n    } else if (\"encoded\" in itemDescriptor) {\n      this._raw.push(itemDescriptor.encoded.encode(item));\n    } else if (isRefEncoded(itemDescriptor)) {\n      this._raw.push((item as unknown as CoValue).id);\n    }\n  }\n\n  /**\n   * Get a JSON representation of the `CoFeed`\n   * @category\n   */\n  toJSON(): {\n    id: string;\n    _type: \"CoStream\";\n    [key: string]: unknown;\n    in: { [key: string]: unknown };\n  } {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n    const mapper =\n      itemDescriptor === \"json\"\n        ? (v: unknown) => v\n        : \"encoded\" in itemDescriptor\n          ? itemDescriptor.encoded.encode\n          : (v: unknown) => v && (v as CoValue).id;\n\n    return {\n      id: this.id,\n      _type: this._type,\n      ...Object.fromEntries(\n        Object.entries(this).map(([account, entry]) => [\n          account,\n          mapper(entry.value),\n        ]),\n      ),\n      in: Object.fromEntries(\n        Object.entries(this.perSession).map(([session, entry]) => [\n          session,\n          mapper(entry.value),\n        ]),\n      ),\n    };\n  }\n\n  /** @internal */\n  [inspect](): {\n    id: string;\n    _type: \"CoStream\";\n    [key: string]: unknown;\n    in: { [key: string]: unknown };\n  } {\n    return this.toJSON();\n  }\n\n  /** @internal */\n  static schema<V extends CoFeed>(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this: { new (...args: any): V } & typeof CoFeed,\n    def: { [ItemsSym]: V[\"_schema\"][ItemsSym] },\n  ) {\n    this._schema ||= {};\n    Object.assign(this._schema, def);\n  }\n\n  /**\n   * Load a `CoFeed`\n   * @category Subscription & Loading\n   */\n  static load<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: {\n      resolve?: RefsToResolveStrict<F, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<F, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Subscribe to a `CoFeed`, when you have an ID but don't have a `CoFeed` instance yet\n   * @category Subscription & Loading\n   */\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: SubscribeListenerOptions<F, R>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<F, R>(this, id, options, listener);\n  }\n\n  /**\n   * Ensure a `CoFeed` is loaded to the specified depth\n   *\n   * @returns A new instance of the same CoFeed that's loaded to the specified depth\n   * @category Subscription & Loading\n   */\n  ensureLoaded<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    options?: { resolve?: RefsToResolveStrict<F, R> },\n  ): Promise<Resolved<F, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * An instance method to subscribe to an existing `CoFeed`\n   *\n   * No need to provide an ID or Account since they're already part of the instance.\n   * @category Subscription & Loading\n   */\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    options: { resolve?: RefsToResolveStrict<F, R> },\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `CoFeed` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\n/**\n * Converts a raw stream entry into a formatted CoFeed entry with proper typing and accessors.\n * @internal\n */\nfunction entryFromRawEntry<Item>(\n  accessFrom: CoValue,\n  rawEntry: {\n    by: RawAccountID | AgentID;\n    tx: CojsonInternalTypes.TransactionID;\n    at: Date;\n    value: JsonValue;\n  },\n  loadedAs: Account | AnonymousJazzAgent,\n  accountID: ID<Account> | undefined,\n  itemField: Schema,\n): Omit<CoFeedEntry<Item>, \"all\"> {\n  return {\n    get value(): NonNullable<Item> extends CoValue\n      ? (CoValue & Item) | null\n      : Item {\n      if (itemField === \"json\") {\n        return rawEntry.value as NonNullable<Item> extends CoValue\n          ? (CoValue & Item) | null\n          : Item;\n      } else if (\"encoded\" in itemField) {\n        return itemField.encoded.decode(rawEntry.value);\n      } else if (isRefEncoded(itemField)) {\n        return this.ref?.accessFrom(\n          accessFrom,\n          rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + \".value\",\n        ) as NonNullable<Item> extends CoValue ? (CoValue & Item) | null : Item;\n      } else {\n        throw new Error(\"Invalid item field schema\");\n      }\n    },\n    get ref(): NonNullable<Item> extends CoValue\n      ? Ref<NonNullable<Item>>\n      : never {\n      if (itemField !== \"json\" && isRefEncoded(itemField)) {\n        const rawId = rawEntry.value;\n        return new Ref(\n          rawId as unknown as ID<CoValue>,\n          loadedAs,\n          itemField,\n        ) as NonNullable<Item> extends CoValue ? Ref<NonNullable<Item>> : never;\n      } else {\n        return undefined as never;\n      }\n    },\n    get by() {\n      return (\n        accountID &&\n        new Ref<Account>(accountID as unknown as ID<Account>, loadedAs, {\n          ref: RegisteredSchemas[\"Account\"],\n          optional: false,\n        })?.accessFrom(\n          accessFrom,\n          rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + \".by\",\n        )\n      );\n    },\n    madeAt: rawEntry.at,\n    tx: rawEntry.tx,\n  };\n}\n\n/**\n * The proxy handler for `CoFeed` instances\n * @internal\n */\nexport const CoStreamProxyHandler: ProxyHandler<CoFeed> = {\n  get(target, key, receiver) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      const rawEntry = target._raw.lastItemBy(key as RawAccountID);\n\n      if (!rawEntry) return;\n      const entry = entryFromRawEntry(\n        receiver,\n        rawEntry,\n        target._loadedAs,\n        key as unknown as ID<Account>,\n        target._schema[ItemsSym],\n      );\n\n      Object.defineProperty(entry, \"all\", {\n        get: () => {\n          const allRawEntries = target._raw.itemsBy(key as RawAccountID);\n          return (function* () {\n            while (true) {\n              const rawEntry = allRawEntries.next();\n              if (rawEntry.done) return;\n              yield entryFromRawEntry(\n                receiver,\n                rawEntry.value,\n                target._loadedAs,\n                key as unknown as ID<Account>,\n                target._schema[ItemsSym],\n              );\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          })() satisfies IterableIterator<SingleCoFeedEntry<any>>;\n        },\n      });\n\n      return entry;\n    } else if (key === \"perSession\") {\n      return new Proxy({}, CoStreamPerSessionProxyHandler(target, receiver));\n    } else {\n      return Reflect.get(target, key, receiver);\n    }\n  },\n  set(target, key, value, receiver) {\n    if (key === ItemsSym && typeof value === \"object\" && SchemaInit in value) {\n      (target.constructor as typeof CoFeed)._schema ||= {};\n      (target.constructor as typeof CoFeed)._schema[ItemsSym] =\n        value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    if (\n      descriptor.value &&\n      key === ItemsSym &&\n      typeof descriptor.value === \"object\" &&\n      SchemaInit in descriptor.value\n    ) {\n      (target.constructor as typeof CoFeed)._schema ||= {};\n      (target.constructor as typeof CoFeed)._schema[ItemsSym] =\n        descriptor.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, descriptor);\n    }\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target);\n\n    for (const accountID of target._raw.accounts()) {\n      keys.push(accountID);\n    }\n\n    return keys;\n  },\n  getOwnPropertyDescriptor(target, key) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      return {\n        configurable: true,\n        enumerable: true,\n        writable: false,\n      };\n    } else {\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    }\n  },\n};\n\n/**\n * The proxy handler for the per-session view of a `CoFeed`\n * @internal\n */\nconst CoStreamPerSessionProxyHandler = (\n  innerTarget: CoFeed,\n  accessFrom: CoFeed,\n): ProxyHandler<Record<string, never>> => ({\n  get(_target, key, receiver) {\n    if (typeof key === \"string\" && key.includes(\"session\")) {\n      const sessionID = key as SessionID;\n      const rawEntry = innerTarget._raw.lastItemIn(sessionID);\n\n      if (!rawEntry) return;\n      const by = cojsonInternals.accountOrAgentIDfromSessionID(sessionID);\n\n      const entry = entryFromRawEntry(\n        accessFrom,\n        rawEntry,\n        innerTarget._loadedAs,\n        cojsonInternals.isAccountID(by)\n          ? (by as unknown as ID<Account>)\n          : undefined,\n        innerTarget._schema[ItemsSym],\n      );\n\n      Object.defineProperty(entry, \"all\", {\n        get: () => {\n          const allRawEntries = innerTarget._raw.itemsIn(sessionID);\n          return (function* () {\n            while (true) {\n              const rawEntry = allRawEntries.next();\n              if (rawEntry.done) return;\n              yield entryFromRawEntry(\n                accessFrom,\n                rawEntry.value,\n                innerTarget._loadedAs,\n                cojsonInternals.isAccountID(by)\n                  ? (by as unknown as ID<Account>)\n                  : undefined,\n                innerTarget._schema[ItemsSym],\n              );\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          })() satisfies IterableIterator<SingleCoFeedEntry<any>>;\n        },\n      });\n\n      return entry;\n    } else {\n      return Reflect.get(innerTarget, key, receiver);\n    }\n  },\n  ownKeys() {\n    return innerTarget._raw.sessions();\n  },\n  getOwnPropertyDescriptor(target, key) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      return {\n        configurable: true,\n        enumerable: true,\n        writable: false,\n      };\n    } else {\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    }\n  },\n});\n\n/** @deprecated Use FileStream instead */\nexport { FileStream as BinaryCoStream };\n\n/**\n * FileStreams are `CoFeed`s that contain binary data, collaborative versions of `Blob`s.\n *\n * @categoryDescription Declaration\n * `FileStream` can be referenced in schemas.\n *\n * ```ts\n * import { co, FileStream } from \"jazz-tools\";\n *\n * class MyCoMap extends CoMap {\n *   file = co.ref(FileStream);\n * }\n * ```\n *\n * @category CoValues\n */\nexport class FileStream extends CoValueBase implements CoValue {\n  /**\n   * The ID of this `FileStream`\n   * @category Content\n   */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"BinaryCoStream\";\n  /** @internal */\n  declare _raw: RawBinaryCoStream;\n\n  constructor(\n    options:\n      | {\n          owner: Account | Group;\n        }\n      | {\n          fromRaw: RawBinaryCoStream;\n        },\n  ) {\n    super();\n\n    let raw: RawBinaryCoStream;\n\n    if (\"fromRaw\" in options) {\n      raw = options.fromRaw;\n    } else {\n      const rawOwner = options.owner._raw;\n      raw = rawOwner.createBinaryStream();\n    }\n\n    Object.defineProperties(this, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _type: { value: \"BinaryCoStream\", enumerable: false },\n      _raw: { value: raw, enumerable: false },\n    });\n  }\n\n  /**\n   * Create a new empty `FileStream` instance.\n   *\n   * @param options - Configuration options for the new FileStream\n   * @param options.owner - The Account or Group that will own this FileStream and control access rights\n   *\n   * @example\n   * ```typescript\n   * // Create owned by an account\n   * const stream = FileStream.create({ owner: myAccount });\n   *\n   * // Create owned by a group\n   * const stream = FileStream.create({ owner: teamGroup });\n   *\n   * // Create with implicit owner\n   * const stream = FileStream.create(myAccount);\n   * ```\n   *\n   * @remarks\n   * For uploading an existing file or blob, use {@link FileStream.createFromBlob} instead.\n   *\n   * @category Creation\n   */\n  static create<S extends FileStream>(\n    this: CoValueClass<S>,\n    options?: { owner?: Account | Group } | Account | Group,\n  ) {\n    return new this(parseCoValueCreateOptions(options));\n  }\n\n  getChunks(options?: {\n    allowUnfinished?: boolean;\n  }):\n    | (BinaryStreamInfo & { chunks: Uint8Array[]; finished: boolean })\n    | undefined {\n    return this._raw.getBinaryChunks(options?.allowUnfinished);\n  }\n\n  isBinaryStreamEnded(): boolean {\n    return this._raw.isBinaryStreamEnded();\n  }\n\n  start(options: BinaryStreamInfo): void {\n    this._raw.startBinaryStream(options);\n  }\n\n  push(data: Uint8Array): void {\n    this._raw.pushBinaryStreamChunk(data);\n  }\n\n  end(): void {\n    this._raw.endBinaryStream();\n  }\n\n  toBlob(options?: { allowUnfinished?: boolean }): Blob | undefined {\n    const chunks = this.getChunks({\n      allowUnfinished: options?.allowUnfinished,\n    });\n\n    if (!chunks) {\n      return undefined;\n    }\n\n    // @ts-ignore\n    return new Blob(chunks.chunks, { type: chunks.mimeType });\n  }\n\n  /**\n   * Load a `FileStream` as a `Blob`\n   *\n   * @category Content\n   */\n  static async loadAsBlob(\n    id: ID<FileStream>,\n    options?: {\n      allowUnfinished?: boolean;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Blob | undefined> {\n    let stream = await this.load(id, options);\n\n    /**\n     * If the user hasn't requested an incomplete blob and the\n     * stream isn't complete wait for the stream download before progressing\n     */\n    if (!options?.allowUnfinished && !stream?.isBinaryStreamEnded()) {\n      stream = await new Promise<FileStream>((resolve) => {\n        subscribeToCoValueWithoutMe(\n          this,\n          id,\n          options || {},\n          (value, unsubscribe) => {\n            if (value.isBinaryStreamEnded()) {\n              unsubscribe();\n              resolve(value);\n            }\n          },\n        );\n      });\n    }\n\n    return stream?.toBlob({\n      allowUnfinished: options?.allowUnfinished,\n    });\n  }\n\n  /**\n   * Create a `FileStream` from a `Blob` or `File`\n   *\n   * @example\n   * ```ts\n   * import { co, FileStream } from \"jazz-tools\";\n   *\n   * const fileStream = await FileStream.createFromBlob(file, {owner: group})\n   * ```\n   * @category Content\n   */\n  static async createFromBlob(\n    blob: Blob | File,\n    options?:\n      | {\n          owner?: Group | Account;\n          onProgress?: (progress: number) => void;\n        }\n      | Account\n      | Group,\n  ): Promise<FileStream> {\n    const stream = this.create(options);\n    const onProgress =\n      options && \"onProgress\" in options ? options.onProgress : undefined;\n\n    const start = Date.now();\n\n    const data = new Uint8Array(await blob.arrayBuffer());\n    stream.start({\n      mimeType: blob.type,\n      totalSizeBytes: blob.size,\n      fileName: blob instanceof File ? blob.name : undefined,\n    });\n    const chunkSize = MAX_RECOMMENDED_TX_SIZE;\n\n    let lastProgressUpdate = Date.now();\n\n    for (let idx = 0; idx < data.length; idx += chunkSize) {\n      stream.push(data.slice(idx, idx + chunkSize));\n\n      if (Date.now() - lastProgressUpdate > 100) {\n        onProgress?.(idx / data.length);\n        lastProgressUpdate = Date.now();\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 0));\n    }\n    stream.end();\n    const end = Date.now();\n\n    console.debug(\n      \"Finished creating binary stream in\",\n      (end - start) / 1000,\n      \"s - Throughput in MB/s\",\n      (1000 * (blob.size / (end - start))) / (1024 * 1024),\n    );\n    onProgress?.(1);\n\n    return stream;\n  }\n\n  /**\n   * Get a JSON representation of the `FileStream`\n   * @category Content\n   */\n  toJSON(): {\n    id: string;\n    _type: \"BinaryCoStream\";\n    mimeType?: string;\n    totalSizeBytes?: number;\n    fileName?: string;\n    chunks?: Uint8Array[];\n    finished?: boolean;\n  } {\n    return {\n      id: this.id,\n      _type: this._type,\n      ...this.getChunks(),\n    };\n  }\n\n  /** @internal */\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /**\n   * Load a `FileStream`\n   * @category Subscription & Loading\n   */\n  static load<C extends FileStream>(\n    this: CoValueClass<C>,\n    id: ID<C>,\n    options?: { loadAs?: Account | AnonymousJazzAgent },\n  ): Promise<Resolved<C, true> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Subscribe to a `FileStream`, when you have an ID but don't have a `FileStream` instance yet\n   * @category Subscription & Loading\n   */\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: SubscribeListenerOptions<F, R>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<F, R>(this, id, options, listener);\n  }\n\n  /**\n   * An instance method to subscribe to an existing `FileStream`\n   * @category Subscription & Loading\n   */\n  subscribe<B extends FileStream>(\n    this: B,\n    listener: (value: Resolved<B, true>) => void,\n  ): () => void {\n    return subscribeToExistingCoValue(this, {}, listener);\n  }\n\n  /**\n   * Wait for the `FileStream` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n", "import type { JsonValue, RawCoList } from \"cojson\";\nimport { RawAccount } from \"cojson\";\nimport { calcPatch } from \"fast-myers-diff\";\nimport type {\n  CoValue,\n  CoValueClass,\n  CoValueFromRaw,\n  ID,\n  RefEncoded,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SchemaFor,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  UnCo,\n} from \"../internal.js\";\nimport {\n  AnonymousJazzAgent,\n  ItemsSym,\n  Ref,\n  SchemaInit,\n  co,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  makeRefs,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { type Account } from \"./account.js\";\nimport { type Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\n/**\n * CoLists are collaborative versions of plain arrays.\n *\n * @categoryDescription Content\n * You can access items on a `CoList` as if they were normal items on a plain array, using `[]` notation, etc.\n *\n * Since `CoList` is a subclass of `Array`, you can use all the normal array methods like `push`, `pop`, `splice`, etc.\n *\n * ```ts\n * colorList[0];\n * colorList[3] = \"yellow\";\n * colorList.push(\"Kawazaki Green\");\n * colorList.splice(1, 1);\n * ```\n *\n * @category CoValues\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class CoList<Item = any> extends Array<Item> implements CoValue {\n  /**\n   * Declare a `CoList` by subclassing `CoList.Of(...)` and passing the item schema using `co`.\n   *\n   * @example\n   * ```ts\n   * class ColorList extends CoList.Of(\n   *   co.string\n   * ) {}\n   * class AnimalList extends CoList.Of(\n   *   co.ref(Animal)\n   * ) {}\n   * ```\n   *\n   * @category Declaration\n   */\n  static Of<Item>(item: Item): typeof CoList<Item> {\n    // TODO: cache superclass for item class\n    return class CoListOf extends CoList<Item> {\n      [co.items] = item;\n    };\n  }\n\n  /**\n   * @ignore\n   * @deprecated Use UPPERCASE `CoList.Of` instead! */\n  static of(..._args: never): never {\n    throw new Error(\"Can't use Array.of with CoLists\");\n  }\n\n  /**\n   * The ID of this `CoList`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoList\";\n  static {\n    this.prototype._type = \"CoList\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoList;\n  /** @category Internals */\n  declare _instanceID: string;\n\n  /** @internal This is only a marker type and doesn't exist at runtime */\n  [ItemsSym]!: Item;\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema(): {\n    [ItemsSym]: SchemaFor<Item>;\n  } {\n    return (this.constructor as typeof CoList)._schema;\n  }\n\n  /** @category Collaboration */\n  get _owner(): Account | Group {\n    return this._raw.group instanceof RawAccount\n      ? RegisteredSchemas[\"Account\"].fromRaw(this._raw.group)\n      : RegisteredSchemas[\"Group\"].fromRaw(this._raw.group);\n  }\n\n  /**\n   * If a `CoList`'s items are a `co.ref(...)`, you can use `coList._refs[i]` to access\n   * the `Ref` instead of the potentially loaded/null value.\n   *\n   * This allows you to always get the ID or load the value manually.\n   *\n   * @example\n   * ```ts\n   * animals._refs[0].id; // => ID<Animal>\n   * animals._refs[0].value;\n   * // => Animal | null\n   * const animal = await animals._refs[0].load();\n   * ```\n   *\n   * @category Content\n   **/\n  get _refs(): {\n    [idx: number]: Exclude<Item, null> extends CoValue\n      ? Ref<UnCo<Exclude<Item, null>>>\n      : never;\n  } & {\n    length: number;\n    [Symbol.iterator](): IterableIterator<\n      Exclude<Item, null> extends CoValue ? Ref<Exclude<Item, null>> : never\n    >;\n  } {\n    return makeRefs<number>(\n      (idx) => this._raw.get(idx) as unknown as ID<CoValue>,\n      () => Array.from({ length: this._raw.entries().length }, (_, idx) => idx),\n      this._loadedAs,\n      (_idx) => this._schema[ItemsSym] as RefEncoded<CoValue>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) as any;\n  }\n\n  get _edits(): {\n    [idx: number]: {\n      value?: Item;\n      ref?: Item extends CoValue ? Ref<Item> : never;\n      by?: RegisteredAccount;\n      madeAt: Date;\n    };\n  } {\n    throw new Error(\"Not implemented\");\n  }\n\n  get _loadedAs() {\n    const rawAccount = this._raw.core.node.account;\n\n    if (rawAccount instanceof RawAccount) {\n      return coValuesCache.get(rawAccount, () =>\n        RegisteredSchemas[\"Account\"].fromRaw(rawAccount),\n      );\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  static get [Symbol.species]() {\n    return Array;\n  }\n\n  constructor(options: { fromRaw: RawCoList } | undefined) {\n    super();\n\n    Object.defineProperty(this, \"_instanceID\", {\n      value: `instance-${Math.random().toString(36).slice(2)}`,\n      enumerable: false,\n    });\n\n    if (options && \"fromRaw\" in options) {\n      Object.defineProperties(this, {\n        id: {\n          value: options.fromRaw.id,\n          enumerable: false,\n        },\n        _raw: { value: options.fromRaw, enumerable: false },\n      });\n    }\n\n    return new Proxy(this, CoListProxyHandler as ProxyHandler<this>);\n  }\n\n  /**\n   * Create a new CoList with the given initial values and owner.\n   *\n   * The owner (a Group or Account) determines access rights to the CoMap.\n   *\n   * The CoList will immediately be persisted and synced to connected peers.\n   *\n   * @example\n   * ```ts\n   * const colours = ColorList.create(\n   *   [\"red\", \"green\", \"blue\"],\n   *   { owner: me }\n   * );\n   * const animals = AnimalList.create(\n   *   [cat, dog, fish],\n   *   { owner: me }\n   * );\n   * ```\n   *\n   * @category Creation\n   **/\n  static create<L extends CoList>(\n    this: CoValueClass<L>,\n    items: UnCo<L[number]>[],\n    options?: { owner: Account | Group } | Account | Group,\n  ) {\n    const { owner } = parseCoValueCreateOptions(options);\n    const instance = new this({ init: items, owner });\n    const raw = owner._raw.createList(\n      toRawItems(items, instance._schema[ItemsSym]),\n    );\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    return instance;\n  }\n\n  push(...items: Item[]): number {\n    this._raw.appendItems(\n      toRawItems(items, this._schema[ItemsSym]),\n      undefined,\n      \"private\",\n    );\n\n    return this._raw.entries().length;\n  }\n\n  unshift(...items: Item[]): number {\n    for (const item of toRawItems(items as Item[], this._schema[ItemsSym])) {\n      this._raw.prepend(item);\n    }\n\n    return this._raw.entries().length;\n  }\n\n  pop(): Item | undefined {\n    const last = this[this.length - 1];\n\n    this._raw.delete(this.length - 1);\n\n    return last;\n  }\n\n  shift(): Item | undefined {\n    const first = this[0];\n\n    this._raw.delete(0);\n\n    return first;\n  }\n\n  /**\n   * Splice the `CoList` at a given index.\n   *\n   * @param start - The index to start the splice.\n   * @param deleteCount - The number of items to delete.\n   * @param items - The items to insert.\n   */\n  splice(start: number, deleteCount: number, ...items: Item[]): Item[] {\n    const deleted = this.slice(start, start + deleteCount);\n\n    for (\n      let idxToDelete = start + deleteCount - 1;\n      idxToDelete >= start;\n      idxToDelete--\n    ) {\n      this._raw.delete(idxToDelete);\n    }\n\n    const rawItems = toRawItems(items as Item[], this._schema[ItemsSym]);\n\n    // If there are no items to insert, return the deleted items\n    if (rawItems.length === 0) {\n      return deleted;\n    }\n\n    // Fast path for single item insertion\n    if (rawItems.length === 1) {\n      const item = rawItems[0];\n      if (item === undefined) return deleted;\n      if (start === 0) {\n        this._raw.prepend(item);\n      } else {\n        this._raw.append(item, Math.max(start - 1, 0));\n      }\n      return deleted;\n    }\n\n    // Handle multiple items\n    if (start === 0) {\n      // Iterate in reverse order without creating a new array\n      for (let i = rawItems.length - 1; i >= 0; i--) {\n        const item = rawItems[i];\n        if (item === undefined) continue;\n        this._raw.prepend(item);\n      }\n    } else {\n      let appendAfter = Math.max(start - 1, 0);\n      for (const item of rawItems) {\n        if (item === undefined) continue;\n        this._raw.append(item, appendAfter);\n        appendAfter++;\n      }\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Modify the `CoList` to match another list, where the changes are managed internally.\n   *\n   * @param result - The resolved list of items.\n   */\n  applyDiff(result: Item[]) {\n    const current = this._raw.asArray() as Item[];\n    const comparator = isRefEncoded(this._schema[ItemsSym])\n      ? (aIdx: number, bIdx: number) => {\n          return (\n            (current[aIdx] as CoValue)?.id === (result[bIdx] as CoValue)?.id\n          );\n        }\n      : undefined;\n\n    const patches = [...calcPatch(current, result, comparator)];\n    for (const [from, to, insert] of patches.reverse()) {\n      this.splice(from, to - from, ...insert);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(_key?: string, seenAbove?: ID<CoValue>[]): any[] {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n    if (itemDescriptor === \"json\") {\n      return this._raw.asArray();\n    } else if (\"encoded\" in itemDescriptor) {\n      return this._raw.asArray().map((e) => itemDescriptor.encoded.encode(e));\n    } else if (isRefEncoded(itemDescriptor)) {\n      return this.map((item, idx) =>\n        seenAbove?.includes((item as CoValue)?.id)\n          ? { _circular: (item as CoValue).id }\n          : (item as unknown as CoValue)?.toJSON(idx + \"\", [\n              ...(seenAbove || []),\n              this.id,\n            ]),\n      );\n    } else {\n      return [];\n    }\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /** @category Internals */\n  static fromRaw<V extends CoList>(\n    this: CoValueClass<V> & typeof CoList,\n    raw: RawCoList,\n  ) {\n    return new this({ fromRaw: raw });\n  }\n\n  /** @internal */\n  static schema<V extends CoList>(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this: { new (...args: any): V } & typeof CoList,\n    def: { [ItemsSym]: V[\"_schema\"][ItemsSym] },\n  ) {\n    this._schema ||= {};\n    Object.assign(this._schema, def);\n  }\n\n  /**\n   * Load a `CoList` with a given ID, as a given account.\n   *\n   * `depth` specifies if item CoValue references should be loaded as well before resolving.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * @example\n   * ```ts\n   * const animalsWithVets =\n   *   await ListOfAnimals.load(\n   *     \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *     me,\n   *     [{ vet: {} }]\n   *   );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static load<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    options?: {\n      resolve?: RefsToResolveStrict<L, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<L, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Load and subscribe to a `CoList` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * `depth` specifies if item CoValue references should be loaded as well before calling `listener` for the first time.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @example\n   * ```ts\n   * const unsub = ListOfAnimals.subscribe(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   me,\n   *   { vet: {} },\n   *   (animalsWithVets) => console.log(animalsWithVets)\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    options: SubscribeListenerOptions<L, R>,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<L extends CoList, const R extends RefsToResolve<L>>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    ...args: SubscribeRestArgs<L, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<L, R>(this, id, options, listener);\n  }\n\n  /**\n   * Given an already loaded `CoList`, ensure that items are loaded to the specified depth.\n   *\n   * Works like `CoList.load()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * @category Subscription & Loading\n   */\n  ensureLoaded<L extends CoList, const R extends RefsToResolve<L>>(\n    this: L,\n    options: { resolve: RefsToResolveStrict<L, R> },\n  ): Promise<Resolved<L, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * Given an already loaded `CoList`, subscribe to updates to the `CoList` and ensure that items are loaded to the specified depth.\n   *\n   * Works like `CoList.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: L,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: L,\n    options: { resolve?: RefsToResolveStrict<L, R> },\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<L extends CoList, const R extends RefsToResolve<L>>(\n    this: L,\n    ...args: SubscribeRestArgs<L, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /** @category Type Helpers */\n  castAs<Cl extends CoValueClass & CoValueFromRaw<CoValue>>(\n    cl: Cl,\n  ): InstanceType<Cl> {\n    const casted = cl.fromRaw(this._raw) as InstanceType<Cl>;\n    const subscriptionScope = subscriptionsScopes.get(this);\n    if (subscriptionScope) {\n      subscriptionsScopes.set(casted, subscriptionScope);\n    }\n    return casted;\n  }\n\n  /**\n   * Wait for the `CoList` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\n/**\n * Convert an array of items to a raw array of items.\n * @param items - The array of items to convert.\n * @param itemDescriptor - The descriptor of the items.\n * @returns The raw array of items.\n */\nfunction toRawItems<Item>(items: Item[], itemDescriptor: Schema) {\n  const rawItems =\n    itemDescriptor === \"json\"\n      ? (items as JsonValue[])\n      : \"encoded\" in itemDescriptor\n        ? items?.map((e) => itemDescriptor.encoded.encode(e))\n        : isRefEncoded(itemDescriptor)\n          ? items?.map((v) => {\n              if (!v) return null;\n\n              return (v as unknown as CoValue).id;\n            })\n          : (() => {\n              throw new Error(\"Invalid element descriptor\");\n            })();\n  return rawItems;\n}\n\nconst CoListProxyHandler: ProxyHandler<CoList> = {\n  get(target, key, receiver) {\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      const itemDescriptor = target._schema[ItemsSym] as Schema;\n      const rawValue = target._raw.get(Number(key));\n      if (itemDescriptor === \"json\") {\n        return rawValue;\n      } else if (\"encoded\" in itemDescriptor) {\n        return rawValue === undefined\n          ? undefined\n          : itemDescriptor.encoded.decode(rawValue);\n      } else if (isRefEncoded(itemDescriptor)) {\n        return rawValue === undefined\n          ? undefined\n          : new Ref(\n              rawValue as unknown as ID<CoValue>,\n              target._loadedAs,\n              itemDescriptor,\n            ).accessFrom(receiver, Number(key));\n      }\n    } else if (key === \"length\") {\n      return target._raw.entries().length;\n    } else {\n      return Reflect.get(target, key, receiver);\n    }\n  },\n  set(target, key, value, receiver) {\n    if (key === ItemsSym && typeof value === \"object\" && SchemaInit in value) {\n      (target.constructor as typeof CoList)._schema ||= {};\n      (target.constructor as typeof CoList)._schema[ItemsSym] =\n        value[SchemaInit];\n      return true;\n    }\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      const itemDescriptor = target._schema[ItemsSym] as Schema;\n      let rawValue;\n      if (itemDescriptor === \"json\") {\n        rawValue = value;\n      } else if (\"encoded\" in itemDescriptor) {\n        rawValue = itemDescriptor.encoded.encode(value);\n      } else if (isRefEncoded(itemDescriptor)) {\n        if (value === null) {\n          if (itemDescriptor.optional) {\n            rawValue = null;\n          } else {\n            throw new Error(`Cannot set required reference ${key} to null`);\n          }\n        } else if (value?.id) {\n          rawValue = value.id;\n        } else {\n          throw new Error(\n            `Cannot set reference ${key} to a non-CoValue. Got ${value}`,\n          );\n        }\n      }\n      target._raw.replace(Number(key), rawValue);\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    if (\n      descriptor.value &&\n      key === ItemsSym &&\n      typeof descriptor.value === \"object\" &&\n      SchemaInit in descriptor.value\n    ) {\n      (target.constructor as typeof CoList)._schema ||= {};\n      (target.constructor as typeof CoList)._schema[ItemsSym] =\n        descriptor.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, descriptor);\n    }\n  },\n  has(target, key) {\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      return Number(key) < target._raw.entries().length;\n    } else {\n      return Reflect.has(target, key);\n    }\n  },\n};\n", "import type {\n  AccountRole,\n  AgentID,\n  Everyone,\n  RawAccountID,\n  RawGroup,\n  Role,\n} from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport type {\n  CoValue,\n  CoValueClass,\n  ID,\n  RefEncoded,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n} from \"../internal.js\";\nimport {\n  CoValueBase,\n  Ref,\n  co,\n  ensureCoValueLoaded,\n  loadCoValueWithoutMe,\n  parseGroupCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { AccountAndGroupProxyHandler, isControlledAccount } from \"./account.js\";\nimport { type Account } from \"./account.js\";\nimport { type CoMap } from \"./coMap.js\";\nimport { type Profile } from \"./profile.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\n/** @category Identity & Permissions */\nexport class Group extends CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"Group\";\n  static {\n    this.prototype._type = \"Group\";\n  }\n  declare _raw: RawGroup;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  get _schema(): {\n    profile: Schema;\n    root: Schema;\n  } {\n    return (this.constructor as typeof Group)._schema;\n  }\n  static {\n    this._schema = {\n      profile: \"json\" satisfies Schema,\n      root: \"json\" satisfies Schema,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any;\n    Object.defineProperty(this.prototype, \"_schema\", {\n      get: () => this._schema,\n    });\n  }\n\n  declare profile: Profile | null;\n  declare root: CoMap | null;\n\n  get _refs(): {\n    profile: Ref<Profile> | undefined;\n    root: Ref<CoMap> | undefined;\n  } {\n    const profileID = this._raw.get(\"profile\") as unknown as\n      | ID<NonNullable<this[\"profile\"]>>\n      | undefined;\n    const rootID = this._raw.get(\"root\") as unknown as\n      | ID<NonNullable<this[\"root\"]>>\n      | undefined;\n    return {\n      profile:\n        profileID &&\n        (new Ref(\n          profileID,\n          this._loadedAs,\n          this._schema.profile as RefEncoded<NonNullable<this[\"profile\"]>>,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any as this[\"profile\"] extends Profile\n          ? Ref<this[\"profile\"]>\n          : never),\n      root:\n        rootID &&\n        (new Ref(\n          rootID,\n          this._loadedAs,\n          this._schema.root as RefEncoded<NonNullable<this[\"root\"]>>,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any as this[\"root\"] extends CoMap ? Ref<this[\"root\"]> : never),\n    };\n  }\n\n  /** @deprecated Don't use constructor directly, use .create */\n  constructor(options: { fromRaw: RawGroup } | { owner: Account | Group }) {\n    super();\n    let raw: RawGroup;\n\n    if (options && \"fromRaw\" in options) {\n      raw = options.fromRaw;\n    } else {\n      const initOwner = options.owner;\n      if (!initOwner) throw new Error(\"No owner provided\");\n      if (initOwner._type === \"Account\" && isControlledAccount(initOwner)) {\n        const rawOwner = initOwner._raw;\n        raw = rawOwner.createGroup();\n      } else {\n        throw new Error(\"Can only construct group as a controlled account\");\n      }\n    }\n\n    Object.defineProperties(this, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    return new Proxy(this, AccountAndGroupProxyHandler as ProxyHandler<this>);\n  }\n\n  static create<G extends Group>(\n    this: CoValueClass<G>,\n    options?: { owner: Account } | Account,\n  ) {\n    return new this(parseGroupCreateOptions(options));\n  }\n\n  myRole(): Role | undefined {\n    return this._raw.myRole();\n  }\n\n  addMember(member: Everyone, role: \"writer\" | \"reader\" | \"writeOnly\"): void;\n  addMember(member: Account, role: AccountRole): void;\n  addMember(member: Everyone | Account, role: AccountRole) {\n    this._raw.addMember(member === \"everyone\" ? member : member._raw, role);\n  }\n\n  removeMember(member: Everyone | Account) {\n    return this._raw.removeMember(member === \"everyone\" ? member : member._raw);\n  }\n\n  get members(): Array<{\n    id: ID<RegisteredAccount>;\n    role: AccountRole;\n    ref: Ref<RegisteredAccount>;\n    account: RegisteredAccount;\n  }> {\n    const members = [];\n\n    const BaseAccountSchema =\n      (activeAccountContext.maybeGet()?.constructor as typeof Account) ||\n      RegisteredSchemas[\"Account\"];\n    const refEncodedAccountSchema = {\n      ref: () => BaseAccountSchema,\n      optional: false,\n    } satisfies RefEncoded<RegisteredAccount>;\n\n    for (const accountID of this._raw.getAllMemberKeysSet()) {\n      if (!isAccountID(accountID)) continue;\n\n      const role = this._raw.roleOf(accountID);\n\n      if (\n        role === \"admin\" ||\n        role === \"writer\" ||\n        role === \"reader\" ||\n        role === \"writeOnly\"\n      ) {\n        const ref = new Ref<RegisteredAccount>(\n          accountID as unknown as ID<RegisteredAccount>,\n          this._loadedAs,\n          refEncodedAccountSchema,\n        );\n        const accessRef = () => ref.accessFrom(this, \"members.\" + accountID);\n\n        if (!ref.syncLoad()) {\n          console.warn(\"Account not loaded\", accountID);\n        }\n\n        members.push({\n          id: accountID as unknown as ID<Account>,\n          role,\n          ref,\n          get account() {\n            // Accounts values are non-nullable because are loaded as dependencies\n            return accessRef() as RegisteredAccount;\n          },\n        });\n      }\n    }\n\n    return members;\n  }\n\n  getRoleOf(member: Everyone | ID<Account> | \"me\") {\n    if (member === \"me\") {\n      return this._raw.roleOf(\n        activeAccountContext.get().id as unknown as RawAccountID,\n      );\n    }\n\n    return this._raw.roleOf(\n      member === \"everyone\" ? member : (member as unknown as RawAccountID),\n    );\n  }\n\n  getParentGroups(): Array<Group> {\n    return this._raw.getParentGroups().map((group) => Group.fromRaw(group));\n  }\n\n  extend(\n    parent: Group,\n    roleMapping?: \"reader\" | \"writer\" | \"admin\" | \"inherit\",\n  ) {\n    this._raw.extend(parent._raw, roleMapping);\n    return this;\n  }\n\n  async revokeExtend(parent: Group) {\n    await this._raw.revokeExtend(parent._raw);\n    return this;\n  }\n\n  /** @category Subscription & Loading */\n  static load<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    options?: { resolve?: RefsToResolveStrict<G, R>; loadAs?: Account },\n  ): Promise<Resolved<G, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /** @category Subscription & Loading */\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    options: SubscribeListenerOptions<G, R>,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    ...args: SubscribeRestArgs<G, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<G, R>(this, id, options, listener);\n  }\n\n  /** @category Subscription & Loading */\n  ensureLoaded<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    options?: { resolve?: RefsToResolveStrict<G, R> },\n  ): Promise<Resolved<G, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /** @category Subscription & Loading */\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    options: { resolve?: RefsToResolveStrict<G, R> },\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    ...args: SubscribeRestArgs<G, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `Group` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\nRegisteredSchemas[\"Group\"] = Group;\n\nexport function isAccountID(id: RawAccountID | AgentID): id is RawAccountID {\n  return id.startsWith(\"co_\");\n}\n", "import {\n  type OpID,\n  RawAccount,\n  type RawCoPlainText,\n  stringifyOpID,\n} from \"cojson\";\nimport { calcPatch } from \"fast-myers-diff\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  ID,\n  Resolved,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n} from \"../internal.js\";\nimport {\n  inspect,\n  loadCoValueWithoutMe,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\nimport { Account } from \"./account.js\";\nimport { Group } from \"./group.js\";\n\nexport type TextPos = OpID;\n\nexport class CoPlainText extends String implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"CoPlainText\";\n  declare _raw: RawCoPlainText;\n\n  get _owner(): Account | Group {\n    return this._raw.group instanceof RawAccount\n      ? Account.fromRaw(this._raw.group)\n      : Group.fromRaw(this._raw.group);\n  }\n\n  get _loadedAs() {\n    return Account.fromNode(this._raw.core.node);\n  }\n\n  constructor(\n    options:\n      | { fromRaw: RawCoPlainText }\n      | { text: string; owner: Account | Group },\n  ) {\n    super(\"fromRaw\" in options ? options.fromRaw.toString() : options.text);\n\n    let raw;\n\n    if (\"fromRaw\" in options) {\n      raw = options.fromRaw;\n    } else {\n      raw = options.owner._raw.createPlainText(options.text);\n    }\n\n    Object.defineProperties(this, {\n      id: { value: raw.id, enumerable: false },\n      _type: { value: \"CoPlainText\", enumerable: false },\n      _raw: { value: raw, enumerable: false },\n    });\n  }\n\n  static create<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    text: string,\n    options: { owner: Account | Group },\n  ) {\n    return new this({ text, owner: options.owner });\n  }\n\n  get length() {\n    return this._raw.toString().length;\n  }\n\n  toString() {\n    return this._raw.toString();\n  }\n\n  valueOf() {\n    return this._raw.toString();\n  }\n\n  toJSON(): string {\n    return this._raw.toString();\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  insertBefore(idx: number, text: string) {\n    this._raw.insertBefore(idx, text);\n  }\n\n  insertAfter(idx: number, text: string) {\n    this._raw.insertAfter(idx, text);\n  }\n\n  deleteRange(range: { from: number; to: number }) {\n    this._raw.deleteRange(range);\n  }\n\n  posBefore(idx: number): TextPos | undefined {\n    return this._raw.mapping.opIDbeforeIdx[idx];\n  }\n\n  posAfter(idx: number): TextPos | undefined {\n    return this._raw.mapping.opIDafterIdx[idx];\n  }\n\n  idxBefore(pos: TextPos): number | undefined {\n    return this._raw.mapping.idxBeforeOpID[stringifyOpID(pos)];\n  }\n\n  idxAfter(pos: TextPos): number | undefined {\n    return this._raw.mapping.idxAfterOpID[stringifyOpID(pos)];\n  }\n\n  static fromRaw<V extends CoPlainText>(\n    this: CoValueClass<V> & typeof CoPlainText,\n    raw: RawCoPlainText,\n  ) {\n    return new this({ fromRaw: raw });\n  }\n\n  /**\n   * Apply text, modifying the text in place. Calculates the diff and applies it to the CoValue.\n   *\n   * @category Mutation\n   */\n  applyDiff(other: string) {\n    const current = this._raw.toString();\n    for (const [from, to, insert] of [...calcPatch(current, other)].reverse()) {\n      if (to > from) {\n        this.deleteRange({ from, to });\n      }\n      if (insert.length > 0) {\n        this.insertBefore(from, insert);\n      }\n    }\n  }\n\n  /**\n   * Load a `CoPlainText` with a given ID, as a given account.\n   *\n   * @category Subscription & Loading\n   */\n  static load<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    options?: { loadAs?: Account | AnonymousJazzAgent },\n  ): Promise<T | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  //   /**\n  //    * Effectful version of `CoMap.load()`.\n  //    *\n  //    * Needs to be run inside an `AccountCtx` context.\n  //    *\n  //    * @category Subscription & Loading\n  //    */\n  //   static loadEf<T extends CoPlainText>(\n  //     this: CoValueClass<T>,\n  //     id: ID<T>,\n  //   ): Effect.Effect<T, UnavailableError, AccountCtx> {\n  //     return loadCoValueEf(this, id, []);\n  //   }\n\n  /**\n   * Load and subscribe to a `CoPlainText` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoStream`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    options: Omit<SubscribeListenerOptions<T, true>, \"resolve\">,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    ...args: SubscribeRestArgs<T, true>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<T, true>(this, id, options, listener);\n  }\n\n  /**\n   * Given an already loaded `CoPlainText`, subscribe to updates to the `CoPlainText` and ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoPlainText.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<T extends CoPlainText>(\n    this: T,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void {\n    return subscribeToExistingCoValue(this, {}, listener);\n  }\n}\n", "import { CoPlainText } from \"./coPlainText.js\";\n\nexport class CoRichText extends CoPlainText {}\n", "import { co, subscriptionsScopes } from \"../../internal.js\";\nimport { FileStream } from \"../coFeed.js\";\nimport { CoMap } from \"../coMap.js\";\n\n/** @category Media */\nexport class ImageDefinition extends CoMap {\n  originalSize = co.json<[number, number]>();\n  placeholderDataURL? = co.string;\n\n  [co.items] = co.ref(FileStream);\n  [res: `${number}x${number}`]: co<FileStream | null>;\n\n  highestResAvailable(options?: {\n    maxWidth?: number;\n    targetWidth?: number;\n  }): { res: `${number}x${number}`; stream: FileStream } | undefined {\n    if (!subscriptionsScopes.get(this)) {\n      console.warn(\n        \"highestResAvailable() only makes sense when used within a subscription.\",\n      );\n    }\n\n    const resolutions = Object.keys(this).filter((key) =>\n      key.match(/^\\d+x\\d+$/),\n    ) as `${number}x${number}`[];\n\n    let maxWidth = options?.maxWidth;\n\n    if (options?.targetWidth) {\n      const targetWidth = options.targetWidth;\n      const widths = resolutions.map((res) => Number(res.split(\"x\")[0]));\n\n      maxWidth = Math.min(...widths.filter((w) => w >= targetWidth));\n    }\n\n    const validResolutions = resolutions.filter(\n      (key) => maxWidth === undefined || Number(key.split(\"x\")[0]) <= maxWidth,\n    ) as `${number}x${number}`[];\n\n    // Sort the resolutions by width, smallest to largest\n    validResolutions.sort((a, b) => {\n      const aWidth = Number(a.split(\"x\")[0]);\n      const bWidth = Number(b.split(\"x\")[0]);\n      return aWidth - bWidth; // Sort smallest to largest\n    });\n\n    let highestAvailableResolution: `${number}x${number}` | undefined;\n\n    for (const resolution of validResolutions) {\n      if (this[resolution] && this[resolution]?.getChunks()) {\n        highestAvailableResolution = resolution;\n      }\n    }\n\n    // Return the highest complete resolution if we found one\n    return (\n      highestAvailableResolution && {\n        res: highestAvailableResolution,\n        stream: this[highestAvailableResolution]!,\n      }\n    );\n  }\n}\n", "import {\n  CoValue,\n  CoValueBase,\n  CoValueClass,\n  CoValueFromRaw,\n} from \"../internal.js\";\n\n/**\n * SchemaUnion allows you to create union types of CoValues that can be discriminated at runtime.\n *\n * @categoryDescription Declaration\n * Declare your union types by extending `SchemaUnion.Of(...)` and passing a discriminator function that determines which concrete type to use based on the raw data.\n *\n * ```ts\n * import { SchemaUnion, CoMap } from \"jazz-tools\";\n *\n * class BaseWidget extends CoMap {\n *   type = co.string;\n * }\n *\n * class ButtonWidget extends BaseWidget {\n *   type = co.literal(\"button\");\n *   label = co.string;\n * }\n *\n * class SliderWidget extends BaseWidget {\n *   type = co.literal(\"slider\");\n *   min = co.number;\n *   max = co.number;\n * }\n *\n * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {\n *   switch (raw.get(\"type\")) {\n *     case \"button\": return ButtonWidget;\n *     case \"slider\": return SliderWidget;\n *     default: throw new Error(\"Unknown widget type\");\n *   }\n * });\n * ```\n *\n * @category CoValues\n */\nexport abstract class SchemaUnion extends CoValueBase implements CoValue {\n  /**\n   * Create a new union type from a discriminator function.\n   *\n   * The discriminator function receives the raw data and should return the appropriate concrete class to use for that data.\n   *\n   * When loading a SchemaUnion, the correct subclass will be instantiated based on the discriminator.\n   *\n   * @param discriminator - Function that determines which concrete type to use\n   * @returns A new class that can create/load instances of the union type\n   *\n   * @example\n   * ```ts\n   * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {\n   *   switch (raw.get(\"type\")) {\n   *     case \"button\": return ButtonWidget;\n   *     case \"slider\": return SliderWidget;\n   *     default: throw new Error(\"Unknown widget type\");\n   *   }\n   * });\n   *\n   * const widget = await loadCoValue(WidgetUnion, id, me, {});\n   *\n   * // You can narrow the returned instance to a subclass by using `instanceof`\n   * if (widget instanceof ButtonWidget) {\n   *   console.log(widget.label);\n   * } else if (widget instanceof SliderWidget) {\n   *   console.log(widget.min, widget.max);\n   * }\n   * ```\n   *\n   * @category Declaration\n   **/\n  static Of<V extends CoValue>(\n    discriminator: (raw: V[\"_raw\"]) => CoValueClass<V> & CoValueFromRaw<V>,\n  ): CoValueClass<V> & typeof SchemaUnion {\n    return class SchemaUnionClass extends SchemaUnion {\n      static override fromRaw<T extends CoValue>(\n        this: CoValueClass<T> & CoValueFromRaw<T>,\n        raw: T[\"_raw\"],\n      ): T {\n        const ResolvedClass = discriminator(\n          raw as V[\"_raw\"],\n        ) as unknown as CoValueClass<T> & CoValueFromRaw<T>;\n        return ResolvedClass.fromRaw(raw);\n      }\n    } as unknown as CoValueClass<V> & typeof SchemaUnion;\n  }\n\n  /**\n   * Create an instance from raw data. This is called internally and should not be used directly.\n   * Use {@link SchemaUnion.Of} to create a union type instead.\n   *\n   * @internal\n   */\n  // @ts-ignore\n  static fromRaw<V extends CoValue>(this: CoValueClass<V>, raw: V[\"_raw\"]): V {\n    throw new Error(\"Not implemented\");\n  }\n}\n", "export interface KvStore {\n  get(key: string): Promise<string | null>;\n  set(key: string, value: string): Promise<void>;\n  delete(key: string): Promise<void>;\n  clearAll(): Promise<void>;\n}\n\nexport class KvStoreContext {\n  private static instance: KvStoreContext;\n  private storageInstance: KvStore | null = null;\n\n  private constructor() {}\n\n  public static getInstance(): KvStoreContext {\n    if (!KvStoreContext.instance) {\n      KvStoreContext.instance = new KvStoreContext();\n    }\n    return KvStoreContext.instance;\n  }\n\n  public isInitialized(): boolean {\n    return this.storageInstance !== null;\n  }\n\n  public initialize(store: KvStore): void {\n    if (!this.storageInstance) {\n      this.storageInstance = store;\n    }\n  }\n\n  public getStorage(): KvStore {\n    if (!this.storageInstance) {\n      throw new Error(\"Storage instance is not initialized.\");\n    }\n    return this.storageInstance;\n  }\n}\n\nexport default KvStoreContext;\n", "import { AgentSecret } from \"cojson\";\nimport type { Account } from \"../coValues/account.js\";\nimport type { ID } from \"../internal.js\";\nimport { AuthCredentials } from \"../types.js\";\nimport KvStoreContext from \"./KvStoreContext.js\";\n\nconst STORAGE_KEY = \"jazz-logged-in-secret\";\n\nexport type AuthSetPayload = {\n  accountID: ID<Account>;\n  secretSeed?: Uint8Array;\n  accountSecret: AgentSecret;\n  provider: \"anonymous\" | \"clerk\" | \"demo\" | \"passkey\" | \"passphrase\" | string;\n};\n\nexport class AuthSecretStorage {\n  private listeners: Set<(isAuthenticated: boolean) => void>;\n  public isAuthenticated: boolean;\n\n  constructor() {\n    this.listeners = new Set();\n    this.isAuthenticated = false;\n  }\n\n  async migrate() {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n\n    if (!(await kvStore.get(STORAGE_KEY))) {\n      const demoAuthSecret = await kvStore.get(\"demo-auth-logged-in-secret\");\n      if (demoAuthSecret) {\n        const parsed = JSON.parse(demoAuthSecret);\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            accountSecret: parsed.accountSecret,\n            provider: \"demo\",\n          }),\n        );\n        await kvStore.delete(\"demo-auth-logged-in-secret\");\n      }\n\n      const clerkAuthSecret = await kvStore.get(\"jazz-clerk-auth\");\n      if (clerkAuthSecret) {\n        const parsed = JSON.parse(clerkAuthSecret);\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            accountSecret: parsed.secret,\n            provider: \"clerk\",\n          }),\n        );\n        await kvStore.delete(\"jazz-clerk-auth\");\n      }\n    }\n\n    const value = await kvStore.get(STORAGE_KEY);\n\n    if (value) {\n      const parsed = JSON.parse(value);\n\n      if (\"secret\" in parsed) {\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            secretSeed: parsed.secretSeed,\n            accountSecret: parsed.secret,\n            provider: parsed.provider,\n          }),\n        );\n      }\n    }\n  }\n\n  async get(): Promise<AuthCredentials | null> {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    const data = await kvStore.get(STORAGE_KEY);\n\n    if (!data) return null;\n\n    const parsed = JSON.parse(data);\n\n    if (!parsed.accountID || !parsed.accountSecret) {\n      throw new Error(\"Invalid auth secret storage data\");\n    }\n\n    return {\n      accountID: parsed.accountID,\n      secretSeed: parsed.secretSeed\n        ? new Uint8Array(parsed.secretSeed)\n        : undefined,\n      accountSecret: parsed.accountSecret,\n      provider: parsed.provider,\n    };\n  }\n\n  async setWithoutNotify(payload: AuthSetPayload) {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await kvStore.set(\n      STORAGE_KEY,\n      JSON.stringify({\n        accountID: payload.accountID,\n        secretSeed: payload.secretSeed\n          ? Array.from(payload.secretSeed)\n          : undefined,\n        accountSecret: payload.accountSecret,\n        provider: payload.provider,\n      }),\n    );\n  }\n\n  async set(payload: AuthSetPayload) {\n    this.setWithoutNotify(payload);\n    this.emitUpdate(payload);\n  }\n\n  getIsAuthenticated(data: AuthCredentials | null): boolean {\n    if (!data) return false;\n    return data.provider !== \"anonymous\";\n  }\n\n  onUpdate(handler: (isAuthenticated: boolean) => void) {\n    this.listeners.add(handler);\n    return () => {\n      this.listeners.delete(handler);\n    };\n  }\n\n  emitUpdate(data: AuthCredentials | null) {\n    const isAuthenticated = this.getIsAuthenticated(data);\n\n    if (this.isAuthenticated === isAuthenticated) return;\n\n    this.isAuthenticated = isAuthenticated;\n    for (const listener of this.listeners) {\n      listener(this.isAuthenticated);\n    }\n  }\n\n  async clearWithoutNotify() {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await kvStore.delete(STORAGE_KEY);\n  }\n\n  async clear() {\n    await this.clearWithoutNotify();\n    this.emitUpdate(null);\n  }\n}\n", "import { KvStore } from \"./KvStoreContext.js\";\n\nexport class InMemoryKVStore implements KvStore {\n  private store: Record<string, string> = {};\n\n  async get(key: string) {\n    const data = this.store[key];\n\n    if (!data) return null;\n\n    return data;\n  }\n\n  async set(key: string, value: string) {\n    this.store[key] = value;\n  }\n\n  async delete(key: string) {\n    delete this.store[key];\n  }\n\n  async clearAll() {\n    this.store = {};\n  }\n}\n", "import { AgentSecret, LocalNode, cojsonInternals } from \"cojson\";\nimport { AuthSecretStorage } from \"../auth/AuthSecretStorage.js\";\nimport { InMemoryKVStore } from \"../auth/InMemoryKVStore.js\";\nimport { KvStore, KvStoreContext } from \"../auth/KvStoreContext.js\";\nimport { Account } from \"../coValues/account.js\";\nimport { AuthCredentials } from \"../types.js\";\nimport { JazzContextType } from \"../types.js\";\nimport { AnonymousJazzAgent } from \"./anonymousJazzAgent.js\";\n\nexport type JazzContextManagerAuthProps = {\n  credentials?: AuthCredentials;\n  newAccountProps?: { secret: AgentSecret; creationProps: { name: string } };\n};\n\nexport type JazzContextManagerBaseProps<Acc extends Account> = {\n  onAnonymousAccountDiscarded?: (anonymousAccount: Acc) => Promise<void>;\n  onLogOut?: () => void | Promise<unknown>;\n  logOutReplacement?: () => void | Promise<unknown>;\n};\n\ntype PlatformSpecificAuthContext<Acc extends Account> = {\n  me: Acc;\n  node: LocalNode;\n  logOut: () => Promise<void>;\n  done: () => void;\n};\n\ntype PlatformSpecificGuestContext = {\n  guest: AnonymousJazzAgent;\n  node: LocalNode;\n  logOut: () => Promise<void>;\n  done: () => void;\n};\n\ntype PlatformSpecificContext<Acc extends Account> =\n  | PlatformSpecificAuthContext<Acc>\n  | PlatformSpecificGuestContext;\n\nexport class JazzContextManager<\n  Acc extends Account,\n  P extends JazzContextManagerBaseProps<Acc>,\n> {\n  protected value: JazzContextType<Acc> | undefined;\n  protected context: PlatformSpecificContext<Acc> | undefined;\n  protected props: P | undefined;\n  protected authSecretStorage = new AuthSecretStorage();\n  protected keepContextOpen = false;\n  protected contextPromise: Promise<void> | undefined;\n\n  constructor() {\n    KvStoreContext.getInstance().initialize(this.getKvStore());\n  }\n\n  getKvStore(): KvStore {\n    return new InMemoryKVStore();\n  }\n\n  async createContext(props: P, authProps?: JazzContextManagerAuthProps) {\n    // We need to store the props here to block the double effect execution\n    // on React. Otherwise when calling propsChanged this.props is undefined.\n    this.props = props;\n\n    // Avoid race condition between the previous context and the new one\n    const { promise, resolve } = createResolvablePromise<void>();\n\n    const prevPromise = this.contextPromise;\n    this.contextPromise = promise;\n\n    await prevPromise;\n\n    try {\n      const result = await this.getNewContext(props, authProps);\n      await this.updateContext(props, result, authProps);\n\n      resolve();\n    } catch (error) {\n      resolve();\n      throw error;\n    }\n  }\n\n  async getNewContext(\n    props: P,\n    authProps?: JazzContextManagerAuthProps,\n  ): Promise<PlatformSpecificContext<Acc>> {\n    props;\n    authProps;\n    throw new Error(\"Not implemented\");\n  }\n\n  async updateContext(\n    props: P,\n    context: PlatformSpecificContext<Acc>,\n    authProps?: JazzContextManagerAuthProps,\n  ) {\n    // When keepContextOpen we don't want to close the previous context\n    // because we might need to handle the onAnonymousAccountDiscarded callback\n    if (!this.keepContextOpen) {\n      this.context?.done();\n    }\n\n    this.context = context;\n    this.props = props;\n    this.value = {\n      ...context,\n      node: context.node,\n      authenticate: this.authenticate,\n      register: this.register,\n      logOut: this.logOut,\n    };\n\n    if (authProps?.credentials) {\n      this.authSecretStorage.emitUpdate(authProps.credentials);\n    } else {\n      this.authSecretStorage.emitUpdate(await this.authSecretStorage.get());\n    }\n\n    this.notify();\n  }\n\n  propsChanged(props: P) {\n    props;\n    throw new Error(\"Not implemented\");\n  }\n\n  getCurrentValue() {\n    return this.value;\n  }\n\n  getAuthSecretStorage() {\n    return this.authSecretStorage;\n  }\n\n  logOut = async () => {\n    if (!this.context || !this.props) {\n      return;\n    }\n\n    await this.props.onLogOut?.();\n\n    if (this.props.logOutReplacement) {\n      await this.props.logOutReplacement();\n    } else {\n      await this.context.logOut();\n      return this.createContext(this.props);\n    }\n  };\n\n  done = () => {\n    if (!this.context) {\n      return;\n    }\n\n    this.context.done();\n  };\n\n  shouldMigrateAnonymousAccount = async () => {\n    if (!this.props?.onAnonymousAccountDiscarded) {\n      return false;\n    }\n\n    const prevCredentials = await this.authSecretStorage.get();\n    const wasAnonymous =\n      this.authSecretStorage.getIsAuthenticated(prevCredentials) === false;\n\n    return wasAnonymous;\n  };\n\n  /**\n   * Authenticates the user with the given credentials\n   */\n  authenticate = async (credentials: AuthCredentials) => {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const prevContext = this.context;\n    const migratingAnonymousAccount =\n      await this.shouldMigrateAnonymousAccount();\n\n    this.keepContextOpen = migratingAnonymousAccount;\n    await this.createContext(this.props, { credentials }).finally(() => {\n      this.keepContextOpen = false;\n    });\n\n    if (migratingAnonymousAccount) {\n      await this.handleAnonymousAccountMigration(prevContext);\n    }\n  };\n\n  register = async (\n    accountSecret: AgentSecret,\n    creationProps: { name: string },\n  ) => {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const prevContext = this.context;\n    const migratingAnonymousAccount =\n      await this.shouldMigrateAnonymousAccount();\n\n    this.keepContextOpen = migratingAnonymousAccount;\n    await this.createContext(this.props, {\n      newAccountProps: {\n        secret: accountSecret,\n        creationProps,\n      },\n    }).finally(() => {\n      this.keepContextOpen = false;\n    });\n\n    if (migratingAnonymousAccount) {\n      await this.handleAnonymousAccountMigration(prevContext);\n    }\n\n    if (this.context && \"me\" in this.context) {\n      return this.context.me.id;\n    }\n\n    throw new Error(\"The registration hasn't created a new account\");\n  };\n\n  private async handleAnonymousAccountMigration(\n    prevContext: PlatformSpecificContext<Acc> | undefined,\n  ) {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const currentContext = this.context;\n\n    if (\n      prevContext &&\n      currentContext &&\n      \"me\" in prevContext &&\n      \"me\" in currentContext\n    ) {\n      // Using a direct connection to make coValue transfer almost synchronous\n      const [prevAccountAsPeer, currentAccountAsPeer] =\n        cojsonInternals.connectedPeers(\n          prevContext.me.id,\n          currentContext.me.id,\n          {\n            peer1role: \"client\",\n            peer2role: \"server\",\n          },\n        );\n\n      prevContext.node.syncManager.addPeer(currentAccountAsPeer);\n      currentContext.node.syncManager.addPeer(prevAccountAsPeer);\n\n      try {\n        await this.props.onAnonymousAccountDiscarded?.(prevContext.me);\n        await prevContext.me.waitForAllCoValuesSync();\n      } catch (error) {\n        console.error(\"Error onAnonymousAccountDiscarded\", error);\n      }\n\n      prevAccountAsPeer.outgoing.close();\n      currentAccountAsPeer.outgoing.close();\n    }\n\n    prevContext?.done();\n  }\n\n  listeners = new Set<() => void>();\n  subscribe = (callback: () => void) => {\n    this.listeners.add(callback);\n\n    return () => {\n      this.listeners.delete(callback);\n    };\n  };\n\n  notify() {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n\nfunction createResolvablePromise<T>() {\n  let resolve!: (value: T) => void;\n\n  const promise = new Promise<T>((res) => {\n    resolve = res;\n  });\n\n  return { promise, resolve };\n}\n", "import { AgentSecret } from \"cojson\";\nimport { Account } from \"../coValues/account.js\";\nimport { ID } from \"../internal.js\";\nimport { AuthenticateAccountFunction } from \"../types.js\";\nimport { AuthSecretStorage } from \"./AuthSecretStorage.js\";\nimport { KvStore, KvStoreContext } from \"./KvStoreContext.js\";\n\ntype StorageData = {\n  accountID: ID<Account>;\n  accountSecret: AgentSecret;\n  secretSeed?: number[];\n};\n\n/**\n * `DemoAuth` provides a `JazzAuth` object for demo authentication.\n *\n * Demo authentication is useful for quickly testing your app, as it allows you to create new accounts and log in as existing ones.\n *\n * ```\n * import { DemoAuth } from \"jazz-tools\";\n *\n * const auth = new DemoAuth(jazzContext.authenticate, new AuthSecretStorage());\n * ```\n *\n * @category Auth Providers\n */\nexport class DemoAuth {\n  constructor(\n    private authenticate: AuthenticateAccountFunction,\n    private authSecretStorage: AuthSecretStorage,\n  ) {}\n\n  logIn = async (username: string) => {\n    const existingUsers = await this.getExisitingUsersWithData();\n    const storageData = existingUsers[username];\n\n    if (!storageData?.accountID) {\n      throw new Error(\"User not found\");\n    }\n\n    await this.authenticate({\n      accountID: storageData.accountID,\n      accountSecret: storageData.accountSecret,\n    });\n\n    await this.authSecretStorage.set({\n      accountID: storageData.accountID,\n      accountSecret: storageData.accountSecret,\n      secretSeed: storageData.secretSeed\n        ? new Uint8Array(storageData.secretSeed)\n        : undefined,\n      provider: \"demo\",\n    });\n  };\n\n  signUp = async (username: string) => {\n    const existingUsers = await this.getExistingUsers();\n    if (existingUsers.includes(username)) {\n      throw new Error(\"User already registered\");\n    }\n\n    const credentials = await this.authSecretStorage.get();\n\n    if (!credentials) {\n      throw new Error(\"No credentials found\");\n    }\n\n    const currentAccount = await Account.getMe().ensureLoaded({\n      resolve: {\n        profile: true,\n      },\n    });\n\n    currentAccount.profile.name = username;\n\n    await this.authSecretStorage.set({\n      accountID: credentials.accountID,\n      accountSecret: credentials.accountSecret,\n      secretSeed: credentials.secretSeed\n        ? new Uint8Array(credentials.secretSeed)\n        : undefined,\n      provider: \"demo\",\n    });\n\n    await this.addToExistingUsers(username, {\n      accountID: credentials.accountID,\n      accountSecret: credentials.accountSecret,\n      secretSeed: credentials.secretSeed\n        ? Array.from(credentials.secretSeed)\n        : undefined,\n    });\n  };\n\n  private async addToExistingUsers(username: string, data: StorageData) {\n    const existingUsers = await this.getExisitingUsersWithData();\n\n    if (existingUsers[username]) {\n      return;\n    }\n\n    existingUsers[username] = data;\n\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await kvStore.set(\"demo-auth-users\", JSON.stringify(existingUsers));\n  }\n\n  private async getExisitingUsersWithData() {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await migrateExistingUsers(kvStore);\n\n    const existingUsers = await kvStore.get(\"demo-auth-users\");\n    return existingUsers ? JSON.parse(existingUsers) : {};\n  }\n\n  getExistingUsers = async () => {\n    return Object.keys(await this.getExisitingUsersWithData());\n  };\n}\n\nexport function encodeUsername(username: string) {\n  return btoa(username)\n    .replace(/=/g, \"-\")\n    .replace(/\\+/g, \"_\")\n    .replace(/\\//g, \".\");\n}\n\nasync function getStorageVersion(kvStore: KvStore) {\n  try {\n    const version = await kvStore.get(\"demo-auth-storage-version\");\n    return version ? parseInt(version) : 1;\n  } catch (error) {\n    return 1;\n  }\n}\n\nasync function setStorageVersion(kvStore: KvStore, version: number) {\n  await kvStore.set(\"demo-auth-storage-version\", version.toString());\n}\n\nasync function getExistingUsersList(kvStore: KvStore) {\n  const existingUsers = await kvStore.get(\"demo-auth-existing-users\");\n  return existingUsers ? existingUsers.split(\",\") : [];\n}\n\n/**\n * Migrates existing users keys to work with any storage.\n */\nasync function migrateExistingUsers(kvStore: KvStore) {\n  if ((await getStorageVersion(kvStore)) < 2) {\n    const existingUsers = await getExistingUsersList(kvStore);\n\n    for (const username of existingUsers) {\n      const legacyKey = `demo-auth-existing-users-${username}`;\n      const storageData = await kvStore.get(legacyKey);\n      if (storageData) {\n        await kvStore.set(\n          `demo-auth-existing-users-${encodeUsername(username)}`,\n          storageData,\n        );\n        await kvStore.delete(legacyKey);\n      }\n    }\n\n    await setStorageVersion(kvStore, 2);\n  }\n\n  if ((await getStorageVersion(kvStore)) < 3) {\n    const existingUsersList = await getExistingUsersList(kvStore);\n\n    const existingUsers: Record<string, StorageData> = {};\n    const keysToDelete: string[] = [\"demo-auth-existing-users\"];\n\n    for (const username of existingUsersList) {\n      const key = `demo-auth-existing-users-${encodeUsername(username)}`;\n      const storageData = await kvStore.get(key);\n      if (storageData) {\n        existingUsers[username] = JSON.parse(storageData);\n        keysToDelete.push(key);\n      }\n    }\n\n    await kvStore.set(\"demo-auth-users\", JSON.stringify(existingUsers));\n\n    for (const key of keysToDelete) {\n      await kvStore.delete(key);\n    }\n\n    await setStorageVersion(kvStore, 3);\n  }\n}\n", "import * as bip39 from \"@scure/bip39\";\nimport { entropyToMnemonic } from \"@scure/bip39\";\nimport { CryptoProvider, cojsonInternals } from \"cojson\";\nimport { Account } from \"../coValues/account.js\";\nimport type { ID } from \"../internal.js\";\nimport type {\n  AuthenticateAccountFunction,\n  RegisterAccountFunction,\n} from \"../types.js\";\nimport { AuthSecretStorage } from \"./AuthSecretStorage.js\";\n\n/**\n * `PassphraseAuth` provides a `JazzAuth` object for passphrase authentication.\n *\n * ```ts\n * import { PassphraseAuth } from \"jazz-tools\";\n *\n * const auth = new PassphraseAuth(crypto, jazzContext.authenticate, new AuthSecretStorage(), wordlist);\n * ```\n *\n * @category Auth Providers\n */\nexport class PassphraseAuth {\n  passphrase: string = \"\";\n\n  constructor(\n    private crypto: CryptoProvider,\n    private authenticate: AuthenticateAccountFunction,\n    private register: RegisterAccountFunction,\n    private authSecretStorage: AuthSecretStorage,\n    public wordlist: string[],\n  ) {}\n\n  logIn = async (passphrase: string) => {\n    const { crypto, authenticate } = this;\n\n    let secretSeed;\n\n    try {\n      secretSeed = bip39.mnemonicToEntropy(passphrase, this.wordlist);\n    } catch (e) {\n      throw new Error(\"Invalid passphrase\");\n    }\n\n    const accountSecret = crypto.agentSecretFromSecretSeed(secretSeed);\n\n    const accountID = cojsonInternals.idforHeader(\n      cojsonInternals.accountHeaderForInitialAgentSecret(accountSecret, crypto),\n      crypto,\n    ) as ID<Account>;\n\n    await authenticate({\n      accountID,\n      accountSecret,\n    });\n\n    await this.authSecretStorage.set({\n      accountID,\n      secretSeed,\n      accountSecret,\n      provider: \"passphrase\",\n    });\n\n    this.passphrase = passphrase;\n    this.notify();\n  };\n\n  signUp = async (name?: string) => {\n    const credentials = await this.authSecretStorage.get();\n\n    if (!credentials || !credentials.secretSeed) {\n      throw new Error(\"No credentials found\");\n    }\n\n    const passphrase = entropyToMnemonic(credentials.secretSeed, this.wordlist);\n\n    await this.authSecretStorage.set({\n      accountID: credentials.accountID,\n      secretSeed: credentials.secretSeed,\n      accountSecret: credentials.accountSecret,\n      provider: \"passphrase\",\n    });\n\n    if (name?.trim()) {\n      const currentAccount = await Account.getMe().ensureLoaded({\n        resolve: {\n          profile: true,\n        },\n      });\n\n      currentAccount.profile.name = name;\n    }\n\n    return passphrase;\n  };\n\n  registerNewAccount = async (passphrase: string, name: string) => {\n    const secretSeed = bip39.mnemonicToEntropy(passphrase, this.wordlist);\n    const accountSecret = this.crypto.agentSecretFromSecretSeed(secretSeed);\n    const accountID = await this.register(accountSecret, { name });\n\n    await this.authSecretStorage.set({\n      accountID,\n      secretSeed,\n      accountSecret,\n      provider: \"passphrase\",\n    });\n\n    return accountID;\n  };\n\n  getCurrentAccountPassphrase = async () => {\n    const credentials = await this.authSecretStorage.get();\n\n    if (!credentials || !credentials.secretSeed) {\n      throw new Error(\"No credentials found\");\n    }\n\n    return entropyToMnemonic(credentials.secretSeed, this.wordlist);\n  };\n\n  generateRandomPassphrase = () => {\n    return entropyToMnemonic(this.crypto.newRandomSecretSeed(), this.wordlist);\n  };\n\n  loadCurrentAccountPassphrase = async () => {\n    const passphrase = await this.getCurrentAccountPassphrase();\n    this.passphrase = passphrase;\n    this.notify();\n  };\n\n  listeners = new Set<() => void>();\n  subscribe = (callback: () => void) => {\n    this.listeners.add(callback);\n\n    return () => {\n      this.listeners.delete(callback);\n    };\n  };\n\n  notify() {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n", "import { type InviteSecret, cojsonInternals } from \"cojson\";\nimport { Account } from \"../coValues/account.js\";\nimport type { CoValue, CoValueClass, ID } from \"../internal.js\";\n\n/** @category Invite Links */\nexport function createInviteLink<C extends CoValue>(\n  value: C,\n  role: \"reader\" | \"writer\" | \"admin\" | \"writeOnly\",\n  baseURL: string,\n  valueHint?: string,\n): string {\n  const coValueCore = value._raw.core;\n  let currentCoValue = coValueCore;\n\n  while (currentCoValue.header.ruleset.type === \"ownedByGroup\") {\n    currentCoValue = currentCoValue.getGroup().core;\n  }\n\n  const { ruleset, meta } = currentCoValue.header;\n\n  if (ruleset.type !== \"group\" || meta?.type === \"account\") {\n    throw new Error(\"Can't create invite link for object without group\");\n  }\n\n  const group = cojsonInternals.expectGroup(currentCoValue.getCurrentContent());\n  const inviteSecret = group.createInvite(role);\n\n  return `${baseURL}#/invite/${valueHint ? valueHint + \"/\" : \"\"}${\n    value.id\n  }/${inviteSecret}`;\n}\n\n/** @category Invite Links */\nexport function parseInviteLink<C extends CoValue>(\n  inviteURL: string,\n):\n  | {\n      valueID: ID<C>;\n      valueHint?: string;\n      inviteSecret: InviteSecret;\n    }\n  | undefined {\n  const url = new URL(inviteURL);\n  const parts = url.hash.split(\"/\");\n\n  let valueHint: string | undefined;\n  let valueID: ID<C> | undefined;\n  let inviteSecret: InviteSecret | undefined;\n\n  if (parts[0] === \"#\" && parts[1] === \"invite\") {\n    if (parts.length === 5) {\n      valueHint = parts[2];\n      valueID = parts[3] as ID<C>;\n      inviteSecret = parts[4] as InviteSecret;\n    } else if (parts.length === 4) {\n      valueID = parts[2] as ID<C>;\n      inviteSecret = parts[3] as InviteSecret;\n    }\n\n    if (!valueID || !inviteSecret) {\n      return undefined;\n    }\n    return { valueID, inviteSecret, valueHint };\n  }\n}\n\n/** @category Invite Links */\nexport function consumeInviteLink<V extends CoValue>({\n  inviteURL,\n  as = Account.getMe(),\n  forValueHint,\n  invitedObjectSchema,\n}: {\n  inviteURL: string;\n  as?: Account;\n  forValueHint?: string;\n  invitedObjectSchema: CoValueClass<V>;\n}): Promise<\n  | {\n      valueID: ID<V>;\n      valueHint?: string;\n      inviteSecret: InviteSecret;\n    }\n  | undefined\n> {\n  return new Promise((resolve, reject) => {\n    const result = parseInviteLink<V>(inviteURL);\n\n    if (result && result.valueHint === forValueHint) {\n      as.acceptInvite(result.valueID, result.inviteSecret, invitedObjectSchema)\n        .then(() => {\n          resolve(result);\n        })\n        .catch(reject);\n    } else {\n      resolve(undefined);\n    }\n  });\n}\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// TODO: temporarily set to false, trying to understand bugs\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) {\n    astr('base64', s); return (Uint8Array as any).fromBase64(s, { lastChunkHandling: 'strict' });\n  },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { astr('base64', s); return (Uint8Array as any).fromBase64(s, { alphabet: 'base64url' }); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n", "/**\n * Audited & minimal JS implementation of\n * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @module\n * @example\n```js\nimport * as bip39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nconst mn = bip39.generateMnemonic(wordlist);\nconsole.log(mn);\nconst ent = bip39.mnemonicToEntropy(mn, wordlist)\nbip39.entropyToMnemonic(ent, wordlist);\nbip39.validateMnemonic(mn, wordlist);\nawait bip39.mnemonicToSeed(mn, 'password');\nbip39.mnemonicToSeedSync(mn, 'password');\n\n// Wordlists\nimport { wordlist as czech } from '@scure/bip39/wordlists/czech';\nimport { wordlist as english } from '@scure/bip39/wordlists/english';\nimport { wordlist as french } from '@scure/bip39/wordlists/french';\nimport { wordlist as italian } from '@scure/bip39/wordlists/italian';\nimport { wordlist as japanese } from '@scure/bip39/wordlists/japanese';\nimport { wordlist as korean } from '@scure/bip39/wordlists/korean';\nimport { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';\nimport { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';\nimport { wordlist as spanish } from '@scure/bip39/wordlists/spanish';\nimport { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';\n```\n */\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { sha256, sha512 } from '@noble/hashes/sha2';\nimport { abytes, anumber, randomBytes } from '@noble/hashes/utils';\nimport { utils as baseUtils } from '@scure/base';\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError('invalid mnemonic type: ' + typeof str);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction aentropy(ent) {\n    abytes(ent, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function generateMnemonic(wordlist, strength = 128) {\n    anumber(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic(randomBytes(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([(sha256(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Wordlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error('wordlist: non-string element: ' + i);\n    });\n    return baseUtils.chain(baseUtils.checksum(1, calcChecksum), baseUtils.radix2(11, true), baseUtils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase) => nfkd('mnemonic' + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeed(mnemonic, passphrase = '') {\n    return pbkdf2Async(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return pbkdf2(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n"],
  "mappings": "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",
  "names": ["c", "i", "h", "u", "v", "diff", "j", "calcPatch", "base64", "n", "m", "i", "a", "e", "o", "s", "m", "i", "v", "g", "n", "a", "r", "f", "p", "d", "ok", "t", "err", "Result", "fromThrowable", "f", "e", "ok", "_", "v", "err", "LogLevel", "_a", "_b", "i", "a", "n", "entries", "_a", "n", "a", "n", "a", "c", "alphabet", "l", "i", "d", "padding", "n", "e", "alphabet", "s", "alphabet", "i", "c", "v", "alphabet", "s", "i", "e", "crypto", "agent", "crypto", "a", "_a", "_b", "_", "g", "_a", "a", "e", "co", "_a", "_b", "crypto", "_a", "_b", "e", "a", "co", "v", "isCompatible", "diag", "_a", "err", "_b", "DiagComponentLogger", "logger", "DiagLogLevel", "logger", "DiagAPI", "logger", "__spreadArray", "__read", "self", "err", "_a", "_b", "BaggageImpl", "_a", "_b", "__read", "v", "__values", "BaseContext", "self", "context", "NoopMeter", "NoopMetric", "NoopCounterMetric", "NoopUpDownCounterMetric", "NoopGaugeMetric", "NoopHistogramMetric", "NoopObservableMetric", "NoopObservableCounterMetric", "NoopObservableGaugeMetric", "NoopObservableUpDownCounterMetric", "ValueType", "NoopContextManager", "__spreadArray", "__read", "API_NAME", "ContextAPI", "context", "_a", "__spreadArray", "__read", "TraceFlags", "NonRecordingSpan", "context", "_a", "NoopTracer", "context", "ProxyTracer", "context", "NoopTracerProvider", "ProxyTracerProvider", "_a", "SamplingDecision", "SpanKind", "SpanStatusCode", "TraceStateImpl", "i", "diag", "NoopMeterProvider", "API_NAME", "MetricsAPI", "NoopTextMapPropagator", "context", "context", "API_NAME", "PropagationAPI", "context", "API_NAME", "TraceAPI", "_a", "e", "getIsUploaded", "_a", "a", "id", "e", "_a", "promise", "syncState", "_a", "crypto", "e", "Deferred", "constructor", "this", "promise", "Promise", "resolve", "reject", "value", "reason", "t", "e", "Item", "data", "prev", "next", "FastList", "_head", "_tail", "length", "prototype", "push", "pop", "undefined", "unshift", "shift", "h", "item", "n", "slice", "m", "Error", "len", "ret", "Array", "i", "drop", "call", "forEach", "fn", "thisp", "p", "map", "v", "me", "filter", "reduce", "val", "module", "_Symbol$iterator", "_list", "_classPrivateFieldLooseKey", "_reversed", "Symbol", "iterator", "Buffer", "limit", "Infinity", "Object", "defineProperty", "writable", "_classPrivateFieldLooseBase", "fastList", "enqueue", "list", "dequeue", "clear", "f", "reverse", "done", "static", "iterable", "buffer", "doneResult", "freeze", "fromDom", "init", "type", "target", "options", "adapter", "listener", "event", "addEventListener", "wrap", "removeEventListener", "fromEmitter", "emitter", "addListener", "removeListener", "_Symbol$asyncIterator", "asyncIterator", "Channel", "closed", "pushBuffer", "pullBuffer", "defer", "result", "close", "_Symbol$asyncIterator$2", "async", "onReturn", "_this", "return", "Multicast", "receivers", "Set", "balancer", "_Symbol$asyncIterator$1", "producer", "add", "onStart", "size", "delete", "onStop", "LastResult", "resolved", "requested", "trace", "v", "import_fast_myers_diff", "crypto", "isBytes", "a", "anumber", "n", "h", "i", "n", "i", "u", "_", "i", "a", "randomBytes", "crypto", "i", "isLE", "_32n", "h", "l", "a", "c", "i", "n", "i", "h", "l", "h", "s", "l", "l", "i", "n", "isBytes", "a", "abytes", "isArrayOf", "afn", "astr", "anumber", "n", "aArr", "astrArr", "anumArr", "chain", "c", "alphabet", "l", "i", "join", "padding", "normalize", "convertRadix", "d", "gcd", "radix2carry", "powers", "convertRadix2", "radix", "radix2", "unsafeWrapper", "e", "base16", "base32", "base32nopad", "base32hex", "base32hexnopad", "base32crockford", "s", "base64", "base64nopad", "base64url", "base64urlnopad", "genBase58", "base58", "base58flickr", "base58xrp", "BECH_ALPHABET", "chain", "alphabet", "join", "POLYMOD_GENERATORS", "bech32Polymod", "i", "bechChecksum", "c", "v", "convertRadix2", "powers", "genBech32", "radix2", "unsafeWrapper", "astr", "isBytes", "anumArr", "bech32", "bech32m", "hasHexBuiltin", "abytes", "s", "astr", "hex", "chain", "radix2", "alphabet", "join", "normalize", "normalize", "i", "normalize", "_a", "_b", "key", "crypto", "account", "creationProps", "context", "v", "i", "RawAccount", "loadCoValue", "ref", "subscription", "e", "Group", "error", "message", "_CoMap", "rawEdit", "_Account", "LocalNode", "connectedPeers", "cojsonInternals", "_CoFeed", "rawEntry", "_CoList", "_", "_Group", "isAccountID", "calcPatch", "w", "a", "authenticate"]
}
