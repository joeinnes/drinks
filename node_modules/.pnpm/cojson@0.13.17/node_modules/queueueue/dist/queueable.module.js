class t{constructor(){this.promise=void 0,this.promise=new Promise((t,e)=>{this.resolve=e=>(t(e),this.promise),this.reject=t=>(e(t),this.promise)})}}var e=0;function r(t){return"__private_"+e+++"_"+t}function s(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}var i,n,h=(i=function(t,e){!function(){function e(t,e,r){this.next=r,r&&(r.prev=this),this.prev=e,e&&(e.next=this),this.data=t}function r(){if(!(this instanceof r))return new r;this._head=null,this._tail=null,this.length=0}r.prototype={push:function(t){this._tail=new e(t,this._tail,null),this._head||(this._head=this._tail),this.length++},pop:function(){if(0!==this.length){var t=this._tail;return this._tail=t.prev,t.prev&&(t.prev=this._tail.next=null),this.length--,1===this.length?this._head=this._tail:0===this.length&&(this._head=this._tail=null),t.data}},unshift:function(t){this._head=new e(t,null,this._head),this._tail||(this._tail=this._head),this.length++},shift:function(){if(0!==this.length){var t=this._head;return this._head=t.next,t.next&&(t.next=this._head.prev=null),this.length--,1===this.length?this._tail=this._head:0===this.length&&(this._head=this._tail=null),t.data}},item:function(t){t<0&&(t=this.length+t);for(var e=this._head;t-- >0&&e;)e=e.next;return e?e.data:void 0},slice:function(t,e){if(t||(t=0),e||(e=this.length),e<0&&(e=this.length+e),t<0&&(t=this.length+t),e===t)return[];if(e<t)throw new Error("invalid offset: "+t+","+e+" (length="+this.length+")");for(var r=e-t,s=new Array(r),i=0,n=this._head;t-- >0&&n;)n=n.next;for(;i<r&&n;)s[i++]=n.data,n=n.next;return s},drop:function(){r.call(this)},forEach:function(t,e){for(var r=this._head,s=0,i=this.length;s<i&&r;)t.call(e||this,r.data,s,this),r=r.next,s++},map:function(t,e){var s=new r;return this.forEach(function(r,i,n){s.push(t.call(e||n,r,i,n))}),s},filter:function(t,e){var s=new r;return this.forEach(function(r,i,n){t.call(e||n,r,i,n)&&s.push(r)}),s},reduce:function(t,e,r){var s=0,i=this._head,n=this.length;for(e||(s=1,e=i&&i.data,i=i&&i.next);s<n&&i;)e=t.call(r||this,e,i.data,this),s++,i=i.next;return e}},t.exports=r}()},i(n={exports:{}}),n.exports);let o;var u=/*#__PURE__*/r("list"),l=/*#__PURE__*/r("reversed");o=Symbol.iterator;class a{constructor(t=Infinity){this.limit=void 0,Object.defineProperty(this,u,{writable:!0,value:void 0}),Object.defineProperty(this,l,{writable:!0,value:!1}),this.length=0,this.limit=t,s(this,u)[u]=new h}enqueue(t){const e=s(this,u)[u];e.length===this.limit?e.shift():this.length+=1,e.push(t)}dequeue(){if(0===this.length)throw Error("Buffer is empty");return this.length-=1,s(this,l)[l]?s(this,u)[u].pop():s(this,u)[u].shift()}clear(){this.length=0,s(this,u)[u].drop()}forEach(t){s(this,u)[u].forEach(t)}reverse(){return s(this,l)[l]=!0,this}[o](){return{next:()=>this.length>0?{value:this.dequeue(),done:!1}:{done:!0,value:void 0},[Symbol.iterator](){return this}}}static from(t,e){const r=new a(e);for(const e of t)r.enqueue(e);return r}}const c=Object.freeze({value:void 0,done:!0});Promise.resolve(c);const f=t=>(e,r,s)=>{const i=t(),n=t=>{i.push(t)};return r.addEventListener(e,n,s),i.wrap(()=>r.removeEventListener(e,n,s))},d=t=>(e,r)=>{const s=t(),i=t=>{s.push(t)};return r.addListener(e,i),s.wrap(()=>{r.removeListener(e,i)})};let p,v,m;p=Symbol.asyncIterator;class w{constructor(t=Infinity){this.pushBuffer=void 0,this.pullBuffer=void 0,this.closed=!1,this.pushBuffer=new a(t),this.pullBuffer=new a(t)}next(){if(this.closed)return Promise.resolve(c);if(0===this.pushBuffer.length){const e=new t;return this.pullBuffer.enqueue(e),e.promise}const{result:e,defer:r}=this.pushBuffer.dequeue();return r.resolve(e),e.done&&this.close(),r.promise}push(e,r=!1){if(this.closed)return Promise.resolve(c);const s={value:e,done:r};if(this.pullBuffer.length>0)return this.pullBuffer.dequeue().resolve(s);const i=new t;return this.pushBuffer.enqueue({result:s,defer:i}),i.promise}[p](){return this}return(t){try{return this.close(),Promise.resolve({done:!0,value:t})}catch(t){return Promise.reject(t)}}close(){this.closed||(this.closed=!0,this.pushBuffer.forEach(({defer:{resolve:t}})=>{t(c)}),this.pushBuffer.clear(),this.pullBuffer.forEach(({resolve:t})=>{t(c)}),this.pullBuffer.clear())}wrap(t){const e=this;if(this.closed)throw Error("Balancer is closed");return{[Symbol.asyncIterator](){return this},next:()=>this.next(),return:function(r){try{return t&&t(),Promise.resolve(e.return(r))}catch(t){return Promise.reject(t)}}}}}w.fromDom=f(()=>new w),w.fromEmitter=d(()=>new w),v=Symbol.asyncIterator;class _{constructor(t=(()=>new w)){this.init=void 0,this.receivers=new Set,this.init=t}push(t){return this.receivers.forEach(e=>e.push(t)),this}[v](){const t=this.init(),{receivers:e}=this;return e.add(t),this.onStart&&1===e.size&&this.onStart(),t.wrap(()=>{e.delete(t),this.onStop&&0===e.size&&this.onStop()})}}m=Symbol.asyncIterator;class g{constructor(){this.buffer=new t,this.closed=!1,this.resolved=!1,this.requested=!1}push(e,r=!1){if(this.closed)throw Error("Iterator closed");const s={value:e,done:r};return!1===this.resolved?this.resolved=!0:(this.buffer=new t,this.resolved=!1),this.requested=!1,this.buffer.resolve(s),this.buffer.promise}next(){try{const t=this;return t.closed?Promise.resolve(c):(t.requested=!0,Promise.resolve(t.buffer.promise))}catch(t){return Promise.reject(t)}}return(t){try{const e=this;return e.closed=!0,!e.resolved&&e.requested&&e.buffer.resolve(c),Promise.resolve({value:t,done:!0})}catch(t){return Promise.reject(t)}}wrap(t){return{next:()=>this.next(),[Symbol.asyncIterator](){return this},return:e=>(t&&t(),this.return(e))}}[m](){return this}}g.fromDom=f(()=>new g),g.fromEmitter=d(()=>new g);export{a as Buffer,w as Channel,t as Deferred,g as LastResult,_ as Multicast,f as fromDom,d as fromEmitter};
//# sourceMappingURL=queueable.module.js.map
