import { combinedKnownStates, emptyKnownState, } from "./sync.js";
export class PeerKnownStates {
    constructor() {
        this.coValues = new Map();
        this.listeners = new Set();
    }
    updateHeader(id, header) {
        const knownState = this.coValues.get(id) ?? emptyKnownState(id);
        knownState.header = header;
        this.coValues.set(id, knownState);
        this.triggerUpdate(id);
    }
    combineWith(id, value) {
        const knownState = this.coValues.get(id) ?? emptyKnownState(id);
        this.coValues.set(id, combinedKnownStates(knownState, value));
        this.triggerUpdate(id);
    }
    updateSessionCounter(id, sessionId, value) {
        const knownState = this.coValues.get(id) ?? emptyKnownState(id);
        const currentValue = knownState.sessions[sessionId] || 0;
        knownState.sessions[sessionId] = Math.max(currentValue, value);
        this.coValues.set(id, knownState);
        this.triggerUpdate(id);
    }
    set(id, knownState) {
        this.coValues.set(id, knownState === "empty" ? emptyKnownState(id) : knownState);
        this.triggerUpdate(id);
    }
    get(id) {
        return this.coValues.get(id);
    }
    has(id) {
        return this.coValues.has(id);
    }
    clone() {
        const clone = new PeerKnownStates();
        clone.coValues = new Map(this.coValues);
        return clone;
    }
    triggerUpdate(id) {
        this.trigger(id, this.coValues.get(id) ?? emptyKnownState(id));
    }
    trigger(id, knownState) {
        for (const listener of this.listeners) {
            listener(id, knownState);
        }
    }
    subscribe(listener) {
        this.listeners.add(listener);
        return () => {
            this.listeners.delete(listener);
        };
    }
}
//# sourceMappingURL=PeerKnownStates.js.map