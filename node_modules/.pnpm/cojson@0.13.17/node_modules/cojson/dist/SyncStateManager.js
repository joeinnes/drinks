import { emptyKnownState, } from "./sync.js";
export class SyncStateManager {
    constructor(syncManager) {
        this.syncManager = syncManager;
        this.listeners = new Set();
        this.listenersByPeers = new Map();
    }
    subscribeToUpdates(listener) {
        this.listeners.add(listener);
        return () => {
            this.listeners.delete(listener);
        };
    }
    subscribeToPeerUpdates(peerId, listener) {
        const listeners = this.listenersByPeers.get(peerId) ?? new Set();
        if (listeners.size === 0) {
            this.listenersByPeers.set(peerId, listeners);
        }
        listeners.add(listener);
        return () => {
            listeners.delete(listener);
        };
    }
    getCurrentSyncState(peerId, id) {
        // Build a lazy sync state object to process the isUploaded info
        // only when requested
        const syncState = {};
        const getIsUploaded = () => this.getIsCoValueFullyUploadedIntoPeer(peerId, id);
        Object.defineProperties(syncState, {
            uploaded: {
                enumerable: true,
                get: getIsUploaded,
            },
        });
        return syncState;
    }
    triggerUpdate(peerId, id) {
        const peer = this.syncManager.peers[peerId];
        if (!peer) {
            return;
        }
        const peerListeners = this.listenersByPeers.get(peer.id);
        // If we don't have any active listeners do nothing
        if (!peerListeners?.size && !this.listeners.size) {
            return;
        }
        const knownState = peer.knownStates.get(id) ?? emptyKnownState(id);
        const syncState = this.getCurrentSyncState(peerId, id);
        for (const listener of this.listeners) {
            listener(peerId, knownState, syncState);
        }
        if (!peerListeners)
            return;
        for (const listener of peerListeners) {
            listener(knownState, syncState);
        }
    }
    getKnownStateSessions(peerId, id) {
        const peer = this.syncManager.peers[peerId];
        if (!peer) {
            return undefined;
        }
        const peerSessions = peer.knownStates.get(id)?.sessions;
        if (!peerSessions) {
            return undefined;
        }
        const entry = this.syncManager.local.coValuesStore.get(id);
        if (!entry.isAvailable()) {
            return undefined;
        }
        const coValue = entry.core;
        const coValueSessions = coValue.knownState().sessions;
        return {
            peer: peerSessions,
            coValue: coValueSessions,
        };
    }
    getIsCoValueFullyUploadedIntoPeer(peerId, id) {
        const sessions = this.getKnownStateSessions(peerId, id);
        if (!sessions) {
            return false;
        }
        return getIsUploaded(sessions.coValue, sessions.peer);
    }
}
function getIsUploaded(from, to) {
    for (const sessionId of Object.keys(from)) {
        if (from[sessionId] !== to[sessionId]) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=SyncStateManager.js.map