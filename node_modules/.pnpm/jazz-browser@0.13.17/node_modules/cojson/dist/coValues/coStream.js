import { base64URLtoBytes, bytesToBase64url } from "../base64url.js";
import { logger } from "../logger.js";
import { accountOrAgentIDfromSessionID } from "../typeUtils/accountOrAgentIDfromSessionID.js";
import { isAccountID } from "../typeUtils/isAccountID.js";
import { isCoValue } from "../typeUtils/isCoValue.js";
export class RawCoStreamView {
    constructor(core) {
        this.type = "costream";
        this.totalValidTransactions = 0;
        this.id = core.id;
        this.core = core;
        this.items = {};
        this.knownTransactions = {};
        this.processNewTransactions();
    }
    get headerMeta() {
        return this.core.header.meta;
    }
    get group() {
        return this.core.getGroup();
    }
    /** Not yet implemented */
    atTime(_time) {
        throw new Error("Not yet implemented");
    }
    /** @internal */
    compareStreamItems(a, b) {
        return (a.madeAt - b.madeAt ||
            (a.tx.sessionID === b.tx.sessionID
                ? 0
                : a.tx.sessionID < b.tx.sessionID
                    ? -1
                    : 1) ||
            a.tx.txIndex - b.tx.txIndex);
    }
    /** @internal */
    processNewTransactions() {
        const changeEntries = new Set();
        const newValidTransactions = this.core.getValidTransactions({
            ignorePrivateTransactions: false,
            knownTransactions: this.knownTransactions,
        });
        if (newValidTransactions.length === 0) {
            return;
        }
        for (const { txID, madeAt, changes } of newValidTransactions) {
            this.totalValidTransactions++;
            for (const changeUntyped of changes) {
                const change = changeUntyped;
                let entries = this.items[txID.sessionID];
                if (!entries) {
                    entries = [];
                    this.items[txID.sessionID] = entries;
                }
                entries.push({ value: change, madeAt, tx: txID });
                changeEntries.add(entries);
            }
            this.knownTransactions[txID.sessionID] = Math.max(this.knownTransactions[txID.sessionID] ?? 0, txID.txIndex);
        }
        for (const entries of changeEntries) {
            entries.sort(this.compareStreamItems);
        }
    }
    getSingleStream() {
        const streams = Object.values(this.items);
        const firstStream = streams[0];
        if (!firstStream) {
            return undefined;
        }
        if (streams.length > 1) {
            throw new Error("CoStream.getSingleStream() can only be called when there is exactly one stream");
        }
        return firstStream.map((item) => item.value);
    }
    sessions() {
        return Object.keys(this.items);
    }
    accounts() {
        return new Set(this.sessions().map(accountOrAgentIDfromSessionID).filter(isAccountID));
    }
    nthItemIn(sessionID, n) {
        const items = this.items[sessionID];
        if (!items)
            return;
        const item = items[n];
        if (!item)
            return;
        return {
            by: accountOrAgentIDfromSessionID(sessionID),
            tx: item.tx,
            at: new Date(item.madeAt),
            value: item.value,
        };
    }
    lastItemIn(sessionID) {
        const items = this.items[sessionID];
        if (!items)
            return;
        return this.nthItemIn(sessionID, items.length - 1);
    }
    *itemsIn(sessionID) {
        const items = this.items[sessionID];
        if (!items)
            return;
        for (const item of items) {
            yield {
                by: accountOrAgentIDfromSessionID(sessionID),
                tx: item.tx,
                at: new Date(item.madeAt),
                value: item.value,
            };
        }
    }
    lastItemBy(account) {
        let latestItem;
        for (const sessionID of Object.keys(this.items)) {
            if (sessionID.startsWith(account)) {
                const item = this.lastItemIn(sessionID);
                if (!item)
                    continue;
                if (!latestItem || item.at > latestItem.at) {
                    latestItem = {
                        by: item.by,
                        tx: item.tx,
                        at: item.at,
                        value: item.value,
                    };
                }
            }
        }
        return latestItem;
    }
    *itemsBy(account) {
        // TODO: this can be made more lazy without a huge collect and sort
        const items = [
            ...Object.keys(this.items).flatMap((sessionID) => sessionID.startsWith(account)
                ? [...this.itemsIn(sessionID)].map((item) => ({
                    in: sessionID,
                    ...item,
                }))
                : []),
        ];
        items.sort((a, b) => a.at.getTime() - b.at.getTime());
        for (const item of items) {
            yield item;
        }
    }
    toJSON() {
        return Object.fromEntries(Object.entries(this.items).map(([sessionID, items]) => [
            sessionID,
            items.map((item) => item.value),
        ]));
    }
    subscribe(listener) {
        return this.core.subscribe((content) => {
            listener(content);
        });
    }
}
export class RawCoStream extends RawCoStreamView {
    push(item, privacy = "private") {
        this.core.makeTransaction([isCoValue(item) ? item.id : item], privacy);
        this.processNewTransactions();
    }
}
const binary_U_prefixLength = 8; // "binary_U".length;
export class RawBinaryCoStreamView extends RawCoStreamView {
    isBinaryStreamEnded() {
        const items = this.getSingleStream();
        if (!items || items.length === 0) {
            return false;
        }
        const lastItem = items[items.length - 1];
        return lastItem?.type === "end";
    }
    getBinaryChunks(allowUnfinished) {
        const items = this.getSingleStream();
        // No active streams
        if (!items)
            return;
        const start = items[0];
        if (start?.type !== "start") {
            logger.error("Invalid binary stream start", start);
            return;
        }
        const end = items[items.length - 1];
        if (end?.type !== "end" && !allowUnfinished)
            return;
        const chunks = [];
        let finished = false;
        for (const item of items.slice(1)) {
            if (item.type === "end") {
                finished = true;
                break;
            }
            if (item.type !== "chunk") {
                logger.error("Invalid binary stream chunk", item);
                return undefined;
            }
            const chunk = base64URLtoBytes(item.chunk.slice(binary_U_prefixLength));
            chunks.push(chunk);
        }
        return {
            mimeType: start.mimeType,
            fileName: start.fileName,
            totalSizeBytes: start.totalSizeBytes,
            chunks,
            finished,
        };
    }
}
export class RawBinaryCoStream extends RawBinaryCoStreamView {
    /** @internal */
    push(item, privacy = "private", updateView = true) {
        this.core.makeTransaction([item], privacy);
        if (updateView) {
            this.processNewTransactions();
        }
    }
    startBinaryStream(settings, privacy = "private") {
        this.push({
            type: "start",
            ...settings,
        }, privacy, false);
    }
    pushBinaryStreamChunk(chunk, privacy = "private") {
        this.push({
            type: "chunk",
            chunk: `binary_U${bytesToBase64url(chunk)}`,
        }, privacy, false);
    }
    endBinaryStream(privacy = "private") {
        this.push({
            type: "end",
        }, privacy, true);
    }
}
//# sourceMappingURL=coStream.js.map