import { PeerState } from "./PeerState.js";
import { SyncStateManager } from "./SyncStateManager.js";
import { CoValueHeader, Transaction } from "./coValueCore.js";
import { CoValueCore } from "./coValueCore.js";
import { Signature } from "./crypto/crypto.js";
import { RawCoID, SessionID } from "./ids.js";
import { LocalNode } from "./localNode.js";
import { CoValuePriority } from "./priority.js";
export type CoValueKnownState = {
    id: RawCoID;
    header: boolean;
    sessions: {
        [sessionID: SessionID]: number;
    };
};
export declare function emptyKnownState(id: RawCoID): CoValueKnownState;
export type SyncMessage = LoadMessage | KnownStateMessage | NewContentMessage | DoneMessage;
export type LoadMessage = {
    action: "load";
} & CoValueKnownState;
export type KnownStateMessage = {
    action: "known";
    isCorrection?: boolean;
    asDependencyOf?: RawCoID;
} & CoValueKnownState;
export type NewContentMessage = {
    action: "content";
    id: RawCoID;
    header?: CoValueHeader;
    priority: CoValuePriority;
    new: {
        [sessionID: SessionID]: SessionNewContent;
    };
};
export type SessionNewContent = {
    after: number;
    newTransactions: Transaction[];
    lastSignature: Signature;
};
export type DoneMessage = {
    action: "done";
    id: RawCoID;
};
export type PeerID = string;
export type DisconnectedError = "Disconnected";
export type PingTimeoutError = "PingTimeout";
export type IncomingSyncStream = AsyncIterable<SyncMessage | DisconnectedError | PingTimeoutError>;
export type OutgoingSyncQueue = {
    push: (msg: SyncMessage) => Promise<unknown>;
    close: () => void;
};
export interface Peer {
    id: PeerID;
    incoming: IncomingSyncStream;
    outgoing: OutgoingSyncQueue;
    role: "server" | "client" | "storage";
    priority?: number;
    crashOnClose: boolean;
    deletePeerStateOnClose?: boolean;
}
export declare function combinedKnownStates(stateA: CoValueKnownState, stateB: CoValueKnownState): CoValueKnownState;
export declare class SyncManager {
    peers: {
        [key: PeerID]: PeerState;
    };
    local: LocalNode;
    peersCounter: import("@opentelemetry/api").UpDownCounter<import("@opentelemetry/api").Attributes>;
    private transactionsSizeHistogram;
    constructor(local: LocalNode);
    syncState: SyncStateManager;
    peersInPriorityOrder(): PeerState[];
    getPeers(): PeerState[];
    getServerAndStoragePeers(excludePeerId?: PeerID): PeerState[];
    handleSyncMessage(msg: SyncMessage, peer: PeerState): void;
    sendNewContentIncludingDependencies(id: RawCoID, peer: PeerState): void;
    startPeerReconciliation(peer: PeerState): void;
    addPeer(peer: Peer): Promise<void>;
    trySendToPeer(peer: PeerState, msg: SyncMessage): void;
    /**
     * Handles the load message from a peer.
     *
     * Differences with the known state message:
     * - The load message triggers the CoValue loading process on the other peer
     * - The peer known state is stored as-is instead of being merged
     * - The load message always replies with a known state message
     */
    handleLoad(msg: LoadMessage, peer: PeerState): void;
    handleKnownState(msg: KnownStateMessage, peer: PeerState): void;
    recordTransactionsSize(newTransactions: Transaction[], source: string): void;
    handleNewContent(msg: NewContentMessage, peer: PeerState): void;
    handleCorrection(msg: KnownStateMessage, peer: PeerState): void;
    handleUnsubscribe(_msg: DoneMessage): void;
    requestedSyncs: Map<`co_z${string}`, Promise<void>>;
    requestCoValueSync(coValue: CoValueCore): Promise<void>;
    syncCoValue(coValue: CoValueCore): Promise<void>;
    waitForSyncWithPeer(peerId: PeerID, id: RawCoID, timeout: number): Promise<unknown>;
    waitForSync(id: RawCoID, timeout?: number): Promise<unknown[]>;
    waitForAllCoValuesSync(timeout?: number): Promise<unknown[][]>;
    gracefulShutdown(): void;
}
//# sourceMappingURL=sync.d.ts.map