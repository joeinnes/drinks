import { blake3_empty_state, blake3_hash_once, blake3_hash_once_with_context, decrypt, encrypt, get_sealer_id, get_signer_id, initialize, new_ed25519_signing_key, new_x25519_private_key, seal, sign, unseal, verify, } from "jazz-crypto-rs";
import { base64URLtoBytes, bytesToBase64url } from "../base64url.js";
import { stableStringify } from "../jsonStringify.js";
import { logger } from "../logger.js";
import { PureJSCrypto } from "./PureJSCrypto.js";
import { CryptoProvider, textDecoder, textEncoder, } from "./crypto.js";
/**
 * WebAssembly implementation of the CryptoProvider interface using jazz-crypto-rs.
 * This provides the primary implementation using WebAssembly for optimal performance, offering:
 * - Signing/verifying (Ed25519)
 * - Encryption/decryption (XSalsa20)
 * - Sealing/unsealing (X25519 + XSalsa20-Poly1305)
 * - Hashing (BLAKE3)
 */
export class WasmCrypto extends CryptoProvider {
    constructor() {
        super();
    }
    static async create() {
        try {
            await initialize();
        }
        catch (e) {
            logger.warn("Failed to initialize WasmCrypto, falling back to PureJSCrypto", { err: e });
            return new PureJSCrypto();
        }
        return new WasmCrypto();
    }
    emptyBlake3State() {
        return blake3_empty_state();
    }
    cloneBlake3State(state) {
        return state.clone();
    }
    blake3HashOnce(data) {
        return blake3_hash_once(data);
    }
    blake3HashOnceWithContext(data, { context }) {
        return blake3_hash_once_with_context(data, context);
    }
    blake3IncrementalUpdate(state, data) {
        state.update(data);
        return state;
    }
    blake3DigestForState(state) {
        return state.finalize();
    }
    newEd25519SigningKey() {
        return new_ed25519_signing_key();
    }
    getSignerID(secret) {
        return get_signer_id(textEncoder.encode(secret));
    }
    sign(secret, message) {
        return sign(textEncoder.encode(stableStringify(message)), textEncoder.encode(secret));
    }
    verify(signature, message, id) {
        return verify(textEncoder.encode(signature), textEncoder.encode(stableStringify(message)), textEncoder.encode(id));
    }
    newX25519StaticSecret() {
        return new_x25519_private_key();
    }
    getSealerID(secret) {
        return get_sealer_id(textEncoder.encode(secret));
    }
    encrypt(value, keySecret, nOnceMaterial) {
        return `encrypted_U${bytesToBase64url(encrypt(textEncoder.encode(stableStringify(value)), keySecret, textEncoder.encode(stableStringify(nOnceMaterial))))}`;
    }
    decryptRaw(encrypted, keySecret, nOnceMaterial) {
        return textDecoder.decode(decrypt(base64URLtoBytes(encrypted.substring("encrypted_U".length)), keySecret, textEncoder.encode(stableStringify(nOnceMaterial))));
    }
    seal({ message, from, to, nOnceMaterial, }) {
        return `sealed_U${bytesToBase64url(seal(textEncoder.encode(stableStringify(message)), from, to, textEncoder.encode(stableStringify(nOnceMaterial))))}`;
    }
    unseal(sealed, sealer, from, nOnceMaterial) {
        const plaintext = textDecoder.decode(unseal(base64URLtoBytes(sealed.substring("sealed_U".length)), sealer, from, textEncoder.encode(stableStringify(nOnceMaterial))));
        try {
            return JSON.parse(plaintext);
        }
        catch (e) {
            logger.error("Failed to decrypt/parse sealed message", { err: e });
            return undefined;
        }
    }
}
//# sourceMappingURL=WasmCrypto.js.map