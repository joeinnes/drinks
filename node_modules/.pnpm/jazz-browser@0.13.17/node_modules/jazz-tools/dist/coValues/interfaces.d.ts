import type { CoValueUniqueness, CojsonInternalTypes, RawCoValue } from "cojson";
import { AnonymousJazzAgent } from "../implementation/anonymousJazzAgent.js";
import { inspect } from "../internal.js";
import { type Account } from "./account.js";
import { RefsToResolve, RefsToResolveStrict, Resolved } from "./deepLoading.js";
import { type Group } from "./group.js";
/** @category Abstract interfaces */
export interface CoValueClass<Value extends CoValue = CoValue> {
    /** @ignore */
    new (...args: any[]): Value;
}
export interface CoValueFromRaw<V extends CoValue> {
    fromRaw(raw: V["_raw"]): V;
}
/** @category Abstract interfaces */
export interface CoValue {
    /** @category Content */
    readonly id: ID<this>;
    /** @category Type Helpers */
    _type: string;
    /** @category Collaboration */
    _owner: Account | Group;
    /** @category Internals */
    _raw: RawCoValue;
    /** @internal */
    readonly _loadedAs: Account | AnonymousJazzAgent;
    /** @category Stringifying & Inspection */
    toJSON(key?: string, seenAbove?: ID<CoValue>[]): any[] | object | string;
    /** @category Stringifying & Inspection */
    [inspect](): any;
}
export declare function isCoValue(value: any): value is CoValue;
export declare function isCoValueClass<V extends CoValue>(value: any): value is CoValueClass<V> & CoValueFromRaw<V>;
/**
 * IDs are unique identifiers for `CoValue`s.
 * Can be used with a type argument to refer to a specific `CoValue` type.
 *
 * @example
 *
 * ```ts
 * type AccountID = ID<Account>;
 * ```
 *
 * @category CoValues
 */
export type ID<T> = CojsonInternalTypes.RawCoID & IDMarker<T>;
type IDMarker<out T> = {
    __type(_: never): T;
};
/** @internal */
export declare class CoValueBase implements CoValue {
    id: ID<this>;
    _type: string;
    _raw: RawCoValue;
    /** @category Internals */
    _instanceID: string;
    get _owner(): Account | Group;
    /** @private */
    get _loadedAs(): Account | AnonymousJazzAgent;
    constructor(..._args: any);
    /** @category Internals */
    static fromRaw<V extends CoValue>(this: CoValueClass<V>, raw: RawCoValue): V;
    toJSON(): object | any[] | string;
    [inspect](): string | object | any[];
    /** @category Type Helpers */
    castAs<Cl extends CoValueClass & CoValueFromRaw<CoValue>>(cl: Cl): InstanceType<Cl>;
}
export declare function loadCoValueWithoutMe<V extends CoValue, const R extends RefsToResolve<V>>(cls: CoValueClass<V>, id: ID<CoValue>, options?: {
    resolve?: RefsToResolveStrict<V, R>;
    loadAs?: Account | AnonymousJazzAgent;
}): Promise<Resolved<V, R> | null>;
export declare function loadCoValue<V extends CoValue, const R extends RefsToResolve<V>>(cls: CoValueClass<V>, id: ID<CoValue>, options: {
    resolve?: RefsToResolveStrict<V, R>;
    loadAs: Account | AnonymousJazzAgent;
}): Promise<Resolved<V, R> | null>;
export declare function ensureCoValueLoaded<V extends CoValue, const R extends RefsToResolve<V>>(existing: V, options?: {
    resolve?: RefsToResolveStrict<V, R>;
} | undefined): Promise<Resolved<V, R>>;
type SubscribeListener<V extends CoValue, R extends RefsToResolve<V>> = (value: Resolved<V, R>, unsubscribe: () => void) => void;
export type SubscribeListenerOptions<V extends CoValue, R extends RefsToResolve<V>> = {
    resolve?: RefsToResolveStrict<V, R>;
    loadAs?: Account | AnonymousJazzAgent;
    onUnauthorized?: () => void;
    onUnavailable?: () => void;
};
export type SubscribeRestArgs<V extends CoValue, R extends RefsToResolve<V>> = [options: SubscribeListenerOptions<V, R>, listener: SubscribeListener<V, R>] | [listener: SubscribeListener<V, R>];
export declare function parseSubscribeRestArgs<V extends CoValue, R extends RefsToResolve<V>>(args: SubscribeRestArgs<V, R>): {
    options: SubscribeListenerOptions<V, R>;
    listener: SubscribeListener<V, R>;
};
export declare function subscribeToCoValueWithoutMe<V extends CoValue, const R extends RefsToResolve<V>>(cls: CoValueClass<V>, id: ID<CoValue>, options: SubscribeListenerOptions<V, R>, listener: SubscribeListener<V, R>): () => void;
export declare function subscribeToCoValue<V extends CoValue, const R extends RefsToResolve<V>>(cls: CoValueClass<V>, id: ID<CoValue>, options: {
    resolve?: RefsToResolveStrict<V, R>;
    loadAs: Account | AnonymousJazzAgent;
    onUnavailable?: () => void;
    onUnauthorized?: (errorPath: string[]) => void;
    syncResolution?: boolean;
}, listener: SubscribeListener<V, R>): () => void;
export declare function createCoValueObservable<V extends CoValue, const R extends RefsToResolve<V>>(initialValue?: undefined | null): {
    getCurrentValue: () => Resolved<V, R> | null | undefined;
    subscribe: (cls: CoValueClass<V>, id: ID<CoValue>, options: {
        loadAs: Account | AnonymousJazzAgent;
        resolve?: RefsToResolveStrict<V, R>;
        onUnavailable?: () => void;
        onUnauthorized?: () => void;
        syncResolution?: boolean;
    }, listener: () => void) => () => void;
};
export declare function subscribeToExistingCoValue<V extends CoValue, const R extends RefsToResolve<V>>(existing: V, options: {
    resolve?: RefsToResolveStrict<V, R>;
    onUnavailable?: () => void;
    onUnauthorized?: () => void;
} | undefined, listener: SubscribeListener<V, R>): () => void;
export declare function isAccountInstance(instance: unknown): instance is Account;
export declare function isAnonymousAgentInstance(instance: unknown): instance is AnonymousJazzAgent;
export declare function parseCoValueCreateOptions(options: {
    owner?: Account | Group;
    unique?: CoValueUniqueness["uniqueness"];
} | Account | Group | undefined): {
    owner: Account | Group;
    uniqueness: {
        uniqueness: string | number | true | import("cojson").JsonObject | import("cojson").JsonValue[] | readonly import("cojson").JsonValue[];
    } | undefined;
};
export declare function parseGroupCreateOptions(options: {
    owner?: Account;
} | Account | undefined): {
    owner: Account;
};
export {};
//# sourceMappingURL=interfaces.d.ts.map