import { Result } from "neverthrow";
import { AnyRawCoValue, RawCoValue } from "./coValue.js";
import { ControlledAccountOrAgent } from "./coValues/account.js";
import { RawGroup } from "./coValues/group.js";
import { CryptoProvider, Encrypted, Hash, KeyID, KeySecret, Signature, SignerID, StreamingHash } from "./crypto/crypto.js";
import { RawCoID, SessionID, TransactionID } from "./ids.js";
import { Stringified } from "./jsonStringify.js";
import { JsonObject, JsonValue } from "./jsonValue.js";
import { LocalNode, ResolveAccountAgentError } from "./localNode.js";
import { PermissionsDef as RulesetDef } from "./permissions.js";
import { CoValueKnownState, NewContentMessage } from "./sync.js";
/**
    In order to not block other concurrently syncing CoValues we introduce a maximum size of transactions,
    since they are the smallest unit of progress that can be synced within a CoValue.
    This is particularly important for storing binary data in CoValues, since they are likely to be at least on the order of megabytes.
    This also means that we want to keep signatures roughly after each MAX_RECOMMENDED_TX size chunk,
    to be able to verify partially loaded CoValues or CoValues that are still being created (like a video live stream).
**/
export declare const MAX_RECOMMENDED_TX_SIZE: number;
export type CoValueHeader = {
    type: AnyRawCoValue["type"];
    ruleset: RulesetDef;
    meta: JsonObject | null;
} & CoValueUniqueness;
export type CoValueUniqueness = {
    uniqueness: JsonValue;
    createdAt?: `2${string}` | null;
};
export declare function idforHeader(header: CoValueHeader, crypto: CryptoProvider): RawCoID;
type SessionLog = {
    transactions: Transaction[];
    lastHash?: Hash;
    streamingHash: StreamingHash;
    signatureAfter: {
        [txIdx: number]: Signature | undefined;
    };
    lastSignature: Signature;
};
export type PrivateTransaction = {
    privacy: "private";
    madeAt: number;
    keyUsed: KeyID;
    encryptedChanges: Encrypted<JsonValue[], {
        in: RawCoID;
        tx: TransactionID;
    }>;
};
export type TrustingTransaction = {
    privacy: "trusting";
    madeAt: number;
    changes: Stringified<JsonValue[]>;
};
export type Transaction = PrivateTransaction | TrustingTransaction;
export type DecryptedTransaction = {
    txID: TransactionID;
    changes: JsonValue[];
    madeAt: number;
};
export declare class CoValueCore {
    id: RawCoID;
    node: LocalNode;
    crypto: CryptoProvider;
    header: CoValueHeader;
    _sessionLogs: Map<SessionID, SessionLog>;
    _cachedContent?: RawCoValue;
    listeners: Set<(content?: RawCoValue) => void>;
    _decryptionCache: {
        [key: Encrypted<JsonValue[], JsonValue>]: JsonValue[] | undefined;
    };
    _cachedKnownState?: CoValueKnownState;
    _cachedDependentOn?: RawCoID[];
    _cachedNewContentSinceEmpty?: NewContentMessage[] | undefined;
    _currentAsyncAddTransaction?: Promise<void>;
    constructor(header: CoValueHeader, node: LocalNode, internalInitSessions?: Map<SessionID, SessionLog>);
    groupInvalidationSubscription?: () => void;
    subscribeToGroupInvalidation(): void;
    get sessionLogs(): Map<SessionID, SessionLog>;
    testWithDifferentAccount(account: ControlledAccountOrAgent, currentSessionID: SessionID): CoValueCore;
    knownState(): CoValueKnownState;
    /** @internal */
    knownStateUncached(): CoValueKnownState;
    get meta(): JsonValue;
    nextTransactionID(): TransactionID;
    tryAddTransactions(sessionID: SessionID, newTransactions: Transaction[], givenExpectedNewHash: Hash | undefined, newSignature: Signature, skipVerify?: boolean, givenNewStreamingHash?: StreamingHash): Result<true, TryAddTransactionsError>;
    private doAddTransactions;
    deferredUpdates: number;
    nextDeferredNotify: Promise<void> | undefined;
    notifyUpdate(notifyMode: "immediate" | "deferred"): void;
    subscribe(listener: (content?: RawCoValue) => void, immediateInvoke?: boolean): () => void;
    expectedNewHashAfter(sessionID: SessionID, newTransactions: Transaction[]): {
        expectedNewHash: Hash;
        newStreamingHash: StreamingHash;
    };
    makeTransaction(changes: JsonValue[], privacy: "private" | "trusting"): boolean;
    getCurrentContent(options?: {
        ignorePrivateTransactions: true;
    }): RawCoValue;
    getValidTransactions(options?: {
        ignorePrivateTransactions: boolean;
        knownTransactions?: CoValueKnownState["sessions"];
    }): DecryptedTransaction[];
    getValidSortedTransactions(options?: {
        ignorePrivateTransactions: boolean;
        knownTransactions: CoValueKnownState["sessions"];
    }): DecryptedTransaction[];
    compareTransactions(a: Pick<DecryptedTransaction, "madeAt" | "txID">, b: Pick<DecryptedTransaction, "madeAt" | "txID">): number;
    getCurrentReadKey(): {
        secret: KeySecret | undefined;
        id: KeyID;
    };
    getReadKey(keyID: KeyID): KeySecret | undefined;
    getUncachedReadKey(keyID: KeyID): KeySecret | undefined;
    findValidParentKeys(keyID: KeyID, group: RawGroup, parentGroup: CoValueCore): {
        id: KeyID;
        secret: KeySecret;
    }[];
    getGroup(): RawGroup;
    getTx(txID: TransactionID): Transaction | undefined;
    newContentSince(knownState: CoValueKnownState | undefined): NewContentMessage[] | undefined;
    getDependedOnCoValues(): RawCoID[];
    /** @internal */
    getDependedOnCoValuesUncached(): RawCoID[];
    waitForSync(options?: {
        timeout?: number;
    }): Promise<unknown[]>;
}
export type InvalidHashError = {
    type: "InvalidHash";
    id: RawCoID;
    expectedNewHash: Hash;
    givenExpectedNewHash: Hash;
};
export type InvalidSignatureError = {
    type: "InvalidSignature";
    id: RawCoID;
    newSignature: Signature;
    sessionID: SessionID;
    signerID: SignerID;
};
export type TryAddTransactionsError = ResolveAccountAgentError | InvalidHashError | InvalidSignatureError;
export {};
//# sourceMappingURL=coValueCore.d.ts.map