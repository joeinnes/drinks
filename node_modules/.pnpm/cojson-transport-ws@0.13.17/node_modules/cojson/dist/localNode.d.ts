import { Result, ResultAsync } from "neverthrow";
import { CoValuesStore } from "./CoValuesStore.js";
import { CoID } from "./coValue.js";
import { RawCoValue } from "./coValue.js";
import { CoValueCore, CoValueHeader, CoValueUniqueness } from "./coValueCore.js";
import { AccountMeta, ControlledAccountOrAgent, InvalidAccountAgentIDError, RawAccountID, RawAccountMigration, RawControlledAccount, RawProfile } from "./coValues/account.js";
import { InviteSecret, RawGroup } from "./coValues/group.js";
import { AgentSecret, CryptoProvider } from "./crypto/crypto.js";
import { AgentID, RawCoID, SessionID } from "./ids.js";
import { Peer, PeerID, SyncManager } from "./sync.js";
/** A `LocalNode` represents a local view of a set of loaded `CoValue`s, from the perspective of a particular account (or primitive cryptographic agent).

A `LocalNode` can have peers that it syncs to, for example some form of local persistence, or a sync server, such as `cloud.jazz.tools` (Jazz Cloud).

@example
You typically get hold of a `LocalNode` using `jazz-react`'s `useJazz()`:

```typescript
const { localNode } = useJazz();
```
*/
export declare class LocalNode {
    /** @internal */
    crypto: CryptoProvider;
    /** @internal */
    coValuesStore: CoValuesStore;
    /** @category 3. Low-level */
    account: ControlledAccountOrAgent;
    /** @category 3. Low-level */
    currentSessionID: SessionID;
    /** @category 3. Low-level */
    syncManager: SyncManager;
    crashed: Error | undefined;
    /** @category 3. Low-level */
    constructor(account: ControlledAccountOrAgent, currentSessionID: SessionID, crypto: CryptoProvider);
    /** @category 2. Node Creation */
    static withNewlyCreatedAccount<Meta extends AccountMeta = AccountMeta>({ creationProps, peersToLoadFrom, migration, crypto, initialAgentSecret, }: {
        creationProps: {
            name: string;
        };
        peersToLoadFrom?: Peer[];
        migration?: RawAccountMigration<Meta>;
        crypto: CryptoProvider;
        initialAgentSecret?: AgentSecret;
    }): Promise<{
        node: LocalNode;
        accountID: RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID;
    }>;
    /** @category 2. Node Creation */
    static withLoadedAccount<Meta extends AccountMeta = AccountMeta>({ accountID, accountSecret, sessionID, peersToLoadFrom, crypto, migration, }: {
        accountID: RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID | undefined;
        peersToLoadFrom: Peer[];
        crypto: CryptoProvider;
        migration?: RawAccountMigration<Meta>;
    }): Promise<LocalNode>;
    /** @internal */
    createCoValue(header: CoValueHeader): CoValueCore;
    /** @internal */
    loadCoValueCore(id: RawCoID, skipLoadingFromPeer?: PeerID): Promise<CoValueCore | "unavailable">;
    /**
     * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
     * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
     * for listening to subsequent updates to the CoValue.
     *
     * @category 3. Low-level
     */
    load<T extends RawCoValue>(id: CoID<T>): Promise<T | "unavailable">;
    getLoaded<T extends RawCoValue>(id: CoID<T>): T | undefined;
    /** @category 3. Low-level */
    subscribe<T extends RawCoValue>(id: CoID<T>, callback: (update: T | "unavailable") => void): () => void;
    /** @deprecated Use Account.acceptInvite instead */
    acceptInvite<T extends RawCoValue>(groupOrOwnedValueID: CoID<T>, inviteSecret: InviteSecret): Promise<void>;
    /** @internal */
    expectCoValueLoaded(id: RawCoID, expectation?: string): CoValueCore;
    /** @internal */
    expectProfileLoaded(id: RawAccountID, expectation?: string): RawProfile;
    /** @internal */
    createAccount(agentSecret?: `sealerSecret_z${string}/signerSecret_z${string}`): RawControlledAccount;
    /** @internal */
    resolveAccountAgent(id: RawAccountID | AgentID, expectation?: string): Result<AgentID, ResolveAccountAgentError>;
    resolveAccountAgentAsync(id: RawAccountID | AgentID, expectation?: string): ResultAsync<AgentID, ResolveAccountAgentError>;
    /**
     * @deprecated use Account.createGroup() instead
     */
    createGroup(uniqueness?: CoValueUniqueness): RawGroup;
    /** @internal */
    testWithDifferentAccount(account: ControlledAccountOrAgent, currentSessionID: SessionID): LocalNode;
    gracefulShutdown(): void;
}
export type LoadCoValueCoreError = {
    type: "ErrorLoadingCoValueCore";
    error: unknown;
    expectation?: string;
    id: RawAccountID;
};
export type AccountUnavailableFromAllPeersError = {
    type: "AccountUnavailableFromAllPeers";
    expectation?: string;
    id: RawAccountID;
};
export type UnexpectedlyNotAccountError = {
    type: "UnexpectedlyNotAccount";
    expectation?: string;
    id: RawAccountID;
};
export type ResolveAccountAgentError = InvalidAccountAgentIDError | LoadCoValueCoreError | AccountUnavailableFromAllPeersError | UnexpectedlyNotAccountError;
//# sourceMappingURL=localNode.d.ts.map