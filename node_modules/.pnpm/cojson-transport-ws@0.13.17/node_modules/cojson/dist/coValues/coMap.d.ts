import { CoID, RawCoValue } from "../coValue.js";
import { CoValueCore } from "../coValueCore.js";
import { AgentID, TransactionID } from "../ids.js";
import { JsonObject, JsonValue } from "../jsonValue.js";
import { CoValueKnownState } from "../sync.js";
import { RawAccountID } from "./account.js";
import type { RawGroup } from "./group.js";
type MapOp<K extends string, V extends JsonValue | undefined> = {
    txID: TransactionID;
    madeAt: number;
    changeIdx: number;
    change: MapOpPayload<K, V>;
};
export type MapOpPayload<K extends string, V extends JsonValue | undefined> = {
    op: "set";
    key: K;
    value: V;
} | {
    op: "del";
    key: K;
};
export declare class RawCoMapView<Shape extends {
    [key: string]: JsonValue | undefined;
} = {
    [key: string]: JsonValue | undefined;
}, Meta extends JsonObject | null = JsonObject | null> implements RawCoValue {
    /** @category 6. Meta */
    id: CoID<this>;
    /** @category 6. Meta */
    type: "comap";
    /** @category 6. Meta */
    core: CoValueCore;
    /** @internal */
    latest: {
        [Key in keyof Shape & string]?: MapOp<Key, Shape[Key]>;
    };
    /** @internal */
    latestTxMadeAt: number;
    /** @internal */
    ops: {
        [Key in keyof Shape & string]?: MapOp<Key, Shape[Key]>[];
    };
    /** @internal */
    knownTransactions: CoValueKnownState["sessions"];
    /** @internal */
    ignorePrivateTransactions: boolean;
    /** @internal */
    atTimeFilter?: number;
    /** @category 6. Meta */
    readonly _shape: Shape;
    totalValidTransactions: number;
    /** @internal */
    constructor(core: CoValueCore, options?: {
        ignorePrivateTransactions: boolean;
    });
    processNewTransactions(): void;
    isTimeTravelEntity(): boolean;
    /** @category 6. Meta */
    get headerMeta(): Meta;
    /** @category 6. Meta */
    get group(): RawGroup;
    /** @category 4. Time travel */
    atTime(time: number): this;
    /** @internal */
    timeFilteredOps<K extends keyof Shape & string>(key: K): MapOp<K, Shape[K]>[] | undefined;
    /**
     * Get all keys currently in the map.
     *
     * @category 1. Reading */
    keys<K extends keyof Shape & string = keyof Shape & string>(): K[];
    getRaw<K extends keyof Shape & string>(key: K): ({ [Key in keyof Shape & string]?: MapOp<Key, Shape[Key]> | undefined; }[K] & {}) | undefined;
    /**
     * Returns the current value for the given key.
     *
     * @category 1. Reading
     **/
    get<K extends keyof Shape & string>(key: K): Shape[K] | undefined;
    /** @category 1. Reading */
    asObject(): {
        [K in keyof Shape & string]: Shape[K];
    };
    /** @category 1. Reading */
    toJSON(): {
        [K in keyof Shape & string]: Shape[K];
    };
    /** @category 5. Edit history */
    nthEditAt<K extends keyof Shape & string>(key: K, n: number): {
        by: RawAccountID | `sealer_z${string}/signer_z${string}`;
        tx: TransactionID;
        at: Date;
        value: Shape[K] | undefined;
    } | undefined;
    /** @category 5. Edit history */
    lastEditAt<K extends keyof Shape & string>(key: K): {
        by: RawAccountID | AgentID;
        tx: TransactionID;
        at: Date;
        value?: Shape[K];
    } | undefined;
    /** @category 5. Edit history */
    editsAt<K extends keyof Shape & string>(key: K): Generator<{
        by: RawAccountID | `sealer_z${string}/signer_z${string}`;
        tx: TransactionID;
        at: Date;
        value: Shape[K] | undefined;
    }, void, unknown>;
    /** @category 3. Subscription */
    subscribe(listener: (coMap: this) => void): () => void;
}
/** A collaborative map with precise shape `Shape` and optional static metadata `Meta` */
export declare class RawCoMap<Shape extends {
    [key: string]: JsonValue | undefined;
} = {
    [key: string]: JsonValue | undefined;
}, Meta extends JsonObject | null = JsonObject | null> extends RawCoMapView<Shape, Meta> implements RawCoValue {
    /** Set a new value for the given key.
     *
     * If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
     *
     * If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
     *
     * @category 2. Editing
     **/
    set<K extends keyof Shape & string>(key: K, value: Shape[K], privacy?: "private" | "trusting"): void;
    assign(entries: Partial<Shape>, privacy?: "private" | "trusting"): void;
    /** Delete the given key (setting it to undefined).
     *
     * If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
     *
     * If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
     *
     * @category 2. Editing
     **/
    delete(key: keyof Shape & string, privacy?: "private" | "trusting"): void;
}
export declare function operationToEditEntry<K extends string, V extends JsonValue | undefined>(op: MapOp<K, V>): {
    by: RawAccountID | `sealer_z${string}/signer_z${string}`;
    tx: TransactionID;
    at: Date;
    value: V | undefined;
};
export {};
//# sourceMappingURL=coMap.d.ts.map