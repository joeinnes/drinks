import { RawAccountID } from "../coValues/account.js";
import { AgentID, RawCoID, TransactionID } from "../ids.js";
import { SessionID } from "../ids.js";
import { Stringified } from "../jsonStringify.js";
import { JsonValue } from "../jsonValue.js";
export type SignerSecret = `signerSecret_z${string}`;
export type SignerID = `signer_z${string}`;
export type Signature = `signature_z${string}`;
export type SealerSecret = `sealerSecret_z${string}`;
export type SealerID = `sealer_z${string}`;
export type Sealed<T> = `sealed_U${string}` & {
    __type: T;
};
export type AgentSecret = `${SealerSecret}/${SignerSecret}`;
export declare const textEncoder: import("util").TextEncoder;
export declare const textDecoder: import("util").TextDecoder;
export declare abstract class CryptoProvider<Blake3State = any> {
    randomBytes(length: number): Uint8Array;
    abstract newEd25519SigningKey(): Uint8Array;
    newRandomSigner(): SignerSecret;
    signerSecretToBytes(secret: SignerSecret): Uint8Array;
    signerSecretFromBytes(bytes: Uint8Array): SignerSecret;
    abstract getSignerID(secret: SignerSecret): SignerID;
    abstract sign(secret: SignerSecret, message: JsonValue): Signature;
    abstract verify(signature: Signature, message: JsonValue, id: SignerID): boolean;
    abstract newX25519StaticSecret(): Uint8Array;
    newRandomSealer(): SealerSecret;
    sealerSecretToBytes(secret: SealerSecret): Uint8Array;
    sealerSecretFromBytes(bytes: Uint8Array): SealerSecret;
    abstract getSealerID(secret: SealerSecret): SealerID;
    newRandomAgentSecret(): AgentSecret;
    agentSecretToBytes(secret: AgentSecret): Uint8Array;
    agentSecretFromBytes(bytes: Uint8Array): AgentSecret;
    getAgentID(secret: AgentSecret): AgentID;
    getAgentSignerID(agentId: AgentID): SignerID;
    getAgentSignerSecret(agentSecret: AgentSecret): SignerSecret;
    getAgentSealerID(agentId: AgentID): SealerID;
    getAgentSealerSecret(agentSecret: AgentSecret): SealerSecret;
    abstract emptyBlake3State(): Blake3State;
    abstract cloneBlake3State(state: Blake3State): Blake3State;
    abstract blake3HashOnce(data: Uint8Array): Uint8Array;
    abstract blake3HashOnceWithContext(data: Uint8Array, { context }: {
        context: Uint8Array;
    }): Uint8Array;
    abstract blake3IncrementalUpdate(state: Blake3State, data: Uint8Array): Blake3State;
    abstract blake3DigestForState(state: Blake3State): Uint8Array;
    secureHash(value: JsonValue): Hash;
    shortHash(value: JsonValue): ShortHash;
    abstract encrypt<T extends JsonValue, N extends JsonValue>(value: T, keySecret: KeySecret, nOnceMaterial: N): Encrypted<T, N>;
    encryptForTransaction<T extends JsonValue>(value: T, keySecret: KeySecret, nOnceMaterial: {
        in: RawCoID;
        tx: TransactionID;
    }): Encrypted<T, {
        in: RawCoID;
        tx: TransactionID;
    }>;
    abstract decryptRaw<T extends JsonValue, N extends JsonValue>(encrypted: Encrypted<T, N>, keySecret: KeySecret, nOnceMaterial: N): Stringified<T>;
    decrypt<T extends JsonValue, N extends JsonValue>(encrypted: Encrypted<T, N>, keySecret: KeySecret, nOnceMaterial: N): T | undefined;
    newRandomKeySecret(): {
        secret: KeySecret;
        id: KeyID;
    };
    decryptRawForTransaction<T extends JsonValue>(encrypted: Encrypted<T, {
        in: RawCoID;
        tx: TransactionID;
    }>, keySecret: KeySecret, nOnceMaterial: {
        in: RawCoID;
        tx: TransactionID;
    }): Stringified<T> | undefined;
    decryptForTransaction<T extends JsonValue>(encrypted: Encrypted<T, {
        in: RawCoID;
        tx: TransactionID;
    }>, keySecret: KeySecret, nOnceMaterial: {
        in: RawCoID;
        tx: TransactionID;
    }): T | undefined;
    encryptKeySecret(keys: {
        toEncrypt: {
            id: KeyID;
            secret: KeySecret;
        };
        encrypting: {
            id: KeyID;
            secret: KeySecret;
        };
    }): {
        encryptedID: KeyID;
        encryptingID: KeyID;
        encrypted: Encrypted<KeySecret, {
            encryptedID: KeyID;
            encryptingID: KeyID;
        }>;
    };
    decryptKeySecret(encryptedInfo: {
        encryptedID: KeyID;
        encryptingID: KeyID;
        encrypted: Encrypted<KeySecret, {
            encryptedID: KeyID;
            encryptingID: KeyID;
        }>;
    }, sealingSecret: KeySecret): KeySecret | undefined;
    abstract seal<T extends JsonValue>({ message, from, to, nOnceMaterial, }: {
        message: T;
        from: SealerSecret;
        to: SealerID;
        nOnceMaterial: {
            in: RawCoID;
            tx: TransactionID;
        };
    }): Sealed<T>;
    abstract unseal<T extends JsonValue>(sealed: Sealed<T>, sealer: SealerSecret, from: SealerID, nOnceMaterial: {
        in: RawCoID;
        tx: TransactionID;
    }): T | undefined;
    uniquenessForHeader(): `z${string}`;
    createdNowUnique(): {
        createdAt: `2${string}`;
        uniqueness: `z${string}`;
    };
    newRandomSecretSeed(): Uint8Array;
    agentSecretFromSecretSeed(secretSeed: Uint8Array): AgentSecret;
    newRandomSessionID(accountID: RawAccountID | AgentID): SessionID;
}
export type Hash = `hash_z${string}`;
export declare class StreamingHash {
    state: Uint8Array;
    crypto: CryptoProvider;
    constructor(crypto: CryptoProvider, fromClone?: Uint8Array);
    update(value: JsonValue): Uint8Array;
    digest(): Hash;
    clone(): StreamingHash;
}
export type ShortHash = `shortHash_z${string}`;
export declare const shortHashLength = 19;
export type Encrypted<T extends JsonValue, N extends JsonValue> = `encrypted_U${string}` & {
    __type: T;
    __nOnceMaterial: N;
};
export type KeySecret = `keySecret_z${string}`;
export type KeyID = `key_z${string}`;
export declare const secretSeedLength = 32;
//# sourceMappingURL=crypto.d.ts.map