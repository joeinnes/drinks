import { MAX_RECOMMENDED_TX_SIZE, cojsonInternals, emptyKnownState, logger, } from "cojson";
import { collectNewTxs, getDependedOnCoValues } from "./syncUtils.js";
export class SyncManager {
    constructor(dbClient, toLocalNode) {
        this.toLocalNode = toLocalNode;
        this.dbClient = dbClient;
    }
    async handleSyncMessage(msg) {
        switch (msg.action) {
            case "load":
                await this.handleLoad(msg);
                break;
            case "content":
                await this.handleContent(msg);
                break;
            case "known":
                await this.handleKnown(msg);
                break;
            case "done":
                await this.handleDone(msg);
                break;
        }
    }
    async handleSessionUpdate({ sessionRow, peerKnownState, newContentMessages, }) {
        if (sessionRow.lastIdx <= (peerKnownState.sessions[sessionRow.sessionID] || 0))
            return;
        const firstNewTxIdx = peerKnownState.sessions[sessionRow.sessionID] || 0;
        const newTxsInSession = await this.dbClient.getNewTransactionInSession(sessionRow.rowID, firstNewTxIdx);
        collectNewTxs({
            newTxsInSession,
            newContentMessages,
            sessionRow,
            firstNewTxIdx,
        });
    }
    async sendNewContent(coValueKnownState) {
        const outputMessages = await this.collectCoValueData(coValueKnownState);
        // reverse it to send the top level id the last in the order
        const collectedMessages = Object.values(outputMessages).reverse();
        for (const { knownMessage, contentMessages } of collectedMessages) {
            this.sendStateMessage(knownMessage);
            if (contentMessages?.length) {
                for (const msg of contentMessages) {
                    this.sendStateMessage(msg);
                }
            }
        }
    }
    async collectCoValueData(peerKnownState, messageMap = {}, asDependencyOf) {
        if (messageMap[peerKnownState.id]) {
            return messageMap;
        }
        const coValueRow = await this.dbClient.getCoValue(peerKnownState.id);
        if (!coValueRow) {
            const emptyKnownMessage = {
                action: "known",
                ...emptyKnownState(peerKnownState.id),
            };
            if (asDependencyOf) {
                emptyKnownMessage.asDependencyOf = asDependencyOf;
            }
            messageMap[peerKnownState.id] = { knownMessage: emptyKnownMessage };
            return messageMap;
        }
        const allCoValueSessions = await this.dbClient.getCoValueSessions(coValueRow.rowID);
        const newCoValueKnownState = {
            id: coValueRow.id,
            header: true,
            sessions: {},
        };
        const newContentMessages = [
            {
                action: "content",
                id: coValueRow.id,
                header: coValueRow.header,
                new: {},
                priority: cojsonInternals.getPriorityFromHeader(coValueRow.header),
            },
        ];
        await Promise.all(allCoValueSessions.map((sessionRow) => {
            newCoValueKnownState.sessions[sessionRow.sessionID] =
                sessionRow.lastIdx;
            // Collect new sessions data into newContentMessages
            return this.handleSessionUpdate({
                sessionRow,
                peerKnownState,
                newContentMessages,
            });
        }));
        const dependedOnCoValuesList = getDependedOnCoValues({
            coValueRow,
            newContentMessages,
        });
        const knownMessage = {
            action: "known",
            ...newCoValueKnownState,
        };
        if (asDependencyOf) {
            knownMessage.asDependencyOf = asDependencyOf;
        }
        messageMap[newCoValueKnownState.id] = {
            knownMessage: knownMessage,
            contentMessages: newContentMessages,
        };
        await Promise.all(dependedOnCoValuesList.map((dependedOnCoValue) => this.collectCoValueData({
            id: dependedOnCoValue,
            header: false,
            sessions: {},
        }, messageMap, asDependencyOf || coValueRow.id)));
        return messageMap;
    }
    handleLoad(msg) {
        return this.sendNewContent(msg);
    }
    async handleContent(msg) {
        const coValueRow = await this.dbClient.getCoValue(msg.id);
        // We have no info about coValue header
        const invalidAssumptionOnHeaderPresence = !msg.header && !coValueRow;
        if (invalidAssumptionOnHeaderPresence) {
            return this.sendStateMessage({
                action: "known",
                id: msg.id,
                header: false,
                sessions: {},
                isCorrection: true,
            });
        }
        const storedCoValueRowID = coValueRow
            ? coValueRow.rowID
            : await this.dbClient.addCoValue(msg);
        const ourKnown = {
            id: msg.id,
            header: true,
            sessions: {},
        };
        let invalidAssumptions = false;
        for (const sessionID of Object.keys(msg.new)) {
            await this.dbClient.transaction(async () => {
                const sessionRow = await this.dbClient.getSingleCoValueSession(storedCoValueRowID, sessionID);
                if (sessionRow) {
                    ourKnown.sessions[sessionRow.sessionID] = sessionRow.lastIdx;
                }
                if ((sessionRow?.lastIdx || 0) < (msg.new[sessionID]?.after || 0)) {
                    invalidAssumptions = true;
                }
                else {
                    return this.putNewTxs(msg, sessionID, sessionRow, storedCoValueRowID);
                }
            });
        }
        if (invalidAssumptions) {
            this.sendStateMessage({
                action: "known",
                ...ourKnown,
                isCorrection: invalidAssumptions,
            });
        }
    }
    async putNewTxs(msg, sessionID, sessionRow, storedCoValueRowID) {
        const newTransactions = msg.new[sessionID]?.newTransactions || [];
        const actuallyNewOffset = (sessionRow?.lastIdx || 0) - (msg.new[sessionID]?.after || 0);
        const actuallyNewTransactions = newTransactions.slice(actuallyNewOffset);
        let newBytesSinceLastSignature = (sessionRow?.bytesSinceLastSignature || 0) +
            actuallyNewTransactions.reduce((sum, tx) => sum +
                (tx.privacy === "private"
                    ? tx.encryptedChanges.length
                    : tx.changes.length), 0);
        const newLastIdx = (sessionRow?.lastIdx || 0) + actuallyNewTransactions.length;
        let shouldWriteSignature = false;
        if (newBytesSinceLastSignature > MAX_RECOMMENDED_TX_SIZE) {
            shouldWriteSignature = true;
            newBytesSinceLastSignature = 0;
        }
        const nextIdx = sessionRow?.lastIdx || 0;
        if (!msg.new[sessionID])
            throw new Error("Session ID not found");
        const sessionUpdate = {
            coValue: storedCoValueRowID,
            sessionID,
            lastIdx: newLastIdx,
            lastSignature: msg.new[sessionID].lastSignature,
            bytesSinceLastSignature: newBytesSinceLastSignature,
        };
        const sessionRowID = await this.dbClient.addSessionUpdate({
            sessionUpdate,
            sessionRow,
        });
        if (shouldWriteSignature) {
            await this.dbClient.addSignatureAfter({
                sessionRowID,
                idx: newLastIdx - 1,
                signature: msg.new[sessionID].lastSignature,
            });
        }
        return Promise.all(actuallyNewTransactions.map((newTransaction, i) => this.dbClient.addTransaction(sessionRowID, nextIdx + i, newTransaction)));
    }
    handleKnown(_msg) {
        // We don't intend to use the storage (SQLite,IDB,etc.) itself as a synchronisation mechanism, so we can ignore the known messages
    }
    handleDone(_msg) { }
    async sendStateMessage(msg) {
        return this.toLocalNode.push(msg).catch((e) => logger.error(`Error sending ${msg.action} state, id ${msg.id}`, {
            err: e,
        }));
    }
}
//# sourceMappingURL=syncManager.js.map