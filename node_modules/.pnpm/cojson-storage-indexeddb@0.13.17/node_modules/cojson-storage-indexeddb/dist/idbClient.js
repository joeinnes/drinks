import { CoJsonIDBTransaction } from "./CoJsonIDBTransaction.js";
export class IDBClient {
    constructor(db) {
        this.db = db;
    }
    makeRequest(handler) {
        if (this.activeTransaction) {
            return this.activeTransaction.handleRequest(handler);
        }
        if (this.autoBatchingTransaction?.isReusable()) {
            return this.autoBatchingTransaction.handleRequest(handler);
        }
        const tx = new CoJsonIDBTransaction(this.db);
        this.autoBatchingTransaction = tx;
        return tx.handleRequest(handler);
    }
    async getCoValue(coValueId) {
        return this.makeRequest((tx) => tx.getObjectStore("coValues").index("coValuesById").get(coValueId));
    }
    async getCoValueSessions(coValueRowId) {
        return this.makeRequest((tx) => tx
            .getObjectStore("sessions")
            .index("sessionsByCoValue")
            .getAll(coValueRowId));
    }
    async getSingleCoValueSession(coValueRowId, sessionID) {
        return this.makeRequest((tx) => tx
            .getObjectStore("sessions")
            .index("uniqueSessions")
            .get([coValueRowId, sessionID]));
    }
    async getNewTransactionInSession(sessionRowId, firstNewTxIdx) {
        return this.makeRequest((tx) => tx
            .getObjectStore("transactions")
            .getAll(IDBKeyRange.bound([sessionRowId, firstNewTxIdx], [sessionRowId, Number.POSITIVE_INFINITY])));
    }
    async getSignatures(sessionRowId, firstNewTxIdx) {
        return this.makeRequest((tx) => tx
            .getObjectStore("signatureAfter")
            .getAll(IDBKeyRange.bound([sessionRowId, firstNewTxIdx], [sessionRowId, Number.POSITIVE_INFINITY])));
    }
    async addCoValue(msg) {
        if (!msg.header) {
            throw new Error(`Header is required, coId: ${msg.id}`);
        }
        return (await this.makeRequest((tx) => tx.getObjectStore("coValues").put({
            id: msg.id,
            // biome-ignore lint/style/noNonNullAssertion: TODO(JAZZ-561): Review
            header: msg.header,
        })));
    }
    async addSessionUpdate({ sessionUpdate, sessionRow, }) {
        return this.makeRequest((tx) => tx.getObjectStore("sessions").put(sessionRow?.rowID
            ? {
                rowID: sessionRow.rowID,
                ...sessionUpdate,
            }
            : sessionUpdate));
    }
    async addTransaction(sessionRowID, idx, newTransaction) {
        await this.makeRequest((tx) => tx.getObjectStore("transactions").add({
            ses: sessionRowID,
            idx,
            tx: newTransaction,
        }));
    }
    async addSignatureAfter({ sessionRowID, idx, signature, }) {
        return this.makeRequest((tx) => tx.getObjectStore("signatureAfter").put({
            ses: sessionRowID,
            idx,
            signature,
        }));
    }
    closeTransaction(tx) {
        tx.commit();
        if (tx === this.activeTransaction) {
            this.activeTransaction = undefined;
        }
    }
    async transaction(operationsCallback) {
        const tx = new CoJsonIDBTransaction(this.db);
        this.activeTransaction = tx;
        try {
            await operationsCallback();
            tx.commit(); // Tells the browser to not wait for another possible request and commit the transaction immediately
        }
        finally {
            this.activeTransaction = undefined;
        }
    }
}
//# sourceMappingURL=idbClient.js.map