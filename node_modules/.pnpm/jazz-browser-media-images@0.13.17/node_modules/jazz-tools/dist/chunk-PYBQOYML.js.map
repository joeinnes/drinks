{"version":3,"sources":["../src/implementation/activeAccountContext.ts","../src/implementation/anonymousJazzAgent.ts","../src/coValues/interfaces.ts","../src/implementation/inspect.ts","../src/implementation/symbols.ts","../src/coValues/deepLoading.ts","../src/implementation/refs.ts","../src/lib/cache.ts","../src/implementation/schema.ts","../src/implementation/subscriptionScope.ts","../src/implementation/createContext.ts","../src/coValues/registeredSchemas.ts","../src/implementation/devtoolsFormatters.ts","../src/coValues/inbox.ts","../src/coValues/coMap.ts","../src/coValues/profile.ts","../src/coValues/account.ts","../src/coValues/coFeed.ts","../src/coValues/coList.ts","../src/coValues/group.ts","../src/coValues/coPlainText.ts","../src/coValues/coRichText.ts","../src/coValues/extensions/imageDef.ts","../src/coValues/schemaUnion.ts","../src/auth/KvStoreContext.ts","../src/auth/AuthSecretStorage.ts","../src/auth/InMemoryKVStore.ts","../src/implementation/ContextManager.ts","../src/auth/DemoAuth.ts","../src/auth/PassphraseAuth.ts","../src/implementation/invites.ts"],"sourcesContent":["import type { Account } from \"../coValues/account.js\";\n\nclass ActiveAccountContext {\n  private activeAccount: Account | null = null;\n  private guestMode: boolean = false;\n\n  set(account: Account | null) {\n    this.activeAccount = account;\n    this.guestMode = false;\n  }\n\n  setGuestMode() {\n    this.activeAccount = null;\n    this.guestMode = true;\n  }\n\n  maybeGet() {\n    return this.activeAccount;\n  }\n\n  get() {\n    if (!this.activeAccount) {\n      if (this.guestMode) {\n        throw new Error(\n          \"Something that expects a full active account was called in guest mode.\",\n        );\n      }\n\n      throw new Error(\"No active account\");\n    }\n\n    return this.activeAccount;\n  }\n}\n\nexport type { ActiveAccountContext };\n\nexport const activeAccountContext = new ActiveAccountContext();\n","import { LocalNode } from \"cojson\";\n\nexport class AnonymousJazzAgent {\n  _type = \"Anonymous\" as const;\n  constructor(public node: LocalNode) {}\n}\n","import type {\n  CoValueUniqueness,\n  CojsonInternalTypes,\n  RawCoValue,\n} from \"cojson\";\nimport { RawAccount } from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport { AnonymousJazzAgent } from \"../implementation/anonymousJazzAgent.js\";\nimport {\n  Ref,\n  SubscriptionScope,\n  inspect,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\nimport { type Account } from \"./account.js\";\nimport {\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  fulfillsDepth,\n} from \"./deepLoading.js\";\nimport { type Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\n/** @category Abstract interfaces */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface CoValueClass<Value extends CoValue = CoValue> {\n  /** @ignore */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]): Value;\n}\n\nexport interface CoValueFromRaw<V extends CoValue> {\n  fromRaw(raw: V[\"_raw\"]): V;\n}\n\n/** @category Abstract interfaces */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface CoValue {\n  /** @category Content */\n  readonly id: ID<this>;\n  /** @category Type Helpers */\n  _type: string;\n  /** @category Collaboration */\n  _owner: Account | Group;\n  /** @category Internals */\n  _raw: RawCoValue;\n  /** @internal */\n  readonly _loadedAs: Account | AnonymousJazzAgent;\n  /** @category Stringifying & Inspection */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(key?: string, seenAbove?: ID<CoValue>[]): any[] | object | string;\n  /** @category Stringifying & Inspection */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [inspect](): any;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isCoValue(value: any): value is CoValue {\n  return value && value._type !== undefined;\n}\n\nexport function isCoValueClass<V extends CoValue>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n): value is CoValueClass<V> & CoValueFromRaw<V> {\n  return typeof value === \"function\" && value.fromRaw !== undefined;\n}\n\n/**\n * IDs are unique identifiers for `CoValue`s.\n * Can be used with a type argument to refer to a specific `CoValue` type.\n *\n * @example\n *\n * ```ts\n * type AccountID = ID<Account>;\n * ```\n *\n * @category CoValues\n */\nexport type ID<T> = CojsonInternalTypes.RawCoID & IDMarker<T>;\n\ntype IDMarker<out T> = { __type(_: never): T };\n\n/** @internal */\nexport class CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: string;\n  declare _raw: RawCoValue;\n  /** @category Internals */\n  declare _instanceID: string;\n\n  get _owner(): Account | Group {\n    const owner =\n      this._raw.group instanceof RawAccount\n        ? RegisteredSchemas[\"Account\"].fromRaw(this._raw.group)\n        : RegisteredSchemas[\"Group\"].fromRaw(this._raw.group);\n\n    const subScope = subscriptionsScopes.get(this);\n    if (subScope) {\n      subScope.onRefAccessedOrSet(this.id, owner.id);\n      subscriptionsScopes.set(owner, subScope);\n    }\n\n    return owner;\n  }\n\n  /** @private */\n  get _loadedAs() {\n    const rawAccount = this._raw.core.node.account;\n\n    if (rawAccount instanceof RawAccount) {\n      return coValuesCache.get(rawAccount, () =>\n        RegisteredSchemas[\"Account\"].fromRaw(rawAccount),\n      );\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(..._args: any) {\n    Object.defineProperty(this, \"_instanceID\", {\n      value: `instance-${Math.random().toString(36).slice(2)}`,\n      enumerable: false,\n    });\n  }\n\n  /** @category Internals */\n  static fromRaw<V extends CoValue>(this: CoValueClass<V>, raw: RawCoValue): V {\n    return new this({ fromRaw: raw });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): object | any[] | string {\n    return {\n      id: this.id,\n      type: this._type,\n      error: \"unknown CoValue class\",\n    };\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /** @category Type Helpers */\n  castAs<Cl extends CoValueClass & CoValueFromRaw<CoValue>>(\n    cl: Cl,\n  ): InstanceType<Cl> {\n    const casted = cl.fromRaw(this._raw) as InstanceType<Cl>;\n    const subscriptionScope = subscriptionsScopes.get(this);\n    if (subscriptionScope) {\n      subscriptionsScopes.set(casted, subscriptionScope);\n    }\n    return casted;\n  }\n}\n\nexport function loadCoValueWithoutMe<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options?: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs?: Account | AnonymousJazzAgent;\n  },\n): Promise<Resolved<V, R> | null> {\n  return loadCoValue(cls, id, {\n    ...options,\n    loadAs: options?.loadAs ?? activeAccountContext.get(),\n  });\n}\n\nexport function loadCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs: Account | AnonymousJazzAgent;\n  },\n): Promise<Resolved<V, R> | null> {\n  return new Promise((resolve) => {\n    subscribeToCoValue<V, R>(\n      cls,\n      id,\n      {\n        resolve: options.resolve,\n        loadAs: options.loadAs,\n        onUnavailable: () => {\n          resolve(null);\n        },\n        onUnauthorized: () => {\n          resolve(null);\n        },\n      },\n      (value, unsubscribe) => {\n        resolve(value);\n        unsubscribe();\n      },\n    );\n  });\n}\n\nexport async function ensureCoValueLoaded<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  existing: V,\n  options?: { resolve?: RefsToResolveStrict<V, R> } | undefined,\n): Promise<Resolved<V, R>> {\n  const response = await loadCoValue(\n    existing.constructor as CoValueClass<V>,\n    existing.id,\n    {\n      loadAs: existing._loadedAs,\n      resolve: options?.resolve,\n    },\n  );\n\n  if (!response) {\n    throw new Error(\"Failed to deeply load CoValue \" + existing.id);\n  }\n\n  return response;\n}\n\ntype SubscribeListener<V extends CoValue, R extends RefsToResolve<V>> = (\n  value: Resolved<V, R>,\n  unsubscribe: () => void,\n) => void;\n\nexport type SubscribeListenerOptions<\n  V extends CoValue,\n  R extends RefsToResolve<V>,\n> = {\n  resolve?: RefsToResolveStrict<V, R>;\n  loadAs?: Account | AnonymousJazzAgent;\n  onUnauthorized?: () => void;\n  onUnavailable?: () => void;\n};\n\nexport type SubscribeRestArgs<V extends CoValue, R extends RefsToResolve<V>> =\n  | [options: SubscribeListenerOptions<V, R>, listener: SubscribeListener<V, R>]\n  | [listener: SubscribeListener<V, R>];\n\nexport function parseSubscribeRestArgs<\n  V extends CoValue,\n  R extends RefsToResolve<V>,\n>(\n  args: SubscribeRestArgs<V, R>,\n): {\n  options: SubscribeListenerOptions<V, R>;\n  listener: SubscribeListener<V, R>;\n} {\n  if (args.length === 2) {\n    if (\n      typeof args[0] === \"object\" &&\n      args[0] &&\n      typeof args[1] === \"function\"\n    ) {\n      return {\n        options: {\n          resolve: args[0].resolve,\n          loadAs: args[0].loadAs,\n          onUnauthorized: args[0].onUnauthorized,\n          onUnavailable: args[0].onUnavailable,\n        },\n        listener: args[1],\n      };\n    } else {\n      throw new Error(\"Invalid arguments\");\n    }\n  } else {\n    if (typeof args[0] === \"function\") {\n      return { options: {}, listener: args[0] };\n    } else {\n      throw new Error(\"Invalid arguments\");\n    }\n  }\n}\n\nexport function subscribeToCoValueWithoutMe<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: SubscribeListenerOptions<V, R>,\n  listener: SubscribeListener<V, R>,\n) {\n  return subscribeToCoValue(\n    cls,\n    id,\n    {\n      ...options,\n      loadAs: options.loadAs ?? activeAccountContext.get(),\n    },\n    listener,\n  );\n}\n\nexport function subscribeToCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs: Account | AnonymousJazzAgent;\n    onUnavailable?: () => void;\n    onUnauthorized?: (errorPath: string[]) => void;\n    syncResolution?: boolean;\n  },\n  listener: SubscribeListener<V, R>,\n): () => void {\n  const ref = new Ref(id, options.loadAs, { ref: cls, optional: false });\n\n  let unsubscribed = false;\n  let unsubscribe: (() => void) | undefined;\n\n  function subscribe() {\n    const value = ref.getValueWithoutAccessCheck();\n\n    if (!value) {\n      options.onUnavailable?.();\n      return;\n    }\n\n    if (unsubscribed) return;\n\n    const subscription = new SubscriptionScope(\n      value,\n      cls as CoValueClass<V> & CoValueFromRaw<V>,\n      (update, subscription) => {\n        if (subscription.syncResolution) return;\n\n        if (!ref.hasReadAccess()) {\n          console.error(\n            \"Not enough permissions to load / subscribe to CoValue\",\n            id,\n          );\n          options.onUnauthorized?.([]);\n          return;\n        }\n\n        let result;\n\n        try {\n          subscription.syncResolution = true;\n          result = fulfillsDepth(options.resolve, update);\n        } catch (e) {\n          console.error(\n            \"Failed to load / subscribe to CoValue\",\n            e,\n            e instanceof Error ? e.stack : undefined,\n          );\n          options.onUnavailable?.();\n          return;\n        } finally {\n          subscription.syncResolution = false;\n        }\n\n        if (result.status === \"unauthorized\") {\n          console.error(\n            \"Not enough permissions to load / subscribe to CoValue\",\n            id,\n            \"on path\",\n            result.path.join(\".\"),\n            \"unaccessible value:\",\n            result.id,\n          );\n          options.onUnauthorized?.(result.path);\n          return;\n        }\n\n        if (result.status === \"fulfilled\") {\n          listener(update as Resolved<V, R>, subscription.unsubscribeAll);\n        }\n      },\n    );\n\n    unsubscribe = subscription.unsubscribeAll;\n  }\n\n  const sync = options.syncResolution ? ref.syncLoad() : undefined;\n\n  if (sync) {\n    subscribe();\n  } else {\n    ref\n      .load()\n      .then(() => subscribe())\n      .catch((e) => {\n        console.error(\n          \"Failed to load / subscribe to CoValue\",\n          e,\n          e instanceof Error ? e.stack : undefined,\n        );\n        options.onUnavailable?.();\n      });\n  }\n\n  return function unsubscribeAtAnyPoint() {\n    unsubscribed = true;\n    unsubscribe && unsubscribe();\n  };\n}\n\nexport function createCoValueObservable<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(initialValue: undefined | null = undefined) {\n  let currentValue: Resolved<V, R> | undefined | null = initialValue;\n  let subscriberCount = 0;\n\n  function subscribe(\n    cls: CoValueClass<V>,\n    id: ID<CoValue>,\n    options: {\n      loadAs: Account | AnonymousJazzAgent;\n      resolve?: RefsToResolveStrict<V, R>;\n      onUnavailable?: () => void;\n      onUnauthorized?: () => void;\n      syncResolution?: boolean;\n    },\n    listener: () => void,\n  ) {\n    subscriberCount++;\n\n    const unsubscribe = subscribeToCoValue(\n      cls,\n      id,\n      {\n        loadAs: options.loadAs,\n        resolve: options.resolve,\n        onUnavailable: () => {\n          currentValue = null;\n          options.onUnavailable?.();\n        },\n        onUnauthorized: () => {\n          currentValue = null;\n          options.onUnauthorized?.();\n        },\n        syncResolution: options.syncResolution,\n      },\n      (value) => {\n        currentValue = value;\n        listener();\n      },\n    );\n\n    return () => {\n      unsubscribe();\n      subscriberCount--;\n      if (subscriberCount === 0) {\n        currentValue = undefined;\n      }\n    };\n  }\n\n  const observable = {\n    getCurrentValue: () => currentValue,\n    subscribe,\n  };\n\n  return observable;\n}\n\nexport function subscribeToExistingCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  existing: V,\n  options:\n    | {\n        resolve?: RefsToResolveStrict<V, R>;\n        onUnavailable?: () => void;\n        onUnauthorized?: () => void;\n      }\n    | undefined,\n  listener: SubscribeListener<V, R>,\n): () => void {\n  return subscribeToCoValue(\n    existing.constructor as CoValueClass<V>,\n    existing.id,\n    {\n      loadAs: existing._loadedAs,\n      resolve: options?.resolve,\n      onUnavailable: options?.onUnavailable,\n      onUnauthorized: options?.onUnauthorized,\n    },\n    listener,\n  );\n}\n\nexport function isAccountInstance(instance: unknown): instance is Account {\n  if (typeof instance !== \"object\" || instance === null) {\n    return false;\n  }\n\n  return \"_type\" in instance && instance._type === \"Account\";\n}\n\nexport function isAnonymousAgentInstance(\n  instance: unknown,\n): instance is AnonymousJazzAgent {\n  if (typeof instance !== \"object\" || instance === null) {\n    return false;\n  }\n\n  return \"_type\" in instance && instance._type === \"Anonymous\";\n}\n\nexport function parseCoValueCreateOptions(\n  options:\n    | {\n        owner?: Account | Group;\n        unique?: CoValueUniqueness[\"uniqueness\"];\n      }\n    | Account\n    | Group\n    | undefined,\n) {\n  const Group = RegisteredSchemas[\"Group\"];\n\n  if (!options) {\n    return { owner: Group.create(), uniqueness: undefined };\n  }\n\n  if (\"_type\" in options) {\n    if (options._type === \"Account\" || options._type === \"Group\") {\n      return { owner: options, uniqueness: undefined };\n    }\n  }\n\n  const uniqueness = options.unique\n    ? { uniqueness: options.unique }\n    : undefined;\n\n  return {\n    owner: options.owner ?? Group.create(),\n    uniqueness,\n  };\n}\n\nexport function parseGroupCreateOptions(\n  options:\n    | {\n        owner?: Account;\n      }\n    | Account\n    | undefined,\n) {\n  if (!options) {\n    return { owner: activeAccountContext.get() };\n  }\n\n  return \"_type\" in options && isAccountInstance(options)\n    ? { owner: options }\n    : { owner: options.owner ?? activeAccountContext.get() };\n}\n","export const inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nexport type inspect = typeof inspect;\n","export type JazzToolsSymbol = SchemaInit | ItemsSym | MembersSym;\n\nexport const SchemaInit = \"$SchemaInit$\";\nexport type SchemaInit = typeof SchemaInit;\n\nexport const ItemsSym = \"$items$\";\nexport type ItemsSym = typeof ItemsSym;\n\nexport const MembersSym = \"$members$\";\nexport type MembersSym = typeof MembersSym;\n","import { JsonValue, RawCoList, SessionID } from \"cojson\";\nimport { ItemsSym, type Ref, RefEncoded, UnCo } from \"../internal.js\";\nimport { type Account } from \"./account.js\";\nimport { type CoFeed, CoFeedEntry } from \"./coFeed.js\";\nimport { type CoList } from \"./coList.js\";\nimport { type CoKeys, type CoMap } from \"./coMap.js\";\nimport { type CoValue, type ID } from \"./interfaces.js\";\n\nfunction hasRefValue(value: CoValue, key: string | number) {\n  return Boolean(\n    (\n      value as unknown as {\n        _refs: { [key: string]: Ref<CoValue> | undefined };\n      }\n    )._refs?.[key],\n  );\n}\n\nfunction hasReadAccess(value: CoValue, key: string | number) {\n  return Boolean(\n    (\n      value as unknown as {\n        _refs: { [key: string]: Ref<CoValue> | undefined };\n      }\n    )._refs?.[key]?.hasReadAccess(),\n  );\n}\n\nfunction isOptionalField(value: CoValue, key: string): boolean {\n  return (\n    ((value as CoMap)._schema[key] as RefEncoded<CoValue>)?.optional ?? false\n  );\n}\n\ntype FulfillsDepthResult =\n  | {\n      status: \"fulfilled\" | \"unfulfilled\";\n    }\n  | {\n      status: \"unauthorized\";\n      path: string[];\n      id: JsonValue;\n    };\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function fulfillsDepth(depth: any, value: CoValue): FulfillsDepthResult {\n  if (depth === true || depth === undefined) {\n    return {\n      status: \"fulfilled\",\n    };\n  }\n\n  if (\n    value._type === \"CoMap\" ||\n    value._type === \"Group\" ||\n    value._type === \"Account\"\n  ) {\n    const map = value as CoMap;\n\n    if (\"$each\" in depth) {\n      const result: FulfillsDepthResult = { status: \"fulfilled\" };\n\n      for (const [key, item] of Object.entries(value)) {\n        const rawValue = map._raw.get(key);\n\n        if (rawValue !== undefined && rawValue !== null) {\n          if (!item) {\n            if (hasReadAccess(map, key)) {\n              result.status = \"unfulfilled\";\n              continue;\n            } else {\n              return {\n                status: \"unauthorized\",\n                path: [key],\n                id: rawValue,\n              };\n            }\n          }\n\n          const innerResult = fulfillsDepth(depth.$each, item);\n\n          if (innerResult.status === \"unfulfilled\") {\n            result.status = \"unfulfilled\";\n          } else if (\n            innerResult.status === \"unauthorized\" &&\n            !isOptionalField(value, ItemsSym)\n          ) {\n            innerResult.path.unshift(key);\n\n            return innerResult; // If any item is unauthorized, the whole thing is unauthorized\n          }\n        } else if (!isOptionalField(value, ItemsSym)) {\n          return {\n            status: \"unfulfilled\",\n          };\n        }\n      }\n\n      return result;\n    } else {\n      const result: FulfillsDepthResult = { status: \"fulfilled\" };\n\n      for (const key of Object.keys(depth)) {\n        const rawValue = map._raw.get(key);\n\n        if (rawValue === undefined || rawValue === null) {\n          if (!map._schema?.[key]) {\n            // Field not defined in schema\n            if (map._schema?.[ItemsSym]) {\n              // CoMap.Record\n              if (isOptionalField(map, ItemsSym)) {\n                continue;\n              } else {\n                // All fields are required, so the returned type is not optional and we must comply\n                throw new Error(\n                  `The ref ${key} requested on ${map.constructor.name} is missing`,\n                );\n              }\n            } else {\n              // Field not defined in CoMap schema\n              throw new Error(\n                `The ref ${key} requested on ${map.constructor.name} is not defined in the schema`,\n              );\n            }\n          } else if (isOptionalField(map, key)) {\n            continue;\n          } else {\n            // Field is required but has never been set\n            throw new Error(\n              `The ref ${key} on ${map.constructor.name} is required but missing`,\n            );\n          }\n        } else {\n          const item = (value as Record<string, any>)[key];\n\n          if (!item) {\n            if (hasReadAccess(map, key)) {\n              result.status = \"unfulfilled\";\n              continue;\n            } else {\n              return {\n                status: \"unauthorized\",\n                path: [key],\n                id: rawValue,\n              };\n            }\n          }\n\n          const innerResult = fulfillsDepth(depth[key], item);\n\n          if (innerResult.status === \"unfulfilled\") {\n            result.status = \"unfulfilled\";\n          } else if (\n            innerResult.status === \"unauthorized\" &&\n            !isOptionalField(value, key)\n          ) {\n            innerResult.path.unshift(key);\n\n            return innerResult; // If any item is unauthorized, the whole thing is unauthorized\n          }\n        }\n      }\n\n      return result;\n    }\n  } else if (value._type === \"CoList\") {\n    if (\"$each\" in depth) {\n      const result: FulfillsDepthResult = { status: \"fulfilled\" };\n      const list = value as CoList;\n\n      for (const [key, item] of (value as CoList).entries()) {\n        const rawValue = list._raw.get(key);\n\n        if (!rawValue) {\n          if (isOptionalField(value, ItemsSym)) {\n            continue;\n          }\n\n          // Throw an error and mark this as unavailable\n          throw new Error(\n            `The ref ${key} on ${list.constructor.name} is required but missing`,\n          );\n        }\n\n        if (hasRefValue(value, key)) {\n          if (!item) {\n            if (hasReadAccess(value, key)) {\n              result.status = \"unfulfilled\";\n              continue;\n            } else {\n              return {\n                status: \"unauthorized\",\n                path: [key.toString()],\n                id: (value._raw as RawCoList).get(key) ?? \"undefined\",\n              };\n            }\n          }\n\n          const innerResult = fulfillsDepth(depth.$each, item);\n\n          if (innerResult.status === \"unfulfilled\") {\n            result.status = \"unfulfilled\";\n          } else if (\n            innerResult.status === \"unauthorized\" &&\n            !isOptionalField(value, ItemsSym)\n          ) {\n            innerResult.path.unshift(key.toString());\n\n            return innerResult; // If any item is unauthorized, the whole thing is unauthorized\n          }\n        } else if (!isOptionalField(value, ItemsSym)) {\n          return {\n            status: \"unfulfilled\",\n          };\n        }\n      }\n\n      return result;\n    }\n\n    return {\n      status: \"fulfilled\",\n    };\n  } else if (value._type === \"CoStream\") {\n    if (\"$each\" in depth) {\n      const result: FulfillsDepthResult = { status: \"fulfilled\" };\n\n      for (const item of Object.values((value as CoFeed).perSession)) {\n        if (item.ref) {\n          if (!item.value) {\n            if (item.ref.hasReadAccess()) {\n              result.status = \"unfulfilled\";\n              continue;\n            } else {\n              return {\n                status: \"unauthorized\",\n                path: [item.ref.id],\n                id: item.ref.id,\n              };\n            }\n          }\n\n          const innerResult = fulfillsDepth(depth.$each, item.value);\n\n          if (innerResult.status === \"unfulfilled\") {\n            result.status = \"unfulfilled\";\n          } else if (\n            innerResult.status === \"unauthorized\" &&\n            !isOptionalField(value, ItemsSym)\n          ) {\n            innerResult.path.unshift(item.ref.id);\n\n            return innerResult; // If any item is unauthorized, the whole thing is unauthorized\n          }\n        } else if (!isOptionalField(value, ItemsSym)) {\n          return {\n            status: \"unfulfilled\",\n          };\n        }\n      }\n\n      return result;\n    }\n\n    return {\n      status: \"fulfilled\",\n    };\n  } else if (\n    value._type === \"BinaryCoStream\" ||\n    value._type === \"CoPlainText\"\n  ) {\n    return {\n      status: \"fulfilled\",\n    };\n  } else {\n    console.error(value);\n    throw new Error(\"Unexpected value type: \" + value._type);\n  }\n}\n\ntype UnCoNotNull<T> = UnCo<Exclude<T, null>>;\nexport type Clean<T> = UnCo<NonNullable<T>>;\n\nexport type RefsToResolve<\n  V,\n  DepthLimit extends number = 10,\n  CurrentDepth extends number[] = [],\n> =\n  | boolean\n  | (DepthLimit extends CurrentDepth[\"length\"]\n      ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        any\n      : // Basically V extends CoList - but if we used that we'd introduce circularity into the definition of CoList itself\n        V extends Array<infer Item>\n        ?\n            | {\n                $each: RefsToResolve<\n                  UnCoNotNull<Item>,\n                  DepthLimit,\n                  [0, ...CurrentDepth]\n                >;\n              }\n            | boolean\n        : // Basically V extends CoMap | Group | Account - but if we used that we'd introduce circularity into the definition of CoMap itself\n          V extends { _type: \"CoMap\" | \"Group\" | \"Account\" }\n          ?\n              | {\n                  [Key in CoKeys<V> as Clean<V[Key]> extends CoValue\n                    ? Key\n                    : never]?: RefsToResolve<\n                    Clean<V[Key]>,\n                    DepthLimit,\n                    [0, ...CurrentDepth]\n                  >;\n                }\n              | (ItemsSym extends keyof V\n                  ? {\n                      $each: RefsToResolve<\n                        Clean<V[ItemsSym]>,\n                        DepthLimit,\n                        [0, ...CurrentDepth]\n                      >;\n                    }\n                  : never)\n              | boolean\n          : V extends {\n                _type: \"CoStream\";\n                byMe: CoFeedEntry<infer Item> | undefined;\n              }\n            ?\n                | {\n                    $each: RefsToResolve<\n                      UnCoNotNull<Item>,\n                      DepthLimit,\n                      [0, ...CurrentDepth]\n                    >;\n                  }\n                | boolean\n            : boolean);\n\nexport type RefsToResolveStrict<T, V> = V extends RefsToResolve<T>\n  ? RefsToResolve<T>\n  : V;\n\nexport type Resolved<T, R extends RefsToResolve<T> | undefined> = DeeplyLoaded<\n  T,\n  R,\n  10,\n  []\n>;\n\nexport type DeeplyLoaded<\n  V,\n  Depth,\n  DepthLimit extends number = 10,\n  CurrentDepth extends number[] = [],\n> = DepthLimit extends CurrentDepth[\"length\"]\n  ? V\n  : Depth extends boolean | undefined // Checking against boolean instead of true because the inference from RefsToResolveStrict transforms true into boolean\n    ? V\n    : // Basically V extends CoList - but if we used that we'd introduce circularity into the definition of CoList itself\n      [V] extends [Array<infer Item>]\n      ? UnCoNotNull<Item> extends CoValue\n        ? Depth extends { $each: infer ItemDepth }\n          ? // Deeply loaded CoList\n            (UnCoNotNull<Item> &\n              DeeplyLoaded<\n                UnCoNotNull<Item>,\n                ItemDepth,\n                DepthLimit,\n                [0, ...CurrentDepth]\n              >)[] &\n              V // the CoList base type needs to be intersected after so that built-in methods return the correct narrowed array type\n          : never\n        : V\n      : // Basically V extends CoMap | Group | Account - but if we used that we'd introduce circularity into the definition of CoMap itself\n        [V] extends [{ _type: \"CoMap\" | \"Group\" | \"Account\" }]\n        ? ItemsSym extends keyof V\n          ? Depth extends { $each: infer ItemDepth }\n            ? // Deeply loaded Record-like CoMap\n              {\n                [key: string]: DeeplyLoaded<\n                  Clean<V[ItemsSym]>,\n                  ItemDepth,\n                  DepthLimit,\n                  [0, ...CurrentDepth]\n                >;\n              } & V // same reason as in CoList\n            : never\n          : keyof Depth extends never // Depth = {}\n            ? V\n            : // Deeply loaded CoMap\n              {\n                -readonly [Key in keyof Depth]-?: Key extends CoKeys<V>\n                  ? Clean<V[Key]> extends CoValue\n                    ?\n                        | DeeplyLoaded<\n                            Clean<V[Key]>,\n                            Depth[Key],\n                            DepthLimit,\n                            [0, ...CurrentDepth]\n                          >\n                        | (undefined extends V[Key] ? undefined : never)\n                    : never\n                  : never;\n              } & V // same reason as in CoList\n        : [V] extends [\n              {\n                _type: \"CoStream\";\n                byMe: CoFeedEntry<infer Item> | undefined;\n              },\n            ]\n          ? // Deeply loaded CoStream\n            {\n              byMe?: { value: UnCoNotNull<Item> };\n              inCurrentSession?: { value: UnCoNotNull<Item> };\n              perSession: {\n                [key: SessionID]: { value: UnCoNotNull<Item> };\n              };\n            } & { [key: ID<Account>]: { value: UnCoNotNull<Item> } } & V // same reason as in CoList\n          : [V] extends [\n                {\n                  _type: \"BinaryCoStream\";\n                },\n              ]\n            ? V\n            : [V] extends [\n                  {\n                    _type: \"CoPlainText\";\n                  },\n                ]\n              ? V\n              : never;\n","import { type CoID, RawAccount, type RawCoValue, RawGroup } from \"cojson\";\nimport { type Account } from \"../coValues/account.js\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  ID,\n  RefEncoded,\n  UnCo,\n} from \"../internal.js\";\nimport {\n  instantiateRefEncoded,\n  isRefEncoded,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\n\nconst TRACE_ACCESSES = false;\n\nexport class Ref<out V extends CoValue> {\n  constructor(\n    readonly id: ID<V>,\n    readonly controlledAccount: Account | AnonymousJazzAgent,\n    readonly schema: RefEncoded<V>,\n  ) {\n    if (!isRefEncoded(schema)) {\n      throw new Error(\"Ref must be constructed with a ref schema\");\n    }\n  }\n\n  private getNode() {\n    return \"node\" in this.controlledAccount\n      ? this.controlledAccount.node\n      : this.controlledAccount._raw.core.node;\n  }\n\n  hasReadAccess() {\n    const node = this.getNode();\n\n    const raw = node.getLoaded(this.id as unknown as CoID<RawCoValue>);\n\n    if (!raw) {\n      return true;\n    }\n\n    if (raw instanceof RawAccount || raw instanceof RawGroup) {\n      return true;\n    }\n\n    const group = raw.core.getGroup();\n\n    if (group instanceof RawAccount) {\n      if (node.account.id !== group.id) {\n        return false;\n      }\n    } else if (group.myRole() === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getValueWithoutAccessCheck() {\n    const node = this.getNode();\n    const raw = node.getLoaded(this.id as unknown as CoID<RawCoValue>);\n\n    if (raw) {\n      return coValuesCache.get(raw, () =>\n        instantiateRefEncoded(this.schema, raw),\n      );\n    } else {\n      return null;\n    }\n  }\n\n  get value() {\n    if (!this.hasReadAccess()) {\n      return null;\n    }\n\n    return this.getValueWithoutAccessCheck();\n  }\n\n  private async loadHelper(): Promise<V | \"unavailable\"> {\n    const node =\n      \"node\" in this.controlledAccount\n        ? this.controlledAccount.node\n        : this.controlledAccount._raw.core.node;\n    const raw = await node.load(this.id as unknown as CoID<RawCoValue>);\n    if (raw === \"unavailable\") {\n      return \"unavailable\";\n    } else {\n      return new Ref(this.id, this.controlledAccount, this.schema).value!;\n    }\n  }\n\n  syncLoad(): V | undefined {\n    const node =\n      \"node\" in this.controlledAccount\n        ? this.controlledAccount.node\n        : this.controlledAccount._raw.core.node;\n\n    const entry = node.coValuesStore.get(\n      this.id as unknown as CoID<RawCoValue>,\n    );\n\n    if (entry.highLevelState === \"available\") {\n      return new Ref(this.id, this.controlledAccount, this.schema).value!;\n    }\n\n    return undefined;\n  }\n\n  async load(): Promise<V | undefined> {\n    const result = await this.loadHelper();\n    if (result === \"unavailable\") {\n      return undefined;\n    } else {\n      return result;\n    }\n  }\n\n  accessFrom(fromScopeValue: CoValue, key: string | number | symbol): V | null {\n    const subScope = subscriptionsScopes.get(fromScopeValue);\n\n    subScope?.onRefAccessedOrSet(fromScopeValue.id, this.id);\n    TRACE_ACCESSES &&\n      console.log(subScope?.scopeID, \"accessing\", fromScopeValue, key, this.id);\n\n    if (this.value && subScope) {\n      subscriptionsScopes.set(this.value, subScope);\n    }\n\n    if (subScope) {\n      const cached = subScope.cachedValues[this.id];\n      if (cached) {\n        TRACE_ACCESSES && console.log(\"cached\", cached);\n        return cached as V;\n      } else if (this.value !== null) {\n        const freshValueInstance = instantiateRefEncoded(\n          this.schema,\n          this.value._raw,\n        );\n        TRACE_ACCESSES && console.log(\"freshValueInstance\", freshValueInstance);\n        subScope.cachedValues[this.id] = freshValueInstance;\n        subscriptionsScopes.set(freshValueInstance, subScope);\n        return freshValueInstance as V;\n      } else {\n        return null;\n      }\n    } else {\n      return this.value;\n    }\n  }\n}\n\nexport function makeRefs<Keys extends string | number>(\n  getIdForKey: (key: Keys) => ID<CoValue> | undefined,\n  getKeysWithIds: () => Keys[],\n  controlledAccount: Account | AnonymousJazzAgent,\n  refSchemaForKey: (key: Keys) => RefEncoded<CoValue>,\n): { [K in Keys]: Ref<CoValue> } & {\n  [Symbol.iterator]: () => IterableIterator<Ref<CoValue>>;\n  length: number;\n} {\n  const refs = {} as { [K in Keys]: Ref<CoValue> } & {\n    [Symbol.iterator]: () => IterableIterator<Ref<CoValue>>;\n    length: number;\n  };\n  return new Proxy(refs, {\n    get(_target, key) {\n      if (key === Symbol.iterator) {\n        return function* () {\n          for (const key of getKeysWithIds()) {\n            yield new Ref(\n              getIdForKey(key)!,\n              controlledAccount,\n              refSchemaForKey(key),\n            );\n          }\n        };\n      }\n      if (typeof key === \"symbol\") return undefined;\n      if (key === \"length\") {\n        return getKeysWithIds().length;\n      }\n      const id = getIdForKey(key as Keys);\n      if (!id) return undefined;\n      return new Ref(\n        id as ID<CoValue>,\n        controlledAccount,\n        refSchemaForKey(key as Keys),\n      );\n    },\n    ownKeys() {\n      return getKeysWithIds().map((key) => key.toString());\n    },\n    getOwnPropertyDescriptor(target, key) {\n      const id = getIdForKey(key as Keys);\n      if (id) {\n        return {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n        };\n      } else {\n        return Reflect.getOwnPropertyDescriptor(target, key);\n      }\n    },\n  });\n}\n\nexport type RefIfCoValue<V> = NonNullable<V> extends CoValue\n  ? Ref<UnCo<NonNullable<V>>>\n  : never;\n","import { RawCoValue } from \"cojson\";\nimport { CoValue } from \"../internal.js\";\n\nconst weakMap = new WeakMap<RawCoValue, CoValue>();\n\nexport const coValuesCache = {\n  get: <V extends CoValue>(raw: RawCoValue, compute: () => V) => {\n    const cached = weakMap.get(raw);\n    if (cached) {\n      return cached as V;\n    }\n    const computed = compute();\n    weakMap.set(raw, computed);\n    return computed;\n  },\n};\n","import type { JsonValue, RawCoValue } from \"cojson\";\nimport { CojsonInternalTypes } from \"cojson\";\nimport {\n  type CoValue,\n  type CoValueClass,\n  CoValueFromRaw,\n  ItemsSym,\n  JazzToolsSymbol,\n  SchemaInit,\n  isCoValueClass,\n} from \"../internal.js\";\n\n/** @category Schema definition */\nexport const Encoders = {\n  Date: {\n    encode: (value: Date) => value.toISOString(),\n    decode: (value: JsonValue) => new Date(value as string),\n  },\n  OptionalDate: {\n    encode: (value: Date | undefined) => value?.toISOString() || null,\n    decode: (value: JsonValue) =>\n      value === null ? undefined : new Date(value as string),\n  },\n};\n\nexport type CoMarker = { readonly __co: unique symbol };\n/** @category Schema definition */\nexport type co<T> = T | (T & CoMarker);\nexport type IfCo<C, R> = C extends infer _A | infer B\n  ? B extends CoMarker\n    ? R extends JazzToolsSymbol // Exclude symbol properties like co.items from the refs/init types\n      ? never\n      : R\n    : never\n  : never;\nexport type UnCo<T> = T extends co<infer A> ? A : T;\n\nconst optional = {\n  ref: optionalRef,\n  json<T extends CojsonInternalTypes.CoJsonValue<T>>(): co<T | undefined> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  encoded<T>(arg: OptionalEncoder<T>): co<T | undefined> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: { encoded: arg } satisfies Schema } as any;\n  },\n  string: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<string | undefined>,\n  number: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<number | undefined>,\n  boolean: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<boolean | undefined>,\n  null: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<null | undefined>,\n  Date: {\n    [SchemaInit]: { encoded: Encoders.OptionalDate } satisfies Schema,\n  } as unknown as co<Date | undefined>,\n  literal<T extends (string | number | boolean)[]>(\n    ..._lit: T\n  ): co<T[number] | undefined> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n};\n\n/** @category Schema definition */\nexport const co = {\n  string: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<string>,\n  number: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<number>,\n  boolean: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<boolean>,\n  null: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as co<null>,\n  Date: {\n    [SchemaInit]: { encoded: Encoders.Date } satisfies Schema,\n  } as unknown as co<Date>,\n  literal<T extends (string | number | boolean)[]>(..._lit: T): co<T[number]> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  json<T extends CojsonInternalTypes.CoJsonValue<T>>(): co<T> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  encoded<T>(arg: Encoder<T>): co<T> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: { encoded: arg } satisfies Schema } as any;\n  },\n  ref,\n  items: ItemsSym as ItemsSym,\n  optional,\n};\n\nfunction optionalRef<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n): co<InstanceType<C> | null | undefined> {\n  return ref(arg, { optional: true });\n}\n\nfunction ref<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options?: never,\n): co<InstanceType<C> | null>;\nfunction ref<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options: { optional: true },\n): co<InstanceType<C> | null | undefined>;\nfunction ref<\n  C extends CoValueClass,\n  Options extends { optional?: boolean } | undefined,\n>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options?: Options,\n): Options extends { optional: true }\n  ? co<InstanceType<C> | null | undefined>\n  : co<InstanceType<C> | null> {\n  return {\n    [SchemaInit]: {\n      ref: arg,\n      optional: options?.optional || false,\n    } satisfies Schema,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } as any;\n}\n\nexport type JsonEncoded = \"json\";\nexport type EncodedAs<V> = { encoded: Encoder<V> | OptionalEncoder<V> };\nexport type RefEncoded<V extends CoValue> = {\n  ref: CoValueClass<V> | ((raw: RawCoValue) => CoValueClass<V>);\n  optional: boolean;\n};\n\nexport function isRefEncoded<V extends CoValue>(\n  schema: Schema,\n): schema is RefEncoded<V> {\n  return (\n    typeof schema === \"object\" &&\n    \"ref\" in schema &&\n    \"optional\" in schema &&\n    typeof schema.ref === \"function\"\n  );\n}\n\nexport function instantiateRefEncoded<V extends CoValue>(\n  schema: RefEncoded<V>,\n  raw: RawCoValue,\n): V {\n  return isCoValueClass<V>(schema.ref)\n    ? schema.ref.fromRaw(raw)\n    : (schema.ref as (raw: RawCoValue) => CoValueClass<V> & CoValueFromRaw<V>)(\n        raw,\n      ).fromRaw(raw);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Schema = JsonEncoded | RefEncoded<CoValue> | EncodedAs<any>;\n\nexport type SchemaFor<Field> = NonNullable<Field> extends CoValue\n  ? RefEncoded<NonNullable<Field>>\n  : NonNullable<Field> extends JsonValue\n    ? JsonEncoded\n    : EncodedAs<NonNullable<Field>>;\n\nexport type Encoder<V> = {\n  encode: (value: V) => JsonValue;\n  decode: (value: JsonValue) => V;\n};\nexport type OptionalEncoder<V> =\n  | Encoder<V>\n  | {\n      encode: (value: V | undefined) => JsonValue;\n      decode: (value: JsonValue) => V | undefined;\n    };\n","import type { CoValueCore, LocalNode, RawCoValue } from \"cojson\";\nimport { type Account } from \"../coValues/account.js\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  CoValueFromRaw,\n  ID,\n} from \"../internal.js\";\n\nexport const subscriptionsScopes = new WeakMap<\n  CoValue,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  SubscriptionScope<any>\n>();\n\nexport class SubscriptionScope<Root extends CoValue> {\n  scopeID: string = `scope-${Math.random().toString(36).slice(2)}`;\n  subscriber: Account | AnonymousJazzAgent;\n  entries = new Map<\n    ID<CoValue>,\n    | { state: \"loading\"; immediatelyUnsub?: boolean }\n    | { state: \"loaded\"; rawUnsub: () => void }\n  >();\n  rootEntry: {\n    state: \"loaded\";\n    value: RawCoValue;\n    rawUnsub: () => void;\n  };\n  scheduleUpdate: () => void;\n  scheduledUpdate: boolean = false;\n  cachedValues: { [id: ID<CoValue>]: CoValue } = {};\n  parents: { [id: ID<CoValue>]: Set<ID<CoValue>> } = {};\n  syncResolution: boolean = false;\n\n  constructor(\n    root: Root,\n    rootSchema: CoValueClass<Root> & CoValueFromRaw<Root>,\n    onUpdate: (newRoot: Root, scope: SubscriptionScope<Root>) => void,\n  ) {\n    this.rootEntry = {\n      state: \"loaded\" as const,\n      value: root._raw,\n      rawUnsub: () => {}, // placeholder\n    };\n    this.entries.set(root.id, this.rootEntry);\n\n    subscriptionsScopes.set(root, this);\n\n    this.subscriber = root._loadedAs;\n\n    this.scheduleUpdate = () => {\n      const value = rootSchema.fromRaw(this.rootEntry.value) as Root;\n      subscriptionsScopes.set(value, this);\n      onUpdate(value, this);\n    };\n\n    this.rootEntry.rawUnsub = root._raw.core.subscribe(\n      (rawUpdate: RawCoValue | undefined) => {\n        if (!rawUpdate) return;\n        this.rootEntry.value = rawUpdate;\n        this.scheduleUpdate();\n      },\n    );\n  }\n\n  onRefAccessedOrSet(\n    fromId: ID<CoValue>,\n    accessedOrSetId: ID<CoValue> | undefined,\n  ) {\n    // console.log(\"onRefAccessedOrSet\", this.scopeID, accessedOrSetId);\n    if (!accessedOrSetId) {\n      return;\n    }\n\n    this.parents[accessedOrSetId] = this.parents[accessedOrSetId] || new Set();\n    this.parents[accessedOrSetId]!.add(fromId);\n\n    if (!this.entries.has(accessedOrSetId)) {\n      const loadingEntry = {\n        state: \"loading\",\n        immediatelyUnsub: false,\n      } as const;\n      this.entries.set(accessedOrSetId, loadingEntry);\n      const node =\n        this.subscriber._type === \"Account\"\n          ? this.subscriber._raw.core.node\n          : this.subscriber.node;\n\n      loadCoValue(\n        node,\n        accessedOrSetId,\n        (core) => {\n          if (\n            loadingEntry.state === \"loading\" &&\n            loadingEntry.immediatelyUnsub\n          ) {\n            return;\n          }\n          if (core !== \"unavailable\") {\n            const entry = {\n              state: \"loaded\" as const,\n              rawUnsub: () => {}, // placeholder\n            };\n            this.entries.set(accessedOrSetId, entry);\n\n            const rawUnsub = core.subscribe((rawUpdate) => {\n              if (!rawUpdate) return;\n\n              this.invalidate(accessedOrSetId);\n              this.scheduleUpdate();\n            });\n\n            entry.rawUnsub = rawUnsub;\n          }\n        },\n        this.syncResolution,\n      );\n    }\n  }\n\n  invalidate(id: ID<CoValue>, seen: Set<ID<CoValue>> = new Set()) {\n    if (seen.has(id)) return;\n\n    delete this.cachedValues[id];\n    seen.add(id);\n    for (const parent of this.parents[id] || []) {\n      this.invalidate(parent, seen);\n    }\n  }\n\n  unsubscribeAll = () => {\n    for (const entry of this.entries.values()) {\n      if (entry.state === \"loaded\") {\n        entry.rawUnsub();\n      } else {\n        entry.immediatelyUnsub = true;\n      }\n    }\n    this.entries.clear();\n  };\n}\n\n/**\n * Loads a CoValue from the node and calls the callback with the result.\n\n * If the CoValue is already loaded, the callback is called synchronously.\n * If the CoValue is not loaded, the callback is called asynchronously.\n */\nfunction loadCoValue(\n  node: LocalNode,\n  id: ID<CoValue>,\n  callback: (value: CoValueCore | \"unavailable\") => void,\n  syncResolution: boolean,\n) {\n  const entry = node.coValuesStore.get(id);\n\n  if (entry.isAvailable() && syncResolution) {\n    callback(entry.core);\n  } else {\n    void node.loadCoValueCore(id).then((core) => {\n      callback(core);\n    });\n  }\n}\n","import {\n  AgentSecret,\n  CoID,\n  ControlledAgent,\n  CryptoProvider,\n  LocalNode,\n  Peer,\n  RawAccount,\n  RawAccountID,\n  SessionID,\n} from \"cojson\";\nimport { AuthSecretStorage } from \"../auth/AuthSecretStorage.js\";\nimport { type Account, type AccountClass } from \"../coValues/account.js\";\nimport { RegisteredSchemas } from \"../coValues/registeredSchemas.js\";\nimport type { ID } from \"../internal.js\";\nimport { AuthCredentials, NewAccountProps } from \"../types.js\";\nimport { activeAccountContext } from \"./activeAccountContext.js\";\nimport { AnonymousJazzAgent } from \"./anonymousJazzAgent.js\";\n\nexport type Credentials = {\n  accountID: ID<Account>;\n  secret: AgentSecret;\n};\n\ntype SessionProvider = (\n  accountID: ID<Account>,\n  crypto: CryptoProvider,\n) => Promise<{ sessionID: SessionID; sessionDone: () => void }>;\n\nexport type AuthResult =\n  | {\n      type: \"existing\";\n      username?: string;\n      credentials: Credentials;\n      saveCredentials?: (credentials: Credentials) => Promise<void>;\n      onSuccess: () => void;\n      onError: (error: string | Error) => void;\n      logOut: () => Promise<void>;\n    }\n  | {\n      type: \"new\";\n      creationProps: {\n        name: string;\n        anonymous?: boolean;\n        other?: Record<string, unknown>;\n      };\n      initialSecret?: AgentSecret;\n      saveCredentials: (credentials: Credentials) => Promise<void>;\n      onSuccess: () => void;\n      onError: (error: string | Error) => void;\n      logOut: () => Promise<void>;\n    };\n\nexport async function randomSessionProvider(\n  accountID: ID<Account>,\n  crypto: CryptoProvider,\n) {\n  return {\n    sessionID: crypto.newRandomSessionID(accountID as unknown as RawAccountID),\n    sessionDone: () => {},\n  };\n}\n\nexport type JazzContextWithAccount<Acc extends Account> = {\n  node: LocalNode;\n  account: Acc;\n  done: () => void;\n  logOut: () => Promise<void>;\n};\n\nexport type JazzContextWithAgent = {\n  agent: AnonymousJazzAgent;\n  done: () => void;\n  logOut: () => Promise<void>;\n};\n\nexport type JazzContext<Acc extends Account> =\n  | JazzContextWithAccount<Acc>\n  | JazzContextWithAgent;\n\nexport async function createJazzContextFromExistingCredentials<\n  Acc extends Account,\n>({\n  credentials,\n  peersToLoadFrom,\n  crypto,\n  AccountSchema: PropsAccountSchema,\n  sessionProvider,\n  onLogOut,\n}: {\n  credentials: Credentials;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  AccountSchema?: AccountClass<Acc>;\n  sessionProvider: SessionProvider;\n  onLogOut?: () => void;\n}): Promise<JazzContextWithAccount<Acc>> {\n  const { sessionID, sessionDone } = await sessionProvider(\n    credentials.accountID,\n    crypto,\n  );\n\n  const CurrentAccountSchema =\n    PropsAccountSchema ??\n    (RegisteredSchemas[\"Account\"] as unknown as AccountClass<Acc>);\n\n  const node = await LocalNode.withLoadedAccount({\n    accountID: credentials.accountID as unknown as CoID<RawAccount>,\n    accountSecret: credentials.secret,\n    sessionID: sessionID,\n    peersToLoadFrom: peersToLoadFrom,\n    crypto: crypto,\n    migration: async (rawAccount, _node, creationProps) => {\n      const account = new CurrentAccountSchema({\n        fromRaw: rawAccount,\n      }) as Acc;\n      activeAccountContext.set(account);\n\n      await account.applyMigration(creationProps);\n    },\n  });\n\n  const account = CurrentAccountSchema.fromNode(node);\n  activeAccountContext.set(account);\n\n  return {\n    node,\n    account,\n    done: () => {\n      node.gracefulShutdown();\n      sessionDone();\n    },\n    logOut: async () => {\n      node.gracefulShutdown();\n      sessionDone();\n      await onLogOut?.();\n    },\n  };\n}\n\nexport async function createJazzContextForNewAccount<Acc extends Account>({\n  creationProps,\n  initialAgentSecret,\n  peersToLoadFrom,\n  crypto,\n  AccountSchema: PropsAccountSchema,\n  onLogOut,\n}: {\n  creationProps: { name: string };\n  initialAgentSecret?: AgentSecret;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  AccountSchema?: AccountClass<Acc>;\n  onLogOut?: () => Promise<void>;\n}): Promise<JazzContextWithAccount<Acc>> {\n  const CurrentAccountSchema =\n    PropsAccountSchema ??\n    (RegisteredSchemas[\"Account\"] as unknown as AccountClass<Acc>);\n\n  const { node } = await LocalNode.withNewlyCreatedAccount({\n    creationProps,\n    peersToLoadFrom,\n    crypto,\n    initialAgentSecret,\n    migration: async (rawAccount, _node, creationProps) => {\n      const account = new CurrentAccountSchema({\n        fromRaw: rawAccount,\n      }) as Acc;\n      activeAccountContext.set(account);\n\n      await account.applyMigration(creationProps);\n    },\n  });\n\n  const account = CurrentAccountSchema.fromNode(node);\n  activeAccountContext.set(account);\n\n  return {\n    node,\n    account,\n    done: () => {\n      node.gracefulShutdown();\n    },\n    logOut: async () => {\n      node.gracefulShutdown();\n      await onLogOut?.();\n    },\n  };\n}\n\nexport async function createJazzContext<Acc extends Account>(options: {\n  credentials?: AuthCredentials;\n  newAccountProps?: NewAccountProps;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  defaultProfileName?: string;\n  AccountSchema?: AccountClass<Acc>;\n  sessionProvider: SessionProvider;\n  authSecretStorage: AuthSecretStorage;\n}) {\n  const crypto = options.crypto;\n\n  let context: JazzContextWithAccount<Acc>;\n\n  const authSecretStorage = options.authSecretStorage;\n\n  await authSecretStorage.migrate();\n\n  const credentials = options.credentials ?? (await authSecretStorage.get());\n\n  if (credentials && !options.newAccountProps) {\n    context = await createJazzContextFromExistingCredentials({\n      credentials: {\n        accountID: credentials.accountID,\n        secret: credentials.accountSecret,\n      },\n      peersToLoadFrom: options.peersToLoadFrom,\n      crypto,\n      AccountSchema: options.AccountSchema,\n      sessionProvider: options.sessionProvider,\n      onLogOut: () => {\n        authSecretStorage.clearWithoutNotify();\n      },\n    });\n  } else {\n    const secretSeed = options.crypto.newRandomSecretSeed();\n\n    const initialAgentSecret =\n      options.newAccountProps?.secret ??\n      crypto.agentSecretFromSecretSeed(secretSeed);\n\n    const creationProps = options.newAccountProps?.creationProps ?? {\n      name: options.defaultProfileName ?? \"Anonymous user\",\n    };\n\n    context = await createJazzContextForNewAccount({\n      creationProps,\n      initialAgentSecret,\n      peersToLoadFrom: options.peersToLoadFrom,\n      crypto,\n      AccountSchema: options.AccountSchema,\n      onLogOut: async () => {\n        await authSecretStorage.clearWithoutNotify();\n      },\n    });\n\n    if (!options.newAccountProps) {\n      await authSecretStorage.setWithoutNotify({\n        accountID: context.account.id,\n        secretSeed,\n        accountSecret: context.node.account.agentSecret,\n        provider: \"anonymous\",\n      });\n    }\n  }\n\n  return {\n    ...context,\n    authSecretStorage,\n  };\n}\n\nexport async function createAnonymousJazzContext({\n  peersToLoadFrom,\n  crypto,\n}: {\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n}): Promise<JazzContextWithAgent> {\n  const agentSecret = crypto.newRandomAgentSecret();\n  const rawAgent = new ControlledAgent(agentSecret, crypto);\n\n  const node = new LocalNode(\n    rawAgent,\n    crypto.newRandomSessionID(rawAgent.id),\n    crypto,\n  );\n\n  for (const peer of peersToLoadFrom) {\n    node.syncManager.addPeer(peer);\n  }\n\n  activeAccountContext.setGuestMode();\n\n  return {\n    agent: new AnonymousJazzAgent(node),\n    done: () => {},\n    logOut: async () => {},\n  };\n}\n","import type { Account } from \"./account.js\";\nimport type { CoMap } from \"./coMap.js\";\nimport type { Group } from \"./group.js\";\n\n/**\n * Regisering schemas into this Record to avoid circular dependencies.\n */\nexport const RegisteredSchemas = {} as {\n  Account: typeof Account;\n  Group: typeof Group;\n  CoMap: typeof CoMap;\n};\n","/* istanbul ignore file -- @preserve */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ItemsSym } from \"./symbols.js\";\n\n(globalThis as any).devtoolsFormatters = [\n  {\n    header: (object: any) => {\n      if (object._type === \"CoMap\") {\n        return [\"div\", {}, [\"span\", {}, object.constructor.name]];\n      } else if (object._type === \"CoList\") {\n        return [\n          \"div\",\n          {},\n          [\"span\", {}, object.constructor.name + \"(\" + object.length + \") \"],\n        ];\n      } else if (object._type === \"Account\") {\n        return [\n          \"div\",\n          {},\n          [\n            \"span\",\n            {},\n            object.constructor.name +\n              \"(\" +\n              object._refs.profile.value?.name +\n              (object.isMe ? \" ME\" : \"\") +\n              \")\",\n          ],\n        ];\n      } else {\n        return null;\n      }\n    },\n    hasBody: function () {\n      return true;\n    },\n    body: function (object: any) {\n      if (object._type === \"CoMap\" || object._type === \"Account\") {\n        return [\n          \"div\",\n          { style: \"margin-left: 15px\" },\n          [\"div\", \"id: \", [\"object\", { object: object.id }]],\n          ...Object.entries(object).map(([k, v]) => [\n            \"div\",\n            { style: \"white-space: nowrap;\" },\n            [\"span\", { style: \"font-weight: bold; opacity: 0.6\" }, k, \": \"],\n            [\"object\", { object: v }],\n            ...(typeof object._schema[k] === \"function\"\n              ? v === null\n                ? [\n                    [\n                      \"span\",\n                      { style: \"opacity: 0.5\" },\n                      ` (pending ${object._schema[k].name} `,\n                      [\"object\", { object: object._refs[k] }],\n                      \")\",\n                    ],\n                  ]\n                : []\n              : []),\n          ]),\n        ];\n      } else if (object._type === \"CoList\") {\n        return [\n          \"div\",\n          { style: \"margin-left: 15px\" },\n          [\"div\", \"id: \", [\"object\", { object: object.id }]],\n          ...(object as any[]).map((v, i) => [\n            \"div\",\n            { style: \"white-space: nowrap;\" },\n            [\"span\", { style: \"font-weight: bold; opacity: 0.6\" }, i, \": \"],\n            [\"object\", { object: v }],\n            ...(typeof object._schema[ItemsSym] === \"function\"\n              ? v === null\n                ? [\n                    [\n                      \"span\",\n                      { style: \"opacity: 0.5\" },\n                      ` (pending ${object._schema[ItemsSym].name} `,\n                      [\"object\", { object: object._refs[i] }],\n                      \")\",\n                    ],\n                  ]\n                : []\n              : []),\n          ]),\n        ];\n      }\n    },\n  },\n];\n","import {\n  CoID,\n  InviteSecret,\n  RawAccount,\n  RawCoMap,\n  RawControlledAccount,\n  SessionID,\n} from \"cojson\";\nimport { CoStreamItem, RawCoStream } from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport { type Account } from \"./account.js\";\nimport { CoValue, CoValueClass, ID, loadCoValue } from \"./interfaces.js\";\n\nexport type InboxInvite = `${CoID<MessagesStream>}/${InviteSecret}`;\ntype TxKey = `${SessionID}/${number}`;\n\ntype MessagesStream = RawCoStream<CoID<InboxMessage<CoValue, any>>>;\ntype FailedMessagesStream = RawCoStream<{\n  errors: string[];\n  value: CoID<InboxMessage<CoValue, any>>;\n}>;\ntype TxKeyStream = RawCoStream<TxKey>;\nexport type InboxRoot = RawCoMap<{\n  messages: CoID<MessagesStream>;\n  processed: CoID<TxKeyStream>;\n  failed: CoID<FailedMessagesStream>;\n  inviteLink: InboxInvite;\n}>;\n\nexport function createInboxRoot(account: Account) {\n  if (!account.isLocalNodeOwner) {\n    throw new Error(\"Account is not controlled\");\n  }\n\n  const rawAccount = account._raw as RawControlledAccount;\n\n  const group = rawAccount.createGroup();\n  const messagesFeed = group.createStream<MessagesStream>();\n\n  const inboxRoot = rawAccount.createMap<InboxRoot>();\n  const processedFeed = rawAccount.createStream<TxKeyStream>();\n  const failedFeed = rawAccount.createStream<FailedMessagesStream>();\n\n  const inviteLink =\n    `${messagesFeed.id}/${group.createInvite(\"writeOnly\")}` as const;\n\n  inboxRoot.set(\"messages\", messagesFeed.id);\n  inboxRoot.set(\"processed\", processedFeed.id);\n  inboxRoot.set(\"failed\", failedFeed.id);\n\n  return {\n    id: inboxRoot.id,\n    inviteLink,\n  };\n}\n\ntype InboxMessage<I extends CoValue, O extends CoValue | undefined> = RawCoMap<{\n  payload: ID<I>;\n  result: ID<O> | undefined;\n  processed: boolean;\n  error: string | undefined;\n}>;\n\nasync function createInboxMessage<\n  I extends CoValue,\n  O extends CoValue | undefined,\n>(payload: I, inboxOwner: RawAccount) {\n  const group = payload._raw.group;\n\n  if (group instanceof RawAccount) {\n    throw new Error(\"Inbox messages should be owned by a group\");\n  }\n\n  group.addMember(inboxOwner, \"writer\");\n\n  const message = group.createMap<InboxMessage<I, O>>({\n    payload: payload.id,\n    result: undefined,\n    processed: false,\n    error: undefined,\n  });\n\n  await payload._raw.core.waitForSync();\n  await message.core.waitForSync();\n\n  return message;\n}\n\nexport class Inbox {\n  account: Account;\n  messages: MessagesStream;\n  processed: TxKeyStream;\n  failed: FailedMessagesStream;\n  root: InboxRoot;\n  processing = new Set<`${SessionID}/${number}`>();\n\n  private constructor(\n    account: Account,\n    root: InboxRoot,\n    messages: MessagesStream,\n    processed: TxKeyStream,\n    failed: FailedMessagesStream,\n  ) {\n    this.account = account;\n    this.root = root;\n    this.messages = messages;\n    this.processed = processed;\n    this.failed = failed;\n  }\n\n  subscribe<I extends CoValue, O extends CoValue | undefined>(\n    Schema: CoValueClass<I>,\n    callback: (\n      message: I,\n      senderAccountID: ID<Account>,\n    ) => Promise<O | undefined | void>,\n    options: { retries?: number } = {},\n  ) {\n    const processed = new Set<`${SessionID}/${number}`>();\n    const failed = new Map<`${SessionID}/${number}`, string[]>();\n    const node = this.account._raw.core.node;\n\n    this.processed.subscribe((stream) => {\n      for (const items of Object.values(stream.items)) {\n        for (const item of items) {\n          processed.add(item.value as TxKey);\n        }\n      }\n    });\n\n    const { account } = this;\n    const { retries = 3 } = options;\n\n    let failTimer: ReturnType<typeof setTimeout> | number | undefined =\n      undefined;\n\n    const clearFailTimer = () => {\n      clearTimeout(failTimer);\n      failTimer = undefined;\n    };\n\n    const handleNewMessages = (stream: MessagesStream) => {\n      clearFailTimer(); // Stop the failure timers, we're going to process the failed entries anyway\n\n      for (const [sessionID, items] of Object.entries(stream.items) as [\n        SessionID,\n        CoStreamItem<CoID<InboxMessage<I, O>>>[],\n      ][]) {\n        const accountID = getAccountIDfromSessionID(sessionID);\n\n        if (!accountID) {\n          console.warn(\"Received message from unknown account\", sessionID);\n          continue;\n        }\n\n        for (const item of items) {\n          const txKey = `${sessionID}/${item.tx.txIndex}` as const;\n\n          if (!processed.has(txKey) && !this.processing.has(txKey)) {\n            this.processing.add(txKey);\n\n            const id = item.value;\n\n            node\n              .load(id)\n              .then((message) => {\n                if (message === \"unavailable\") {\n                  return Promise.reject(\n                    new Error(\"Unable to load inbox message \" + id),\n                  );\n                }\n\n                return loadCoValue(Schema, message.get(\"payload\") as ID<I>, {\n                  loadAs: account,\n                });\n              })\n              .then((value) => {\n                if (!value) {\n                  return Promise.reject(\n                    new Error(\"Unable to load inbox message \" + id),\n                  );\n                }\n\n                return callback(value, accountID);\n              })\n              .then((result) => {\n                const inboxMessage = node\n                  .expectCoValueLoaded(item.value)\n                  .getCurrentContent() as RawCoMap;\n\n                if (result) {\n                  inboxMessage.set(\"result\", result.id);\n                }\n\n                inboxMessage.set(\"processed\", true);\n\n                this.processed.push(txKey);\n                this.processing.delete(txKey);\n              })\n              .catch((error) => {\n                console.error(\"Error processing inbox message\", error);\n                this.processing.delete(txKey);\n                const errors = failed.get(txKey) ?? [];\n\n                const stringifiedError = String(error);\n                errors.push(stringifiedError);\n\n                let inboxMessage: RawCoMap | undefined;\n\n                try {\n                  inboxMessage = node\n                    .expectCoValueLoaded(item.value)\n                    .getCurrentContent() as RawCoMap;\n\n                  inboxMessage.set(\"error\", stringifiedError);\n                } catch (error) {}\n\n                if (errors.length > retries) {\n                  inboxMessage?.set(\"processed\", true);\n                  this.processed.push(txKey);\n                  this.failed.push({ errors, value: item.value });\n                } else {\n                  failed.set(txKey, errors);\n                  if (!failTimer) {\n                    failTimer = setTimeout(\n                      () => handleNewMessages(stream),\n                      100,\n                    );\n                  }\n                }\n              });\n          }\n        }\n      }\n    };\n\n    const unsubscribe = this.messages.subscribe(handleNewMessages);\n\n    return () => {\n      unsubscribe();\n      clearFailTimer();\n    };\n  }\n\n  static async load(account: Account) {\n    const profile = account.profile;\n\n    if (!profile) {\n      throw new Error(\"Account profile should already be loaded\");\n    }\n\n    if (!profile.inbox) {\n      throw new Error(\"The account has not set up their inbox\");\n    }\n\n    const node = account._raw.core.node;\n\n    const root = await node.load(profile.inbox as CoID<InboxRoot>);\n\n    if (root === \"unavailable\") {\n      throw new Error(\"Inbox not found\");\n    }\n\n    const [messages, processed, failed] = await Promise.all([\n      node.load(root.get(\"messages\")!),\n      node.load(root.get(\"processed\")!),\n      node.load(root.get(\"failed\")!),\n    ]);\n\n    if (\n      messages === \"unavailable\" ||\n      processed === \"unavailable\" ||\n      failed === \"unavailable\"\n    ) {\n      throw new Error(\"Inbox not found\");\n    }\n\n    return new Inbox(account, root, messages, processed, failed);\n  }\n}\n\nexport class InboxSender<I extends CoValue, O extends CoValue | undefined> {\n  currentAccount: Account;\n  owner: RawAccount;\n  messages: MessagesStream;\n\n  private constructor(\n    currentAccount: Account,\n    owner: RawAccount,\n    messages: MessagesStream,\n  ) {\n    this.currentAccount = currentAccount;\n    this.owner = owner;\n    this.messages = messages;\n  }\n\n  getOwnerAccount() {\n    return this.owner;\n  }\n\n  async sendMessage(\n    message: I,\n  ): Promise<O extends CoValue ? ID<O> : undefined> {\n    const inboxMessage = await createInboxMessage<I, O>(message, this.owner);\n\n    this.messages.push(inboxMessage.id);\n\n    return new Promise((resolve, reject) => {\n      inboxMessage.subscribe((message) => {\n        if (message.get(\"processed\")) {\n          const error = message.get(\"error\");\n          if (error) {\n            reject(new Error(error));\n          } else {\n            resolve(\n              message.get(\"result\") as O extends CoValue ? ID<O> : undefined,\n            );\n          }\n        }\n      });\n    });\n  }\n\n  static async load<\n    I extends CoValue,\n    O extends CoValue | undefined = undefined,\n  >(inboxOwnerID: ID<Account>, currentAccount?: Account) {\n    currentAccount ||= activeAccountContext.get();\n\n    const node = currentAccount._raw.core.node;\n\n    const inboxOwnerRaw = await node.load(\n      inboxOwnerID as unknown as CoID<RawAccount>,\n    );\n\n    if (inboxOwnerRaw === \"unavailable\") {\n      throw new Error(\"Failed to load the inbox owner\");\n    }\n\n    const inboxOwnerProfileRaw = await node.load(inboxOwnerRaw.get(\"profile\")!);\n\n    if (inboxOwnerProfileRaw === \"unavailable\") {\n      throw new Error(\"Failed to load the inbox owner profile\");\n    }\n\n    if (\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"reader\" &&\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"writer\" &&\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"admin\"\n    ) {\n      throw new Error(\n        \"Insufficient permissions to access the inbox, make sure its user profile is publicly readable.\",\n      );\n    }\n\n    const inboxInvite = inboxOwnerProfileRaw.get(\"inboxInvite\");\n\n    if (!inboxInvite) {\n      throw new Error(\"The user has not set up their inbox\");\n    }\n\n    const id = await acceptInvite(inboxInvite as InboxInvite, currentAccount);\n\n    const messages = await node.load(id);\n\n    if (messages === \"unavailable\") {\n      throw new Error(\"Inbox not found\");\n    }\n\n    return new InboxSender<I, O>(currentAccount, inboxOwnerRaw, messages);\n  }\n}\n\nasync function acceptInvite(invite: string, account?: Account) {\n  account ||= activeAccountContext.get();\n\n  const id = invite.slice(0, invite.indexOf(\"/\")) as CoID<MessagesStream>;\n\n  const inviteSecret = invite.slice(invite.indexOf(\"/\") + 1) as InviteSecret;\n\n  if (!id?.startsWith(\"co_z\") || !inviteSecret.startsWith(\"inviteSecret_\")) {\n    throw new Error(\"Invalid inbox ticket\");\n  }\n\n  if (!account.isLocalNodeOwner) {\n    throw new Error(\"Account is not controlled\");\n  }\n\n  await (account._raw as RawControlledAccount).acceptInvite(id, inviteSecret);\n\n  return id;\n}\n\nfunction getAccountIDfromSessionID(sessionID: SessionID) {\n  const until = sessionID.indexOf(\"_session\");\n  const accountID = sessionID.slice(0, until);\n\n  if (accountID.startsWith(\"co_z\")) {\n    return accountID as ID<Account>;\n  }\n\n  return;\n}\n","import {\n  AgentID,\n  type CoValueUniqueness,\n  CojsonInternalTypes,\n  type JsonValue,\n  RawAccountID,\n  type RawCoMap,\n  cojsonInternals,\n} from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  ID,\n  IfCo,\n  RefEncoded,\n  RefIfCoValue,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  co,\n} from \"../internal.js\";\nimport {\n  CoValueBase,\n  ItemsSym,\n  Ref,\n  SchemaInit,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  makeRefs,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { type Account } from \"./account.js\";\nimport { type Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\ntype CoMapEdit<V> = {\n  value?: V;\n  ref?: RefIfCoValue<V>;\n  by?: RegisteredAccount;\n  madeAt: Date;\n  key?: string;\n};\n\ntype LastAndAllCoMapEdits<V> = CoMapEdit<V> & { all: CoMapEdit<V>[] };\n\nexport type Simplify<A> = {\n  [K in keyof A]: A[K];\n} extends infer B\n  ? B\n  : never;\n\n/**\n * CoMaps are collaborative versions of plain objects, mapping string-like keys to values.\n *\n * @categoryDescription Declaration\n * Declare your own CoMap schemas by subclassing `CoMap` and assigning field schemas with `co`.\n *\n * Optional `co.ref(...)` fields must be marked with `{ optional: true }`.\n *\n * ```ts\n * import { co, CoMap } from \"jazz-tools\";\n *\n * class Person extends CoMap {\n *   name = co.string;\n *   age = co.number;\n *   pet = co.ref(Animal);\n *   car = co.ref(Car, { optional: true });\n * }\n * ```\n *\n * @categoryDescription Content\n * You can access properties you declare on a `CoMap` (using `co`) as if they were normal properties on a plain object, using dot notation, `Object.keys()`, etc.\n *\n * ```ts\n * person.name;\n * person[\"age\"];\n * person.age = 42;\n * person.pet?.name;\n * Object.keys(person);\n * // => [\"name\", \"age\", \"pet\"]\n * ```\n *\n * @category CoValues\n *  */\nexport class CoMap extends CoValueBase implements CoValue {\n  /**\n   * The ID of this `CoMap`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoMap\";\n  static {\n    this.prototype._type = \"CoMap\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoMap;\n\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema() {\n    return (this.constructor as typeof CoMap)._schema as {\n      [key: string]: Schema;\n    } & { [ItemsSym]?: Schema };\n  }\n\n  /**\n   * If property `prop` is a `co.ref(...)`, you can use `coMaps._refs.prop` to access\n   * the `Ref` instead of the potentially loaded/null value.\n   *\n   * This allows you to always get the ID or load the value manually.\n   *\n   * @example\n   * ```ts\n   * person._refs.pet.id; // => ID<Animal>\n   * person._refs.pet.value;\n   * // => Animal | null\n   * const pet = await person._refs.pet.load();\n   * ```\n   *\n   * @category Content\n   **/\n  get _refs(): {\n    [Key in CoKeys<this>]: IfCo<this[Key], RefIfCoValue<this[Key]>>;\n  } {\n    return makeRefs<CoKeys<this>>(\n      (key) => this._raw.get(key as string) as unknown as ID<CoValue>,\n      () => {\n        const keys = this._raw.keys().filter((key) => {\n          const schema =\n            this._schema[key as keyof typeof this._schema] ||\n            (this._schema[ItemsSym] as Schema | undefined);\n          return schema && schema !== \"json\" && isRefEncoded(schema);\n        }) as CoKeys<this>[];\n\n        return keys;\n      },\n      this._loadedAs,\n      (key) =>\n        (this._schema[key] || this._schema[ItemsSym]) as RefEncoded<CoValue>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) as any;\n  }\n\n  /** @internal */\n  public getEditFromRaw(\n    target: CoMap,\n    rawEdit: {\n      by: RawAccountID | AgentID;\n      tx: CojsonInternalTypes.TransactionID;\n      at: Date;\n      value?: JsonValue | undefined;\n    },\n    descriptor: Schema,\n    key: string,\n  ) {\n    return {\n      value:\n        descriptor === \"json\"\n          ? rawEdit.value\n          : \"encoded\" in descriptor\n            ? rawEdit.value === null || rawEdit.value === undefined\n              ? rawEdit.value\n              : descriptor.encoded.decode(rawEdit.value)\n            : new Ref(\n                rawEdit.value as ID<CoValue>,\n                target._loadedAs,\n                descriptor,\n              ).accessFrom(target, \"_edits.\" + key + \".value\"),\n      ref:\n        descriptor !== \"json\" && isRefEncoded(descriptor)\n          ? new Ref(rawEdit.value as ID<CoValue>, target._loadedAs, descriptor)\n          : undefined,\n      by:\n        rawEdit.by &&\n        new Ref<Account>(rawEdit.by as ID<Account>, target._loadedAs, {\n          ref: RegisteredSchemas[\"Account\"],\n          optional: false,\n        }).accessFrom(target, \"_edits.\" + key + \".by\"),\n      madeAt: rawEdit.at,\n      key,\n    };\n  }\n\n  /** @category Collaboration */\n  get _edits() {\n    const map = this;\n    return new Proxy(\n      {},\n      {\n        get(_target, key) {\n          const rawEdit = map._raw.lastEditAt(key as string);\n          if (!rawEdit) return undefined;\n\n          const descriptor = map._schema[\n            key as keyof typeof map._schema\n          ] as Schema;\n\n          return {\n            ...map.getEditFromRaw(map, rawEdit, descriptor, key as string),\n            get all() {\n              return [...map._raw.editsAt(key as string)].map((rawEdit) =>\n                map.getEditFromRaw(map, rawEdit, descriptor, key as string),\n              );\n            },\n          };\n        },\n        ownKeys(_target) {\n          return map._raw.keys();\n        },\n        getOwnPropertyDescriptor(target, key) {\n          return {\n            value: Reflect.get(target, key),\n            writable: false,\n            enumerable: true,\n            configurable: true,\n          };\n        },\n      },\n    ) as {\n      [Key in CoKeys<this>]: IfCo<this[Key], LastAndAllCoMapEdits<this[Key]>>;\n    };\n  }\n\n  /** @internal */\n  constructor(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options: { fromRaw: RawCoMap } | undefined,\n  ) {\n    super();\n\n    if (options) {\n      if (\"fromRaw\" in options) {\n        Object.defineProperties(this, {\n          id: {\n            value: options.fromRaw.id as unknown as ID<this>,\n            enumerable: false,\n          },\n          _raw: { value: options.fromRaw, enumerable: false },\n        });\n      } else {\n        throw new Error(\"Invalid CoMap constructor arguments\");\n      }\n    }\n\n    return new Proxy(this, CoMapProxyHandler as ProxyHandler<this>);\n  }\n\n  /**\n   * Create a new CoMap with the given initial values and owner.\n   *\n   * The owner (a Group or Account) determines access rights to the CoMap.\n   *\n   * The CoMap will immediately be persisted and synced to connected peers.\n   *\n   * @example\n   * ```ts\n   * const person = Person.create({\n   *   name: \"Alice\",\n   *   age: 42,\n   *   pet: cat,\n   * }, { owner: friendGroup });\n   * ```\n   *\n   * @category Creation\n   **/\n  static create<M extends CoMap>(\n    this: CoValueClass<M>,\n    init: Simplify<CoMapInit<M>>,\n    options?:\n      | {\n          owner: Account | Group;\n          unique?: CoValueUniqueness[\"uniqueness\"];\n        }\n      | Account\n      | Group,\n  ) {\n    const instance = new this();\n\n    const { owner, uniqueness } = parseCoValueCreateOptions(options);\n    const raw = instance.rawFromInit(init, owner, uniqueness);\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n    return instance;\n  }\n\n  /**\n   * Return a JSON representation of the `CoMap`\n   * @category Content\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(_key?: string, processedValues?: ID<CoValue>[]): any {\n    const result = {\n      id: this.id,\n      _type: this._type,\n    } as Record<string, any>;\n\n    for (const key of this._raw.keys()) {\n      const tKey = key as CoKeys<this>;\n      const descriptor = (this._schema[tKey] ||\n        this._schema[ItemsSym]) as Schema;\n\n      if (!descriptor) {\n        continue;\n      }\n\n      if (descriptor == \"json\" || \"encoded\" in descriptor) {\n        result[key] = this._raw.get(key);\n      } else if (isRefEncoded(descriptor)) {\n        const id = this._raw.get(key) as ID<CoValue>;\n\n        if (processedValues?.includes(id) || id === this.id) {\n          result[key] = { _circular: id };\n          continue;\n        }\n\n        const ref = this[tKey];\n\n        if (\n          ref &&\n          typeof ref === \"object\" &&\n          \"toJSON\" in ref &&\n          typeof ref.toJSON === \"function\"\n        ) {\n          const jsonedRef = ref.toJSON(tKey, [\n            ...(processedValues || []),\n            this.id,\n          ]);\n          result[key] = jsonedRef;\n        }\n      } else {\n        result[key] = undefined;\n      }\n    }\n\n    return result;\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /**\n   * Create a new `RawCoMap` from an initialization object\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawFromInit<Fields extends object = Record<string, any>>(\n    init: Simplify<CoMapInit<Fields>> | undefined,\n    owner: Account | Group,\n    uniqueness?: CoValueUniqueness,\n  ) {\n    const rawOwner = owner._raw;\n\n    const rawInit = {} as {\n      [key in keyof Fields]: JsonValue | undefined;\n    };\n\n    if (init)\n      for (const key of Object.keys(init) as (keyof Fields)[]) {\n        const initValue = init[key as keyof typeof init];\n\n        const descriptor = (this._schema[key as keyof typeof this._schema] ||\n          this._schema[ItemsSym]) as Schema;\n\n        if (!descriptor) {\n          continue;\n        }\n\n        if (descriptor === \"json\") {\n          rawInit[key] = initValue as JsonValue;\n        } else if (isRefEncoded(descriptor)) {\n          if (initValue) {\n            rawInit[key] = (initValue as unknown as CoValue).id;\n          }\n        } else if (\"encoded\" in descriptor) {\n          rawInit[key] = descriptor.encoded.encode(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            initValue as any,\n          );\n        }\n      }\n\n    return rawOwner.createMap(rawInit, null, \"private\", uniqueness);\n  }\n\n  /**\n   * Declare a Record-like CoMap schema, by extending `CoMap.Record(...)` and passing the value schema using `co`. Keys are always `string`.\n   *\n   * @example\n   * ```ts\n   * import { co, CoMap } from \"jazz-tools\";\n   *\n   * class ColorToFruitMap extends CoMap.Record(\n   *  co.ref(Fruit)\n   * ) {}\n   *\n   * // assume we have map: ColorToFruitMap\n   * // and strawberry: Fruit\n   * map[\"red\"] = strawberry;\n   * ```\n   *\n   * @category Declaration\n   */\n  static Record<Value>(value: IfCo<Value, Value>) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n    class RecordLikeCoMap extends CoMap {\n      [ItemsSym] = value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n    interface RecordLikeCoMap extends Record<string, Value> {}\n\n    return RecordLikeCoMap;\n  }\n\n  /**\n   * Load a `CoMap` with a given ID, as a given account.\n   *\n   * `depth` specifies which (if any) fields that reference other CoValues to load as well before resolving.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * @example\n   * ```ts\n   * const person = await Person.load(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   { pet: {} }\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static load<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    options?: {\n      resolve?: RefsToResolveStrict<M, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<M, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Load and subscribe to a `CoMap` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * `depth` specifies which (if any) fields that reference other CoValues to load as well before calling `listener` for the first time.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @example\n   * ```ts\n   * const unsub = Person.subscribe(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   { pet: {} },\n   *   (person) => console.log(person)\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    options: SubscribeListenerOptions<M, R>,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    ...args: SubscribeRestArgs<M, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<M, R>(this, id, options, listener);\n  }\n\n  static findUnique<M extends CoMap>(\n    this: CoValueClass<M>,\n    unique: CoValueUniqueness[\"uniqueness\"],\n    ownerID: ID<Account> | ID<Group>,\n    as?: Account | Group | AnonymousJazzAgent,\n  ) {\n    as ||= activeAccountContext.get();\n\n    const header = {\n      type: \"comap\" as const,\n      ruleset: {\n        type: \"ownedByGroup\" as const,\n        group: ownerID,\n      },\n      meta: null,\n      uniqueness: unique,\n    };\n    const crypto =\n      as._type === \"Anonymous\" ? as.node.crypto : as._raw.core.crypto;\n    return cojsonInternals.idforHeader(header, crypto) as ID<M>;\n  }\n\n  /**\n   * Given an already loaded `CoMap`, ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoMap.load()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * @category Subscription & Loading\n   */\n  ensureLoaded<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: M,\n    options: { resolve: RefsToResolveStrict<M, R> },\n  ): Promise<Resolved<M, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * Given an already loaded `CoMap`, subscribe to updates to the `CoMap` and ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoMap.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: M,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: M,\n    options: { resolve?: RefsToResolveStrict<M, R> },\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: M,\n    ...args: SubscribeRestArgs<M, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue<M, R>(this, options, listener);\n  }\n\n  applyDiff<N extends Partial<CoMapInit<this>>>(newValues: N) {\n    for (const key in newValues) {\n      if (Object.prototype.hasOwnProperty.call(newValues, key)) {\n        const tKey = key as keyof typeof newValues & keyof this;\n        const descriptor = (this._schema[tKey as string] ||\n          this._schema[ItemsSym]) as Schema;\n\n        if (tKey in this._schema) {\n          const newValue = newValues[tKey];\n          const currentValue = (this as unknown as N)[tKey];\n\n          if (descriptor === \"json\" || \"encoded\" in descriptor) {\n            if (currentValue !== newValue) {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (this as any)[tKey] = newValue;\n            }\n          } else if (isRefEncoded(descriptor)) {\n            const currentId = (currentValue as CoValue | undefined)?.id;\n            const newId = (newValue as CoValue | undefined)?.id;\n            if (currentId !== newId) {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (this as any)[tKey] = newValue;\n            }\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Wait for the `CoMap` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\nexport type CoKeys<Map extends object> = Exclude<\n  keyof Map & string,\n  keyof CoMap\n>;\n\n/**\n * Force required ref fields to be non nullable\n *\n * Considering that:\n * - Optional refs are typed as co<InstanceType<CoValueClass> | null | undefined>\n * - Required refs are typed as co<InstanceType<CoValueClass> | null>\n *\n * This type works in two steps:\n * - Remove the null from both types\n * - Then we check if the input type accepts undefined, if positive we put the null union back\n *\n * So the optional refs stays unchanged while we safely remove the null union\n * from required refs\n *\n * This way required refs can be marked as required in the CoMapInit while\n * staying a nullable property for value access.\n *\n * Example:\n *\n * const map = MyCoMap.create({\n *   requiredRef: NestedMap.create({}) // null is not valid here\n * })\n *\n * map.requiredRef // this value is still nullable\n */\ntype ForceRequiredRef<V> = V extends co<InstanceType<CoValueClass> | null>\n  ? NonNullable<V>\n  : V extends co<InstanceType<CoValueClass> | undefined>\n    ? V | null\n    : V;\n\nexport type CoMapInit<Map extends object> = {\n  [Key in CoKeys<Map> as undefined extends Map[Key]\n    ? never\n    : IfCo<Map[Key], Key>]: ForceRequiredRef<Map[Key]>;\n} & {\n  [Key in CoKeys<Map> as IfCo<Map[Key], Key>]?: ForceRequiredRef<Map[Key]>;\n};\n\n// TODO: cache handlers per descriptor for performance?\nconst CoMapProxyHandler: ProxyHandler<CoMap> = {\n  get(target, key, receiver) {\n    if (key === \"_schema\") {\n      return Reflect.get(target, key);\n    } else if (key in target) {\n      return Reflect.get(target, key, receiver);\n    } else {\n      const schema = target._schema;\n\n      if (!schema) {\n        return undefined;\n      }\n\n      const descriptor = (schema[key as keyof CoMap[\"_schema\"]] ||\n        schema[ItemsSym]) as Schema;\n      if (descriptor && typeof key === \"string\") {\n        const raw = target._raw.get(key);\n\n        if (descriptor === \"json\") {\n          return raw;\n        } else if (\"encoded\" in descriptor) {\n          return raw === undefined ? undefined : descriptor.encoded.decode(raw);\n        } else if (isRefEncoded(descriptor)) {\n          return raw === undefined\n            ? undefined\n            : new Ref(\n                raw as unknown as ID<CoValue>,\n                target._loadedAs,\n                descriptor,\n              ).accessFrom(receiver, key);\n        }\n      } else {\n        return undefined;\n      }\n    }\n  },\n  set(target, key, value, receiver) {\n    if (\n      (typeof key === \"string\" || ItemsSym) &&\n      typeof value === \"object\" &&\n      value !== null &&\n      SchemaInit in value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] = value[SchemaInit];\n      return true;\n    }\n\n    const descriptor = (target._schema[key as keyof CoMap[\"_schema\"]] ||\n      target._schema[ItemsSym]) as Schema;\n    if (descriptor && typeof key === \"string\") {\n      if (descriptor === \"json\") {\n        target._raw.set(key, value);\n      } else if (\"encoded\" in descriptor) {\n        target._raw.set(key, descriptor.encoded.encode(value));\n      } else if (isRefEncoded(descriptor)) {\n        if (value === null) {\n          if (descriptor.optional) {\n            target._raw.set(key, null);\n          } else {\n            throw new Error(`Cannot set required reference ${key} to null`);\n          }\n        } else if (value?.id) {\n          target._raw.set(key, value.id);\n          subscriptionsScopes\n            .get(target)\n            ?.onRefAccessedOrSet(target.id, value.id);\n        } else {\n          throw new Error(\n            `Cannot set reference ${key} to a non-CoValue. Got ${value}`,\n          );\n        }\n      }\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, attributes) {\n    if (\n      \"value\" in attributes &&\n      typeof attributes.value === \"object\" &&\n      SchemaInit in attributes.value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key as string] =\n        attributes.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, attributes);\n    }\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target).filter((k) => k !== ItemsSym);\n    // for (const key of Reflect.ownKeys(target._schema)) {\n    //     if (key !== ItemsSym && !keys.includes(key)) {\n    //         keys.push(key);\n    //     }\n    // }\n    for (const key of target._raw.keys()) {\n      if (!keys.includes(key)) {\n        keys.push(key);\n      }\n    }\n\n    return keys;\n  },\n  getOwnPropertyDescriptor(target, key) {\n    if (key in target) {\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    } else {\n      const descriptor = (target._schema[key as keyof CoMap[\"_schema\"]] ||\n        target._schema[ItemsSym]) as Schema;\n      if (descriptor || key in target._raw.latest) {\n        return {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n        };\n      }\n    }\n  },\n  has(target, key) {\n    const descriptor = (target._schema?.[key as keyof CoMap[\"_schema\"]] ||\n      target._schema?.[ItemsSym]) as Schema;\n\n    if (target._raw && typeof key === \"string\" && descriptor) {\n      return target._raw.get(key) !== undefined;\n    } else {\n      return Reflect.has(target, key);\n    }\n  },\n  deleteProperty(target, key) {\n    const descriptor = (target._schema[key as keyof CoMap[\"_schema\"]] ||\n      target._schema[ItemsSym]) as Schema;\n    if (typeof key === \"string\" && descriptor) {\n      target._raw.delete(key);\n      return true;\n    } else {\n      return Reflect.deleteProperty(target, key);\n    }\n  },\n};\n\nRegisteredSchemas[\"CoMap\"] = CoMap;\n","import { CoID } from \"cojson\";\nimport { CoValueClass, co } from \"../internal.js\";\nimport { Account } from \"./account.js\";\nimport { CoMap, CoMapInit, Simplify } from \"./coMap.js\";\nimport { Group } from \"./group.js\";\nimport { InboxInvite, InboxRoot } from \"./inbox.js\";\n\n/** @category Identity & Permissions */\nexport class Profile extends CoMap {\n  name = co.string;\n  inbox = co.optional.json<CoID<InboxRoot>>();\n  inboxInvite = co.optional.json<InboxInvite>();\n\n  override get _owner(): Group {\n    return super._owner as Group;\n  }\n\n  /**\n   * Creates a new profile with the given initial values and owner.\n   *\n   * The owner (a Group) determines access rights to the Profile.\n   *\n   * @category Creation\n   */\n  static override create<M extends CoMap>(\n    this: CoValueClass<M>,\n    init: Simplify<CoMapInit<M>>,\n    options?:\n      | {\n          owner: Group;\n        }\n      | Group,\n  ) {\n    const owner =\n      options !== undefined && \"owner\" in options ? options.owner : options;\n\n    // We add some guardrails to ensure that the owner of a profile is a group\n    if ((owner as Group | Account | undefined)?._type === \"Account\") {\n      throw new Error(\"Profiles should be owned by a group\");\n    }\n\n    return super.create<M>(init, options);\n  }\n}\n","import {\n  AgentSecret,\n  CoID,\n  CryptoProvider,\n  Everyone,\n  InviteSecret,\n  LocalNode,\n  Peer,\n  RawAccount,\n  RawCoMap,\n  RawCoValue,\n  RawControlledAccount,\n  Role,\n  SessionID,\n  cojsonInternals,\n} from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport {\n  AnonymousJazzAgent,\n  type CoValue,\n  CoValueBase,\n  CoValueClass,\n  ID,\n  Ref,\n  type RefEncoded,\n  RefIfCoValue,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  type Schema,\n  SchemaInit,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  ensureCoValueLoaded,\n  inspect,\n  loadCoValue,\n  loadCoValueWithoutMe,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { type CoMap } from \"./coMap.js\";\nimport { type Group } from \"./group.js\";\nimport { createInboxRoot } from \"./inbox.js\";\nimport { Profile } from \"./profile.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\nexport type AccountCreationProps = {\n  name: string;\n  onboarding?: boolean;\n};\n\n/** @category Identity & Permissions */\nexport class Account extends CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"Account\";\n  declare _raw: RawAccount | RawControlledAccount;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  get _schema(): {\n    profile: Schema;\n    root: Schema;\n  } {\n    return (this.constructor as typeof Account)._schema;\n  }\n  static {\n    this._schema = {\n      profile: {\n        ref: () => Profile,\n        optional: false,\n      } satisfies RefEncoded<Profile>,\n      root: {\n        ref: () => RegisteredSchemas[\"CoMap\"],\n        optional: true,\n      } satisfies RefEncoded<CoMap>,\n    };\n  }\n\n  get _owner(): Account {\n    return this as Account;\n  }\n  get _loadedAs(): Account | AnonymousJazzAgent {\n    if (this.isLocalNodeOwner) return this;\n\n    const rawAccount = this._raw.core.node.account;\n\n    if (rawAccount instanceof RawAccount) {\n      return coValuesCache.get(rawAccount, () => Account.fromRaw(rawAccount));\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  declare profile: Profile | null;\n  declare root: CoMap | null;\n\n  get _refs(): {\n    profile: RefIfCoValue<Profile> | undefined;\n    root: RefIfCoValue<CoMap> | undefined;\n  } {\n    const profileID = this._raw.get(\"profile\") as unknown as\n      | ID<NonNullable<this[\"profile\"]>>\n      | undefined;\n    const rootID = this._raw.get(\"root\") as unknown as\n      | ID<NonNullable<this[\"root\"]>>\n      | undefined;\n\n    return {\n      profile:\n        profileID &&\n        (new Ref(\n          profileID,\n          this._loadedAs,\n          this._schema.profile as RefEncoded<\n            NonNullable<this[\"profile\"]> & CoValue\n          >,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any as RefIfCoValue<this[\"profile\"]>),\n      root:\n        rootID &&\n        (new Ref(\n          rootID,\n          this._loadedAs,\n          this._schema.root as RefEncoded<NonNullable<this[\"root\"]> & CoValue>,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any as RefIfCoValue<this[\"root\"]>),\n    };\n  }\n\n  /**\n   * Whether this account is the currently active account.\n   */\n  get isMe() {\n    return activeAccountContext.get().id === this.id;\n  }\n\n  /**\n   * Whether this account is the owner of the local node.\n   */\n  isLocalNodeOwner: boolean;\n  sessionID: SessionID | undefined;\n\n  constructor(options: { fromRaw: RawAccount | RawControlledAccount }) {\n    super();\n    if (!(\"fromRaw\" in options)) {\n      throw new Error(\"Can only construct account from raw or with .create()\");\n    }\n    this.isLocalNodeOwner =\n      options.fromRaw.id == options.fromRaw.core.node.account.id;\n\n    Object.defineProperties(this, {\n      id: {\n        value: options.fromRaw.id,\n        enumerable: false,\n      },\n      _raw: { value: options.fromRaw, enumerable: false },\n      _type: { value: \"Account\", enumerable: false },\n    });\n\n    if (this.isLocalNodeOwner) {\n      this.sessionID = options.fromRaw.core.node.currentSessionID;\n    }\n\n    return new Proxy(this, AccountAndGroupProxyHandler as ProxyHandler<this>);\n  }\n\n  myRole(): \"admin\" | undefined {\n    if (this.isLocalNodeOwner) {\n      return \"admin\";\n    }\n  }\n\n  getRoleOf(member: Everyone | ID<Account> | \"me\") {\n    if (member === \"me\") {\n      return this.isMe ? \"admin\" : undefined;\n    }\n\n    if (member === this.id) {\n      return \"admin\";\n    }\n\n    return undefined;\n  }\n\n  getParentGroups(): Array<Group> {\n    return [];\n  }\n\n  get members(): Array<{\n    id: ID<RegisteredAccount> | \"everyone\";\n    role: Role;\n    ref: Ref<RegisteredAccount> | undefined;\n    account: RegisteredAccount | null | undefined;\n  }> {\n    const ref = new Ref<RegisteredAccount>(this.id, this._loadedAs, {\n      ref: () => this.constructor as typeof Account,\n      optional: false,\n    });\n\n    return [{ id: this.id, role: \"admin\", ref, account: this }];\n  }\n\n  canRead(value: CoValue) {\n    const role = value._owner.getRoleOf(this.id);\n\n    return (\n      role === \"admin\" ||\n      role === \"writer\" ||\n      role === \"reader\" ||\n      role === \"writeOnly\"\n    );\n  }\n\n  canWrite(value: CoValue) {\n    const role = value._owner.getRoleOf(this.id);\n\n    return role === \"admin\" || role === \"writer\" || role === \"writeOnly\";\n  }\n\n  canAdmin(value: CoValue) {\n    return value._owner.getRoleOf(this.id) === \"admin\";\n  }\n\n  async acceptInvite<V extends CoValue>(\n    valueID: ID<V>,\n    inviteSecret: InviteSecret,\n    coValueClass: CoValueClass<V>,\n  ): Promise<Resolved<V, true> | null> {\n    if (!this.isLocalNodeOwner) {\n      throw new Error(\"Only a controlled account can accept invites\");\n    }\n\n    await (this._raw as RawControlledAccount).acceptInvite(\n      valueID as unknown as CoID<RawCoValue>,\n      inviteSecret,\n    );\n\n    return loadCoValue(coValueClass, valueID, {\n      loadAs: this,\n    });\n  }\n\n  /** @private */\n  static async create<A extends Account>(\n    this: CoValueClass<A> & typeof Account,\n    options: {\n      creationProps: { name: string };\n      initialAgentSecret?: AgentSecret;\n      peersToLoadFrom?: Peer[];\n      crypto: CryptoProvider;\n    },\n  ): Promise<A> {\n    const { node } = await LocalNode.withNewlyCreatedAccount({\n      ...options,\n      migration: async (rawAccount, _node, creationProps) => {\n        const account = new this({\n          fromRaw: rawAccount,\n        }) as A;\n\n        await account.applyMigration?.(creationProps);\n      },\n    });\n\n    return this.fromNode(node) as A;\n  }\n\n  static getMe<A extends Account>(this: CoValueClass<A> & typeof Account) {\n    return activeAccountContext.get() as A;\n  }\n\n  static async createAs<A extends Account>(\n    this: CoValueClass<A> & typeof Account,\n    as: Account,\n    options: {\n      creationProps: { name: string };\n    },\n  ) {\n    // TODO: is there a cleaner way to do this?\n    const connectedPeers = cojsonInternals.connectedPeers(\n      \"creatingAccount\",\n      \"createdAccount\",\n      { peer1role: \"server\", peer2role: \"client\" },\n    );\n\n    as._raw.core.node.syncManager.addPeer(connectedPeers[1]);\n\n    const account = await this.create<A>({\n      creationProps: options.creationProps,\n      crypto: as._raw.core.node.crypto,\n      peersToLoadFrom: [connectedPeers[0]],\n    });\n\n    await account.waitForAllCoValuesSync();\n\n    return account;\n  }\n\n  static fromNode<A extends Account>(\n    this: CoValueClass<A>,\n    node: LocalNode,\n  ): A {\n    return new this({\n      fromRaw: node.account as RawControlledAccount,\n    }) as A;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): object | any[] {\n    return {\n      id: this.id,\n      _type: this._type,\n    };\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  async applyMigration(creationProps?: AccountCreationProps) {\n    await this.migrate(creationProps);\n\n    // if the user has not defined a profile themselves, we create one\n    if (this.profile === undefined && creationProps) {\n      const profileGroup = RegisteredSchemas[\"Group\"].create({ owner: this });\n\n      this.profile = Profile.create({ name: creationProps.name }, profileGroup);\n      this.profile._owner.addMember(\"everyone\", \"reader\");\n    } else if (this.profile && creationProps) {\n      if (this.profile._owner._type !== \"Group\") {\n        throw new Error(\"Profile must be owned by a Group\", {\n          cause: `The profile of the account \"${this.id}\" was created with an Account as owner, which is not allowed.`,\n        });\n      }\n    }\n\n    const node = this._raw.core.node;\n    const profile = node\n      .expectCoValueLoaded(this._raw.get(\"profile\")!)\n      .getCurrentContent() as RawCoMap;\n\n    if (!profile.get(\"inbox\")) {\n      const inboxRoot = createInboxRoot(this);\n      profile.set(\"inbox\", inboxRoot.id);\n      profile.set(\"inboxInvite\", inboxRoot.inviteLink);\n    }\n  }\n\n  // Placeholder method for subclasses to override\n  migrate(creationProps?: AccountCreationProps) {\n    creationProps; // To avoid unused parameter warning\n  }\n\n  /** @category Subscription & Loading */\n  static load<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    options?: {\n      resolve?: RefsToResolveStrict<A, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<A, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /** @category Subscription & Loading */\n  static subscribe<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    options: SubscribeListenerOptions<A, R>,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    ...args: SubscribeRestArgs<A, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<A, R>(this, id, options, listener);\n  }\n\n  /** @category Subscription & Loading */\n  ensureLoaded<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    options: { resolve: RefsToResolveStrict<A, R> },\n  ): Promise<Resolved<A, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /** @category Subscription & Loading */\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    options: { resolve?: RefsToResolveStrict<A, R> },\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    ...args: SubscribeRestArgs<A, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `Account` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.waitForSync(options);\n  }\n\n  /**\n   * Wait for all the available `CoValues` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForAllCoValuesSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.node.syncManager.waitForAllCoValuesSync(\n      options?.timeout,\n    );\n  }\n}\n\nexport const AccountAndGroupProxyHandler: ProxyHandler<Account | Group> = {\n  get(target, key, receiver) {\n    if (key === \"profile\") {\n      const ref = target._refs.profile;\n      return ref\n        ? ref.accessFrom(receiver, \"profile\")\n        : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (undefined as any);\n    } else if (key === \"root\") {\n      const ref = target._refs.root;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return ref ? ref.accessFrom(receiver, \"root\") : (undefined as any);\n    } else {\n      return Reflect.get(target, key, receiver);\n    }\n  },\n  set(target, key, value, receiver) {\n    if (\n      (key === \"profile\" || key === \"root\") &&\n      typeof value === \"object\" &&\n      SchemaInit in value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] = value[SchemaInit];\n      return true;\n    } else if (key === \"profile\") {\n      if (value) {\n        target._raw.set(\n          \"profile\",\n          value.id as unknown as CoID<RawCoMap>,\n          \"trusting\",\n        );\n      }\n      subscriptionsScopes\n        .get(receiver)\n        ?.onRefAccessedOrSet(target.id, value.id);\n      return true;\n    } else if (key === \"root\") {\n      if (value) {\n        target._raw.set(\"root\", value.id as unknown as CoID<RawCoMap>);\n      }\n      subscriptionsScopes\n        .get(receiver)\n        ?.onRefAccessedOrSet(target.id, value.id);\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    if (\n      (key === \"profile\" || key === \"root\") &&\n      typeof descriptor.value === \"object\" &&\n      SchemaInit in descriptor.value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] =\n        descriptor.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, descriptor);\n    }\n  },\n};\n\n/** @category Identity & Permissions */\nexport function isControlledAccount(account: Account): account is Account & {\n  isLocalNodeOwner: true;\n  sessionID: SessionID;\n  _raw: RawControlledAccount;\n} {\n  return account.isLocalNodeOwner;\n}\n\nexport type AccountClass<Acc extends Account> = CoValueClass<Acc> & {\n  fromNode: (typeof Account)[\"fromNode\"];\n};\n\nRegisteredSchemas[\"Account\"] = Account;\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport type {\n  AgentID,\n  BinaryStreamInfo,\n  CojsonInternalTypes,\n  JsonValue,\n  RawAccountID,\n  RawBinaryCoStream,\n  RawCoStream,\n  SessionID,\n} from \"cojson\";\nimport { MAX_RECOMMENDED_TX_SIZE, cojsonInternals } from \"cojson\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  ID,\n  IfCo,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SchemaFor,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  UnCo,\n} from \"../internal.js\";\nimport {\n  CoValueBase,\n  ItemsSym,\n  Ref,\n  SchemaInit,\n  co,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { type Account } from \"./account.js\";\nimport { type Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\n/** @deprecated Use CoFeedEntry instead */\nexport type CoStreamEntry<Item> = CoFeedEntry<Item>;\n\nexport type CoFeedEntry<Item> = SingleCoFeedEntry<Item> & {\n  all: IterableIterator<SingleCoFeedEntry<Item>>;\n};\n\n/** @deprecated Use SingleCoFeedEntry instead */\nexport type SingleCoStreamEntry<Item> = SingleCoFeedEntry<Item>;\n\nexport type SingleCoFeedEntry<Item> = {\n  value: NonNullable<Item> extends CoValue ? NonNullable<Item> | null : Item;\n  ref: NonNullable<Item> extends CoValue ? Ref<NonNullable<Item>> : never;\n  by?: RegisteredAccount | null;\n  madeAt: Date;\n  tx: CojsonInternalTypes.TransactionID;\n};\n\n/** @deprecated Use CoFeed instead */\nexport { CoFeed as CoStream };\n\n/**\n * CoFeeds are collaborative logs of data.\n *\n * @categoryDescription Content\n * They are similar to `CoList`s, but with a few key differences:\n * - They are append-only\n * - They consist of several internal append-only logs, one per account session (tab, device, app instance, etc.)\n * - They expose those as a per-account aggregated view (default) or a precise per-session view\n *\n * ```ts\n * favDog.push(\"Poodle\");\n * favDog.push(\"Schnowzer\");\n * ```\n *\n * @category CoValues\n */\nexport class CoFeed<Item = any> extends CoValueBase implements CoValue {\n  /**\n   * Declare a `CoFeed` by subclassing `CoFeed.Of(...)` and passing the item schema using a `co` primitive or a `co.ref`.\n   *\n   * @example\n   * ```ts\n   * class ColorFeed extends CoFeed.Of(co.string) {}\n   * class AnimalFeed extends CoFeed.Of(co.ref(Animal)) {}\n   * ```\n   *\n   * @category Declaration\n   */\n  static Of<Item>(item: IfCo<Item, Item>): typeof CoFeed<Item> {\n    return class CoFeedOf extends CoFeed<Item> {\n      [co.items] = item;\n    };\n  }\n\n  /**\n   * The ID of this `CoFeed`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoStream\";\n  static {\n    this.prototype._type = \"CoStream\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoStream;\n\n  /** @internal This is only a marker type and doesn't exist at runtime */\n  [ItemsSym]!: Item;\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema(): {\n    [ItemsSym]: SchemaFor<Item>;\n  } {\n    return (this.constructor as typeof CoFeed)._schema;\n  }\n\n  /**\n   * The per-account view of this `CoFeed`\n   *\n   * @example\n   * ```ts\n   * // Access entries directly by account ID\n   * const aliceEntries = feed[aliceAccount.id];\n   * console.log(aliceEntries.value); // Latest value from Alice\n   *\n   * // Iterate through all accounts' entries\n   * for (const [accountId, entries] of Object.entries(feed)) {\n   *   console.log(`Latest entry from ${accountId}:`, entries.value);\n   *\n   *   // Access all entries from this account\n   *   for (const entry of entries.all) {\n   *     console.log(`Entry made at ${entry.madeAt}:`, entry.value);\n   *   }\n   * }\n   * ```\n   *\n   * @category Content\n   */\n  [key: ID<Account>]: CoFeedEntry<Item>;\n\n  /**\n   * The current account's view of this `CoFeed`\n   * @category Content\n   */\n  get byMe(): CoFeedEntry<Item> | undefined {\n    if (this._loadedAs._type === \"Account\") {\n      return this[this._loadedAs.id];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * The per-session view of this `CoFeed`\n   * @category Content\n   */\n  perSession!: {\n    [key: SessionID]: CoFeedEntry<Item>;\n  };\n\n  /**\n   * The current session's view of this `CoFeed`\n   *\n   * This is a shortcut for `this.perSession` where the session ID is the current session ID.\n   *\n   * @category Content\n   */\n  get inCurrentSession(): CoFeedEntry<Item> | undefined {\n    if (this._loadedAs._type === \"Account\") {\n      return this.perSession[this._loadedAs.sessionID!];\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(\n    options:\n      | { init: Item[]; owner: Account | Group }\n      | { fromRaw: RawCoStream },\n  ) {\n    super();\n\n    if (options && \"fromRaw\" in options) {\n      Object.defineProperties(this, {\n        id: {\n          value: options.fromRaw.id,\n          enumerable: false,\n        },\n        _raw: { value: options.fromRaw, enumerable: false },\n      });\n    }\n\n    return new Proxy(this, CoStreamProxyHandler as ProxyHandler<this>);\n  }\n\n  /**\n   * Create a new `CoFeed`\n   * @category Creation\n   */\n  static create<S extends CoFeed>(\n    this: CoValueClass<S>,\n    init: S extends CoFeed<infer Item> ? UnCo<Item>[] : never,\n    options?: { owner: Account | Group } | Account | Group,\n  ) {\n    const { owner } = parseCoValueCreateOptions(options);\n    const instance = new this({ init, owner });\n    const raw = owner._raw.createStream();\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    if (init) {\n      instance.push(...init);\n    }\n    return instance;\n  }\n\n  /**\n   * Push items to this `CoFeed`\n   *\n   * Items are appended to the current session's log. Each session (tab, device, app instance)\n   * maintains its own append-only log, which is then aggregated into the per-account view.\n   *\n   * @example\n   * ```ts\n   * // Adds items to current session's log\n   * feed.push(\"item1\", \"item2\");\n   *\n   * // View items from current session\n   * console.log(feed.inCurrentSession);\n   *\n   * // View aggregated items from all sessions for current account\n   * console.log(feed.byMe);\n   * ```\n   *\n   * @category Content\n   */\n  push(...items: Item[]) {\n    for (const item of items) {\n      this.pushItem(item);\n    }\n  }\n\n  private pushItem(item: Item) {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n\n    if (itemDescriptor === \"json\") {\n      this._raw.push(item as JsonValue);\n    } else if (\"encoded\" in itemDescriptor) {\n      this._raw.push(itemDescriptor.encoded.encode(item));\n    } else if (isRefEncoded(itemDescriptor)) {\n      this._raw.push((item as unknown as CoValue).id);\n    }\n  }\n\n  /**\n   * Get a JSON representation of the `CoFeed`\n   * @category\n   */\n  toJSON(): {\n    id: string;\n    _type: \"CoStream\";\n    [key: string]: unknown;\n    in: { [key: string]: unknown };\n  } {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n    const mapper =\n      itemDescriptor === \"json\"\n        ? (v: unknown) => v\n        : \"encoded\" in itemDescriptor\n          ? itemDescriptor.encoded.encode\n          : (v: unknown) => v && (v as CoValue).id;\n\n    return {\n      id: this.id,\n      _type: this._type,\n      ...Object.fromEntries(\n        Object.entries(this).map(([account, entry]) => [\n          account,\n          mapper(entry.value),\n        ]),\n      ),\n      in: Object.fromEntries(\n        Object.entries(this.perSession).map(([session, entry]) => [\n          session,\n          mapper(entry.value),\n        ]),\n      ),\n    };\n  }\n\n  /** @internal */\n  [inspect](): {\n    id: string;\n    _type: \"CoStream\";\n    [key: string]: unknown;\n    in: { [key: string]: unknown };\n  } {\n    return this.toJSON();\n  }\n\n  /** @internal */\n  static schema<V extends CoFeed>(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this: { new (...args: any): V } & typeof CoFeed,\n    def: { [ItemsSym]: V[\"_schema\"][ItemsSym] },\n  ) {\n    this._schema ||= {};\n    Object.assign(this._schema, def);\n  }\n\n  /**\n   * Load a `CoFeed`\n   * @category Subscription & Loading\n   */\n  static load<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: {\n      resolve?: RefsToResolveStrict<F, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<F, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Subscribe to a `CoFeed`, when you have an ID but don't have a `CoFeed` instance yet\n   * @category Subscription & Loading\n   */\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: SubscribeListenerOptions<F, R>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<F, R>(this, id, options, listener);\n  }\n\n  /**\n   * Ensure a `CoFeed` is loaded to the specified depth\n   *\n   * @returns A new instance of the same CoFeed that's loaded to the specified depth\n   * @category Subscription & Loading\n   */\n  ensureLoaded<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    options?: { resolve?: RefsToResolveStrict<F, R> },\n  ): Promise<Resolved<F, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * An instance method to subscribe to an existing `CoFeed`\n   *\n   * No need to provide an ID or Account since they're already part of the instance.\n   * @category Subscription & Loading\n   */\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    options: { resolve?: RefsToResolveStrict<F, R> },\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `CoFeed` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\n/**\n * Converts a raw stream entry into a formatted CoFeed entry with proper typing and accessors.\n * @internal\n */\nfunction entryFromRawEntry<Item>(\n  accessFrom: CoValue,\n  rawEntry: {\n    by: RawAccountID | AgentID;\n    tx: CojsonInternalTypes.TransactionID;\n    at: Date;\n    value: JsonValue;\n  },\n  loadedAs: Account | AnonymousJazzAgent,\n  accountID: ID<Account> | undefined,\n  itemField: Schema,\n): Omit<CoFeedEntry<Item>, \"all\"> {\n  return {\n    get value(): NonNullable<Item> extends CoValue\n      ? (CoValue & Item) | null\n      : Item {\n      if (itemField === \"json\") {\n        return rawEntry.value as NonNullable<Item> extends CoValue\n          ? (CoValue & Item) | null\n          : Item;\n      } else if (\"encoded\" in itemField) {\n        return itemField.encoded.decode(rawEntry.value);\n      } else if (isRefEncoded(itemField)) {\n        return this.ref?.accessFrom(\n          accessFrom,\n          rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + \".value\",\n        ) as NonNullable<Item> extends CoValue ? (CoValue & Item) | null : Item;\n      } else {\n        throw new Error(\"Invalid item field schema\");\n      }\n    },\n    get ref(): NonNullable<Item> extends CoValue\n      ? Ref<NonNullable<Item>>\n      : never {\n      if (itemField !== \"json\" && isRefEncoded(itemField)) {\n        const rawId = rawEntry.value;\n        return new Ref(\n          rawId as unknown as ID<CoValue>,\n          loadedAs,\n          itemField,\n        ) as NonNullable<Item> extends CoValue ? Ref<NonNullable<Item>> : never;\n      } else {\n        return undefined as never;\n      }\n    },\n    get by() {\n      return (\n        accountID &&\n        new Ref<Account>(accountID as unknown as ID<Account>, loadedAs, {\n          ref: RegisteredSchemas[\"Account\"],\n          optional: false,\n        })?.accessFrom(\n          accessFrom,\n          rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + \".by\",\n        )\n      );\n    },\n    madeAt: rawEntry.at,\n    tx: rawEntry.tx,\n  };\n}\n\n/**\n * The proxy handler for `CoFeed` instances\n * @internal\n */\nexport const CoStreamProxyHandler: ProxyHandler<CoFeed> = {\n  get(target, key, receiver) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      const rawEntry = target._raw.lastItemBy(key as RawAccountID);\n\n      if (!rawEntry) return;\n      const entry = entryFromRawEntry(\n        receiver,\n        rawEntry,\n        target._loadedAs,\n        key as unknown as ID<Account>,\n        target._schema[ItemsSym],\n      );\n\n      Object.defineProperty(entry, \"all\", {\n        get: () => {\n          const allRawEntries = target._raw.itemsBy(key as RawAccountID);\n          return (function* () {\n            while (true) {\n              const rawEntry = allRawEntries.next();\n              if (rawEntry.done) return;\n              yield entryFromRawEntry(\n                receiver,\n                rawEntry.value,\n                target._loadedAs,\n                key as unknown as ID<Account>,\n                target._schema[ItemsSym],\n              );\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          })() satisfies IterableIterator<SingleCoFeedEntry<any>>;\n        },\n      });\n\n      return entry;\n    } else if (key === \"perSession\") {\n      return new Proxy({}, CoStreamPerSessionProxyHandler(target, receiver));\n    } else {\n      return Reflect.get(target, key, receiver);\n    }\n  },\n  set(target, key, value, receiver) {\n    if (key === ItemsSym && typeof value === \"object\" && SchemaInit in value) {\n      (target.constructor as typeof CoFeed)._schema ||= {};\n      (target.constructor as typeof CoFeed)._schema[ItemsSym] =\n        value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    if (\n      descriptor.value &&\n      key === ItemsSym &&\n      typeof descriptor.value === \"object\" &&\n      SchemaInit in descriptor.value\n    ) {\n      (target.constructor as typeof CoFeed)._schema ||= {};\n      (target.constructor as typeof CoFeed)._schema[ItemsSym] =\n        descriptor.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, descriptor);\n    }\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target);\n\n    for (const accountID of target._raw.accounts()) {\n      keys.push(accountID);\n    }\n\n    return keys;\n  },\n  getOwnPropertyDescriptor(target, key) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      return {\n        configurable: true,\n        enumerable: true,\n        writable: false,\n      };\n    } else {\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    }\n  },\n};\n\n/**\n * The proxy handler for the per-session view of a `CoFeed`\n * @internal\n */\nconst CoStreamPerSessionProxyHandler = (\n  innerTarget: CoFeed,\n  accessFrom: CoFeed,\n): ProxyHandler<Record<string, never>> => ({\n  get(_target, key, receiver) {\n    if (typeof key === \"string\" && key.includes(\"session\")) {\n      const sessionID = key as SessionID;\n      const rawEntry = innerTarget._raw.lastItemIn(sessionID);\n\n      if (!rawEntry) return;\n      const by = cojsonInternals.accountOrAgentIDfromSessionID(sessionID);\n\n      const entry = entryFromRawEntry(\n        accessFrom,\n        rawEntry,\n        innerTarget._loadedAs,\n        cojsonInternals.isAccountID(by)\n          ? (by as unknown as ID<Account>)\n          : undefined,\n        innerTarget._schema[ItemsSym],\n      );\n\n      Object.defineProperty(entry, \"all\", {\n        get: () => {\n          const allRawEntries = innerTarget._raw.itemsIn(sessionID);\n          return (function* () {\n            while (true) {\n              const rawEntry = allRawEntries.next();\n              if (rawEntry.done) return;\n              yield entryFromRawEntry(\n                accessFrom,\n                rawEntry.value,\n                innerTarget._loadedAs,\n                cojsonInternals.isAccountID(by)\n                  ? (by as unknown as ID<Account>)\n                  : undefined,\n                innerTarget._schema[ItemsSym],\n              );\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          })() satisfies IterableIterator<SingleCoFeedEntry<any>>;\n        },\n      });\n\n      return entry;\n    } else {\n      return Reflect.get(innerTarget, key, receiver);\n    }\n  },\n  ownKeys() {\n    return innerTarget._raw.sessions();\n  },\n  getOwnPropertyDescriptor(target, key) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      return {\n        configurable: true,\n        enumerable: true,\n        writable: false,\n      };\n    } else {\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    }\n  },\n});\n\n/** @deprecated Use FileStream instead */\nexport { FileStream as BinaryCoStream };\n\n/**\n * FileStreams are `CoFeed`s that contain binary data, collaborative versions of `Blob`s.\n *\n * @categoryDescription Declaration\n * `FileStream` can be referenced in schemas.\n *\n * ```ts\n * import { co, FileStream } from \"jazz-tools\";\n *\n * class MyCoMap extends CoMap {\n *   file = co.ref(FileStream);\n * }\n * ```\n *\n * @category CoValues\n */\nexport class FileStream extends CoValueBase implements CoValue {\n  /**\n   * The ID of this `FileStream`\n   * @category Content\n   */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"BinaryCoStream\";\n  /** @internal */\n  declare _raw: RawBinaryCoStream;\n\n  constructor(\n    options:\n      | {\n          owner: Account | Group;\n        }\n      | {\n          fromRaw: RawBinaryCoStream;\n        },\n  ) {\n    super();\n\n    let raw: RawBinaryCoStream;\n\n    if (\"fromRaw\" in options) {\n      raw = options.fromRaw;\n    } else {\n      const rawOwner = options.owner._raw;\n      raw = rawOwner.createBinaryStream();\n    }\n\n    Object.defineProperties(this, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _type: { value: \"BinaryCoStream\", enumerable: false },\n      _raw: { value: raw, enumerable: false },\n    });\n  }\n\n  /**\n   * Create a new empty `FileStream` instance.\n   *\n   * @param options - Configuration options for the new FileStream\n   * @param options.owner - The Account or Group that will own this FileStream and control access rights\n   *\n   * @example\n   * ```typescript\n   * // Create owned by an account\n   * const stream = FileStream.create({ owner: myAccount });\n   *\n   * // Create owned by a group\n   * const stream = FileStream.create({ owner: teamGroup });\n   *\n   * // Create with implicit owner\n   * const stream = FileStream.create(myAccount);\n   * ```\n   *\n   * @remarks\n   * For uploading an existing file or blob, use {@link FileStream.createFromBlob} instead.\n   *\n   * @category Creation\n   */\n  static create<S extends FileStream>(\n    this: CoValueClass<S>,\n    options?: { owner?: Account | Group } | Account | Group,\n  ) {\n    return new this(parseCoValueCreateOptions(options));\n  }\n\n  getChunks(options?: {\n    allowUnfinished?: boolean;\n  }):\n    | (BinaryStreamInfo & { chunks: Uint8Array[]; finished: boolean })\n    | undefined {\n    return this._raw.getBinaryChunks(options?.allowUnfinished);\n  }\n\n  isBinaryStreamEnded(): boolean {\n    return this._raw.isBinaryStreamEnded();\n  }\n\n  start(options: BinaryStreamInfo): void {\n    this._raw.startBinaryStream(options);\n  }\n\n  push(data: Uint8Array): void {\n    this._raw.pushBinaryStreamChunk(data);\n  }\n\n  end(): void {\n    this._raw.endBinaryStream();\n  }\n\n  toBlob(options?: { allowUnfinished?: boolean }): Blob | undefined {\n    const chunks = this.getChunks({\n      allowUnfinished: options?.allowUnfinished,\n    });\n\n    if (!chunks) {\n      return undefined;\n    }\n\n    // @ts-ignore\n    return new Blob(chunks.chunks, { type: chunks.mimeType });\n  }\n\n  /**\n   * Load a `FileStream` as a `Blob`\n   *\n   * @category Content\n   */\n  static async loadAsBlob(\n    id: ID<FileStream>,\n    options?: {\n      allowUnfinished?: boolean;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Blob | undefined> {\n    let stream = await this.load(id, options);\n\n    /**\n     * If the user hasn't requested an incomplete blob and the\n     * stream isn't complete wait for the stream download before progressing\n     */\n    if (!options?.allowUnfinished && !stream?.isBinaryStreamEnded()) {\n      stream = await new Promise<FileStream>((resolve) => {\n        subscribeToCoValueWithoutMe(\n          this,\n          id,\n          options || {},\n          (value, unsubscribe) => {\n            if (value.isBinaryStreamEnded()) {\n              unsubscribe();\n              resolve(value);\n            }\n          },\n        );\n      });\n    }\n\n    return stream?.toBlob({\n      allowUnfinished: options?.allowUnfinished,\n    });\n  }\n\n  /**\n   * Create a `FileStream` from a `Blob` or `File`\n   *\n   * @example\n   * ```ts\n   * import { co, FileStream } from \"jazz-tools\";\n   *\n   * const fileStream = await FileStream.createFromBlob(file, {owner: group})\n   * ```\n   * @category Content\n   */\n  static async createFromBlob(\n    blob: Blob | File,\n    options?:\n      | {\n          owner?: Group | Account;\n          onProgress?: (progress: number) => void;\n        }\n      | Account\n      | Group,\n  ): Promise<FileStream> {\n    const stream = this.create(options);\n    const onProgress =\n      options && \"onProgress\" in options ? options.onProgress : undefined;\n\n    const start = Date.now();\n\n    const data = new Uint8Array(await blob.arrayBuffer());\n    stream.start({\n      mimeType: blob.type,\n      totalSizeBytes: blob.size,\n      fileName: blob instanceof File ? blob.name : undefined,\n    });\n    const chunkSize = MAX_RECOMMENDED_TX_SIZE;\n\n    let lastProgressUpdate = Date.now();\n\n    for (let idx = 0; idx < data.length; idx += chunkSize) {\n      stream.push(data.slice(idx, idx + chunkSize));\n\n      if (Date.now() - lastProgressUpdate > 100) {\n        onProgress?.(idx / data.length);\n        lastProgressUpdate = Date.now();\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 0));\n    }\n    stream.end();\n    const end = Date.now();\n\n    console.debug(\n      \"Finished creating binary stream in\",\n      (end - start) / 1000,\n      \"s - Throughput in MB/s\",\n      (1000 * (blob.size / (end - start))) / (1024 * 1024),\n    );\n    onProgress?.(1);\n\n    return stream;\n  }\n\n  /**\n   * Get a JSON representation of the `FileStream`\n   * @category Content\n   */\n  toJSON(): {\n    id: string;\n    _type: \"BinaryCoStream\";\n    mimeType?: string;\n    totalSizeBytes?: number;\n    fileName?: string;\n    chunks?: Uint8Array[];\n    finished?: boolean;\n  } {\n    return {\n      id: this.id,\n      _type: this._type,\n      ...this.getChunks(),\n    };\n  }\n\n  /** @internal */\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /**\n   * Load a `FileStream`\n   * @category Subscription & Loading\n   */\n  static load<C extends FileStream>(\n    this: CoValueClass<C>,\n    id: ID<C>,\n    options?: { loadAs?: Account | AnonymousJazzAgent },\n  ): Promise<Resolved<C, true> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Subscribe to a `FileStream`, when you have an ID but don't have a `FileStream` instance yet\n   * @category Subscription & Loading\n   */\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: SubscribeListenerOptions<F, R>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<F, R>(this, id, options, listener);\n  }\n\n  /**\n   * An instance method to subscribe to an existing `FileStream`\n   * @category Subscription & Loading\n   */\n  subscribe<B extends FileStream>(\n    this: B,\n    listener: (value: Resolved<B, true>) => void,\n  ): () => void {\n    return subscribeToExistingCoValue(this, {}, listener);\n  }\n\n  /**\n   * Wait for the `FileStream` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n","import type { JsonValue, RawCoList } from \"cojson\";\nimport { RawAccount } from \"cojson\";\nimport { calcPatch } from \"fast-myers-diff\";\nimport type {\n  CoValue,\n  CoValueClass,\n  CoValueFromRaw,\n  ID,\n  RefEncoded,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SchemaFor,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  UnCo,\n} from \"../internal.js\";\nimport {\n  AnonymousJazzAgent,\n  ItemsSym,\n  Ref,\n  SchemaInit,\n  co,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  makeRefs,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n  subscriptionsScopes,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { type Account } from \"./account.js\";\nimport { type Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\n/**\n * CoLists are collaborative versions of plain arrays.\n *\n * @categoryDescription Content\n * You can access items on a `CoList` as if they were normal items on a plain array, using `[]` notation, etc.\n *\n * Since `CoList` is a subclass of `Array`, you can use all the normal array methods like `push`, `pop`, `splice`, etc.\n *\n * ```ts\n * colorList[0];\n * colorList[3] = \"yellow\";\n * colorList.push(\"Kawazaki Green\");\n * colorList.splice(1, 1);\n * ```\n *\n * @category CoValues\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class CoList<Item = any> extends Array<Item> implements CoValue {\n  /**\n   * Declare a `CoList` by subclassing `CoList.Of(...)` and passing the item schema using `co`.\n   *\n   * @example\n   * ```ts\n   * class ColorList extends CoList.Of(\n   *   co.string\n   * ) {}\n   * class AnimalList extends CoList.Of(\n   *   co.ref(Animal)\n   * ) {}\n   * ```\n   *\n   * @category Declaration\n   */\n  static Of<Item>(item: Item): typeof CoList<Item> {\n    // TODO: cache superclass for item class\n    return class CoListOf extends CoList<Item> {\n      [co.items] = item;\n    };\n  }\n\n  /**\n   * @ignore\n   * @deprecated Use UPPERCASE `CoList.Of` instead! */\n  static of(..._args: never): never {\n    throw new Error(\"Can't use Array.of with CoLists\");\n  }\n\n  /**\n   * The ID of this `CoList`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoList\";\n  static {\n    this.prototype._type = \"CoList\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoList;\n  /** @category Internals */\n  declare _instanceID: string;\n\n  /** @internal This is only a marker type and doesn't exist at runtime */\n  [ItemsSym]!: Item;\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema(): {\n    [ItemsSym]: SchemaFor<Item>;\n  } {\n    return (this.constructor as typeof CoList)._schema;\n  }\n\n  /** @category Collaboration */\n  get _owner(): Account | Group {\n    return this._raw.group instanceof RawAccount\n      ? RegisteredSchemas[\"Account\"].fromRaw(this._raw.group)\n      : RegisteredSchemas[\"Group\"].fromRaw(this._raw.group);\n  }\n\n  /**\n   * If a `CoList`'s items are a `co.ref(...)`, you can use `coList._refs[i]` to access\n   * the `Ref` instead of the potentially loaded/null value.\n   *\n   * This allows you to always get the ID or load the value manually.\n   *\n   * @example\n   * ```ts\n   * animals._refs[0].id; // => ID<Animal>\n   * animals._refs[0].value;\n   * // => Animal | null\n   * const animal = await animals._refs[0].load();\n   * ```\n   *\n   * @category Content\n   **/\n  get _refs(): {\n    [idx: number]: Exclude<Item, null> extends CoValue\n      ? Ref<UnCo<Exclude<Item, null>>>\n      : never;\n  } & {\n    length: number;\n    [Symbol.iterator](): IterableIterator<\n      Exclude<Item, null> extends CoValue ? Ref<Exclude<Item, null>> : never\n    >;\n  } {\n    return makeRefs<number>(\n      (idx) => this._raw.get(idx) as unknown as ID<CoValue>,\n      () => Array.from({ length: this._raw.entries().length }, (_, idx) => idx),\n      this._loadedAs,\n      (_idx) => this._schema[ItemsSym] as RefEncoded<CoValue>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) as any;\n  }\n\n  get _edits(): {\n    [idx: number]: {\n      value?: Item;\n      ref?: Item extends CoValue ? Ref<Item> : never;\n      by?: RegisteredAccount;\n      madeAt: Date;\n    };\n  } {\n    throw new Error(\"Not implemented\");\n  }\n\n  get _loadedAs() {\n    const rawAccount = this._raw.core.node.account;\n\n    if (rawAccount instanceof RawAccount) {\n      return coValuesCache.get(rawAccount, () =>\n        RegisteredSchemas[\"Account\"].fromRaw(rawAccount),\n      );\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  static get [Symbol.species]() {\n    return Array;\n  }\n\n  constructor(options: { fromRaw: RawCoList } | undefined) {\n    super();\n\n    Object.defineProperty(this, \"_instanceID\", {\n      value: `instance-${Math.random().toString(36).slice(2)}`,\n      enumerable: false,\n    });\n\n    if (options && \"fromRaw\" in options) {\n      Object.defineProperties(this, {\n        id: {\n          value: options.fromRaw.id,\n          enumerable: false,\n        },\n        _raw: { value: options.fromRaw, enumerable: false },\n      });\n    }\n\n    return new Proxy(this, CoListProxyHandler as ProxyHandler<this>);\n  }\n\n  /**\n   * Create a new CoList with the given initial values and owner.\n   *\n   * The owner (a Group or Account) determines access rights to the CoMap.\n   *\n   * The CoList will immediately be persisted and synced to connected peers.\n   *\n   * @example\n   * ```ts\n   * const colours = ColorList.create(\n   *   [\"red\", \"green\", \"blue\"],\n   *   { owner: me }\n   * );\n   * const animals = AnimalList.create(\n   *   [cat, dog, fish],\n   *   { owner: me }\n   * );\n   * ```\n   *\n   * @category Creation\n   **/\n  static create<L extends CoList>(\n    this: CoValueClass<L>,\n    items: UnCo<L[number]>[],\n    options?: { owner: Account | Group } | Account | Group,\n  ) {\n    const { owner } = parseCoValueCreateOptions(options);\n    const instance = new this({ init: items, owner });\n    const raw = owner._raw.createList(\n      toRawItems(items, instance._schema[ItemsSym]),\n    );\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    return instance;\n  }\n\n  push(...items: Item[]): number {\n    this._raw.appendItems(\n      toRawItems(items, this._schema[ItemsSym]),\n      undefined,\n      \"private\",\n    );\n\n    return this._raw.entries().length;\n  }\n\n  unshift(...items: Item[]): number {\n    for (const item of toRawItems(items as Item[], this._schema[ItemsSym])) {\n      this._raw.prepend(item);\n    }\n\n    return this._raw.entries().length;\n  }\n\n  pop(): Item | undefined {\n    const last = this[this.length - 1];\n\n    this._raw.delete(this.length - 1);\n\n    return last;\n  }\n\n  shift(): Item | undefined {\n    const first = this[0];\n\n    this._raw.delete(0);\n\n    return first;\n  }\n\n  /**\n   * Splice the `CoList` at a given index.\n   *\n   * @param start - The index to start the splice.\n   * @param deleteCount - The number of items to delete.\n   * @param items - The items to insert.\n   */\n  splice(start: number, deleteCount: number, ...items: Item[]): Item[] {\n    const deleted = this.slice(start, start + deleteCount);\n\n    for (\n      let idxToDelete = start + deleteCount - 1;\n      idxToDelete >= start;\n      idxToDelete--\n    ) {\n      this._raw.delete(idxToDelete);\n    }\n\n    const rawItems = toRawItems(items as Item[], this._schema[ItemsSym]);\n\n    // If there are no items to insert, return the deleted items\n    if (rawItems.length === 0) {\n      return deleted;\n    }\n\n    // Fast path for single item insertion\n    if (rawItems.length === 1) {\n      const item = rawItems[0];\n      if (item === undefined) return deleted;\n      if (start === 0) {\n        this._raw.prepend(item);\n      } else {\n        this._raw.append(item, Math.max(start - 1, 0));\n      }\n      return deleted;\n    }\n\n    // Handle multiple items\n    if (start === 0) {\n      // Iterate in reverse order without creating a new array\n      for (let i = rawItems.length - 1; i >= 0; i--) {\n        const item = rawItems[i];\n        if (item === undefined) continue;\n        this._raw.prepend(item);\n      }\n    } else {\n      let appendAfter = Math.max(start - 1, 0);\n      for (const item of rawItems) {\n        if (item === undefined) continue;\n        this._raw.append(item, appendAfter);\n        appendAfter++;\n      }\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Modify the `CoList` to match another list, where the changes are managed internally.\n   *\n   * @param result - The resolved list of items.\n   */\n  applyDiff(result: Item[]) {\n    const current = this._raw.asArray() as Item[];\n    const comparator = isRefEncoded(this._schema[ItemsSym])\n      ? (aIdx: number, bIdx: number) => {\n          return (\n            (current[aIdx] as CoValue)?.id === (result[bIdx] as CoValue)?.id\n          );\n        }\n      : undefined;\n\n    const patches = [...calcPatch(current, result, comparator)];\n    for (const [from, to, insert] of patches.reverse()) {\n      this.splice(from, to - from, ...insert);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(_key?: string, seenAbove?: ID<CoValue>[]): any[] {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n    if (itemDescriptor === \"json\") {\n      return this._raw.asArray();\n    } else if (\"encoded\" in itemDescriptor) {\n      return this._raw.asArray().map((e) => itemDescriptor.encoded.encode(e));\n    } else if (isRefEncoded(itemDescriptor)) {\n      return this.map((item, idx) =>\n        seenAbove?.includes((item as CoValue)?.id)\n          ? { _circular: (item as CoValue).id }\n          : (item as unknown as CoValue)?.toJSON(idx + \"\", [\n              ...(seenAbove || []),\n              this.id,\n            ]),\n      );\n    } else {\n      return [];\n    }\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /** @category Internals */\n  static fromRaw<V extends CoList>(\n    this: CoValueClass<V> & typeof CoList,\n    raw: RawCoList,\n  ) {\n    return new this({ fromRaw: raw });\n  }\n\n  /** @internal */\n  static schema<V extends CoList>(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this: { new (...args: any): V } & typeof CoList,\n    def: { [ItemsSym]: V[\"_schema\"][ItemsSym] },\n  ) {\n    this._schema ||= {};\n    Object.assign(this._schema, def);\n  }\n\n  /**\n   * Load a `CoList` with a given ID, as a given account.\n   *\n   * `depth` specifies if item CoValue references should be loaded as well before resolving.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * @example\n   * ```ts\n   * const animalsWithVets =\n   *   await ListOfAnimals.load(\n   *     \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *     me,\n   *     [{ vet: {} }]\n   *   );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static load<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    options?: {\n      resolve?: RefsToResolveStrict<L, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<L, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Load and subscribe to a `CoList` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * `depth` specifies if item CoValue references should be loaded as well before calling `listener` for the first time.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @example\n   * ```ts\n   * const unsub = ListOfAnimals.subscribe(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   me,\n   *   { vet: {} },\n   *   (animalsWithVets) => console.log(animalsWithVets)\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    options: SubscribeListenerOptions<L, R>,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<L extends CoList, const R extends RefsToResolve<L>>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    ...args: SubscribeRestArgs<L, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<L, R>(this, id, options, listener);\n  }\n\n  /**\n   * Given an already loaded `CoList`, ensure that items are loaded to the specified depth.\n   *\n   * Works like `CoList.load()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * @category Subscription & Loading\n   */\n  ensureLoaded<L extends CoList, const R extends RefsToResolve<L>>(\n    this: L,\n    options: { resolve: RefsToResolveStrict<L, R> },\n  ): Promise<Resolved<L, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * Given an already loaded `CoList`, subscribe to updates to the `CoList` and ensure that items are loaded to the specified depth.\n   *\n   * Works like `CoList.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: L,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: L,\n    options: { resolve?: RefsToResolveStrict<L, R> },\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<L extends CoList, const R extends RefsToResolve<L>>(\n    this: L,\n    ...args: SubscribeRestArgs<L, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /** @category Type Helpers */\n  castAs<Cl extends CoValueClass & CoValueFromRaw<CoValue>>(\n    cl: Cl,\n  ): InstanceType<Cl> {\n    const casted = cl.fromRaw(this._raw) as InstanceType<Cl>;\n    const subscriptionScope = subscriptionsScopes.get(this);\n    if (subscriptionScope) {\n      subscriptionsScopes.set(casted, subscriptionScope);\n    }\n    return casted;\n  }\n\n  /**\n   * Wait for the `CoList` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\n/**\n * Convert an array of items to a raw array of items.\n * @param items - The array of items to convert.\n * @param itemDescriptor - The descriptor of the items.\n * @returns The raw array of items.\n */\nfunction toRawItems<Item>(items: Item[], itemDescriptor: Schema) {\n  const rawItems =\n    itemDescriptor === \"json\"\n      ? (items as JsonValue[])\n      : \"encoded\" in itemDescriptor\n        ? items?.map((e) => itemDescriptor.encoded.encode(e))\n        : isRefEncoded(itemDescriptor)\n          ? items?.map((v) => {\n              if (!v) return null;\n\n              return (v as unknown as CoValue).id;\n            })\n          : (() => {\n              throw new Error(\"Invalid element descriptor\");\n            })();\n  return rawItems;\n}\n\nconst CoListProxyHandler: ProxyHandler<CoList> = {\n  get(target, key, receiver) {\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      const itemDescriptor = target._schema[ItemsSym] as Schema;\n      const rawValue = target._raw.get(Number(key));\n      if (itemDescriptor === \"json\") {\n        return rawValue;\n      } else if (\"encoded\" in itemDescriptor) {\n        return rawValue === undefined\n          ? undefined\n          : itemDescriptor.encoded.decode(rawValue);\n      } else if (isRefEncoded(itemDescriptor)) {\n        return rawValue === undefined\n          ? undefined\n          : new Ref(\n              rawValue as unknown as ID<CoValue>,\n              target._loadedAs,\n              itemDescriptor,\n            ).accessFrom(receiver, Number(key));\n      }\n    } else if (key === \"length\") {\n      return target._raw.entries().length;\n    } else {\n      return Reflect.get(target, key, receiver);\n    }\n  },\n  set(target, key, value, receiver) {\n    if (key === ItemsSym && typeof value === \"object\" && SchemaInit in value) {\n      (target.constructor as typeof CoList)._schema ||= {};\n      (target.constructor as typeof CoList)._schema[ItemsSym] =\n        value[SchemaInit];\n      return true;\n    }\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      const itemDescriptor = target._schema[ItemsSym] as Schema;\n      let rawValue;\n      if (itemDescriptor === \"json\") {\n        rawValue = value;\n      } else if (\"encoded\" in itemDescriptor) {\n        rawValue = itemDescriptor.encoded.encode(value);\n      } else if (isRefEncoded(itemDescriptor)) {\n        if (value === null) {\n          if (itemDescriptor.optional) {\n            rawValue = null;\n          } else {\n            throw new Error(`Cannot set required reference ${key} to null`);\n          }\n        } else if (value?.id) {\n          rawValue = value.id;\n        } else {\n          throw new Error(\n            `Cannot set reference ${key} to a non-CoValue. Got ${value}`,\n          );\n        }\n      }\n      target._raw.replace(Number(key), rawValue);\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    if (\n      descriptor.value &&\n      key === ItemsSym &&\n      typeof descriptor.value === \"object\" &&\n      SchemaInit in descriptor.value\n    ) {\n      (target.constructor as typeof CoList)._schema ||= {};\n      (target.constructor as typeof CoList)._schema[ItemsSym] =\n        descriptor.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, descriptor);\n    }\n  },\n  has(target, key) {\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      return Number(key) < target._raw.entries().length;\n    } else {\n      return Reflect.has(target, key);\n    }\n  },\n};\n","import type {\n  AccountRole,\n  AgentID,\n  Everyone,\n  RawAccountID,\n  RawGroup,\n  Role,\n} from \"cojson\";\nimport { activeAccountContext } from \"../implementation/activeAccountContext.js\";\nimport type {\n  CoValue,\n  CoValueClass,\n  ID,\n  RefEncoded,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n} from \"../internal.js\";\nimport {\n  CoValueBase,\n  Ref,\n  co,\n  ensureCoValueLoaded,\n  loadCoValueWithoutMe,\n  parseGroupCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\nimport { RegisteredAccount } from \"../types.js\";\nimport { AccountAndGroupProxyHandler, isControlledAccount } from \"./account.js\";\nimport { type Account } from \"./account.js\";\nimport { type CoMap } from \"./coMap.js\";\nimport { type Profile } from \"./profile.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\n/** @category Identity & Permissions */\nexport class Group extends CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"Group\";\n  static {\n    this.prototype._type = \"Group\";\n  }\n  declare _raw: RawGroup;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  get _schema(): {\n    profile: Schema;\n    root: Schema;\n  } {\n    return (this.constructor as typeof Group)._schema;\n  }\n  static {\n    this._schema = {\n      profile: \"json\" satisfies Schema,\n      root: \"json\" satisfies Schema,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any;\n    Object.defineProperty(this.prototype, \"_schema\", {\n      get: () => this._schema,\n    });\n  }\n\n  declare profile: Profile | null;\n  declare root: CoMap | null;\n\n  get _refs(): {\n    profile: Ref<Profile> | undefined;\n    root: Ref<CoMap> | undefined;\n  } {\n    const profileID = this._raw.get(\"profile\") as unknown as\n      | ID<NonNullable<this[\"profile\"]>>\n      | undefined;\n    const rootID = this._raw.get(\"root\") as unknown as\n      | ID<NonNullable<this[\"root\"]>>\n      | undefined;\n    return {\n      profile:\n        profileID &&\n        (new Ref(\n          profileID,\n          this._loadedAs,\n          this._schema.profile as RefEncoded<NonNullable<this[\"profile\"]>>,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any as this[\"profile\"] extends Profile\n          ? Ref<this[\"profile\"]>\n          : never),\n      root:\n        rootID &&\n        (new Ref(\n          rootID,\n          this._loadedAs,\n          this._schema.root as RefEncoded<NonNullable<this[\"root\"]>>,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any as this[\"root\"] extends CoMap ? Ref<this[\"root\"]> : never),\n    };\n  }\n\n  /** @deprecated Don't use constructor directly, use .create */\n  constructor(options: { fromRaw: RawGroup } | { owner: Account | Group }) {\n    super();\n    let raw: RawGroup;\n\n    if (options && \"fromRaw\" in options) {\n      raw = options.fromRaw;\n    } else {\n      const initOwner = options.owner;\n      if (!initOwner) throw new Error(\"No owner provided\");\n      if (initOwner._type === \"Account\" && isControlledAccount(initOwner)) {\n        const rawOwner = initOwner._raw;\n        raw = rawOwner.createGroup();\n      } else {\n        throw new Error(\"Can only construct group as a controlled account\");\n      }\n    }\n\n    Object.defineProperties(this, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    return new Proxy(this, AccountAndGroupProxyHandler as ProxyHandler<this>);\n  }\n\n  static create<G extends Group>(\n    this: CoValueClass<G>,\n    options?: { owner: Account } | Account,\n  ) {\n    return new this(parseGroupCreateOptions(options));\n  }\n\n  myRole(): Role | undefined {\n    return this._raw.myRole();\n  }\n\n  addMember(member: Everyone, role: \"writer\" | \"reader\" | \"writeOnly\"): void;\n  addMember(member: Account, role: AccountRole): void;\n  addMember(member: Everyone | Account, role: AccountRole) {\n    this._raw.addMember(member === \"everyone\" ? member : member._raw, role);\n  }\n\n  removeMember(member: Everyone | Account) {\n    return this._raw.removeMember(member === \"everyone\" ? member : member._raw);\n  }\n\n  get members(): Array<{\n    id: ID<RegisteredAccount>;\n    role: AccountRole;\n    ref: Ref<RegisteredAccount>;\n    account: RegisteredAccount;\n  }> {\n    const members = [];\n\n    const BaseAccountSchema =\n      (activeAccountContext.maybeGet()?.constructor as typeof Account) ||\n      RegisteredSchemas[\"Account\"];\n    const refEncodedAccountSchema = {\n      ref: () => BaseAccountSchema,\n      optional: false,\n    } satisfies RefEncoded<RegisteredAccount>;\n\n    for (const accountID of this._raw.getAllMemberKeysSet()) {\n      if (!isAccountID(accountID)) continue;\n\n      const role = this._raw.roleOf(accountID);\n\n      if (\n        role === \"admin\" ||\n        role === \"writer\" ||\n        role === \"reader\" ||\n        role === \"writeOnly\"\n      ) {\n        const ref = new Ref<RegisteredAccount>(\n          accountID as unknown as ID<RegisteredAccount>,\n          this._loadedAs,\n          refEncodedAccountSchema,\n        );\n        const accessRef = () => ref.accessFrom(this, \"members.\" + accountID);\n\n        if (!ref.syncLoad()) {\n          console.warn(\"Account not loaded\", accountID);\n        }\n\n        members.push({\n          id: accountID as unknown as ID<Account>,\n          role,\n          ref,\n          get account() {\n            // Accounts values are non-nullable because are loaded as dependencies\n            return accessRef() as RegisteredAccount;\n          },\n        });\n      }\n    }\n\n    return members;\n  }\n\n  getRoleOf(member: Everyone | ID<Account> | \"me\") {\n    if (member === \"me\") {\n      return this._raw.roleOf(\n        activeAccountContext.get().id as unknown as RawAccountID,\n      );\n    }\n\n    return this._raw.roleOf(\n      member === \"everyone\" ? member : (member as unknown as RawAccountID),\n    );\n  }\n\n  getParentGroups(): Array<Group> {\n    return this._raw.getParentGroups().map((group) => Group.fromRaw(group));\n  }\n\n  extend(\n    parent: Group,\n    roleMapping?: \"reader\" | \"writer\" | \"admin\" | \"inherit\",\n  ) {\n    this._raw.extend(parent._raw, roleMapping);\n    return this;\n  }\n\n  async revokeExtend(parent: Group) {\n    await this._raw.revokeExtend(parent._raw);\n    return this;\n  }\n\n  /** @category Subscription & Loading */\n  static load<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    options?: { resolve?: RefsToResolveStrict<G, R>; loadAs?: Account },\n  ): Promise<Resolved<G, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /** @category Subscription & Loading */\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    options: SubscribeListenerOptions<G, R>,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    ...args: SubscribeRestArgs<G, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<G, R>(this, id, options, listener);\n  }\n\n  /** @category Subscription & Loading */\n  ensureLoaded<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    options?: { resolve?: RefsToResolveStrict<G, R> },\n  ): Promise<Resolved<G, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /** @category Subscription & Loading */\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    options: { resolve?: RefsToResolveStrict<G, R> },\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    ...args: SubscribeRestArgs<G, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `Group` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\nRegisteredSchemas[\"Group\"] = Group;\n\nexport function isAccountID(id: RawAccountID | AgentID): id is RawAccountID {\n  return id.startsWith(\"co_\");\n}\n","import {\n  type OpID,\n  RawAccount,\n  type RawCoPlainText,\n  stringifyOpID,\n} from \"cojson\";\nimport { calcPatch } from \"fast-myers-diff\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  ID,\n  Resolved,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n} from \"../internal.js\";\nimport {\n  inspect,\n  loadCoValueWithoutMe,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\nimport { Account } from \"./account.js\";\nimport { Group } from \"./group.js\";\n\nexport type TextPos = OpID;\n\nexport class CoPlainText extends String implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"CoPlainText\";\n  declare _raw: RawCoPlainText;\n\n  get _owner(): Account | Group {\n    return this._raw.group instanceof RawAccount\n      ? Account.fromRaw(this._raw.group)\n      : Group.fromRaw(this._raw.group);\n  }\n\n  get _loadedAs() {\n    return Account.fromNode(this._raw.core.node);\n  }\n\n  constructor(\n    options:\n      | { fromRaw: RawCoPlainText }\n      | { text: string; owner: Account | Group },\n  ) {\n    super(\"fromRaw\" in options ? options.fromRaw.toString() : options.text);\n\n    let raw;\n\n    if (\"fromRaw\" in options) {\n      raw = options.fromRaw;\n    } else {\n      raw = options.owner._raw.createPlainText(options.text);\n    }\n\n    Object.defineProperties(this, {\n      id: { value: raw.id, enumerable: false },\n      _type: { value: \"CoPlainText\", enumerable: false },\n      _raw: { value: raw, enumerable: false },\n    });\n  }\n\n  static create<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    text: string,\n    options: { owner: Account | Group },\n  ) {\n    return new this({ text, owner: options.owner });\n  }\n\n  get length() {\n    return this._raw.toString().length;\n  }\n\n  toString() {\n    return this._raw.toString();\n  }\n\n  valueOf() {\n    return this._raw.toString();\n  }\n\n  toJSON(): string {\n    return this._raw.toString();\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  insertBefore(idx: number, text: string) {\n    this._raw.insertBefore(idx, text);\n  }\n\n  insertAfter(idx: number, text: string) {\n    this._raw.insertAfter(idx, text);\n  }\n\n  deleteRange(range: { from: number; to: number }) {\n    this._raw.deleteRange(range);\n  }\n\n  posBefore(idx: number): TextPos | undefined {\n    return this._raw.mapping.opIDbeforeIdx[idx];\n  }\n\n  posAfter(idx: number): TextPos | undefined {\n    return this._raw.mapping.opIDafterIdx[idx];\n  }\n\n  idxBefore(pos: TextPos): number | undefined {\n    return this._raw.mapping.idxBeforeOpID[stringifyOpID(pos)];\n  }\n\n  idxAfter(pos: TextPos): number | undefined {\n    return this._raw.mapping.idxAfterOpID[stringifyOpID(pos)];\n  }\n\n  static fromRaw<V extends CoPlainText>(\n    this: CoValueClass<V> & typeof CoPlainText,\n    raw: RawCoPlainText,\n  ) {\n    return new this({ fromRaw: raw });\n  }\n\n  /**\n   * Apply text, modifying the text in place. Calculates the diff and applies it to the CoValue.\n   *\n   * @category Mutation\n   */\n  applyDiff(other: string) {\n    const current = this._raw.toString();\n    for (const [from, to, insert] of [...calcPatch(current, other)].reverse()) {\n      if (to > from) {\n        this.deleteRange({ from, to });\n      }\n      if (insert.length > 0) {\n        this.insertBefore(from, insert);\n      }\n    }\n  }\n\n  /**\n   * Load a `CoPlainText` with a given ID, as a given account.\n   *\n   * @category Subscription & Loading\n   */\n  static load<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    options?: { loadAs?: Account | AnonymousJazzAgent },\n  ): Promise<T | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  //   /**\n  //    * Effectful version of `CoMap.load()`.\n  //    *\n  //    * Needs to be run inside an `AccountCtx` context.\n  //    *\n  //    * @category Subscription & Loading\n  //    */\n  //   static loadEf<T extends CoPlainText>(\n  //     this: CoValueClass<T>,\n  //     id: ID<T>,\n  //   ): Effect.Effect<T, UnavailableError, AccountCtx> {\n  //     return loadCoValueEf(this, id, []);\n  //   }\n\n  /**\n   * Load and subscribe to a `CoPlainText` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoStream`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    options: Omit<SubscribeListenerOptions<T, true>, \"resolve\">,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    ...args: SubscribeRestArgs<T, true>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<T, true>(this, id, options, listener);\n  }\n\n  /**\n   * Given an already loaded `CoPlainText`, subscribe to updates to the `CoPlainText` and ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoPlainText.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<T extends CoPlainText>(\n    this: T,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void {\n    return subscribeToExistingCoValue(this, {}, listener);\n  }\n}\n","import { CoPlainText } from \"./coPlainText.js\";\n\nexport class CoRichText extends CoPlainText {}\n","import { co, subscriptionsScopes } from \"../../internal.js\";\nimport { FileStream } from \"../coFeed.js\";\nimport { CoMap } from \"../coMap.js\";\n\n/** @category Media */\nexport class ImageDefinition extends CoMap {\n  originalSize = co.json<[number, number]>();\n  placeholderDataURL? = co.string;\n\n  [co.items] = co.ref(FileStream);\n  [res: `${number}x${number}`]: co<FileStream | null>;\n\n  highestResAvailable(options?: {\n    maxWidth?: number;\n    targetWidth?: number;\n  }): { res: `${number}x${number}`; stream: FileStream } | undefined {\n    if (!subscriptionsScopes.get(this)) {\n      console.warn(\n        \"highestResAvailable() only makes sense when used within a subscription.\",\n      );\n    }\n\n    const resolutions = Object.keys(this).filter((key) =>\n      key.match(/^\\d+x\\d+$/),\n    ) as `${number}x${number}`[];\n\n    let maxWidth = options?.maxWidth;\n\n    if (options?.targetWidth) {\n      const targetWidth = options.targetWidth;\n      const widths = resolutions.map((res) => Number(res.split(\"x\")[0]));\n\n      maxWidth = Math.min(...widths.filter((w) => w >= targetWidth));\n    }\n\n    const validResolutions = resolutions.filter(\n      (key) => maxWidth === undefined || Number(key.split(\"x\")[0]) <= maxWidth,\n    ) as `${number}x${number}`[];\n\n    // Sort the resolutions by width, smallest to largest\n    validResolutions.sort((a, b) => {\n      const aWidth = Number(a.split(\"x\")[0]);\n      const bWidth = Number(b.split(\"x\")[0]);\n      return aWidth - bWidth; // Sort smallest to largest\n    });\n\n    let highestAvailableResolution: `${number}x${number}` | undefined;\n\n    for (const resolution of validResolutions) {\n      if (this[resolution] && this[resolution]?.getChunks()) {\n        highestAvailableResolution = resolution;\n      }\n    }\n\n    // Return the highest complete resolution if we found one\n    return (\n      highestAvailableResolution && {\n        res: highestAvailableResolution,\n        stream: this[highestAvailableResolution]!,\n      }\n    );\n  }\n}\n","import {\n  CoValue,\n  CoValueBase,\n  CoValueClass,\n  CoValueFromRaw,\n} from \"../internal.js\";\n\n/**\n * SchemaUnion allows you to create union types of CoValues that can be discriminated at runtime.\n *\n * @categoryDescription Declaration\n * Declare your union types by extending `SchemaUnion.Of(...)` and passing a discriminator function that determines which concrete type to use based on the raw data.\n *\n * ```ts\n * import { SchemaUnion, CoMap } from \"jazz-tools\";\n *\n * class BaseWidget extends CoMap {\n *   type = co.string;\n * }\n *\n * class ButtonWidget extends BaseWidget {\n *   type = co.literal(\"button\");\n *   label = co.string;\n * }\n *\n * class SliderWidget extends BaseWidget {\n *   type = co.literal(\"slider\");\n *   min = co.number;\n *   max = co.number;\n * }\n *\n * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {\n *   switch (raw.get(\"type\")) {\n *     case \"button\": return ButtonWidget;\n *     case \"slider\": return SliderWidget;\n *     default: throw new Error(\"Unknown widget type\");\n *   }\n * });\n * ```\n *\n * @category CoValues\n */\nexport abstract class SchemaUnion extends CoValueBase implements CoValue {\n  /**\n   * Create a new union type from a discriminator function.\n   *\n   * The discriminator function receives the raw data and should return the appropriate concrete class to use for that data.\n   *\n   * When loading a SchemaUnion, the correct subclass will be instantiated based on the discriminator.\n   *\n   * @param discriminator - Function that determines which concrete type to use\n   * @returns A new class that can create/load instances of the union type\n   *\n   * @example\n   * ```ts\n   * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {\n   *   switch (raw.get(\"type\")) {\n   *     case \"button\": return ButtonWidget;\n   *     case \"slider\": return SliderWidget;\n   *     default: throw new Error(\"Unknown widget type\");\n   *   }\n   * });\n   *\n   * const widget = await loadCoValue(WidgetUnion, id, me, {});\n   *\n   * // You can narrow the returned instance to a subclass by using `instanceof`\n   * if (widget instanceof ButtonWidget) {\n   *   console.log(widget.label);\n   * } else if (widget instanceof SliderWidget) {\n   *   console.log(widget.min, widget.max);\n   * }\n   * ```\n   *\n   * @category Declaration\n   **/\n  static Of<V extends CoValue>(\n    discriminator: (raw: V[\"_raw\"]) => CoValueClass<V> & CoValueFromRaw<V>,\n  ): CoValueClass<V> & typeof SchemaUnion {\n    return class SchemaUnionClass extends SchemaUnion {\n      static override fromRaw<T extends CoValue>(\n        this: CoValueClass<T> & CoValueFromRaw<T>,\n        raw: T[\"_raw\"],\n      ): T {\n        const ResolvedClass = discriminator(\n          raw as V[\"_raw\"],\n        ) as unknown as CoValueClass<T> & CoValueFromRaw<T>;\n        return ResolvedClass.fromRaw(raw);\n      }\n    } as unknown as CoValueClass<V> & typeof SchemaUnion;\n  }\n\n  /**\n   * Create an instance from raw data. This is called internally and should not be used directly.\n   * Use {@link SchemaUnion.Of} to create a union type instead.\n   *\n   * @internal\n   */\n  // @ts-ignore\n  static fromRaw<V extends CoValue>(this: CoValueClass<V>, raw: V[\"_raw\"]): V {\n    throw new Error(\"Not implemented\");\n  }\n}\n","export interface KvStore {\n  get(key: string): Promise<string | null>;\n  set(key: string, value: string): Promise<void>;\n  delete(key: string): Promise<void>;\n  clearAll(): Promise<void>;\n}\n\nexport class KvStoreContext {\n  private static instance: KvStoreContext;\n  private storageInstance: KvStore | null = null;\n\n  private constructor() {}\n\n  public static getInstance(): KvStoreContext {\n    if (!KvStoreContext.instance) {\n      KvStoreContext.instance = new KvStoreContext();\n    }\n    return KvStoreContext.instance;\n  }\n\n  public isInitialized(): boolean {\n    return this.storageInstance !== null;\n  }\n\n  public initialize(store: KvStore): void {\n    if (!this.storageInstance) {\n      this.storageInstance = store;\n    }\n  }\n\n  public getStorage(): KvStore {\n    if (!this.storageInstance) {\n      throw new Error(\"Storage instance is not initialized.\");\n    }\n    return this.storageInstance;\n  }\n}\n\nexport default KvStoreContext;\n","import { AgentSecret } from \"cojson\";\nimport type { Account } from \"../coValues/account.js\";\nimport type { ID } from \"../internal.js\";\nimport { AuthCredentials } from \"../types.js\";\nimport KvStoreContext from \"./KvStoreContext.js\";\n\nconst STORAGE_KEY = \"jazz-logged-in-secret\";\n\nexport type AuthSetPayload = {\n  accountID: ID<Account>;\n  secretSeed?: Uint8Array;\n  accountSecret: AgentSecret;\n  provider: \"anonymous\" | \"clerk\" | \"demo\" | \"passkey\" | \"passphrase\" | string;\n};\n\nexport class AuthSecretStorage {\n  private listeners: Set<(isAuthenticated: boolean) => void>;\n  public isAuthenticated: boolean;\n\n  constructor() {\n    this.listeners = new Set();\n    this.isAuthenticated = false;\n  }\n\n  async migrate() {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n\n    if (!(await kvStore.get(STORAGE_KEY))) {\n      const demoAuthSecret = await kvStore.get(\"demo-auth-logged-in-secret\");\n      if (demoAuthSecret) {\n        const parsed = JSON.parse(demoAuthSecret);\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            accountSecret: parsed.accountSecret,\n            provider: \"demo\",\n          }),\n        );\n        await kvStore.delete(\"demo-auth-logged-in-secret\");\n      }\n\n      const clerkAuthSecret = await kvStore.get(\"jazz-clerk-auth\");\n      if (clerkAuthSecret) {\n        const parsed = JSON.parse(clerkAuthSecret);\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            accountSecret: parsed.secret,\n            provider: \"clerk\",\n          }),\n        );\n        await kvStore.delete(\"jazz-clerk-auth\");\n      }\n    }\n\n    const value = await kvStore.get(STORAGE_KEY);\n\n    if (value) {\n      const parsed = JSON.parse(value);\n\n      if (\"secret\" in parsed) {\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            secretSeed: parsed.secretSeed,\n            accountSecret: parsed.secret,\n            provider: parsed.provider,\n          }),\n        );\n      }\n    }\n  }\n\n  async get(): Promise<AuthCredentials | null> {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    const data = await kvStore.get(STORAGE_KEY);\n\n    if (!data) return null;\n\n    const parsed = JSON.parse(data);\n\n    if (!parsed.accountID || !parsed.accountSecret) {\n      throw new Error(\"Invalid auth secret storage data\");\n    }\n\n    return {\n      accountID: parsed.accountID,\n      secretSeed: parsed.secretSeed\n        ? new Uint8Array(parsed.secretSeed)\n        : undefined,\n      accountSecret: parsed.accountSecret,\n      provider: parsed.provider,\n    };\n  }\n\n  async setWithoutNotify(payload: AuthSetPayload) {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await kvStore.set(\n      STORAGE_KEY,\n      JSON.stringify({\n        accountID: payload.accountID,\n        secretSeed: payload.secretSeed\n          ? Array.from(payload.secretSeed)\n          : undefined,\n        accountSecret: payload.accountSecret,\n        provider: payload.provider,\n      }),\n    );\n  }\n\n  async set(payload: AuthSetPayload) {\n    this.setWithoutNotify(payload);\n    this.emitUpdate(payload);\n  }\n\n  getIsAuthenticated(data: AuthCredentials | null): boolean {\n    if (!data) return false;\n    return data.provider !== \"anonymous\";\n  }\n\n  onUpdate(handler: (isAuthenticated: boolean) => void) {\n    this.listeners.add(handler);\n    return () => {\n      this.listeners.delete(handler);\n    };\n  }\n\n  emitUpdate(data: AuthCredentials | null) {\n    const isAuthenticated = this.getIsAuthenticated(data);\n\n    if (this.isAuthenticated === isAuthenticated) return;\n\n    this.isAuthenticated = isAuthenticated;\n    for (const listener of this.listeners) {\n      listener(this.isAuthenticated);\n    }\n  }\n\n  async clearWithoutNotify() {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await kvStore.delete(STORAGE_KEY);\n  }\n\n  async clear() {\n    await this.clearWithoutNotify();\n    this.emitUpdate(null);\n  }\n}\n","import { KvStore } from \"./KvStoreContext.js\";\n\nexport class InMemoryKVStore implements KvStore {\n  private store: Record<string, string> = {};\n\n  async get(key: string) {\n    const data = this.store[key];\n\n    if (!data) return null;\n\n    return data;\n  }\n\n  async set(key: string, value: string) {\n    this.store[key] = value;\n  }\n\n  async delete(key: string) {\n    delete this.store[key];\n  }\n\n  async clearAll() {\n    this.store = {};\n  }\n}\n","import { AgentSecret, LocalNode, cojsonInternals } from \"cojson\";\nimport { AuthSecretStorage } from \"../auth/AuthSecretStorage.js\";\nimport { InMemoryKVStore } from \"../auth/InMemoryKVStore.js\";\nimport { KvStore, KvStoreContext } from \"../auth/KvStoreContext.js\";\nimport { Account } from \"../coValues/account.js\";\nimport { AuthCredentials } from \"../types.js\";\nimport { JazzContextType } from \"../types.js\";\nimport { AnonymousJazzAgent } from \"./anonymousJazzAgent.js\";\n\nexport type JazzContextManagerAuthProps = {\n  credentials?: AuthCredentials;\n  newAccountProps?: { secret: AgentSecret; creationProps: { name: string } };\n};\n\nexport type JazzContextManagerBaseProps<Acc extends Account> = {\n  onAnonymousAccountDiscarded?: (anonymousAccount: Acc) => Promise<void>;\n  onLogOut?: () => void | Promise<unknown>;\n  logOutReplacement?: () => void | Promise<unknown>;\n};\n\ntype PlatformSpecificAuthContext<Acc extends Account> = {\n  me: Acc;\n  node: LocalNode;\n  logOut: () => Promise<void>;\n  done: () => void;\n};\n\ntype PlatformSpecificGuestContext = {\n  guest: AnonymousJazzAgent;\n  node: LocalNode;\n  logOut: () => Promise<void>;\n  done: () => void;\n};\n\ntype PlatformSpecificContext<Acc extends Account> =\n  | PlatformSpecificAuthContext<Acc>\n  | PlatformSpecificGuestContext;\n\nexport class JazzContextManager<\n  Acc extends Account,\n  P extends JazzContextManagerBaseProps<Acc>,\n> {\n  protected value: JazzContextType<Acc> | undefined;\n  protected context: PlatformSpecificContext<Acc> | undefined;\n  protected props: P | undefined;\n  protected authSecretStorage = new AuthSecretStorage();\n  protected keepContextOpen = false;\n  protected contextPromise: Promise<void> | undefined;\n\n  constructor() {\n    KvStoreContext.getInstance().initialize(this.getKvStore());\n  }\n\n  getKvStore(): KvStore {\n    return new InMemoryKVStore();\n  }\n\n  async createContext(props: P, authProps?: JazzContextManagerAuthProps) {\n    // We need to store the props here to block the double effect execution\n    // on React. Otherwise when calling propsChanged this.props is undefined.\n    this.props = props;\n\n    // Avoid race condition between the previous context and the new one\n    const { promise, resolve } = createResolvablePromise<void>();\n\n    const prevPromise = this.contextPromise;\n    this.contextPromise = promise;\n\n    await prevPromise;\n\n    try {\n      const result = await this.getNewContext(props, authProps);\n      await this.updateContext(props, result, authProps);\n\n      resolve();\n    } catch (error) {\n      resolve();\n      throw error;\n    }\n  }\n\n  async getNewContext(\n    props: P,\n    authProps?: JazzContextManagerAuthProps,\n  ): Promise<PlatformSpecificContext<Acc>> {\n    props;\n    authProps;\n    throw new Error(\"Not implemented\");\n  }\n\n  async updateContext(\n    props: P,\n    context: PlatformSpecificContext<Acc>,\n    authProps?: JazzContextManagerAuthProps,\n  ) {\n    // When keepContextOpen we don't want to close the previous context\n    // because we might need to handle the onAnonymousAccountDiscarded callback\n    if (!this.keepContextOpen) {\n      this.context?.done();\n    }\n\n    this.context = context;\n    this.props = props;\n    this.value = {\n      ...context,\n      node: context.node,\n      authenticate: this.authenticate,\n      register: this.register,\n      logOut: this.logOut,\n    };\n\n    if (authProps?.credentials) {\n      this.authSecretStorage.emitUpdate(authProps.credentials);\n    } else {\n      this.authSecretStorage.emitUpdate(await this.authSecretStorage.get());\n    }\n\n    this.notify();\n  }\n\n  propsChanged(props: P) {\n    props;\n    throw new Error(\"Not implemented\");\n  }\n\n  getCurrentValue() {\n    return this.value;\n  }\n\n  getAuthSecretStorage() {\n    return this.authSecretStorage;\n  }\n\n  logOut = async () => {\n    if (!this.context || !this.props) {\n      return;\n    }\n\n    await this.props.onLogOut?.();\n\n    if (this.props.logOutReplacement) {\n      await this.props.logOutReplacement();\n    } else {\n      await this.context.logOut();\n      return this.createContext(this.props);\n    }\n  };\n\n  done = () => {\n    if (!this.context) {\n      return;\n    }\n\n    this.context.done();\n  };\n\n  shouldMigrateAnonymousAccount = async () => {\n    if (!this.props?.onAnonymousAccountDiscarded) {\n      return false;\n    }\n\n    const prevCredentials = await this.authSecretStorage.get();\n    const wasAnonymous =\n      this.authSecretStorage.getIsAuthenticated(prevCredentials) === false;\n\n    return wasAnonymous;\n  };\n\n  /**\n   * Authenticates the user with the given credentials\n   */\n  authenticate = async (credentials: AuthCredentials) => {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const prevContext = this.context;\n    const migratingAnonymousAccount =\n      await this.shouldMigrateAnonymousAccount();\n\n    this.keepContextOpen = migratingAnonymousAccount;\n    await this.createContext(this.props, { credentials }).finally(() => {\n      this.keepContextOpen = false;\n    });\n\n    if (migratingAnonymousAccount) {\n      await this.handleAnonymousAccountMigration(prevContext);\n    }\n  };\n\n  register = async (\n    accountSecret: AgentSecret,\n    creationProps: { name: string },\n  ) => {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const prevContext = this.context;\n    const migratingAnonymousAccount =\n      await this.shouldMigrateAnonymousAccount();\n\n    this.keepContextOpen = migratingAnonymousAccount;\n    await this.createContext(this.props, {\n      newAccountProps: {\n        secret: accountSecret,\n        creationProps,\n      },\n    }).finally(() => {\n      this.keepContextOpen = false;\n    });\n\n    if (migratingAnonymousAccount) {\n      await this.handleAnonymousAccountMigration(prevContext);\n    }\n\n    if (this.context && \"me\" in this.context) {\n      return this.context.me.id;\n    }\n\n    throw new Error(\"The registration hasn't created a new account\");\n  };\n\n  private async handleAnonymousAccountMigration(\n    prevContext: PlatformSpecificContext<Acc> | undefined,\n  ) {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const currentContext = this.context;\n\n    if (\n      prevContext &&\n      currentContext &&\n      \"me\" in prevContext &&\n      \"me\" in currentContext\n    ) {\n      // Using a direct connection to make coValue transfer almost synchronous\n      const [prevAccountAsPeer, currentAccountAsPeer] =\n        cojsonInternals.connectedPeers(\n          prevContext.me.id,\n          currentContext.me.id,\n          {\n            peer1role: \"client\",\n            peer2role: \"server\",\n          },\n        );\n\n      prevContext.node.syncManager.addPeer(currentAccountAsPeer);\n      currentContext.node.syncManager.addPeer(prevAccountAsPeer);\n\n      try {\n        await this.props.onAnonymousAccountDiscarded?.(prevContext.me);\n        await prevContext.me.waitForAllCoValuesSync();\n      } catch (error) {\n        console.error(\"Error onAnonymousAccountDiscarded\", error);\n      }\n\n      prevAccountAsPeer.outgoing.close();\n      currentAccountAsPeer.outgoing.close();\n    }\n\n    prevContext?.done();\n  }\n\n  listeners = new Set<() => void>();\n  subscribe = (callback: () => void) => {\n    this.listeners.add(callback);\n\n    return () => {\n      this.listeners.delete(callback);\n    };\n  };\n\n  notify() {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n\nfunction createResolvablePromise<T>() {\n  let resolve!: (value: T) => void;\n\n  const promise = new Promise<T>((res) => {\n    resolve = res;\n  });\n\n  return { promise, resolve };\n}\n","import { AgentSecret } from \"cojson\";\nimport { Account } from \"../coValues/account.js\";\nimport { ID } from \"../internal.js\";\nimport { AuthenticateAccountFunction } from \"../types.js\";\nimport { AuthSecretStorage } from \"./AuthSecretStorage.js\";\nimport { KvStore, KvStoreContext } from \"./KvStoreContext.js\";\n\ntype StorageData = {\n  accountID: ID<Account>;\n  accountSecret: AgentSecret;\n  secretSeed?: number[];\n};\n\n/**\n * `DemoAuth` provides a `JazzAuth` object for demo authentication.\n *\n * Demo authentication is useful for quickly testing your app, as it allows you to create new accounts and log in as existing ones.\n *\n * ```\n * import { DemoAuth } from \"jazz-tools\";\n *\n * const auth = new DemoAuth(jazzContext.authenticate, new AuthSecretStorage());\n * ```\n *\n * @category Auth Providers\n */\nexport class DemoAuth {\n  constructor(\n    private authenticate: AuthenticateAccountFunction,\n    private authSecretStorage: AuthSecretStorage,\n  ) {}\n\n  logIn = async (username: string) => {\n    const existingUsers = await this.getExisitingUsersWithData();\n    const storageData = existingUsers[username];\n\n    if (!storageData?.accountID) {\n      throw new Error(\"User not found\");\n    }\n\n    await this.authenticate({\n      accountID: storageData.accountID,\n      accountSecret: storageData.accountSecret,\n    });\n\n    await this.authSecretStorage.set({\n      accountID: storageData.accountID,\n      accountSecret: storageData.accountSecret,\n      secretSeed: storageData.secretSeed\n        ? new Uint8Array(storageData.secretSeed)\n        : undefined,\n      provider: \"demo\",\n    });\n  };\n\n  signUp = async (username: string) => {\n    const existingUsers = await this.getExistingUsers();\n    if (existingUsers.includes(username)) {\n      throw new Error(\"User already registered\");\n    }\n\n    const credentials = await this.authSecretStorage.get();\n\n    if (!credentials) {\n      throw new Error(\"No credentials found\");\n    }\n\n    const currentAccount = await Account.getMe().ensureLoaded({\n      resolve: {\n        profile: true,\n      },\n    });\n\n    currentAccount.profile.name = username;\n\n    await this.authSecretStorage.set({\n      accountID: credentials.accountID,\n      accountSecret: credentials.accountSecret,\n      secretSeed: credentials.secretSeed\n        ? new Uint8Array(credentials.secretSeed)\n        : undefined,\n      provider: \"demo\",\n    });\n\n    await this.addToExistingUsers(username, {\n      accountID: credentials.accountID,\n      accountSecret: credentials.accountSecret,\n      secretSeed: credentials.secretSeed\n        ? Array.from(credentials.secretSeed)\n        : undefined,\n    });\n  };\n\n  private async addToExistingUsers(username: string, data: StorageData) {\n    const existingUsers = await this.getExisitingUsersWithData();\n\n    if (existingUsers[username]) {\n      return;\n    }\n\n    existingUsers[username] = data;\n\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await kvStore.set(\"demo-auth-users\", JSON.stringify(existingUsers));\n  }\n\n  private async getExisitingUsersWithData() {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await migrateExistingUsers(kvStore);\n\n    const existingUsers = await kvStore.get(\"demo-auth-users\");\n    return existingUsers ? JSON.parse(existingUsers) : {};\n  }\n\n  getExistingUsers = async () => {\n    return Object.keys(await this.getExisitingUsersWithData());\n  };\n}\n\nexport function encodeUsername(username: string) {\n  return btoa(username)\n    .replace(/=/g, \"-\")\n    .replace(/\\+/g, \"_\")\n    .replace(/\\//g, \".\");\n}\n\nasync function getStorageVersion(kvStore: KvStore) {\n  try {\n    const version = await kvStore.get(\"demo-auth-storage-version\");\n    return version ? parseInt(version) : 1;\n  } catch (error) {\n    return 1;\n  }\n}\n\nasync function setStorageVersion(kvStore: KvStore, version: number) {\n  await kvStore.set(\"demo-auth-storage-version\", version.toString());\n}\n\nasync function getExistingUsersList(kvStore: KvStore) {\n  const existingUsers = await kvStore.get(\"demo-auth-existing-users\");\n  return existingUsers ? existingUsers.split(\",\") : [];\n}\n\n/**\n * Migrates existing users keys to work with any storage.\n */\nasync function migrateExistingUsers(kvStore: KvStore) {\n  if ((await getStorageVersion(kvStore)) < 2) {\n    const existingUsers = await getExistingUsersList(kvStore);\n\n    for (const username of existingUsers) {\n      const legacyKey = `demo-auth-existing-users-${username}`;\n      const storageData = await kvStore.get(legacyKey);\n      if (storageData) {\n        await kvStore.set(\n          `demo-auth-existing-users-${encodeUsername(username)}`,\n          storageData,\n        );\n        await kvStore.delete(legacyKey);\n      }\n    }\n\n    await setStorageVersion(kvStore, 2);\n  }\n\n  if ((await getStorageVersion(kvStore)) < 3) {\n    const existingUsersList = await getExistingUsersList(kvStore);\n\n    const existingUsers: Record<string, StorageData> = {};\n    const keysToDelete: string[] = [\"demo-auth-existing-users\"];\n\n    for (const username of existingUsersList) {\n      const key = `demo-auth-existing-users-${encodeUsername(username)}`;\n      const storageData = await kvStore.get(key);\n      if (storageData) {\n        existingUsers[username] = JSON.parse(storageData);\n        keysToDelete.push(key);\n      }\n    }\n\n    await kvStore.set(\"demo-auth-users\", JSON.stringify(existingUsers));\n\n    for (const key of keysToDelete) {\n      await kvStore.delete(key);\n    }\n\n    await setStorageVersion(kvStore, 3);\n  }\n}\n","import * as bip39 from \"@scure/bip39\";\nimport { entropyToMnemonic } from \"@scure/bip39\";\nimport { CryptoProvider, cojsonInternals } from \"cojson\";\nimport { Account } from \"../coValues/account.js\";\nimport type { ID } from \"../internal.js\";\nimport type {\n  AuthenticateAccountFunction,\n  RegisterAccountFunction,\n} from \"../types.js\";\nimport { AuthSecretStorage } from \"./AuthSecretStorage.js\";\n\n/**\n * `PassphraseAuth` provides a `JazzAuth` object for passphrase authentication.\n *\n * ```ts\n * import { PassphraseAuth } from \"jazz-tools\";\n *\n * const auth = new PassphraseAuth(crypto, jazzContext.authenticate, new AuthSecretStorage(), wordlist);\n * ```\n *\n * @category Auth Providers\n */\nexport class PassphraseAuth {\n  passphrase: string = \"\";\n\n  constructor(\n    private crypto: CryptoProvider,\n    private authenticate: AuthenticateAccountFunction,\n    private register: RegisterAccountFunction,\n    private authSecretStorage: AuthSecretStorage,\n    public wordlist: string[],\n  ) {}\n\n  logIn = async (passphrase: string) => {\n    const { crypto, authenticate } = this;\n\n    let secretSeed;\n\n    try {\n      secretSeed = bip39.mnemonicToEntropy(passphrase, this.wordlist);\n    } catch (e) {\n      throw new Error(\"Invalid passphrase\");\n    }\n\n    const accountSecret = crypto.agentSecretFromSecretSeed(secretSeed);\n\n    const accountID = cojsonInternals.idforHeader(\n      cojsonInternals.accountHeaderForInitialAgentSecret(accountSecret, crypto),\n      crypto,\n    ) as ID<Account>;\n\n    await authenticate({\n      accountID,\n      accountSecret,\n    });\n\n    await this.authSecretStorage.set({\n      accountID,\n      secretSeed,\n      accountSecret,\n      provider: \"passphrase\",\n    });\n\n    this.passphrase = passphrase;\n    this.notify();\n  };\n\n  signUp = async (name?: string) => {\n    const credentials = await this.authSecretStorage.get();\n\n    if (!credentials || !credentials.secretSeed) {\n      throw new Error(\"No credentials found\");\n    }\n\n    const passphrase = entropyToMnemonic(credentials.secretSeed, this.wordlist);\n\n    await this.authSecretStorage.set({\n      accountID: credentials.accountID,\n      secretSeed: credentials.secretSeed,\n      accountSecret: credentials.accountSecret,\n      provider: \"passphrase\",\n    });\n\n    if (name?.trim()) {\n      const currentAccount = await Account.getMe().ensureLoaded({\n        resolve: {\n          profile: true,\n        },\n      });\n\n      currentAccount.profile.name = name;\n    }\n\n    return passphrase;\n  };\n\n  registerNewAccount = async (passphrase: string, name: string) => {\n    const secretSeed = bip39.mnemonicToEntropy(passphrase, this.wordlist);\n    const accountSecret = this.crypto.agentSecretFromSecretSeed(secretSeed);\n    const accountID = await this.register(accountSecret, { name });\n\n    await this.authSecretStorage.set({\n      accountID,\n      secretSeed,\n      accountSecret,\n      provider: \"passphrase\",\n    });\n\n    return accountID;\n  };\n\n  getCurrentAccountPassphrase = async () => {\n    const credentials = await this.authSecretStorage.get();\n\n    if (!credentials || !credentials.secretSeed) {\n      throw new Error(\"No credentials found\");\n    }\n\n    return entropyToMnemonic(credentials.secretSeed, this.wordlist);\n  };\n\n  generateRandomPassphrase = () => {\n    return entropyToMnemonic(this.crypto.newRandomSecretSeed(), this.wordlist);\n  };\n\n  loadCurrentAccountPassphrase = async () => {\n    const passphrase = await this.getCurrentAccountPassphrase();\n    this.passphrase = passphrase;\n    this.notify();\n  };\n\n  listeners = new Set<() => void>();\n  subscribe = (callback: () => void) => {\n    this.listeners.add(callback);\n\n    return () => {\n      this.listeners.delete(callback);\n    };\n  };\n\n  notify() {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n","import { type InviteSecret, cojsonInternals } from \"cojson\";\nimport { Account } from \"../coValues/account.js\";\nimport type { CoValue, CoValueClass, ID } from \"../internal.js\";\n\n/** @category Invite Links */\nexport function createInviteLink<C extends CoValue>(\n  value: C,\n  role: \"reader\" | \"writer\" | \"admin\" | \"writeOnly\",\n  baseURL: string,\n  valueHint?: string,\n): string {\n  const coValueCore = value._raw.core;\n  let currentCoValue = coValueCore;\n\n  while (currentCoValue.header.ruleset.type === \"ownedByGroup\") {\n    currentCoValue = currentCoValue.getGroup().core;\n  }\n\n  const { ruleset, meta } = currentCoValue.header;\n\n  if (ruleset.type !== \"group\" || meta?.type === \"account\") {\n    throw new Error(\"Can't create invite link for object without group\");\n  }\n\n  const group = cojsonInternals.expectGroup(currentCoValue.getCurrentContent());\n  const inviteSecret = group.createInvite(role);\n\n  return `${baseURL}#/invite/${valueHint ? valueHint + \"/\" : \"\"}${\n    value.id\n  }/${inviteSecret}`;\n}\n\n/** @category Invite Links */\nexport function parseInviteLink<C extends CoValue>(\n  inviteURL: string,\n):\n  | {\n      valueID: ID<C>;\n      valueHint?: string;\n      inviteSecret: InviteSecret;\n    }\n  | undefined {\n  const url = new URL(inviteURL);\n  const parts = url.hash.split(\"/\");\n\n  let valueHint: string | undefined;\n  let valueID: ID<C> | undefined;\n  let inviteSecret: InviteSecret | undefined;\n\n  if (parts[0] === \"#\" && parts[1] === \"invite\") {\n    if (parts.length === 5) {\n      valueHint = parts[2];\n      valueID = parts[3] as ID<C>;\n      inviteSecret = parts[4] as InviteSecret;\n    } else if (parts.length === 4) {\n      valueID = parts[2] as ID<C>;\n      inviteSecret = parts[3] as InviteSecret;\n    }\n\n    if (!valueID || !inviteSecret) {\n      return undefined;\n    }\n    return { valueID, inviteSecret, valueHint };\n  }\n}\n\n/** @category Invite Links */\nexport function consumeInviteLink<V extends CoValue>({\n  inviteURL,\n  as = Account.getMe(),\n  forValueHint,\n  invitedObjectSchema,\n}: {\n  inviteURL: string;\n  as?: Account;\n  forValueHint?: string;\n  invitedObjectSchema: CoValueClass<V>;\n}): Promise<\n  | {\n      valueID: ID<V>;\n      valueHint?: string;\n      inviteSecret: InviteSecret;\n    }\n  | undefined\n> {\n  return new Promise((resolve, reject) => {\n    const result = parseInviteLink<V>(inviteURL);\n\n    if (result && result.valueHint === forValueHint) {\n      as.acceptInvite(result.valueID, result.inviteSecret, invitedObjectSchema)\n        .then(() => {\n          resolve(result);\n        })\n        .catch(reject);\n    } else {\n      resolve(undefined);\n    }\n  });\n}\n"],"mappings":"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","names":["RawAccount","key","account","creationProps","RawAccount","loadCoValue","ref","subscription","Group","RawAccount","RawAccount","loadCoValue","error","message","rawEdit","ref","_a","_b","LocalNode","RawAccount","cojsonInternals","RawAccount","ref","loadCoValue","LocalNode","cojsonInternals","cojsonInternals","_a","_b","rawEntry","cojsonInternals","RawAccount","_a","_b","RawAccount","ref","RawAccount","calcPatch","RawAccount","calcPatch","cojsonInternals","cojsonInternals","cojsonInternals","cojsonInternals","cojsonInternals","cojsonInternals"]}