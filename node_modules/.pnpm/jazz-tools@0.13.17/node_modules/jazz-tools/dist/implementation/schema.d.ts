import type { JsonValue, RawCoValue } from "cojson";
import { CojsonInternalTypes } from "cojson";
import { type CoValue, type CoValueClass, ItemsSym, JazzToolsSymbol } from "../internal.js";
/** @category Schema definition */
export declare const Encoders: {
    Date: {
        encode: (value: Date) => string;
        decode: (value: JsonValue) => Date;
    };
    OptionalDate: {
        encode: (value: Date | undefined) => string | null;
        decode: (value: JsonValue) => Date | undefined;
    };
};
export type CoMarker = {
    readonly __co: unique symbol;
};
/** @category Schema definition */
export type co<T> = T | (T & CoMarker);
export type IfCo<C, R> = C extends infer _A | infer B ? B extends CoMarker ? R extends JazzToolsSymbol ? never : R : never : never;
export type UnCo<T> = T extends co<infer A> ? A : T;
/** @category Schema definition */
export declare const co: {
    string: co<string>;
    number: co<number>;
    boolean: co<boolean>;
    null: co<null>;
    Date: co<Date>;
    literal<T extends (string | number | boolean)[]>(..._lit: T): co<T[number]>;
    json<T extends CojsonInternalTypes.CoJsonValue<T>>(): co<T>;
    encoded<T>(arg: Encoder<T>): co<T>;
    ref: typeof ref;
    items: ItemsSym;
    optional: {
        ref: typeof optionalRef;
        json<T extends CojsonInternalTypes.CoJsonValue<T>>(): co<T | undefined>;
        encoded<T>(arg: OptionalEncoder<T>): co<T | undefined>;
        string: co<string | undefined>;
        number: co<number | undefined>;
        boolean: co<boolean | undefined>;
        null: co<null | undefined>;
        Date: co<Date | undefined>;
        literal<T extends (string | number | boolean)[]>(..._lit: T): co<T[number] | undefined>;
    };
};
declare function optionalRef<C extends CoValueClass>(arg: C | ((_raw: InstanceType<C>["_raw"]) => C)): co<InstanceType<C> | null | undefined>;
declare function ref<C extends CoValueClass>(arg: C | ((_raw: InstanceType<C>["_raw"]) => C), options?: never): co<InstanceType<C> | null>;
declare function ref<C extends CoValueClass>(arg: C | ((_raw: InstanceType<C>["_raw"]) => C), options: {
    optional: true;
}): co<InstanceType<C> | null | undefined>;
export type JsonEncoded = "json";
export type EncodedAs<V> = {
    encoded: Encoder<V> | OptionalEncoder<V>;
};
export type RefEncoded<V extends CoValue> = {
    ref: CoValueClass<V> | ((raw: RawCoValue) => CoValueClass<V>);
    optional: boolean;
};
export declare function isRefEncoded<V extends CoValue>(schema: Schema): schema is RefEncoded<V>;
export declare function instantiateRefEncoded<V extends CoValue>(schema: RefEncoded<V>, raw: RawCoValue): V;
export type Schema = JsonEncoded | RefEncoded<CoValue> | EncodedAs<any>;
export type SchemaFor<Field> = NonNullable<Field> extends CoValue ? RefEncoded<NonNullable<Field>> : NonNullable<Field> extends JsonValue ? JsonEncoded : EncodedAs<NonNullable<Field>>;
export type Encoder<V> = {
    encode: (value: V) => JsonValue;
    decode: (value: JsonValue) => V;
};
export type OptionalEncoder<V> = Encoder<V> | {
    encode: (value: V | undefined) => JsonValue;
    decode: (value: JsonValue) => V | undefined;
};
export {};
//# sourceMappingURL=schema.d.ts.map