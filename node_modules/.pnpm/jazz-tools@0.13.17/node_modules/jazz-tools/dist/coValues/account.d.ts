import { AgentSecret, CryptoProvider, Everyone, InviteSecret, LocalNode, Peer, RawAccount, RawControlledAccount, Role, SessionID } from "cojson";
import { AnonymousJazzAgent, type CoValue, CoValueBase, CoValueClass, ID, Ref, RefIfCoValue, RefsToResolve, RefsToResolveStrict, Resolved, type Schema, SubscribeListenerOptions, inspect } from "../internal.js";
import { RegisteredAccount } from "../types.js";
import { type CoMap } from "./coMap.js";
import { type Group } from "./group.js";
import { Profile } from "./profile.js";
export type AccountCreationProps = {
    name: string;
    onboarding?: boolean;
};
/** @category Identity & Permissions */
export declare class Account extends CoValueBase implements CoValue {
    id: ID<this>;
    _type: "Account";
    _raw: RawAccount | RawControlledAccount;
    static _schema: any;
    get _schema(): {
        profile: Schema;
        root: Schema;
    };
    get _owner(): Account;
    get _loadedAs(): Account | AnonymousJazzAgent;
    profile: Profile | null;
    root: CoMap | null;
    get _refs(): {
        profile: RefIfCoValue<Profile> | undefined;
        root: RefIfCoValue<CoMap> | undefined;
    };
    /**
     * Whether this account is the currently active account.
     */
    get isMe(): boolean;
    /**
     * Whether this account is the owner of the local node.
     */
    isLocalNodeOwner: boolean;
    sessionID: SessionID | undefined;
    constructor(options: {
        fromRaw: RawAccount | RawControlledAccount;
    });
    myRole(): "admin" | undefined;
    getRoleOf(member: Everyone | ID<Account> | "me"): "admin" | undefined;
    getParentGroups(): Array<Group>;
    get members(): Array<{
        id: ID<RegisteredAccount> | "everyone";
        role: Role;
        ref: Ref<RegisteredAccount> | undefined;
        account: RegisteredAccount | null | undefined;
    }>;
    canRead(value: CoValue): boolean;
    canWrite(value: CoValue): boolean;
    canAdmin(value: CoValue): boolean;
    acceptInvite<V extends CoValue>(valueID: ID<V>, inviteSecret: InviteSecret, coValueClass: CoValueClass<V>): Promise<Resolved<V, true> | null>;
    /** @private */
    static create<A extends Account>(this: CoValueClass<A> & typeof Account, options: {
        creationProps: {
            name: string;
        };
        initialAgentSecret?: AgentSecret;
        peersToLoadFrom?: Peer[];
        crypto: CryptoProvider;
    }): Promise<A>;
    static getMe<A extends Account>(this: CoValueClass<A> & typeof Account): A;
    static createAs<A extends Account>(this: CoValueClass<A> & typeof Account, as: Account, options: {
        creationProps: {
            name: string;
        };
    }): Promise<A>;
    static fromNode<A extends Account>(this: CoValueClass<A>, node: LocalNode): A;
    toJSON(): object | any[];
    [inspect](): object | any[];
    applyMigration(creationProps?: AccountCreationProps): Promise<void>;
    migrate(creationProps?: AccountCreationProps): void;
    /** @category Subscription & Loading */
    static load<A extends Account, const R extends RefsToResolve<A> = true>(this: CoValueClass<A>, id: ID<A>, options?: {
        resolve?: RefsToResolveStrict<A, R>;
        loadAs?: Account | AnonymousJazzAgent;
    }): Promise<Resolved<A, R> | null>;
    /** @category Subscription & Loading */
    static subscribe<A extends Account, const R extends RefsToResolve<A> = true>(this: CoValueClass<A>, id: ID<A>, listener: (value: Resolved<A, R>, unsubscribe: () => void) => void): () => void;
    static subscribe<A extends Account, const R extends RefsToResolve<A> = true>(this: CoValueClass<A>, id: ID<A>, options: SubscribeListenerOptions<A, R>, listener: (value: Resolved<A, R>, unsubscribe: () => void) => void): () => void;
    /** @category Subscription & Loading */
    ensureLoaded<A extends Account, const R extends RefsToResolve<A>>(this: A, options: {
        resolve: RefsToResolveStrict<A, R>;
    }): Promise<Resolved<A, R>>;
    /** @category Subscription & Loading */
    subscribe<A extends Account, const R extends RefsToResolve<A>>(this: A, listener: (value: Resolved<A, R>, unsubscribe: () => void) => void): () => void;
    subscribe<A extends Account, const R extends RefsToResolve<A>>(this: A, options: {
        resolve?: RefsToResolveStrict<A, R>;
    }, listener: (value: Resolved<A, R>, unsubscribe: () => void) => void): () => void;
    /**
     * Wait for the `Account` to be uploaded to the other peers.
     *
     * @category Subscription & Loading
     */
    waitForSync(options?: {
        timeout?: number;
    }): Promise<unknown[]>;
    /**
     * Wait for all the available `CoValues` to be uploaded to the other peers.
     *
     * @category Subscription & Loading
     */
    waitForAllCoValuesSync(options?: {
        timeout?: number;
    }): Promise<unknown[][]>;
}
export declare const AccountAndGroupProxyHandler: ProxyHandler<Account | Group>;
/** @category Identity & Permissions */
export declare function isControlledAccount(account: Account): account is Account & {
    isLocalNodeOwner: true;
    sessionID: SessionID;
    _raw: RawControlledAccount;
};
export type AccountClass<Acc extends Account> = CoValueClass<Acc> & {
    fromNode: (typeof Account)["fromNode"];
};
//# sourceMappingURL=account.d.ts.map