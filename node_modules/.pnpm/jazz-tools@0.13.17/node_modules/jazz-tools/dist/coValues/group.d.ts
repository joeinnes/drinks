import type { AccountRole, AgentID, Everyone, RawAccountID, RawGroup, Role } from "cojson";
import type { CoValue, CoValueClass, ID, RefsToResolve, RefsToResolveStrict, Resolved, Schema, SubscribeListenerOptions } from "../internal.js";
import { CoValueBase, Ref } from "../internal.js";
import { RegisteredAccount } from "../types.js";
import { type Account } from "./account.js";
import { type CoMap } from "./coMap.js";
import { type Profile } from "./profile.js";
/** @category Identity & Permissions */
export declare class Group extends CoValueBase implements CoValue {
    id: ID<this>;
    _type: "Group";
    _raw: RawGroup;
    static _schema: any;
    get _schema(): {
        profile: Schema;
        root: Schema;
    };
    profile: Profile | null;
    root: CoMap | null;
    get _refs(): {
        profile: Ref<Profile> | undefined;
        root: Ref<CoMap> | undefined;
    };
    /** @deprecated Don't use constructor directly, use .create */
    constructor(options: {
        fromRaw: RawGroup;
    } | {
        owner: Account | Group;
    });
    static create<G extends Group>(this: CoValueClass<G>, options?: {
        owner: Account;
    } | Account): G;
    myRole(): Role | undefined;
    addMember(member: Everyone, role: "writer" | "reader" | "writeOnly"): void;
    addMember(member: Account, role: AccountRole): void;
    removeMember(member: Everyone | Account): Promise<void>;
    get members(): Array<{
        id: ID<RegisteredAccount>;
        role: AccountRole;
        ref: Ref<RegisteredAccount>;
        account: RegisteredAccount;
    }>;
    getRoleOf(member: Everyone | ID<Account> | "me"): Role | undefined;
    getParentGroups(): Array<Group>;
    extend(parent: Group, roleMapping?: "reader" | "writer" | "admin" | "inherit"): this;
    revokeExtend(parent: Group): Promise<this>;
    /** @category Subscription & Loading */
    static load<G extends Group, const R extends RefsToResolve<G>>(this: CoValueClass<G>, id: ID<G>, options?: {
        resolve?: RefsToResolveStrict<G, R>;
        loadAs?: Account;
    }): Promise<Resolved<G, R> | null>;
    /** @category Subscription & Loading */
    static subscribe<G extends Group, const R extends RefsToResolve<G>>(this: CoValueClass<G>, id: ID<G>, listener: (value: Resolved<G, R>, unsubscribe: () => void) => void): () => void;
    static subscribe<G extends Group, const R extends RefsToResolve<G>>(this: CoValueClass<G>, id: ID<G>, options: SubscribeListenerOptions<G, R>, listener: (value: Resolved<G, R>, unsubscribe: () => void) => void): () => void;
    /** @category Subscription & Loading */
    ensureLoaded<G extends Group, const R extends RefsToResolve<G>>(this: G, options?: {
        resolve?: RefsToResolveStrict<G, R>;
    }): Promise<Resolved<G, R>>;
    /** @category Subscription & Loading */
    subscribe<G extends Group, const R extends RefsToResolve<G>>(this: G, listener: (value: Resolved<G, R>, unsubscribe: () => void) => void): () => void;
    subscribe<G extends Group, const R extends RefsToResolve<G>>(this: G, options: {
        resolve?: RefsToResolveStrict<G, R>;
    }, listener: (value: Resolved<G, R>, unsubscribe: () => void) => void): () => void;
    /**
     * Wait for the `Group` to be uploaded to the other peers.
     *
     * @category Subscription & Loading
     */
    waitForSync(options?: {
        timeout?: number;
    }): Promise<unknown[]>;
}
export declare function isAccountID(id: RawAccountID | AgentID): id is RawAccountID;
//# sourceMappingURL=group.d.ts.map