// src/implementation/activeAccountContext.ts
var ActiveAccountContext = class {
  constructor() {
    this.activeAccount = null;
    this.guestMode = false;
  }
  set(account) {
    this.activeAccount = account;
    this.guestMode = false;
  }
  setGuestMode() {
    this.activeAccount = null;
    this.guestMode = true;
  }
  maybeGet() {
    return this.activeAccount;
  }
  get() {
    if (!this.activeAccount) {
      if (this.guestMode) {
        throw new Error(
          "Something that expects a full active account was called in guest mode."
        );
      }
      throw new Error("No active account");
    }
    return this.activeAccount;
  }
};
var activeAccountContext = new ActiveAccountContext();

// src/implementation/anonymousJazzAgent.ts
var AnonymousJazzAgent = class {
  constructor(node) {
    this.node = node;
    this._type = "Anonymous";
  }
};

// src/coValues/interfaces.ts
import { RawAccount as RawAccount3 } from "cojson";

// src/implementation/inspect.ts
var inspect = Symbol.for("nodejs.util.inspect.custom");

// src/implementation/symbols.ts
var SchemaInit = "$SchemaInit$";
var ItemsSym = "$items$";

// src/coValues/deepLoading.ts
function hasRefValue(value, key) {
  return Boolean(
    value._refs?.[key]
  );
}
function hasReadAccess(value, key) {
  return Boolean(
    value._refs?.[key]?.hasReadAccess()
  );
}
function isOptionalField(value, key) {
  return value._schema[key]?.optional ?? false;
}
function fulfillsDepth(depth, value) {
  if (depth === true || depth === void 0) {
    return {
      status: "fulfilled"
    };
  }
  if (value._type === "CoMap" || value._type === "Group" || value._type === "Account") {
    const map = value;
    if ("$each" in depth) {
      const result = { status: "fulfilled" };
      for (const [key, item] of Object.entries(value)) {
        const rawValue = map._raw.get(key);
        if (rawValue !== void 0 && rawValue !== null) {
          if (!item) {
            if (hasReadAccess(map, key)) {
              result.status = "unfulfilled";
              continue;
            } else {
              return {
                status: "unauthorized",
                path: [key],
                id: rawValue
              };
            }
          }
          const innerResult = fulfillsDepth(depth.$each, item);
          if (innerResult.status === "unfulfilled") {
            result.status = "unfulfilled";
          } else if (innerResult.status === "unauthorized" && !isOptionalField(value, ItemsSym)) {
            innerResult.path.unshift(key);
            return innerResult;
          }
        } else if (!isOptionalField(value, ItemsSym)) {
          return {
            status: "unfulfilled"
          };
        }
      }
      return result;
    } else {
      const result = { status: "fulfilled" };
      for (const key of Object.keys(depth)) {
        const rawValue = map._raw.get(key);
        if (rawValue === void 0 || rawValue === null) {
          if (!map._schema?.[key]) {
            if (map._schema?.[ItemsSym]) {
              if (isOptionalField(map, ItemsSym)) {
                continue;
              } else {
                throw new Error(
                  `The ref ${key} requested on ${map.constructor.name} is missing`
                );
              }
            } else {
              throw new Error(
                `The ref ${key} requested on ${map.constructor.name} is not defined in the schema`
              );
            }
          } else if (isOptionalField(map, key)) {
            continue;
          } else {
            throw new Error(
              `The ref ${key} on ${map.constructor.name} is required but missing`
            );
          }
        } else {
          const item = value[key];
          if (!item) {
            if (hasReadAccess(map, key)) {
              result.status = "unfulfilled";
              continue;
            } else {
              return {
                status: "unauthorized",
                path: [key],
                id: rawValue
              };
            }
          }
          const innerResult = fulfillsDepth(depth[key], item);
          if (innerResult.status === "unfulfilled") {
            result.status = "unfulfilled";
          } else if (innerResult.status === "unauthorized" && !isOptionalField(value, key)) {
            innerResult.path.unshift(key);
            return innerResult;
          }
        }
      }
      return result;
    }
  } else if (value._type === "CoList") {
    if ("$each" in depth) {
      const result = { status: "fulfilled" };
      const list = value;
      for (const [key, item] of value.entries()) {
        const rawValue = list._raw.get(key);
        if (!rawValue) {
          if (isOptionalField(value, ItemsSym)) {
            continue;
          }
          throw new Error(
            `The ref ${key} on ${list.constructor.name} is required but missing`
          );
        }
        if (hasRefValue(value, key)) {
          if (!item) {
            if (hasReadAccess(value, key)) {
              result.status = "unfulfilled";
              continue;
            } else {
              return {
                status: "unauthorized",
                path: [key.toString()],
                id: value._raw.get(key) ?? "undefined"
              };
            }
          }
          const innerResult = fulfillsDepth(depth.$each, item);
          if (innerResult.status === "unfulfilled") {
            result.status = "unfulfilled";
          } else if (innerResult.status === "unauthorized" && !isOptionalField(value, ItemsSym)) {
            innerResult.path.unshift(key.toString());
            return innerResult;
          }
        } else if (!isOptionalField(value, ItemsSym)) {
          return {
            status: "unfulfilled"
          };
        }
      }
      return result;
    }
    return {
      status: "fulfilled"
    };
  } else if (value._type === "CoStream") {
    if ("$each" in depth) {
      const result = { status: "fulfilled" };
      for (const item of Object.values(value.perSession)) {
        if (item.ref) {
          if (!item.value) {
            if (item.ref.hasReadAccess()) {
              result.status = "unfulfilled";
              continue;
            } else {
              return {
                status: "unauthorized",
                path: [item.ref.id],
                id: item.ref.id
              };
            }
          }
          const innerResult = fulfillsDepth(depth.$each, item.value);
          if (innerResult.status === "unfulfilled") {
            result.status = "unfulfilled";
          } else if (innerResult.status === "unauthorized" && !isOptionalField(value, ItemsSym)) {
            innerResult.path.unshift(item.ref.id);
            return innerResult;
          }
        } else if (!isOptionalField(value, ItemsSym)) {
          return {
            status: "unfulfilled"
          };
        }
      }
      return result;
    }
    return {
      status: "fulfilled"
    };
  } else if (value._type === "BinaryCoStream" || value._type === "CoPlainText") {
    return {
      status: "fulfilled"
    };
  } else {
    console.error(value);
    throw new Error("Unexpected value type: " + value._type);
  }
}

// src/implementation/refs.ts
import { RawAccount, RawGroup } from "cojson";

// src/lib/cache.ts
var weakMap = /* @__PURE__ */ new WeakMap();
var coValuesCache = {
  get: (raw, compute) => {
    const cached = weakMap.get(raw);
    if (cached) {
      return cached;
    }
    const computed = compute();
    weakMap.set(raw, computed);
    return computed;
  }
};

// src/implementation/refs.ts
var TRACE_ACCESSES = false;
var Ref = class _Ref {
  constructor(id, controlledAccount, schema) {
    this.id = id;
    this.controlledAccount = controlledAccount;
    this.schema = schema;
    if (!isRefEncoded(schema)) {
      throw new Error("Ref must be constructed with a ref schema");
    }
  }
  getNode() {
    return "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
  }
  hasReadAccess() {
    const node = this.getNode();
    const raw = node.getLoaded(this.id);
    if (!raw) {
      return true;
    }
    if (raw instanceof RawAccount || raw instanceof RawGroup) {
      return true;
    }
    const group = raw.core.getGroup();
    if (group instanceof RawAccount) {
      if (node.account.id !== group.id) {
        return false;
      }
    } else if (group.myRole() === void 0) {
      return false;
    }
    return true;
  }
  getValueWithoutAccessCheck() {
    const node = this.getNode();
    const raw = node.getLoaded(this.id);
    if (raw) {
      return coValuesCache.get(
        raw,
        () => instantiateRefEncoded(this.schema, raw)
      );
    } else {
      return null;
    }
  }
  get value() {
    if (!this.hasReadAccess()) {
      return null;
    }
    return this.getValueWithoutAccessCheck();
  }
  async loadHelper() {
    const node = "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
    const raw = await node.load(this.id);
    if (raw === "unavailable") {
      return "unavailable";
    } else {
      return new _Ref(this.id, this.controlledAccount, this.schema).value;
    }
  }
  syncLoad() {
    const node = "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
    const entry = node.coValuesStore.get(
      this.id
    );
    if (entry.highLevelState === "available") {
      return new _Ref(this.id, this.controlledAccount, this.schema).value;
    }
    return void 0;
  }
  async load() {
    const result = await this.loadHelper();
    if (result === "unavailable") {
      return void 0;
    } else {
      return result;
    }
  }
  accessFrom(fromScopeValue, key) {
    const subScope = subscriptionsScopes.get(fromScopeValue);
    subScope?.onRefAccessedOrSet(fromScopeValue.id, this.id);
    TRACE_ACCESSES && console.log(subScope?.scopeID, "accessing", fromScopeValue, key, this.id);
    if (this.value && subScope) {
      subscriptionsScopes.set(this.value, subScope);
    }
    if (subScope) {
      const cached = subScope.cachedValues[this.id];
      if (cached) {
        TRACE_ACCESSES && console.log("cached", cached);
        return cached;
      } else if (this.value !== null) {
        const freshValueInstance = instantiateRefEncoded(
          this.schema,
          this.value._raw
        );
        TRACE_ACCESSES && console.log("freshValueInstance", freshValueInstance);
        subScope.cachedValues[this.id] = freshValueInstance;
        subscriptionsScopes.set(freshValueInstance, subScope);
        return freshValueInstance;
      } else {
        return null;
      }
    } else {
      return this.value;
    }
  }
};
function makeRefs(getIdForKey, getKeysWithIds, controlledAccount, refSchemaForKey) {
  const refs = {};
  return new Proxy(refs, {
    get(_target, key) {
      if (key === Symbol.iterator) {
        return function* () {
          for (const key2 of getKeysWithIds()) {
            yield new Ref(
              getIdForKey(key2),
              controlledAccount,
              refSchemaForKey(key2)
            );
          }
        };
      }
      if (typeof key === "symbol") return void 0;
      if (key === "length") {
        return getKeysWithIds().length;
      }
      const id = getIdForKey(key);
      if (!id) return void 0;
      return new Ref(
        id,
        controlledAccount,
        refSchemaForKey(key)
      );
    },
    ownKeys() {
      return getKeysWithIds().map((key) => key.toString());
    },
    getOwnPropertyDescriptor(target, key) {
      const id = getIdForKey(key);
      if (id) {
        return {
          enumerable: true,
          configurable: true,
          writable: true
        };
      } else {
        return Reflect.getOwnPropertyDescriptor(target, key);
      }
    }
  });
}

// src/implementation/schema.ts
var Encoders = {
  Date: {
    encode: (value) => value.toISOString(),
    decode: (value) => new Date(value)
  },
  OptionalDate: {
    encode: (value) => value?.toISOString() || null,
    decode: (value) => value === null ? void 0 : new Date(value)
  }
};
var optional = {
  ref: optionalRef,
  json() {
    return { [SchemaInit]: "json" };
  },
  encoded(arg) {
    return { [SchemaInit]: { encoded: arg } };
  },
  string: {
    [SchemaInit]: "json"
  },
  number: {
    [SchemaInit]: "json"
  },
  boolean: {
    [SchemaInit]: "json"
  },
  null: {
    [SchemaInit]: "json"
  },
  Date: {
    [SchemaInit]: { encoded: Encoders.OptionalDate }
  },
  literal(..._lit) {
    return { [SchemaInit]: "json" };
  }
};
var co = {
  string: {
    [SchemaInit]: "json"
  },
  number: {
    [SchemaInit]: "json"
  },
  boolean: {
    [SchemaInit]: "json"
  },
  null: {
    [SchemaInit]: "json"
  },
  Date: {
    [SchemaInit]: { encoded: Encoders.Date }
  },
  literal(..._lit) {
    return { [SchemaInit]: "json" };
  },
  json() {
    return { [SchemaInit]: "json" };
  },
  encoded(arg) {
    return { [SchemaInit]: { encoded: arg } };
  },
  ref,
  items: ItemsSym,
  optional
};
function optionalRef(arg) {
  return ref(arg, { optional: true });
}
function ref(arg, options) {
  return {
    [SchemaInit]: {
      ref: arg,
      optional: options?.optional || false
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  };
}
function isRefEncoded(schema) {
  return typeof schema === "object" && "ref" in schema && "optional" in schema && typeof schema.ref === "function";
}
function instantiateRefEncoded(schema, raw) {
  return isCoValueClass(schema.ref) ? schema.ref.fromRaw(raw) : schema.ref(
    raw
  ).fromRaw(raw);
}

// src/implementation/subscriptionScope.ts
var subscriptionsScopes = /* @__PURE__ */ new WeakMap();
var SubscriptionScope = class {
  constructor(root, rootSchema, onUpdate) {
    this.scopeID = `scope-${Math.random().toString(36).slice(2)}`;
    this.entries = /* @__PURE__ */ new Map();
    this.scheduledUpdate = false;
    this.cachedValues = {};
    this.parents = {};
    this.syncResolution = false;
    this.unsubscribeAll = () => {
      for (const entry of this.entries.values()) {
        if (entry.state === "loaded") {
          entry.rawUnsub();
        } else {
          entry.immediatelyUnsub = true;
        }
      }
      this.entries.clear();
    };
    this.rootEntry = {
      state: "loaded",
      value: root._raw,
      rawUnsub: () => {
      }
      // placeholder
    };
    this.entries.set(root.id, this.rootEntry);
    subscriptionsScopes.set(root, this);
    this.subscriber = root._loadedAs;
    this.scheduleUpdate = () => {
      const value = rootSchema.fromRaw(this.rootEntry.value);
      subscriptionsScopes.set(value, this);
      onUpdate(value, this);
    };
    this.rootEntry.rawUnsub = root._raw.core.subscribe(
      (rawUpdate) => {
        if (!rawUpdate) return;
        this.rootEntry.value = rawUpdate;
        this.scheduleUpdate();
      }
    );
  }
  onRefAccessedOrSet(fromId, accessedOrSetId) {
    if (!accessedOrSetId) {
      return;
    }
    this.parents[accessedOrSetId] = this.parents[accessedOrSetId] || /* @__PURE__ */ new Set();
    this.parents[accessedOrSetId].add(fromId);
    if (!this.entries.has(accessedOrSetId)) {
      const loadingEntry = {
        state: "loading",
        immediatelyUnsub: false
      };
      this.entries.set(accessedOrSetId, loadingEntry);
      const node = this.subscriber._type === "Account" ? this.subscriber._raw.core.node : this.subscriber.node;
      loadCoValue(
        node,
        accessedOrSetId,
        (core) => {
          if (loadingEntry.state === "loading" && loadingEntry.immediatelyUnsub) {
            return;
          }
          if (core !== "unavailable") {
            const entry = {
              state: "loaded",
              rawUnsub: () => {
              }
              // placeholder
            };
            this.entries.set(accessedOrSetId, entry);
            const rawUnsub = core.subscribe((rawUpdate) => {
              if (!rawUpdate) return;
              this.invalidate(accessedOrSetId);
              this.scheduleUpdate();
            });
            entry.rawUnsub = rawUnsub;
          }
        },
        this.syncResolution
      );
    }
  }
  invalidate(id, seen = /* @__PURE__ */ new Set()) {
    if (seen.has(id)) return;
    delete this.cachedValues[id];
    seen.add(id);
    for (const parent of this.parents[id] || []) {
      this.invalidate(parent, seen);
    }
  }
};
function loadCoValue(node, id, callback, syncResolution) {
  const entry = node.coValuesStore.get(id);
  if (entry.isAvailable() && syncResolution) {
    callback(entry.core);
  } else {
    void node.loadCoValueCore(id).then((core) => {
      callback(core);
    });
  }
}

// src/implementation/createContext.ts
import {
  ControlledAgent,
  LocalNode
} from "cojson";

// src/coValues/registeredSchemas.ts
var RegisteredSchemas = {};

// src/implementation/createContext.ts
async function randomSessionProvider(accountID, crypto) {
  return {
    sessionID: crypto.newRandomSessionID(accountID),
    sessionDone: () => {
    }
  };
}
async function createJazzContextFromExistingCredentials({
  credentials,
  peersToLoadFrom,
  crypto,
  AccountSchema: PropsAccountSchema,
  sessionProvider,
  onLogOut
}) {
  const { sessionID, sessionDone } = await sessionProvider(
    credentials.accountID,
    crypto
  );
  const CurrentAccountSchema = PropsAccountSchema ?? RegisteredSchemas["Account"];
  const node = await LocalNode.withLoadedAccount({
    accountID: credentials.accountID,
    accountSecret: credentials.secret,
    sessionID,
    peersToLoadFrom,
    crypto,
    migration: async (rawAccount, _node, creationProps) => {
      const account2 = new CurrentAccountSchema({
        fromRaw: rawAccount
      });
      activeAccountContext.set(account2);
      await account2.applyMigration(creationProps);
    }
  });
  const account = CurrentAccountSchema.fromNode(node);
  activeAccountContext.set(account);
  return {
    node,
    account,
    done: () => {
      node.gracefulShutdown();
      sessionDone();
    },
    logOut: async () => {
      node.gracefulShutdown();
      sessionDone();
      await onLogOut?.();
    }
  };
}
async function createJazzContextForNewAccount({
  creationProps,
  initialAgentSecret,
  peersToLoadFrom,
  crypto,
  AccountSchema: PropsAccountSchema,
  onLogOut
}) {
  const CurrentAccountSchema = PropsAccountSchema ?? RegisteredSchemas["Account"];
  const { node } = await LocalNode.withNewlyCreatedAccount({
    creationProps,
    peersToLoadFrom,
    crypto,
    initialAgentSecret,
    migration: async (rawAccount, _node, creationProps2) => {
      const account2 = new CurrentAccountSchema({
        fromRaw: rawAccount
      });
      activeAccountContext.set(account2);
      await account2.applyMigration(creationProps2);
    }
  });
  const account = CurrentAccountSchema.fromNode(node);
  activeAccountContext.set(account);
  return {
    node,
    account,
    done: () => {
      node.gracefulShutdown();
    },
    logOut: async () => {
      node.gracefulShutdown();
      await onLogOut?.();
    }
  };
}
async function createJazzContext(options) {
  const crypto = options.crypto;
  let context;
  const authSecretStorage = options.authSecretStorage;
  await authSecretStorage.migrate();
  const credentials = options.credentials ?? await authSecretStorage.get();
  if (credentials && !options.newAccountProps) {
    context = await createJazzContextFromExistingCredentials({
      credentials: {
        accountID: credentials.accountID,
        secret: credentials.accountSecret
      },
      peersToLoadFrom: options.peersToLoadFrom,
      crypto,
      AccountSchema: options.AccountSchema,
      sessionProvider: options.sessionProvider,
      onLogOut: () => {
        authSecretStorage.clearWithoutNotify();
      }
    });
  } else {
    const secretSeed = options.crypto.newRandomSecretSeed();
    const initialAgentSecret = options.newAccountProps?.secret ?? crypto.agentSecretFromSecretSeed(secretSeed);
    const creationProps = options.newAccountProps?.creationProps ?? {
      name: options.defaultProfileName ?? "Anonymous user"
    };
    context = await createJazzContextForNewAccount({
      creationProps,
      initialAgentSecret,
      peersToLoadFrom: options.peersToLoadFrom,
      crypto,
      AccountSchema: options.AccountSchema,
      onLogOut: async () => {
        await authSecretStorage.clearWithoutNotify();
      }
    });
    if (!options.newAccountProps) {
      await authSecretStorage.setWithoutNotify({
        accountID: context.account.id,
        secretSeed,
        accountSecret: context.node.account.agentSecret,
        provider: "anonymous"
      });
    }
  }
  return {
    ...context,
    authSecretStorage
  };
}
async function createAnonymousJazzContext({
  peersToLoadFrom,
  crypto
}) {
  const agentSecret = crypto.newRandomAgentSecret();
  const rawAgent = new ControlledAgent(agentSecret, crypto);
  const node = new LocalNode(
    rawAgent,
    crypto.newRandomSessionID(rawAgent.id),
    crypto
  );
  for (const peer of peersToLoadFrom) {
    node.syncManager.addPeer(peer);
  }
  activeAccountContext.setGuestMode();
  return {
    agent: new AnonymousJazzAgent(node),
    done: () => {
    },
    logOut: async () => {
    }
  };
}

// src/implementation/devtoolsFormatters.ts
globalThis.devtoolsFormatters = [
  {
    header: (object) => {
      if (object._type === "CoMap") {
        return ["div", {}, ["span", {}, object.constructor.name]];
      } else if (object._type === "CoList") {
        return [
          "div",
          {},
          ["span", {}, object.constructor.name + "(" + object.length + ") "]
        ];
      } else if (object._type === "Account") {
        return [
          "div",
          {},
          [
            "span",
            {},
            object.constructor.name + "(" + object._refs.profile.value?.name + (object.isMe ? " ME" : "") + ")"
          ]
        ];
      } else {
        return null;
      }
    },
    hasBody: function() {
      return true;
    },
    body: function(object) {
      if (object._type === "CoMap" || object._type === "Account") {
        return [
          "div",
          { style: "margin-left: 15px" },
          ["div", "id: ", ["object", { object: object.id }]],
          ...Object.entries(object).map(([k, v]) => [
            "div",
            { style: "white-space: nowrap;" },
            ["span", { style: "font-weight: bold; opacity: 0.6" }, k, ": "],
            ["object", { object: v }],
            ...typeof object._schema[k] === "function" ? v === null ? [
              [
                "span",
                { style: "opacity: 0.5" },
                ` (pending ${object._schema[k].name} `,
                ["object", { object: object._refs[k] }],
                ")"
              ]
            ] : [] : []
          ])
        ];
      } else if (object._type === "CoList") {
        return [
          "div",
          { style: "margin-left: 15px" },
          ["div", "id: ", ["object", { object: object.id }]],
          ...object.map((v, i) => [
            "div",
            { style: "white-space: nowrap;" },
            ["span", { style: "font-weight: bold; opacity: 0.6" }, i, ": "],
            ["object", { object: v }],
            ...typeof object._schema[ItemsSym] === "function" ? v === null ? [
              [
                "span",
                { style: "opacity: 0.5" },
                ` (pending ${object._schema[ItemsSym].name} `,
                ["object", { object: object._refs[i] }],
                ")"
              ]
            ] : [] : []
          ])
        ];
      }
    }
  }
];

// src/coValues/interfaces.ts
function isCoValueClass(value) {
  return typeof value === "function" && value.fromRaw !== void 0;
}
var CoValueBase = class {
  get _owner() {
    const owner = this._raw.group instanceof RawAccount3 ? RegisteredSchemas["Account"].fromRaw(this._raw.group) : RegisteredSchemas["Group"].fromRaw(this._raw.group);
    const subScope = subscriptionsScopes.get(this);
    if (subScope) {
      subScope.onRefAccessedOrSet(this.id, owner.id);
      subscriptionsScopes.set(owner, subScope);
    }
    return owner;
  }
  /** @private */
  get _loadedAs() {
    const rawAccount = this._raw.core.node.account;
    if (rawAccount instanceof RawAccount3) {
      return coValuesCache.get(
        rawAccount,
        () => RegisteredSchemas["Account"].fromRaw(rawAccount)
      );
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(..._args) {
    Object.defineProperty(this, "_instanceID", {
      value: `instance-${Math.random().toString(36).slice(2)}`,
      enumerable: false
    });
  }
  /** @category Internals */
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    return {
      id: this.id,
      type: this._type,
      error: "unknown CoValue class"
    };
  }
  [inspect]() {
    return this.toJSON();
  }
  /** @category Type Helpers */
  castAs(cl) {
    const casted = cl.fromRaw(this._raw);
    const subscriptionScope = subscriptionsScopes.get(this);
    if (subscriptionScope) {
      subscriptionsScopes.set(casted, subscriptionScope);
    }
    return casted;
  }
};
function loadCoValueWithoutMe(cls, id, options) {
  return loadCoValue2(cls, id, {
    ...options,
    loadAs: options?.loadAs ?? activeAccountContext.get()
  });
}
function loadCoValue2(cls, id, options) {
  return new Promise((resolve) => {
    subscribeToCoValue(
      cls,
      id,
      {
        resolve: options.resolve,
        loadAs: options.loadAs,
        onUnavailable: () => {
          resolve(null);
        },
        onUnauthorized: () => {
          resolve(null);
        }
      },
      (value, unsubscribe) => {
        resolve(value);
        unsubscribe();
      }
    );
  });
}
async function ensureCoValueLoaded(existing, options) {
  const response = await loadCoValue2(
    existing.constructor,
    existing.id,
    {
      loadAs: existing._loadedAs,
      resolve: options?.resolve
    }
  );
  if (!response) {
    throw new Error("Failed to deeply load CoValue " + existing.id);
  }
  return response;
}
function parseSubscribeRestArgs(args) {
  if (args.length === 2) {
    if (typeof args[0] === "object" && args[0] && typeof args[1] === "function") {
      return {
        options: {
          resolve: args[0].resolve,
          loadAs: args[0].loadAs,
          onUnauthorized: args[0].onUnauthorized,
          onUnavailable: args[0].onUnavailable
        },
        listener: args[1]
      };
    } else {
      throw new Error("Invalid arguments");
    }
  } else {
    if (typeof args[0] === "function") {
      return { options: {}, listener: args[0] };
    } else {
      throw new Error("Invalid arguments");
    }
  }
}
function subscribeToCoValueWithoutMe(cls, id, options, listener) {
  return subscribeToCoValue(
    cls,
    id,
    {
      ...options,
      loadAs: options.loadAs ?? activeAccountContext.get()
    },
    listener
  );
}
function subscribeToCoValue(cls, id, options, listener) {
  const ref2 = new Ref(id, options.loadAs, { ref: cls, optional: false });
  let unsubscribed = false;
  let unsubscribe;
  function subscribe() {
    const value = ref2.getValueWithoutAccessCheck();
    if (!value) {
      options.onUnavailable?.();
      return;
    }
    if (unsubscribed) return;
    const subscription = new SubscriptionScope(
      value,
      cls,
      (update, subscription2) => {
        if (subscription2.syncResolution) return;
        if (!ref2.hasReadAccess()) {
          console.error(
            "Not enough permissions to load / subscribe to CoValue",
            id
          );
          options.onUnauthorized?.([]);
          return;
        }
        let result;
        try {
          subscription2.syncResolution = true;
          result = fulfillsDepth(options.resolve, update);
        } catch (e) {
          console.error(
            "Failed to load / subscribe to CoValue",
            e,
            e instanceof Error ? e.stack : void 0
          );
          options.onUnavailable?.();
          return;
        } finally {
          subscription2.syncResolution = false;
        }
        if (result.status === "unauthorized") {
          console.error(
            "Not enough permissions to load / subscribe to CoValue",
            id,
            "on path",
            result.path.join("."),
            "unaccessible value:",
            result.id
          );
          options.onUnauthorized?.(result.path);
          return;
        }
        if (result.status === "fulfilled") {
          listener(update, subscription2.unsubscribeAll);
        }
      }
    );
    unsubscribe = subscription.unsubscribeAll;
  }
  const sync = options.syncResolution ? ref2.syncLoad() : void 0;
  if (sync) {
    subscribe();
  } else {
    ref2.load().then(() => subscribe()).catch((e) => {
      console.error(
        "Failed to load / subscribe to CoValue",
        e,
        e instanceof Error ? e.stack : void 0
      );
      options.onUnavailable?.();
    });
  }
  return function unsubscribeAtAnyPoint() {
    unsubscribed = true;
    unsubscribe && unsubscribe();
  };
}
function createCoValueObservable(initialValue = void 0) {
  let currentValue = initialValue;
  let subscriberCount = 0;
  function subscribe(cls, id, options, listener) {
    subscriberCount++;
    const unsubscribe = subscribeToCoValue(
      cls,
      id,
      {
        loadAs: options.loadAs,
        resolve: options.resolve,
        onUnavailable: () => {
          currentValue = null;
          options.onUnavailable?.();
        },
        onUnauthorized: () => {
          currentValue = null;
          options.onUnauthorized?.();
        },
        syncResolution: options.syncResolution
      },
      (value) => {
        currentValue = value;
        listener();
      }
    );
    return () => {
      unsubscribe();
      subscriberCount--;
      if (subscriberCount === 0) {
        currentValue = void 0;
      }
    };
  }
  const observable = {
    getCurrentValue: () => currentValue,
    subscribe
  };
  return observable;
}
function subscribeToExistingCoValue(existing, options, listener) {
  return subscribeToCoValue(
    existing.constructor,
    existing.id,
    {
      loadAs: existing._loadedAs,
      resolve: options?.resolve,
      onUnavailable: options?.onUnavailable,
      onUnauthorized: options?.onUnauthorized
    },
    listener
  );
}
function isAccountInstance(instance) {
  if (typeof instance !== "object" || instance === null) {
    return false;
  }
  return "_type" in instance && instance._type === "Account";
}
function parseCoValueCreateOptions(options) {
  const Group2 = RegisteredSchemas["Group"];
  if (!options) {
    return { owner: Group2.create(), uniqueness: void 0 };
  }
  if ("_type" in options) {
    if (options._type === "Account" || options._type === "Group") {
      return { owner: options, uniqueness: void 0 };
    }
  }
  const uniqueness = options.unique ? { uniqueness: options.unique } : void 0;
  return {
    owner: options.owner ?? Group2.create(),
    uniqueness
  };
}
function parseGroupCreateOptions(options) {
  if (!options) {
    return { owner: activeAccountContext.get() };
  }
  return "_type" in options && isAccountInstance(options) ? { owner: options } : { owner: options.owner ?? activeAccountContext.get() };
}

// src/coValues/inbox.ts
import {
  RawAccount as RawAccount4
} from "cojson";
function createInboxRoot(account) {
  if (!account.isLocalNodeOwner) {
    throw new Error("Account is not controlled");
  }
  const rawAccount = account._raw;
  const group = rawAccount.createGroup();
  const messagesFeed = group.createStream();
  const inboxRoot = rawAccount.createMap();
  const processedFeed = rawAccount.createStream();
  const failedFeed = rawAccount.createStream();
  const inviteLink = `${messagesFeed.id}/${group.createInvite("writeOnly")}`;
  inboxRoot.set("messages", messagesFeed.id);
  inboxRoot.set("processed", processedFeed.id);
  inboxRoot.set("failed", failedFeed.id);
  return {
    id: inboxRoot.id,
    inviteLink
  };
}
async function createInboxMessage(payload, inboxOwner) {
  const group = payload._raw.group;
  if (group instanceof RawAccount4) {
    throw new Error("Inbox messages should be owned by a group");
  }
  group.addMember(inboxOwner, "writer");
  const message = group.createMap({
    payload: payload.id,
    result: void 0,
    processed: false,
    error: void 0
  });
  await payload._raw.core.waitForSync();
  await message.core.waitForSync();
  return message;
}
var Inbox = class _Inbox {
  constructor(account, root, messages, processed, failed) {
    this.processing = /* @__PURE__ */ new Set();
    this.account = account;
    this.root = root;
    this.messages = messages;
    this.processed = processed;
    this.failed = failed;
  }
  subscribe(Schema, callback, options = {}) {
    const processed = /* @__PURE__ */ new Set();
    const failed = /* @__PURE__ */ new Map();
    const node = this.account._raw.core.node;
    this.processed.subscribe((stream) => {
      for (const items of Object.values(stream.items)) {
        for (const item of items) {
          processed.add(item.value);
        }
      }
    });
    const { account } = this;
    const { retries = 3 } = options;
    let failTimer = void 0;
    const clearFailTimer = () => {
      clearTimeout(failTimer);
      failTimer = void 0;
    };
    const handleNewMessages = (stream) => {
      clearFailTimer();
      for (const [sessionID, items] of Object.entries(stream.items)) {
        const accountID = getAccountIDfromSessionID(sessionID);
        if (!accountID) {
          console.warn("Received message from unknown account", sessionID);
          continue;
        }
        for (const item of items) {
          const txKey = `${sessionID}/${item.tx.txIndex}`;
          if (!processed.has(txKey) && !this.processing.has(txKey)) {
            this.processing.add(txKey);
            const id = item.value;
            node.load(id).then((message) => {
              if (message === "unavailable") {
                return Promise.reject(
                  new Error("Unable to load inbox message " + id)
                );
              }
              return loadCoValue2(Schema, message.get("payload"), {
                loadAs: account
              });
            }).then((value) => {
              if (!value) {
                return Promise.reject(
                  new Error("Unable to load inbox message " + id)
                );
              }
              return callback(value, accountID);
            }).then((result) => {
              const inboxMessage = node.expectCoValueLoaded(item.value).getCurrentContent();
              if (result) {
                inboxMessage.set("result", result.id);
              }
              inboxMessage.set("processed", true);
              this.processed.push(txKey);
              this.processing.delete(txKey);
            }).catch((error) => {
              console.error("Error processing inbox message", error);
              this.processing.delete(txKey);
              const errors = failed.get(txKey) ?? [];
              const stringifiedError = String(error);
              errors.push(stringifiedError);
              let inboxMessage;
              try {
                inboxMessage = node.expectCoValueLoaded(item.value).getCurrentContent();
                inboxMessage.set("error", stringifiedError);
              } catch (error2) {
              }
              if (errors.length > retries) {
                inboxMessage?.set("processed", true);
                this.processed.push(txKey);
                this.failed.push({ errors, value: item.value });
              } else {
                failed.set(txKey, errors);
                if (!failTimer) {
                  failTimer = setTimeout(
                    () => handleNewMessages(stream),
                    100
                  );
                }
              }
            });
          }
        }
      }
    };
    const unsubscribe = this.messages.subscribe(handleNewMessages);
    return () => {
      unsubscribe();
      clearFailTimer();
    };
  }
  static async load(account) {
    const profile = account.profile;
    if (!profile) {
      throw new Error("Account profile should already be loaded");
    }
    if (!profile.inbox) {
      throw new Error("The account has not set up their inbox");
    }
    const node = account._raw.core.node;
    const root = await node.load(profile.inbox);
    if (root === "unavailable") {
      throw new Error("Inbox not found");
    }
    const [messages, processed, failed] = await Promise.all([
      node.load(root.get("messages")),
      node.load(root.get("processed")),
      node.load(root.get("failed"))
    ]);
    if (messages === "unavailable" || processed === "unavailable" || failed === "unavailable") {
      throw new Error("Inbox not found");
    }
    return new _Inbox(account, root, messages, processed, failed);
  }
};
var InboxSender = class _InboxSender {
  constructor(currentAccount, owner, messages) {
    this.currentAccount = currentAccount;
    this.owner = owner;
    this.messages = messages;
  }
  getOwnerAccount() {
    return this.owner;
  }
  async sendMessage(message) {
    const inboxMessage = await createInboxMessage(message, this.owner);
    this.messages.push(inboxMessage.id);
    return new Promise((resolve, reject) => {
      inboxMessage.subscribe((message2) => {
        if (message2.get("processed")) {
          const error = message2.get("error");
          if (error) {
            reject(new Error(error));
          } else {
            resolve(
              message2.get("result")
            );
          }
        }
      });
    });
  }
  static async load(inboxOwnerID, currentAccount) {
    currentAccount ||= activeAccountContext.get();
    const node = currentAccount._raw.core.node;
    const inboxOwnerRaw = await node.load(
      inboxOwnerID
    );
    if (inboxOwnerRaw === "unavailable") {
      throw new Error("Failed to load the inbox owner");
    }
    const inboxOwnerProfileRaw = await node.load(inboxOwnerRaw.get("profile"));
    if (inboxOwnerProfileRaw === "unavailable") {
      throw new Error("Failed to load the inbox owner profile");
    }
    if (inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "reader" && inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "writer" && inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "admin") {
      throw new Error(
        "Insufficient permissions to access the inbox, make sure its user profile is publicly readable."
      );
    }
    const inboxInvite = inboxOwnerProfileRaw.get("inboxInvite");
    if (!inboxInvite) {
      throw new Error("The user has not set up their inbox");
    }
    const id = await acceptInvite(inboxInvite, currentAccount);
    const messages = await node.load(id);
    if (messages === "unavailable") {
      throw new Error("Inbox not found");
    }
    return new _InboxSender(currentAccount, inboxOwnerRaw, messages);
  }
};
async function acceptInvite(invite, account) {
  account ||= activeAccountContext.get();
  const id = invite.slice(0, invite.indexOf("/"));
  const inviteSecret = invite.slice(invite.indexOf("/") + 1);
  if (!id?.startsWith("co_z") || !inviteSecret.startsWith("inviteSecret_")) {
    throw new Error("Invalid inbox ticket");
  }
  if (!account.isLocalNodeOwner) {
    throw new Error("Account is not controlled");
  }
  await account._raw.acceptInvite(id, inviteSecret);
  return id;
}
function getAccountIDfromSessionID(sessionID) {
  const until = sessionID.indexOf("_session");
  const accountID = sessionID.slice(0, until);
  if (accountID.startsWith("co_z")) {
    return accountID;
  }
  return;
}

// src/coValues/coMap.ts
import {
  cojsonInternals
} from "cojson";
var _CoMap = class _CoMap extends CoValueBase {
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /**
   * If property `prop` is a `co.ref(...)`, you can use `coMaps._refs.prop` to access
   * the `Ref` instead of the potentially loaded/null value.
   *
   * This allows you to always get the ID or load the value manually.
   *
   * @example
   * ```ts
   * person._refs.pet.id; // => ID<Animal>
   * person._refs.pet.value;
   * // => Animal | null
   * const pet = await person._refs.pet.load();
   * ```
   *
   * @category Content
   **/
  get _refs() {
    return makeRefs(
      (key) => this._raw.get(key),
      () => {
        const keys = this._raw.keys().filter((key) => {
          const schema = this._schema[key] || this._schema[ItemsSym];
          return schema && schema !== "json" && isRefEncoded(schema);
        });
        return keys;
      },
      this._loadedAs,
      (key) => this._schema[key] || this._schema[ItemsSym]
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    );
  }
  /** @internal */
  getEditFromRaw(target, rawEdit, descriptor, key) {
    return {
      value: descriptor === "json" ? rawEdit.value : "encoded" in descriptor ? rawEdit.value === null || rawEdit.value === void 0 ? rawEdit.value : descriptor.encoded.decode(rawEdit.value) : new Ref(
        rawEdit.value,
        target._loadedAs,
        descriptor
      ).accessFrom(target, "_edits." + key + ".value"),
      ref: descriptor !== "json" && isRefEncoded(descriptor) ? new Ref(rawEdit.value, target._loadedAs, descriptor) : void 0,
      by: rawEdit.by && new Ref(rawEdit.by, target._loadedAs, {
        ref: RegisteredSchemas["Account"],
        optional: false
      }).accessFrom(target, "_edits." + key + ".by"),
      madeAt: rawEdit.at,
      key
    };
  }
  /** @category Collaboration */
  get _edits() {
    const map = this;
    return new Proxy(
      {},
      {
        get(_target, key) {
          const rawEdit = map._raw.lastEditAt(key);
          if (!rawEdit) return void 0;
          const descriptor = map._schema[key];
          return {
            ...map.getEditFromRaw(map, rawEdit, descriptor, key),
            get all() {
              return [...map._raw.editsAt(key)].map(
                (rawEdit2) => map.getEditFromRaw(map, rawEdit2, descriptor, key)
              );
            }
          };
        },
        ownKeys(_target) {
          return map._raw.keys();
        },
        getOwnPropertyDescriptor(target, key) {
          return {
            value: Reflect.get(target, key),
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    );
  }
  /** @internal */
  constructor(options) {
    super();
    if (options) {
      if ("fromRaw" in options) {
        Object.defineProperties(this, {
          id: {
            value: options.fromRaw.id,
            enumerable: false
          },
          _raw: { value: options.fromRaw, enumerable: false }
        });
      } else {
        throw new Error("Invalid CoMap constructor arguments");
      }
    }
    return new Proxy(this, CoMapProxyHandler);
  }
  /**
   * Create a new CoMap with the given initial values and owner.
   *
   * The owner (a Group or Account) determines access rights to the CoMap.
   *
   * The CoMap will immediately be persisted and synced to connected peers.
   *
   * @example
   * ```ts
   * const person = Person.create({
   *   name: "Alice",
   *   age: 42,
   *   pet: cat,
   * }, { owner: friendGroup });
   * ```
   *
   * @category Creation
   **/
  static create(init, options) {
    const instance = new this();
    const { owner, uniqueness } = parseCoValueCreateOptions(options);
    const raw = instance.rawFromInit(init, owner, uniqueness);
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return instance;
  }
  /**
   * Return a JSON representation of the `CoMap`
   * @category Content
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON(_key, processedValues) {
    const result = {
      id: this.id,
      _type: this._type
    };
    for (const key of this._raw.keys()) {
      const tKey = key;
      const descriptor = this._schema[tKey] || this._schema[ItemsSym];
      if (!descriptor) {
        continue;
      }
      if (descriptor == "json" || "encoded" in descriptor) {
        result[key] = this._raw.get(key);
      } else if (isRefEncoded(descriptor)) {
        const id = this._raw.get(key);
        if (processedValues?.includes(id) || id === this.id) {
          result[key] = { _circular: id };
          continue;
        }
        const ref2 = this[tKey];
        if (ref2 && typeof ref2 === "object" && "toJSON" in ref2 && typeof ref2.toJSON === "function") {
          const jsonedRef = ref2.toJSON(tKey, [
            ...processedValues || [],
            this.id
          ]);
          result[key] = jsonedRef;
        }
      } else {
        result[key] = void 0;
      }
    }
    return result;
  }
  [inspect]() {
    return this.toJSON();
  }
  /**
   * Create a new `RawCoMap` from an initialization object
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  rawFromInit(init, owner, uniqueness) {
    const rawOwner = owner._raw;
    const rawInit = {};
    if (init)
      for (const key of Object.keys(init)) {
        const initValue = init[key];
        const descriptor = this._schema[key] || this._schema[ItemsSym];
        if (!descriptor) {
          continue;
        }
        if (descriptor === "json") {
          rawInit[key] = initValue;
        } else if (isRefEncoded(descriptor)) {
          if (initValue) {
            rawInit[key] = initValue.id;
          }
        } else if ("encoded" in descriptor) {
          rawInit[key] = descriptor.encoded.encode(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            initValue
          );
        }
      }
    return rawOwner.createMap(rawInit, null, "private", uniqueness);
  }
  /**
   * Declare a Record-like CoMap schema, by extending `CoMap.Record(...)` and passing the value schema using `co`. Keys are always `string`.
   *
   * @example
   * ```ts
   * import { co, CoMap } from "jazz-tools";
   *
   * class ColorToFruitMap extends CoMap.Record(
   *  co.ref(Fruit)
   * ) {}
   *
   * // assume we have map: ColorToFruitMap
   * // and strawberry: Fruit
   * map["red"] = strawberry;
   * ```
   *
   * @category Declaration
   */
  static Record(value) {
    var _a2, _b2;
    class RecordLikeCoMap extends (_b2 = _CoMap, _a2 = ItemsSym, _b2) {
      constructor() {
        super(...arguments);
        this[_a2] = value;
      }
    }
    return RecordLikeCoMap;
  }
  /**
   * Load a `CoMap` with a given ID, as a given account.
   *
   * `depth` specifies which (if any) fields that reference other CoValues to load as well before resolving.
   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.
   *
   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.
   *
   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.
   *
   * @example
   * ```ts
   * const person = await Person.load(
   *   "co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax",
   *   { pet: {} }
   * );
   * ```
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  static findUnique(unique, ownerID, as) {
    as ||= activeAccountContext.get();
    const header = {
      type: "comap",
      ruleset: {
        type: "ownedByGroup",
        group: ownerID
      },
      meta: null,
      uniqueness: unique
    };
    const crypto = as._type === "Anonymous" ? as.node.crypto : as._raw.core.crypto;
    return cojsonInternals.idforHeader(header, crypto);
  }
  /**
   * Given an already loaded `CoMap`, ensure that the specified fields are loaded to the specified depth.
   *
   * Works like `CoMap.load()`, but you don't need to pass the ID or the account to load as again.
   *
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  applyDiff(newValues) {
    for (const key in newValues) {
      if (Object.prototype.hasOwnProperty.call(newValues, key)) {
        const tKey = key;
        const descriptor = this._schema[tKey] || this._schema[ItemsSym];
        if (tKey in this._schema) {
          const newValue = newValues[tKey];
          const currentValue = this[tKey];
          if (descriptor === "json" || "encoded" in descriptor) {
            if (currentValue !== newValue) {
              this[tKey] = newValue;
            }
          } else if (isRefEncoded(descriptor)) {
            const currentId = currentValue?.id;
            const newId = newValue?.id;
            if (currentId !== newId) {
              this[tKey] = newValue;
            }
          }
        }
      }
    }
    return this;
  }
  /**
   * Wait for the `CoMap` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoMap.prototype._type = "CoMap";
var CoMap = _CoMap;
var CoMapProxyHandler = {
  get(target, key, receiver) {
    if (key === "_schema") {
      return Reflect.get(target, key);
    } else if (key in target) {
      return Reflect.get(target, key, receiver);
    } else {
      const schema = target._schema;
      if (!schema) {
        return void 0;
      }
      const descriptor = schema[key] || schema[ItemsSym];
      if (descriptor && typeof key === "string") {
        const raw = target._raw.get(key);
        if (descriptor === "json") {
          return raw;
        } else if ("encoded" in descriptor) {
          return raw === void 0 ? void 0 : descriptor.encoded.decode(raw);
        } else if (isRefEncoded(descriptor)) {
          return raw === void 0 ? void 0 : new Ref(
            raw,
            target._loadedAs,
            descriptor
          ).accessFrom(receiver, key);
        }
      } else {
        return void 0;
      }
    }
  },
  set(target, key, value, receiver) {
    if ((typeof key === "string" || ItemsSym) && typeof value === "object" && value !== null && SchemaInit in value) {
      target.constructor._schema ||= {};
      target.constructor._schema[key] = value[SchemaInit];
      return true;
    }
    const descriptor = target._schema[key] || target._schema[ItemsSym];
    if (descriptor && typeof key === "string") {
      if (descriptor === "json") {
        target._raw.set(key, value);
      } else if ("encoded" in descriptor) {
        target._raw.set(key, descriptor.encoded.encode(value));
      } else if (isRefEncoded(descriptor)) {
        if (value === null) {
          if (descriptor.optional) {
            target._raw.set(key, null);
          } else {
            throw new Error(`Cannot set required reference ${key} to null`);
          }
        } else if (value?.id) {
          target._raw.set(key, value.id);
          subscriptionsScopes.get(target)?.onRefAccessedOrSet(target.id, value.id);
        } else {
          throw new Error(
            `Cannot set reference ${key} to a non-CoValue. Got ${value}`
          );
        }
      }
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, attributes) {
    if ("value" in attributes && typeof attributes.value === "object" && SchemaInit in attributes.value) {
      target.constructor._schema ||= {};
      target.constructor._schema[key] = attributes.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, attributes);
    }
  },
  ownKeys(target) {
    const keys = Reflect.ownKeys(target).filter((k) => k !== ItemsSym);
    for (const key of target._raw.keys()) {
      if (!keys.includes(key)) {
        keys.push(key);
      }
    }
    return keys;
  },
  getOwnPropertyDescriptor(target, key) {
    if (key in target) {
      return Reflect.getOwnPropertyDescriptor(target, key);
    } else {
      const descriptor = target._schema[key] || target._schema[ItemsSym];
      if (descriptor || key in target._raw.latest) {
        return {
          enumerable: true,
          configurable: true,
          writable: true
        };
      }
    }
  },
  has(target, key) {
    const descriptor = target._schema?.[key] || target._schema?.[ItemsSym];
    if (target._raw && typeof key === "string" && descriptor) {
      return target._raw.get(key) !== void 0;
    } else {
      return Reflect.has(target, key);
    }
  },
  deleteProperty(target, key) {
    const descriptor = target._schema[key] || target._schema[ItemsSym];
    if (typeof key === "string" && descriptor) {
      target._raw.delete(key);
      return true;
    } else {
      return Reflect.deleteProperty(target, key);
    }
  }
};
RegisteredSchemas["CoMap"] = CoMap;

// src/coValues/profile.ts
var Profile = class extends CoMap {
  constructor() {
    super(...arguments);
    this.name = co.string;
    this.inbox = co.optional.json();
    this.inboxInvite = co.optional.json();
  }
  get _owner() {
    return super._owner;
  }
  /**
   * Creates a new profile with the given initial values and owner.
   *
   * The owner (a Group) determines access rights to the Profile.
   *
   * @category Creation
   */
  static create(init, options) {
    const owner = options !== void 0 && "owner" in options ? options.owner : options;
    if (owner?._type === "Account") {
      throw new Error("Profiles should be owned by a group");
    }
    return super.create(init, options);
  }
};

// src/coValues/account.ts
import {
  LocalNode as LocalNode2,
  RawAccount as RawAccount5,
  cojsonInternals as cojsonInternals2
} from "cojson";
var _Account = class _Account extends CoValueBase {
  get _schema() {
    return this.constructor._schema;
  }
  get _owner() {
    return this;
  }
  get _loadedAs() {
    if (this.isLocalNodeOwner) return this;
    const rawAccount = this._raw.core.node.account;
    if (rawAccount instanceof RawAccount5) {
      return coValuesCache.get(rawAccount, () => _Account.fromRaw(rawAccount));
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  get _refs() {
    const profileID = this._raw.get("profile");
    const rootID = this._raw.get("root");
    return {
      profile: profileID && new Ref(
        profileID,
        this._loadedAs,
        this._schema.profile
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ),
      root: rootID && new Ref(
        rootID,
        this._loadedAs,
        this._schema.root
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      )
    };
  }
  /**
   * Whether this account is the currently active account.
   */
  get isMe() {
    return activeAccountContext.get().id === this.id;
  }
  constructor(options) {
    super();
    if (!("fromRaw" in options)) {
      throw new Error("Can only construct account from raw or with .create()");
    }
    this.isLocalNodeOwner = options.fromRaw.id == options.fromRaw.core.node.account.id;
    Object.defineProperties(this, {
      id: {
        value: options.fromRaw.id,
        enumerable: false
      },
      _raw: { value: options.fromRaw, enumerable: false },
      _type: { value: "Account", enumerable: false }
    });
    if (this.isLocalNodeOwner) {
      this.sessionID = options.fromRaw.core.node.currentSessionID;
    }
    return new Proxy(this, AccountAndGroupProxyHandler);
  }
  myRole() {
    if (this.isLocalNodeOwner) {
      return "admin";
    }
  }
  getRoleOf(member) {
    if (member === "me") {
      return this.isMe ? "admin" : void 0;
    }
    if (member === this.id) {
      return "admin";
    }
    return void 0;
  }
  getParentGroups() {
    return [];
  }
  get members() {
    const ref2 = new Ref(this.id, this._loadedAs, {
      ref: () => this.constructor,
      optional: false
    });
    return [{ id: this.id, role: "admin", ref: ref2, account: this }];
  }
  canRead(value) {
    const role = value._owner.getRoleOf(this.id);
    return role === "admin" || role === "writer" || role === "reader" || role === "writeOnly";
  }
  canWrite(value) {
    const role = value._owner.getRoleOf(this.id);
    return role === "admin" || role === "writer" || role === "writeOnly";
  }
  canAdmin(value) {
    return value._owner.getRoleOf(this.id) === "admin";
  }
  async acceptInvite(valueID, inviteSecret, coValueClass) {
    if (!this.isLocalNodeOwner) {
      throw new Error("Only a controlled account can accept invites");
    }
    await this._raw.acceptInvite(
      valueID,
      inviteSecret
    );
    return loadCoValue2(coValueClass, valueID, {
      loadAs: this
    });
  }
  /** @private */
  static async create(options) {
    const { node } = await LocalNode2.withNewlyCreatedAccount({
      ...options,
      migration: async (rawAccount, _node, creationProps) => {
        const account = new this({
          fromRaw: rawAccount
        });
        await account.applyMigration?.(creationProps);
      }
    });
    return this.fromNode(node);
  }
  static getMe() {
    return activeAccountContext.get();
  }
  static async createAs(as, options) {
    const connectedPeers = cojsonInternals2.connectedPeers(
      "creatingAccount",
      "createdAccount",
      { peer1role: "server", peer2role: "client" }
    );
    as._raw.core.node.syncManager.addPeer(connectedPeers[1]);
    const account = await this.create({
      creationProps: options.creationProps,
      crypto: as._raw.core.node.crypto,
      peersToLoadFrom: [connectedPeers[0]]
    });
    await account.waitForAllCoValuesSync();
    return account;
  }
  static fromNode(node) {
    return new this({
      fromRaw: node.account
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    return {
      id: this.id,
      _type: this._type
    };
  }
  [inspect]() {
    return this.toJSON();
  }
  async applyMigration(creationProps) {
    await this.migrate(creationProps);
    if (this.profile === void 0 && creationProps) {
      const profileGroup = RegisteredSchemas["Group"].create({ owner: this });
      this.profile = Profile.create({ name: creationProps.name }, profileGroup);
      this.profile._owner.addMember("everyone", "reader");
    } else if (this.profile && creationProps) {
      if (this.profile._owner._type !== "Group") {
        throw new Error("Profile must be owned by a Group", {
          cause: `The profile of the account "${this.id}" was created with an Account as owner, which is not allowed.`
        });
      }
    }
    const node = this._raw.core.node;
    const profile = node.expectCoValueLoaded(this._raw.get("profile")).getCurrentContent();
    if (!profile.get("inbox")) {
      const inboxRoot = createInboxRoot(this);
      profile.set("inbox", inboxRoot.id);
      profile.set("inboxInvite", inboxRoot.inviteLink);
    }
  }
  // Placeholder method for subclasses to override
  migrate(creationProps) {
    creationProps;
  }
  /** @category Subscription & Loading */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /** @category Subscription & Loading */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `Account` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
  /**
   * Wait for all the available `CoValues` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForAllCoValuesSync(options) {
    return this._raw.core.node.syncManager.waitForAllCoValuesSync(
      options?.timeout
    );
  }
};
_Account._schema = {
  profile: {
    ref: () => Profile,
    optional: false
  },
  root: {
    ref: () => RegisteredSchemas["CoMap"],
    optional: true
  }
};
var Account = _Account;
var AccountAndGroupProxyHandler = {
  get(target, key, receiver) {
    if (key === "profile") {
      const ref2 = target._refs.profile;
      return ref2 ? ref2.accessFrom(receiver, "profile") : (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        void 0
      );
    } else if (key === "root") {
      const ref2 = target._refs.root;
      return ref2 ? ref2.accessFrom(receiver, "root") : void 0;
    } else {
      return Reflect.get(target, key, receiver);
    }
  },
  set(target, key, value, receiver) {
    if ((key === "profile" || key === "root") && typeof value === "object" && SchemaInit in value) {
      target.constructor._schema ||= {};
      target.constructor._schema[key] = value[SchemaInit];
      return true;
    } else if (key === "profile") {
      if (value) {
        target._raw.set(
          "profile",
          value.id,
          "trusting"
        );
      }
      subscriptionsScopes.get(receiver)?.onRefAccessedOrSet(target.id, value.id);
      return true;
    } else if (key === "root") {
      if (value) {
        target._raw.set("root", value.id);
      }
      subscriptionsScopes.get(receiver)?.onRefAccessedOrSet(target.id, value.id);
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, descriptor) {
    if ((key === "profile" || key === "root") && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
      target.constructor._schema ||= {};
      target.constructor._schema[key] = descriptor.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, descriptor);
    }
  }
};
function isControlledAccount(account) {
  return account.isLocalNodeOwner;
}
RegisteredSchemas["Account"] = Account;

// src/coValues/coFeed.ts
import { MAX_RECOMMENDED_TX_SIZE, cojsonInternals as cojsonInternals3 } from "cojson";
var _CoFeed = class _CoFeed extends CoValueBase {
  /**
   * Declare a `CoFeed` by subclassing `CoFeed.Of(...)` and passing the item schema using a `co` primitive or a `co.ref`.
   *
   * @example
   * ```ts
   * class ColorFeed extends CoFeed.Of(co.string) {}
   * class AnimalFeed extends CoFeed.Of(co.ref(Animal)) {}
   * ```
   *
   * @category Declaration
   */
  static Of(item) {
    var _a2, _b2;
    return class CoFeedOf extends (_b2 = _CoFeed, _a2 = co.items, _b2) {
      constructor() {
        super(...arguments);
        this[_a2] = item;
      }
    };
  }
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /**
   * The current account's view of this `CoFeed`
   * @category Content
   */
  get byMe() {
    if (this._loadedAs._type === "Account") {
      return this[this._loadedAs.id];
    } else {
      return void 0;
    }
  }
  /**
   * The current session's view of this `CoFeed`
   *
   * This is a shortcut for `this.perSession` where the session ID is the current session ID.
   *
   * @category Content
   */
  get inCurrentSession() {
    if (this._loadedAs._type === "Account") {
      return this.perSession[this._loadedAs.sessionID];
    } else {
      return void 0;
    }
  }
  constructor(options) {
    super();
    if (options && "fromRaw" in options) {
      Object.defineProperties(this, {
        id: {
          value: options.fromRaw.id,
          enumerable: false
        },
        _raw: { value: options.fromRaw, enumerable: false }
      });
    }
    return new Proxy(this, CoStreamProxyHandler);
  }
  /**
   * Create a new `CoFeed`
   * @category Creation
   */
  static create(init, options) {
    const { owner } = parseCoValueCreateOptions(options);
    const instance = new this({ init, owner });
    const raw = owner._raw.createStream();
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    if (init) {
      instance.push(...init);
    }
    return instance;
  }
  /**
   * Push items to this `CoFeed`
   *
   * Items are appended to the current session's log. Each session (tab, device, app instance)
   * maintains its own append-only log, which is then aggregated into the per-account view.
   *
   * @example
   * ```ts
   * // Adds items to current session's log
   * feed.push("item1", "item2");
   *
   * // View items from current session
   * console.log(feed.inCurrentSession);
   *
   * // View aggregated items from all sessions for current account
   * console.log(feed.byMe);
   * ```
   *
   * @category Content
   */
  push(...items) {
    for (const item of items) {
      this.pushItem(item);
    }
  }
  pushItem(item) {
    const itemDescriptor = this._schema[ItemsSym];
    if (itemDescriptor === "json") {
      this._raw.push(item);
    } else if ("encoded" in itemDescriptor) {
      this._raw.push(itemDescriptor.encoded.encode(item));
    } else if (isRefEncoded(itemDescriptor)) {
      this._raw.push(item.id);
    }
  }
  /**
   * Get a JSON representation of the `CoFeed`
   * @category
   */
  toJSON() {
    const itemDescriptor = this._schema[ItemsSym];
    const mapper = itemDescriptor === "json" ? (v) => v : "encoded" in itemDescriptor ? itemDescriptor.encoded.encode : (v) => v && v.id;
    return {
      id: this.id,
      _type: this._type,
      ...Object.fromEntries(
        Object.entries(this).map(([account, entry]) => [
          account,
          mapper(entry.value)
        ])
      ),
      in: Object.fromEntries(
        Object.entries(this.perSession).map(([session, entry]) => [
          session,
          mapper(entry.value)
        ])
      )
    };
  }
  /** @internal */
  [(ItemsSym, inspect)]() {
    return this.toJSON();
  }
  /** @internal */
  static schema(def) {
    this._schema ||= {};
    Object.assign(this._schema, def);
  }
  /**
   * Load a `CoFeed`
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Ensure a `CoFeed` is loaded to the specified depth
   *
   * @returns A new instance of the same CoFeed that's loaded to the specified depth
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `CoFeed` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoFeed.prototype._type = "CoStream";
var CoFeed = _CoFeed;
function entryFromRawEntry(accessFrom, rawEntry, loadedAs, accountID, itemField) {
  return {
    get value() {
      if (itemField === "json") {
        return rawEntry.value;
      } else if ("encoded" in itemField) {
        return itemField.encoded.decode(rawEntry.value);
      } else if (isRefEncoded(itemField)) {
        return this.ref?.accessFrom(
          accessFrom,
          rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + ".value"
        );
      } else {
        throw new Error("Invalid item field schema");
      }
    },
    get ref() {
      if (itemField !== "json" && isRefEncoded(itemField)) {
        const rawId = rawEntry.value;
        return new Ref(
          rawId,
          loadedAs,
          itemField
        );
      } else {
        return void 0;
      }
    },
    get by() {
      return accountID && new Ref(accountID, loadedAs, {
        ref: RegisteredSchemas["Account"],
        optional: false
      })?.accessFrom(
        accessFrom,
        rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + ".by"
      );
    },
    madeAt: rawEntry.at,
    tx: rawEntry.tx
  };
}
var CoStreamProxyHandler = {
  get(target, key, receiver) {
    if (typeof key === "string" && key.startsWith("co_")) {
      const rawEntry = target._raw.lastItemBy(key);
      if (!rawEntry) return;
      const entry = entryFromRawEntry(
        receiver,
        rawEntry,
        target._loadedAs,
        key,
        target._schema[ItemsSym]
      );
      Object.defineProperty(entry, "all", {
        get: () => {
          const allRawEntries = target._raw.itemsBy(key);
          return function* () {
            while (true) {
              const rawEntry2 = allRawEntries.next();
              if (rawEntry2.done) return;
              yield entryFromRawEntry(
                receiver,
                rawEntry2.value,
                target._loadedAs,
                key,
                target._schema[ItemsSym]
              );
            }
          }();
        }
      });
      return entry;
    } else if (key === "perSession") {
      return new Proxy({}, CoStreamPerSessionProxyHandler(target, receiver));
    } else {
      return Reflect.get(target, key, receiver);
    }
  },
  set(target, key, value, receiver) {
    if (key === ItemsSym && typeof value === "object" && SchemaInit in value) {
      target.constructor._schema ||= {};
      target.constructor._schema[ItemsSym] = value[SchemaInit];
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.value && key === ItemsSym && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
      target.constructor._schema ||= {};
      target.constructor._schema[ItemsSym] = descriptor.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, descriptor);
    }
  },
  ownKeys(target) {
    const keys = Reflect.ownKeys(target);
    for (const accountID of target._raw.accounts()) {
      keys.push(accountID);
    }
    return keys;
  },
  getOwnPropertyDescriptor(target, key) {
    if (typeof key === "string" && key.startsWith("co_")) {
      return {
        configurable: true,
        enumerable: true,
        writable: false
      };
    } else {
      return Reflect.getOwnPropertyDescriptor(target, key);
    }
  }
};
var CoStreamPerSessionProxyHandler = (innerTarget, accessFrom) => ({
  get(_target, key, receiver) {
    if (typeof key === "string" && key.includes("session")) {
      const sessionID = key;
      const rawEntry = innerTarget._raw.lastItemIn(sessionID);
      if (!rawEntry) return;
      const by = cojsonInternals3.accountOrAgentIDfromSessionID(sessionID);
      const entry = entryFromRawEntry(
        accessFrom,
        rawEntry,
        innerTarget._loadedAs,
        cojsonInternals3.isAccountID(by) ? by : void 0,
        innerTarget._schema[ItemsSym]
      );
      Object.defineProperty(entry, "all", {
        get: () => {
          const allRawEntries = innerTarget._raw.itemsIn(sessionID);
          return function* () {
            while (true) {
              const rawEntry2 = allRawEntries.next();
              if (rawEntry2.done) return;
              yield entryFromRawEntry(
                accessFrom,
                rawEntry2.value,
                innerTarget._loadedAs,
                cojsonInternals3.isAccountID(by) ? by : void 0,
                innerTarget._schema[ItemsSym]
              );
            }
          }();
        }
      });
      return entry;
    } else {
      return Reflect.get(innerTarget, key, receiver);
    }
  },
  ownKeys() {
    return innerTarget._raw.sessions();
  },
  getOwnPropertyDescriptor(target, key) {
    if (typeof key === "string" && key.startsWith("co_")) {
      return {
        configurable: true,
        enumerable: true,
        writable: false
      };
    } else {
      return Reflect.getOwnPropertyDescriptor(target, key);
    }
  }
});
var FileStream = class extends CoValueBase {
  constructor(options) {
    super();
    let raw;
    if ("fromRaw" in options) {
      raw = options.fromRaw;
    } else {
      const rawOwner = options.owner._raw;
      raw = rawOwner.createBinaryStream();
    }
    Object.defineProperties(this, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _type: { value: "BinaryCoStream", enumerable: false },
      _raw: { value: raw, enumerable: false }
    });
  }
  /**
   * Create a new empty `FileStream` instance.
   *
   * @param options - Configuration options for the new FileStream
   * @param options.owner - The Account or Group that will own this FileStream and control access rights
   *
   * @example
   * ```typescript
   * // Create owned by an account
   * const stream = FileStream.create({ owner: myAccount });
   *
   * // Create owned by a group
   * const stream = FileStream.create({ owner: teamGroup });
   *
   * // Create with implicit owner
   * const stream = FileStream.create(myAccount);
   * ```
   *
   * @remarks
   * For uploading an existing file or blob, use {@link FileStream.createFromBlob} instead.
   *
   * @category Creation
   */
  static create(options) {
    return new this(parseCoValueCreateOptions(options));
  }
  getChunks(options) {
    return this._raw.getBinaryChunks(options?.allowUnfinished);
  }
  isBinaryStreamEnded() {
    return this._raw.isBinaryStreamEnded();
  }
  start(options) {
    this._raw.startBinaryStream(options);
  }
  push(data) {
    this._raw.pushBinaryStreamChunk(data);
  }
  end() {
    this._raw.endBinaryStream();
  }
  toBlob(options) {
    const chunks = this.getChunks({
      allowUnfinished: options?.allowUnfinished
    });
    if (!chunks) {
      return void 0;
    }
    return new Blob(chunks.chunks, { type: chunks.mimeType });
  }
  /**
   * Load a `FileStream` as a `Blob`
   *
   * @category Content
   */
  static async loadAsBlob(id, options) {
    let stream = await this.load(id, options);
    if (!options?.allowUnfinished && !stream?.isBinaryStreamEnded()) {
      stream = await new Promise((resolve) => {
        subscribeToCoValueWithoutMe(
          this,
          id,
          options || {},
          (value, unsubscribe) => {
            if (value.isBinaryStreamEnded()) {
              unsubscribe();
              resolve(value);
            }
          }
        );
      });
    }
    return stream?.toBlob({
      allowUnfinished: options?.allowUnfinished
    });
  }
  /**
   * Create a `FileStream` from a `Blob` or `File`
   *
   * @example
   * ```ts
   * import { co, FileStream } from "jazz-tools";
   *
   * const fileStream = await FileStream.createFromBlob(file, {owner: group})
   * ```
   * @category Content
   */
  static async createFromBlob(blob, options) {
    const stream = this.create(options);
    const onProgress = options && "onProgress" in options ? options.onProgress : void 0;
    const start = Date.now();
    const data = new Uint8Array(await blob.arrayBuffer());
    stream.start({
      mimeType: blob.type,
      totalSizeBytes: blob.size,
      fileName: blob instanceof File ? blob.name : void 0
    });
    const chunkSize = MAX_RECOMMENDED_TX_SIZE;
    let lastProgressUpdate = Date.now();
    for (let idx = 0; idx < data.length; idx += chunkSize) {
      stream.push(data.slice(idx, idx + chunkSize));
      if (Date.now() - lastProgressUpdate > 100) {
        onProgress?.(idx / data.length);
        lastProgressUpdate = Date.now();
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    stream.end();
    const end = Date.now();
    console.debug(
      "Finished creating binary stream in",
      (end - start) / 1e3,
      "s - Throughput in MB/s",
      1e3 * (blob.size / (end - start)) / (1024 * 1024)
    );
    onProgress?.(1);
    return stream;
  }
  /**
   * Get a JSON representation of the `FileStream`
   * @category Content
   */
  toJSON() {
    return {
      id: this.id,
      _type: this._type,
      ...this.getChunks()
    };
  }
  /** @internal */
  [inspect]() {
    return this.toJSON();
  }
  /**
   * Load a `FileStream`
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * An instance method to subscribe to an existing `FileStream`
   * @category Subscription & Loading
   */
  subscribe(listener) {
    return subscribeToExistingCoValue(this, {}, listener);
  }
  /**
   * Wait for the `FileStream` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};

// src/coValues/coList.ts
import { RawAccount as RawAccount6 } from "cojson";
import { calcPatch } from "fast-myers-diff";
var _CoList = class _CoList extends Array {
  /**
   * Declare a `CoList` by subclassing `CoList.Of(...)` and passing the item schema using `co`.
   *
   * @example
   * ```ts
   * class ColorList extends CoList.Of(
   *   co.string
   * ) {}
   * class AnimalList extends CoList.Of(
   *   co.ref(Animal)
   * ) {}
   * ```
   *
   * @category Declaration
   */
  static Of(item) {
    var _a2, _b2;
    return class CoListOf extends (_b2 = _CoList, _a2 = co.items, _b2) {
      constructor() {
        super(...arguments);
        this[_a2] = item;
      }
    };
  }
  /**
   * @ignore
   * @deprecated Use UPPERCASE `CoList.Of` instead! */
  static of(..._args) {
    throw new Error("Can't use Array.of with CoLists");
  }
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /** @category Collaboration */
  get _owner() {
    return this._raw.group instanceof RawAccount6 ? RegisteredSchemas["Account"].fromRaw(this._raw.group) : RegisteredSchemas["Group"].fromRaw(this._raw.group);
  }
  /**
   * If a `CoList`'s items are a `co.ref(...)`, you can use `coList._refs[i]` to access
   * the `Ref` instead of the potentially loaded/null value.
   *
   * This allows you to always get the ID or load the value manually.
   *
   * @example
   * ```ts
   * animals._refs[0].id; // => ID<Animal>
   * animals._refs[0].value;
   * // => Animal | null
   * const animal = await animals._refs[0].load();
   * ```
   *
   * @category Content
   **/
  get _refs() {
    return makeRefs(
      (idx) => this._raw.get(idx),
      () => Array.from({ length: this._raw.entries().length }, (_, idx) => idx),
      this._loadedAs,
      (_idx) => this._schema[ItemsSym]
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    );
  }
  get _edits() {
    throw new Error("Not implemented");
  }
  get _loadedAs() {
    const rawAccount = this._raw.core.node.account;
    if (rawAccount instanceof RawAccount6) {
      return coValuesCache.get(
        rawAccount,
        () => RegisteredSchemas["Account"].fromRaw(rawAccount)
      );
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  static get [(ItemsSym, Symbol.species)]() {
    return Array;
  }
  constructor(options) {
    super();
    Object.defineProperty(this, "_instanceID", {
      value: `instance-${Math.random().toString(36).slice(2)}`,
      enumerable: false
    });
    if (options && "fromRaw" in options) {
      Object.defineProperties(this, {
        id: {
          value: options.fromRaw.id,
          enumerable: false
        },
        _raw: { value: options.fromRaw, enumerable: false }
      });
    }
    return new Proxy(this, CoListProxyHandler);
  }
  /**
   * Create a new CoList with the given initial values and owner.
   *
   * The owner (a Group or Account) determines access rights to the CoMap.
   *
   * The CoList will immediately be persisted and synced to connected peers.
   *
   * @example
   * ```ts
   * const colours = ColorList.create(
   *   ["red", "green", "blue"],
   *   { owner: me }
   * );
   * const animals = AnimalList.create(
   *   [cat, dog, fish],
   *   { owner: me }
   * );
   * ```
   *
   * @category Creation
   **/
  static create(items, options) {
    const { owner } = parseCoValueCreateOptions(options);
    const instance = new this({ init: items, owner });
    const raw = owner._raw.createList(
      toRawItems(items, instance._schema[ItemsSym])
    );
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return instance;
  }
  push(...items) {
    this._raw.appendItems(
      toRawItems(items, this._schema[ItemsSym]),
      void 0,
      "private"
    );
    return this._raw.entries().length;
  }
  unshift(...items) {
    for (const item of toRawItems(items, this._schema[ItemsSym])) {
      this._raw.prepend(item);
    }
    return this._raw.entries().length;
  }
  pop() {
    const last = this[this.length - 1];
    this._raw.delete(this.length - 1);
    return last;
  }
  shift() {
    const first = this[0];
    this._raw.delete(0);
    return first;
  }
  /**
   * Splice the `CoList` at a given index.
   *
   * @param start - The index to start the splice.
   * @param deleteCount - The number of items to delete.
   * @param items - The items to insert.
   */
  splice(start, deleteCount, ...items) {
    const deleted = this.slice(start, start + deleteCount);
    for (let idxToDelete = start + deleteCount - 1; idxToDelete >= start; idxToDelete--) {
      this._raw.delete(idxToDelete);
    }
    const rawItems = toRawItems(items, this._schema[ItemsSym]);
    if (rawItems.length === 0) {
      return deleted;
    }
    if (rawItems.length === 1) {
      const item = rawItems[0];
      if (item === void 0) return deleted;
      if (start === 0) {
        this._raw.prepend(item);
      } else {
        this._raw.append(item, Math.max(start - 1, 0));
      }
      return deleted;
    }
    if (start === 0) {
      for (let i = rawItems.length - 1; i >= 0; i--) {
        const item = rawItems[i];
        if (item === void 0) continue;
        this._raw.prepend(item);
      }
    } else {
      let appendAfter = Math.max(start - 1, 0);
      for (const item of rawItems) {
        if (item === void 0) continue;
        this._raw.append(item, appendAfter);
        appendAfter++;
      }
    }
    return deleted;
  }
  /**
   * Modify the `CoList` to match another list, where the changes are managed internally.
   *
   * @param result - The resolved list of items.
   */
  applyDiff(result) {
    const current = this._raw.asArray();
    const comparator = isRefEncoded(this._schema[ItemsSym]) ? (aIdx, bIdx) => {
      return current[aIdx]?.id === result[bIdx]?.id;
    } : void 0;
    const patches = [...calcPatch(current, result, comparator)];
    for (const [from, to, insert] of patches.reverse()) {
      this.splice(from, to - from, ...insert);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON(_key, seenAbove) {
    const itemDescriptor = this._schema[ItemsSym];
    if (itemDescriptor === "json") {
      return this._raw.asArray();
    } else if ("encoded" in itemDescriptor) {
      return this._raw.asArray().map((e) => itemDescriptor.encoded.encode(e));
    } else if (isRefEncoded(itemDescriptor)) {
      return this.map(
        (item, idx) => seenAbove?.includes(item?.id) ? { _circular: item.id } : item?.toJSON(idx + "", [
          ...seenAbove || [],
          this.id
        ])
      );
    } else {
      return [];
    }
  }
  [inspect]() {
    return this.toJSON();
  }
  /** @category Internals */
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  /** @internal */
  static schema(def) {
    this._schema ||= {};
    Object.assign(this._schema, def);
  }
  /**
   * Load a `CoList` with a given ID, as a given account.
   *
   * `depth` specifies if item CoValue references should be loaded as well before resolving.
   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.
   *
   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.
   *
   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.
   *
   * @example
   * ```ts
   * const animalsWithVets =
   *   await ListOfAnimals.load(
   *     "co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax",
   *     me,
   *     [{ vet: {} }]
   *   );
   * ```
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Given an already loaded `CoList`, ensure that items are loaded to the specified depth.
   *
   * Works like `CoList.load()`, but you don't need to pass the ID or the account to load as again.
   *
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /** @category Type Helpers */
  castAs(cl) {
    const casted = cl.fromRaw(this._raw);
    const subscriptionScope = subscriptionsScopes.get(this);
    if (subscriptionScope) {
      subscriptionsScopes.set(casted, subscriptionScope);
    }
    return casted;
  }
  /**
   * Wait for the `CoList` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoList.prototype._type = "CoList";
var CoList = _CoList;
function toRawItems(items, itemDescriptor) {
  const rawItems = itemDescriptor === "json" ? items : "encoded" in itemDescriptor ? items?.map((e) => itemDescriptor.encoded.encode(e)) : isRefEncoded(itemDescriptor) ? items?.map((v) => {
    if (!v) return null;
    return v.id;
  }) : (() => {
    throw new Error("Invalid element descriptor");
  })();
  return rawItems;
}
var CoListProxyHandler = {
  get(target, key, receiver) {
    if (typeof key === "string" && !isNaN(+key)) {
      const itemDescriptor = target._schema[ItemsSym];
      const rawValue = target._raw.get(Number(key));
      if (itemDescriptor === "json") {
        return rawValue;
      } else if ("encoded" in itemDescriptor) {
        return rawValue === void 0 ? void 0 : itemDescriptor.encoded.decode(rawValue);
      } else if (isRefEncoded(itemDescriptor)) {
        return rawValue === void 0 ? void 0 : new Ref(
          rawValue,
          target._loadedAs,
          itemDescriptor
        ).accessFrom(receiver, Number(key));
      }
    } else if (key === "length") {
      return target._raw.entries().length;
    } else {
      return Reflect.get(target, key, receiver);
    }
  },
  set(target, key, value, receiver) {
    if (key === ItemsSym && typeof value === "object" && SchemaInit in value) {
      target.constructor._schema ||= {};
      target.constructor._schema[ItemsSym] = value[SchemaInit];
      return true;
    }
    if (typeof key === "string" && !isNaN(+key)) {
      const itemDescriptor = target._schema[ItemsSym];
      let rawValue;
      if (itemDescriptor === "json") {
        rawValue = value;
      } else if ("encoded" in itemDescriptor) {
        rawValue = itemDescriptor.encoded.encode(value);
      } else if (isRefEncoded(itemDescriptor)) {
        if (value === null) {
          if (itemDescriptor.optional) {
            rawValue = null;
          } else {
            throw new Error(`Cannot set required reference ${key} to null`);
          }
        } else if (value?.id) {
          rawValue = value.id;
        } else {
          throw new Error(
            `Cannot set reference ${key} to a non-CoValue. Got ${value}`
          );
        }
      }
      target._raw.replace(Number(key), rawValue);
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.value && key === ItemsSym && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
      target.constructor._schema ||= {};
      target.constructor._schema[ItemsSym] = descriptor.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, descriptor);
    }
  },
  has(target, key) {
    if (typeof key === "string" && !isNaN(+key)) {
      return Number(key) < target._raw.entries().length;
    } else {
      return Reflect.has(target, key);
    }
  }
};

// src/coValues/group.ts
var _Group = class _Group extends CoValueBase {
  get _schema() {
    return this.constructor._schema;
  }
  get _refs() {
    const profileID = this._raw.get("profile");
    const rootID = this._raw.get("root");
    return {
      profile: profileID && new Ref(
        profileID,
        this._loadedAs,
        this._schema.profile
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ),
      root: rootID && new Ref(
        rootID,
        this._loadedAs,
        this._schema.root
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      )
    };
  }
  /** @deprecated Don't use constructor directly, use .create */
  constructor(options) {
    super();
    let raw;
    if (options && "fromRaw" in options) {
      raw = options.fromRaw;
    } else {
      const initOwner = options.owner;
      if (!initOwner) throw new Error("No owner provided");
      if (initOwner._type === "Account" && isControlledAccount(initOwner)) {
        const rawOwner = initOwner._raw;
        raw = rawOwner.createGroup();
      } else {
        throw new Error("Can only construct group as a controlled account");
      }
    }
    Object.defineProperties(this, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return new Proxy(this, AccountAndGroupProxyHandler);
  }
  static create(options) {
    return new this(parseGroupCreateOptions(options));
  }
  myRole() {
    return this._raw.myRole();
  }
  addMember(member, role) {
    this._raw.addMember(member === "everyone" ? member : member._raw, role);
  }
  removeMember(member) {
    return this._raw.removeMember(member === "everyone" ? member : member._raw);
  }
  get members() {
    const members = [];
    const BaseAccountSchema = activeAccountContext.maybeGet()?.constructor || RegisteredSchemas["Account"];
    const refEncodedAccountSchema = {
      ref: () => BaseAccountSchema,
      optional: false
    };
    for (const accountID of this._raw.getAllMemberKeysSet()) {
      if (!isAccountID(accountID)) continue;
      const role = this._raw.roleOf(accountID);
      if (role === "admin" || role === "writer" || role === "reader" || role === "writeOnly") {
        const ref2 = new Ref(
          accountID,
          this._loadedAs,
          refEncodedAccountSchema
        );
        const accessRef = () => ref2.accessFrom(this, "members." + accountID);
        if (!ref2.syncLoad()) {
          console.warn("Account not loaded", accountID);
        }
        members.push({
          id: accountID,
          role,
          ref: ref2,
          get account() {
            return accessRef();
          }
        });
      }
    }
    return members;
  }
  getRoleOf(member) {
    if (member === "me") {
      return this._raw.roleOf(
        activeAccountContext.get().id
      );
    }
    return this._raw.roleOf(
      member === "everyone" ? member : member
    );
  }
  getParentGroups() {
    return this._raw.getParentGroups().map((group) => _Group.fromRaw(group));
  }
  extend(parent, roleMapping) {
    this._raw.extend(parent._raw, roleMapping);
    return this;
  }
  async revokeExtend(parent) {
    await this._raw.revokeExtend(parent._raw);
    return this;
  }
  /** @category Subscription & Loading */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /** @category Subscription & Loading */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `Group` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_Group.prototype._type = "Group";
_Group._schema = {
  profile: "json",
  root: "json"
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
};
Object.defineProperty(_Group.prototype, "_schema", {
  get: () => _Group._schema
});
var Group = _Group;
RegisteredSchemas["Group"] = Group;
function isAccountID(id) {
  return id.startsWith("co_");
}

// src/coValues/coPlainText.ts
import {
  RawAccount as RawAccount7,
  stringifyOpID
} from "cojson";
import { calcPatch as calcPatch2 } from "fast-myers-diff";
var CoPlainText = class extends String {
  get _owner() {
    return this._raw.group instanceof RawAccount7 ? Account.fromRaw(this._raw.group) : Group.fromRaw(this._raw.group);
  }
  get _loadedAs() {
    return Account.fromNode(this._raw.core.node);
  }
  constructor(options) {
    super("fromRaw" in options ? options.fromRaw.toString() : options.text);
    let raw;
    if ("fromRaw" in options) {
      raw = options.fromRaw;
    } else {
      raw = options.owner._raw.createPlainText(options.text);
    }
    Object.defineProperties(this, {
      id: { value: raw.id, enumerable: false },
      _type: { value: "CoPlainText", enumerable: false },
      _raw: { value: raw, enumerable: false }
    });
  }
  static create(text, options) {
    return new this({ text, owner: options.owner });
  }
  get length() {
    return this._raw.toString().length;
  }
  toString() {
    return this._raw.toString();
  }
  valueOf() {
    return this._raw.toString();
  }
  toJSON() {
    return this._raw.toString();
  }
  [inspect]() {
    return this.toJSON();
  }
  insertBefore(idx, text) {
    this._raw.insertBefore(idx, text);
  }
  insertAfter(idx, text) {
    this._raw.insertAfter(idx, text);
  }
  deleteRange(range) {
    this._raw.deleteRange(range);
  }
  posBefore(idx) {
    return this._raw.mapping.opIDbeforeIdx[idx];
  }
  posAfter(idx) {
    return this._raw.mapping.opIDafterIdx[idx];
  }
  idxBefore(pos) {
    return this._raw.mapping.idxBeforeOpID[stringifyOpID(pos)];
  }
  idxAfter(pos) {
    return this._raw.mapping.idxAfterOpID[stringifyOpID(pos)];
  }
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  /**
   * Apply text, modifying the text in place. Calculates the diff and applies it to the CoValue.
   *
   * @category Mutation
   */
  applyDiff(other) {
    const current = this._raw.toString();
    for (const [from, to, insert] of [...calcPatch2(current, other)].reverse()) {
      if (to > from) {
        this.deleteRange({ from, to });
      }
      if (insert.length > 0) {
        this.insertBefore(from, insert);
      }
    }
  }
  /**
   * Load a `CoPlainText` with a given ID, as a given account.
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Given an already loaded `CoPlainText`, subscribe to updates to the `CoPlainText` and ensure that the specified fields are loaded to the specified depth.
   *
   * Works like `CoPlainText.subscribe()`, but you don't need to pass the ID or the account to load as again.
   *
   * Returns an unsubscribe function that you should call when you no longer need updates.
   *
   * @category Subscription & Loading
   **/
  subscribe(listener) {
    return subscribeToExistingCoValue(this, {}, listener);
  }
};

// src/coValues/coRichText.ts
var CoRichText = class extends CoPlainText {
};

// src/coValues/extensions/imageDef.ts
var _a, _b;
var ImageDefinition = class extends (_b = CoMap, _a = co.items, _b) {
  constructor() {
    super(...arguments);
    this.originalSize = co.json();
    this.placeholderDataURL = co.string;
    this[_a] = co.ref(FileStream);
  }
  highestResAvailable(options) {
    if (!subscriptionsScopes.get(this)) {
      console.warn(
        "highestResAvailable() only makes sense when used within a subscription."
      );
    }
    const resolutions = Object.keys(this).filter(
      (key) => key.match(/^\d+x\d+$/)
    );
    let maxWidth = options?.maxWidth;
    if (options?.targetWidth) {
      const targetWidth = options.targetWidth;
      const widths = resolutions.map((res) => Number(res.split("x")[0]));
      maxWidth = Math.min(...widths.filter((w) => w >= targetWidth));
    }
    const validResolutions = resolutions.filter(
      (key) => maxWidth === void 0 || Number(key.split("x")[0]) <= maxWidth
    );
    validResolutions.sort((a, b) => {
      const aWidth = Number(a.split("x")[0]);
      const bWidth = Number(b.split("x")[0]);
      return aWidth - bWidth;
    });
    let highestAvailableResolution;
    for (const resolution of validResolutions) {
      if (this[resolution] && this[resolution]?.getChunks()) {
        highestAvailableResolution = resolution;
      }
    }
    return highestAvailableResolution && {
      res: highestAvailableResolution,
      stream: this[highestAvailableResolution]
    };
  }
};

// src/coValues/schemaUnion.ts
var SchemaUnion = class _SchemaUnion extends CoValueBase {
  /**
   * Create a new union type from a discriminator function.
   *
   * The discriminator function receives the raw data and should return the appropriate concrete class to use for that data.
   *
   * When loading a SchemaUnion, the correct subclass will be instantiated based on the discriminator.
   *
   * @param discriminator - Function that determines which concrete type to use
   * @returns A new class that can create/load instances of the union type
   *
   * @example
   * ```ts
   * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {
   *   switch (raw.get("type")) {
   *     case "button": return ButtonWidget;
   *     case "slider": return SliderWidget;
   *     default: throw new Error("Unknown widget type");
   *   }
   * });
   *
   * const widget = await loadCoValue(WidgetUnion, id, me, {});
   *
   * // You can narrow the returned instance to a subclass by using `instanceof`
   * if (widget instanceof ButtonWidget) {
   *   console.log(widget.label);
   * } else if (widget instanceof SliderWidget) {
   *   console.log(widget.min, widget.max);
   * }
   * ```
   *
   * @category Declaration
   **/
  static Of(discriminator) {
    return class SchemaUnionClass extends _SchemaUnion {
      static fromRaw(raw) {
        const ResolvedClass = discriminator(
          raw
        );
        return ResolvedClass.fromRaw(raw);
      }
    };
  }
  /**
   * Create an instance from raw data. This is called internally and should not be used directly.
   * Use {@link SchemaUnion.Of} to create a union type instead.
   *
   * @internal
   */
  // @ts-ignore
  static fromRaw(raw) {
    throw new Error("Not implemented");
  }
};

// src/auth/KvStoreContext.ts
var KvStoreContext = class _KvStoreContext {
  constructor() {
    this.storageInstance = null;
  }
  static getInstance() {
    if (!_KvStoreContext.instance) {
      _KvStoreContext.instance = new _KvStoreContext();
    }
    return _KvStoreContext.instance;
  }
  isInitialized() {
    return this.storageInstance !== null;
  }
  initialize(store) {
    if (!this.storageInstance) {
      this.storageInstance = store;
    }
  }
  getStorage() {
    if (!this.storageInstance) {
      throw new Error("Storage instance is not initialized.");
    }
    return this.storageInstance;
  }
};
var KvStoreContext_default = KvStoreContext;

// src/auth/AuthSecretStorage.ts
var STORAGE_KEY = "jazz-logged-in-secret";
var AuthSecretStorage = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.isAuthenticated = false;
  }
  async migrate() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    if (!await kvStore.get(STORAGE_KEY)) {
      const demoAuthSecret = await kvStore.get("demo-auth-logged-in-secret");
      if (demoAuthSecret) {
        const parsed = JSON.parse(demoAuthSecret);
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            accountSecret: parsed.accountSecret,
            provider: "demo"
          })
        );
        await kvStore.delete("demo-auth-logged-in-secret");
      }
      const clerkAuthSecret = await kvStore.get("jazz-clerk-auth");
      if (clerkAuthSecret) {
        const parsed = JSON.parse(clerkAuthSecret);
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            accountSecret: parsed.secret,
            provider: "clerk"
          })
        );
        await kvStore.delete("jazz-clerk-auth");
      }
    }
    const value = await kvStore.get(STORAGE_KEY);
    if (value) {
      const parsed = JSON.parse(value);
      if ("secret" in parsed) {
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            secretSeed: parsed.secretSeed,
            accountSecret: parsed.secret,
            provider: parsed.provider
          })
        );
      }
    }
  }
  async get() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    const data = await kvStore.get(STORAGE_KEY);
    if (!data) return null;
    const parsed = JSON.parse(data);
    if (!parsed.accountID || !parsed.accountSecret) {
      throw new Error("Invalid auth secret storage data");
    }
    return {
      accountID: parsed.accountID,
      secretSeed: parsed.secretSeed ? new Uint8Array(parsed.secretSeed) : void 0,
      accountSecret: parsed.accountSecret,
      provider: parsed.provider
    };
  }
  async setWithoutNotify(payload) {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    await kvStore.set(
      STORAGE_KEY,
      JSON.stringify({
        accountID: payload.accountID,
        secretSeed: payload.secretSeed ? Array.from(payload.secretSeed) : void 0,
        accountSecret: payload.accountSecret,
        provider: payload.provider
      })
    );
  }
  async set(payload) {
    this.setWithoutNotify(payload);
    this.emitUpdate(payload);
  }
  getIsAuthenticated(data) {
    if (!data) return false;
    return data.provider !== "anonymous";
  }
  onUpdate(handler) {
    this.listeners.add(handler);
    return () => {
      this.listeners.delete(handler);
    };
  }
  emitUpdate(data) {
    const isAuthenticated = this.getIsAuthenticated(data);
    if (this.isAuthenticated === isAuthenticated) return;
    this.isAuthenticated = isAuthenticated;
    for (const listener of this.listeners) {
      listener(this.isAuthenticated);
    }
  }
  async clearWithoutNotify() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    await kvStore.delete(STORAGE_KEY);
  }
  async clear() {
    await this.clearWithoutNotify();
    this.emitUpdate(null);
  }
};

// src/auth/InMemoryKVStore.ts
var InMemoryKVStore = class {
  constructor() {
    this.store = {};
  }
  async get(key) {
    const data = this.store[key];
    if (!data) return null;
    return data;
  }
  async set(key, value) {
    this.store[key] = value;
  }
  async delete(key) {
    delete this.store[key];
  }
  async clearAll() {
    this.store = {};
  }
};

// src/implementation/ContextManager.ts
import { cojsonInternals as cojsonInternals4 } from "cojson";
var JazzContextManager = class {
  constructor() {
    this.authSecretStorage = new AuthSecretStorage();
    this.keepContextOpen = false;
    this.logOut = async () => {
      if (!this.context || !this.props) {
        return;
      }
      await this.props.onLogOut?.();
      if (this.props.logOutReplacement) {
        await this.props.logOutReplacement();
      } else {
        await this.context.logOut();
        return this.createContext(this.props);
      }
    };
    this.done = () => {
      if (!this.context) {
        return;
      }
      this.context.done();
    };
    this.shouldMigrateAnonymousAccount = async () => {
      if (!this.props?.onAnonymousAccountDiscarded) {
        return false;
      }
      const prevCredentials = await this.authSecretStorage.get();
      const wasAnonymous = this.authSecretStorage.getIsAuthenticated(prevCredentials) === false;
      return wasAnonymous;
    };
    /**
     * Authenticates the user with the given credentials
     */
    this.authenticate = async (credentials) => {
      if (!this.props) {
        throw new Error("Props required");
      }
      const prevContext = this.context;
      const migratingAnonymousAccount = await this.shouldMigrateAnonymousAccount();
      this.keepContextOpen = migratingAnonymousAccount;
      await this.createContext(this.props, { credentials }).finally(() => {
        this.keepContextOpen = false;
      });
      if (migratingAnonymousAccount) {
        await this.handleAnonymousAccountMigration(prevContext);
      }
    };
    this.register = async (accountSecret, creationProps) => {
      if (!this.props) {
        throw new Error("Props required");
      }
      const prevContext = this.context;
      const migratingAnonymousAccount = await this.shouldMigrateAnonymousAccount();
      this.keepContextOpen = migratingAnonymousAccount;
      await this.createContext(this.props, {
        newAccountProps: {
          secret: accountSecret,
          creationProps
        }
      }).finally(() => {
        this.keepContextOpen = false;
      });
      if (migratingAnonymousAccount) {
        await this.handleAnonymousAccountMigration(prevContext);
      }
      if (this.context && "me" in this.context) {
        return this.context.me.id;
      }
      throw new Error("The registration hasn't created a new account");
    };
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = (callback) => {
      this.listeners.add(callback);
      return () => {
        this.listeners.delete(callback);
      };
    };
    KvStoreContext.getInstance().initialize(this.getKvStore());
  }
  getKvStore() {
    return new InMemoryKVStore();
  }
  async createContext(props, authProps) {
    this.props = props;
    const { promise, resolve } = createResolvablePromise();
    const prevPromise = this.contextPromise;
    this.contextPromise = promise;
    await prevPromise;
    try {
      const result = await this.getNewContext(props, authProps);
      await this.updateContext(props, result, authProps);
      resolve();
    } catch (error) {
      resolve();
      throw error;
    }
  }
  async getNewContext(props, authProps) {
    props;
    authProps;
    throw new Error("Not implemented");
  }
  async updateContext(props, context, authProps) {
    if (!this.keepContextOpen) {
      this.context?.done();
    }
    this.context = context;
    this.props = props;
    this.value = {
      ...context,
      node: context.node,
      authenticate: this.authenticate,
      register: this.register,
      logOut: this.logOut
    };
    if (authProps?.credentials) {
      this.authSecretStorage.emitUpdate(authProps.credentials);
    } else {
      this.authSecretStorage.emitUpdate(await this.authSecretStorage.get());
    }
    this.notify();
  }
  propsChanged(props) {
    props;
    throw new Error("Not implemented");
  }
  getCurrentValue() {
    return this.value;
  }
  getAuthSecretStorage() {
    return this.authSecretStorage;
  }
  async handleAnonymousAccountMigration(prevContext) {
    if (!this.props) {
      throw new Error("Props required");
    }
    const currentContext = this.context;
    if (prevContext && currentContext && "me" in prevContext && "me" in currentContext) {
      const [prevAccountAsPeer, currentAccountAsPeer] = cojsonInternals4.connectedPeers(
        prevContext.me.id,
        currentContext.me.id,
        {
          peer1role: "client",
          peer2role: "server"
        }
      );
      prevContext.node.syncManager.addPeer(currentAccountAsPeer);
      currentContext.node.syncManager.addPeer(prevAccountAsPeer);
      try {
        await this.props.onAnonymousAccountDiscarded?.(prevContext.me);
        await prevContext.me.waitForAllCoValuesSync();
      } catch (error) {
        console.error("Error onAnonymousAccountDiscarded", error);
      }
      prevAccountAsPeer.outgoing.close();
      currentAccountAsPeer.outgoing.close();
    }
    prevContext?.done();
  }
  notify() {
    for (const listener of this.listeners) {
      listener();
    }
  }
};
function createResolvablePromise() {
  let resolve;
  const promise = new Promise((res) => {
    resolve = res;
  });
  return { promise, resolve };
}

// src/auth/DemoAuth.ts
var DemoAuth = class {
  constructor(authenticate, authSecretStorage) {
    this.authenticate = authenticate;
    this.authSecretStorage = authSecretStorage;
    this.logIn = async (username) => {
      const existingUsers = await this.getExisitingUsersWithData();
      const storageData = existingUsers[username];
      if (!storageData?.accountID) {
        throw new Error("User not found");
      }
      await this.authenticate({
        accountID: storageData.accountID,
        accountSecret: storageData.accountSecret
      });
      await this.authSecretStorage.set({
        accountID: storageData.accountID,
        accountSecret: storageData.accountSecret,
        secretSeed: storageData.secretSeed ? new Uint8Array(storageData.secretSeed) : void 0,
        provider: "demo"
      });
    };
    this.signUp = async (username) => {
      const existingUsers = await this.getExistingUsers();
      if (existingUsers.includes(username)) {
        throw new Error("User already registered");
      }
      const credentials = await this.authSecretStorage.get();
      if (!credentials) {
        throw new Error("No credentials found");
      }
      const currentAccount = await Account.getMe().ensureLoaded({
        resolve: {
          profile: true
        }
      });
      currentAccount.profile.name = username;
      await this.authSecretStorage.set({
        accountID: credentials.accountID,
        accountSecret: credentials.accountSecret,
        secretSeed: credentials.secretSeed ? new Uint8Array(credentials.secretSeed) : void 0,
        provider: "demo"
      });
      await this.addToExistingUsers(username, {
        accountID: credentials.accountID,
        accountSecret: credentials.accountSecret,
        secretSeed: credentials.secretSeed ? Array.from(credentials.secretSeed) : void 0
      });
    };
    this.getExistingUsers = async () => {
      return Object.keys(await this.getExisitingUsersWithData());
    };
  }
  async addToExistingUsers(username, data) {
    const existingUsers = await this.getExisitingUsersWithData();
    if (existingUsers[username]) {
      return;
    }
    existingUsers[username] = data;
    const kvStore = KvStoreContext.getInstance().getStorage();
    await kvStore.set("demo-auth-users", JSON.stringify(existingUsers));
  }
  async getExisitingUsersWithData() {
    const kvStore = KvStoreContext.getInstance().getStorage();
    await migrateExistingUsers(kvStore);
    const existingUsers = await kvStore.get("demo-auth-users");
    return existingUsers ? JSON.parse(existingUsers) : {};
  }
};
function encodeUsername(username) {
  return btoa(username).replace(/=/g, "-").replace(/\+/g, "_").replace(/\//g, ".");
}
async function getStorageVersion(kvStore) {
  try {
    const version = await kvStore.get("demo-auth-storage-version");
    return version ? parseInt(version) : 1;
  } catch (error) {
    return 1;
  }
}
async function setStorageVersion(kvStore, version) {
  await kvStore.set("demo-auth-storage-version", version.toString());
}
async function getExistingUsersList(kvStore) {
  const existingUsers = await kvStore.get("demo-auth-existing-users");
  return existingUsers ? existingUsers.split(",") : [];
}
async function migrateExistingUsers(kvStore) {
  if (await getStorageVersion(kvStore) < 2) {
    const existingUsers = await getExistingUsersList(kvStore);
    for (const username of existingUsers) {
      const legacyKey = `demo-auth-existing-users-${username}`;
      const storageData = await kvStore.get(legacyKey);
      if (storageData) {
        await kvStore.set(
          `demo-auth-existing-users-${encodeUsername(username)}`,
          storageData
        );
        await kvStore.delete(legacyKey);
      }
    }
    await setStorageVersion(kvStore, 2);
  }
  if (await getStorageVersion(kvStore) < 3) {
    const existingUsersList = await getExistingUsersList(kvStore);
    const existingUsers = {};
    const keysToDelete = ["demo-auth-existing-users"];
    for (const username of existingUsersList) {
      const key = `demo-auth-existing-users-${encodeUsername(username)}`;
      const storageData = await kvStore.get(key);
      if (storageData) {
        existingUsers[username] = JSON.parse(storageData);
        keysToDelete.push(key);
      }
    }
    await kvStore.set("demo-auth-users", JSON.stringify(existingUsers));
    for (const key of keysToDelete) {
      await kvStore.delete(key);
    }
    await setStorageVersion(kvStore, 3);
  }
}

// src/auth/PassphraseAuth.ts
import * as bip39 from "@scure/bip39";
import { entropyToMnemonic } from "@scure/bip39";
import { cojsonInternals as cojsonInternals5 } from "cojson";
var PassphraseAuth = class {
  constructor(crypto, authenticate, register, authSecretStorage, wordlist) {
    this.crypto = crypto;
    this.authenticate = authenticate;
    this.register = register;
    this.authSecretStorage = authSecretStorage;
    this.wordlist = wordlist;
    this.passphrase = "";
    this.logIn = async (passphrase) => {
      const { crypto, authenticate } = this;
      let secretSeed;
      try {
        secretSeed = bip39.mnemonicToEntropy(passphrase, this.wordlist);
      } catch (e) {
        throw new Error("Invalid passphrase");
      }
      const accountSecret = crypto.agentSecretFromSecretSeed(secretSeed);
      const accountID = cojsonInternals5.idforHeader(
        cojsonInternals5.accountHeaderForInitialAgentSecret(accountSecret, crypto),
        crypto
      );
      await authenticate({
        accountID,
        accountSecret
      });
      await this.authSecretStorage.set({
        accountID,
        secretSeed,
        accountSecret,
        provider: "passphrase"
      });
      this.passphrase = passphrase;
      this.notify();
    };
    this.signUp = async (name) => {
      const credentials = await this.authSecretStorage.get();
      if (!credentials || !credentials.secretSeed) {
        throw new Error("No credentials found");
      }
      const passphrase = entropyToMnemonic(credentials.secretSeed, this.wordlist);
      await this.authSecretStorage.set({
        accountID: credentials.accountID,
        secretSeed: credentials.secretSeed,
        accountSecret: credentials.accountSecret,
        provider: "passphrase"
      });
      if (name?.trim()) {
        const currentAccount = await Account.getMe().ensureLoaded({
          resolve: {
            profile: true
          }
        });
        currentAccount.profile.name = name;
      }
      return passphrase;
    };
    this.registerNewAccount = async (passphrase, name) => {
      const secretSeed = bip39.mnemonicToEntropy(passphrase, this.wordlist);
      const accountSecret = this.crypto.agentSecretFromSecretSeed(secretSeed);
      const accountID = await this.register(accountSecret, { name });
      await this.authSecretStorage.set({
        accountID,
        secretSeed,
        accountSecret,
        provider: "passphrase"
      });
      return accountID;
    };
    this.getCurrentAccountPassphrase = async () => {
      const credentials = await this.authSecretStorage.get();
      if (!credentials || !credentials.secretSeed) {
        throw new Error("No credentials found");
      }
      return entropyToMnemonic(credentials.secretSeed, this.wordlist);
    };
    this.generateRandomPassphrase = () => {
      return entropyToMnemonic(this.crypto.newRandomSecretSeed(), this.wordlist);
    };
    this.loadCurrentAccountPassphrase = async () => {
      const passphrase = await this.getCurrentAccountPassphrase();
      this.passphrase = passphrase;
      this.notify();
    };
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = (callback) => {
      this.listeners.add(callback);
      return () => {
        this.listeners.delete(callback);
      };
    };
  }
  notify() {
    for (const listener of this.listeners) {
      listener();
    }
  }
};

// src/implementation/invites.ts
import { cojsonInternals as cojsonInternals6 } from "cojson";
function createInviteLink(value, role, baseURL, valueHint) {
  const coValueCore = value._raw.core;
  let currentCoValue = coValueCore;
  while (currentCoValue.header.ruleset.type === "ownedByGroup") {
    currentCoValue = currentCoValue.getGroup().core;
  }
  const { ruleset, meta } = currentCoValue.header;
  if (ruleset.type !== "group" || meta?.type === "account") {
    throw new Error("Can't create invite link for object without group");
  }
  const group = cojsonInternals6.expectGroup(currentCoValue.getCurrentContent());
  const inviteSecret = group.createInvite(role);
  return `${baseURL}#/invite/${valueHint ? valueHint + "/" : ""}${value.id}/${inviteSecret}`;
}
function parseInviteLink(inviteURL) {
  const url = new URL(inviteURL);
  const parts = url.hash.split("/");
  let valueHint;
  let valueID;
  let inviteSecret;
  if (parts[0] === "#" && parts[1] === "invite") {
    if (parts.length === 5) {
      valueHint = parts[2];
      valueID = parts[3];
      inviteSecret = parts[4];
    } else if (parts.length === 4) {
      valueID = parts[2];
      inviteSecret = parts[3];
    }
    if (!valueID || !inviteSecret) {
      return void 0;
    }
    return { valueID, inviteSecret, valueHint };
  }
}
function consumeInviteLink({
  inviteURL,
  as = Account.getMe(),
  forValueHint,
  invitedObjectSchema
}) {
  return new Promise((resolve, reject) => {
    const result = parseInviteLink(inviteURL);
    if (result && result.valueHint === forValueHint) {
      as.acceptInvite(result.valueID, result.inviteSecret, invitedObjectSchema).then(() => {
        resolve(result);
      }).catch(reject);
    } else {
      resolve(void 0);
    }
  });
}

export {
  activeAccountContext,
  AnonymousJazzAgent,
  CoValueBase,
  loadCoValue2 as loadCoValue,
  subscribeToCoValue,
  createCoValueObservable,
  Encoders,
  co,
  randomSessionProvider,
  createJazzContextFromExistingCredentials,
  createJazzContextForNewAccount,
  createJazzContext,
  createAnonymousJazzContext,
  Inbox,
  InboxSender,
  CoMap,
  Profile,
  Account,
  isControlledAccount,
  CoFeed,
  FileStream,
  CoList,
  Group,
  CoPlainText,
  CoRichText,
  ImageDefinition,
  SchemaUnion,
  KvStoreContext,
  AuthSecretStorage,
  InMemoryKVStore,
  JazzContextManager,
  DemoAuth,
  PassphraseAuth,
  createInviteLink,
  parseInviteLink,
  consumeInviteLink
};
/* istanbul ignore file -- @preserve */
//# sourceMappingURL=chunk-PYBQOYML.js.map