import { CoID, RawCoValue } from "../coValue.js";
import { CoValueCore } from "../coValueCore.js";
import { AgentID, SessionID, TransactionID } from "../ids.js";
import { JsonObject, JsonValue } from "../jsonValue.js";
import { CoValueKnownState } from "../sync.js";
import { RawAccountID } from "./account.js";
import { RawGroup } from "./group.js";
export type OpID = TransactionID & {
    changeIdx: number;
};
export type InsertionOpPayload<T extends JsonValue> = {
    op: "pre";
    value: T;
    before: OpID | "end";
} | {
    op: "app";
    value: T;
    after: OpID | "start";
};
export type DeletionOpPayload = {
    op: "del";
    insertion: OpID;
};
export type ListOpPayload<T extends JsonValue> = InsertionOpPayload<T> | DeletionOpPayload;
type InsertionEntry<T extends JsonValue> = {
    madeAt: number;
    predecessors: OpID[];
    successors: OpID[];
} & InsertionOpPayload<T>;
type DeletionEntry = {
    madeAt: number;
    deletionID: OpID;
} & DeletionOpPayload;
export declare class RawCoList<Item extends JsonValue = JsonValue, Meta extends JsonObject | null = null> implements RawCoValue {
    /** @category 6. Meta */
    id: CoID<this>;
    /** @category 6. Meta */
    type: "colist" | "coplaintext";
    /** @category 6. Meta */
    core: CoValueCore;
    /** @internal */
    afterStart: OpID[];
    /** @internal */
    beforeEnd: OpID[];
    /** @internal */
    insertions: {
        [sessionID: SessionID]: {
            [txIdx: number]: {
                [changeIdx: number]: InsertionEntry<Item>;
            };
        };
    };
    /** @internal */
    deletionsByInsertion: {
        [deletedSessionID: SessionID]: {
            [deletedTxIdx: number]: {
                [deletedChangeIdx: number]: DeletionEntry[];
            };
        };
    };
    /** @category 6. Meta */
    readonly _item: Item;
    /** @internal */
    _cachedEntries?: {
        value: Item;
        madeAt: number;
        opID: OpID;
    }[];
    /** @internal */
    totalValidTransactions: number;
    knownTransactions: CoValueKnownState["sessions"];
    lastValidTransaction: number | undefined;
    /** @internal */
    constructor(core: CoValueCore);
    processNewTransactions(): void;
    /** @category 6. Meta */
    get headerMeta(): Meta;
    /** @category 6. Meta */
    get group(): RawGroup;
    /**
     * Not yet implemented
     *
     * @category 4. Time travel
     */
    atTime(_time: number): this;
    /**
     * Get the item currently at `idx`.
     *
     * @category 1. Reading
     */
    get(idx: number): Item | undefined;
    /**
     * Returns the current items in the CoList as an array.
     *
     * @category 1. Reading
     **/
    asArray(): Item[];
    /** @internal */
    entries(): {
        value: Item;
        madeAt: number;
        opID: OpID;
    }[];
    /** @internal */
    entriesUncached(): {
        value: Item;
        madeAt: number;
        opID: OpID;
    }[];
    /** @internal */
    private fillArrayFromOpID;
    /**
     * Returns the current items in the CoList as an array. (alias of `asArray`)
     *
     * @category 1. Reading
     */
    toJSON(): Item[];
    /** @category 5. Edit history */
    editAt(idx: number): {
        by: RawAccountID | AgentID;
        tx: TransactionID;
        at: Date;
        value: Item;
    } | undefined;
    /** @category 5. Edit history */
    deletionEdits(): {
        by: RawAccountID | AgentID;
        tx: TransactionID;
        at: Date;
    }[];
    /** @category 3. Subscription */
    subscribe(listener: (coList: this) => void): () => void;
    /** Appends `item` after the item currently at index `after`.
     *
     * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
     *
     * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
     *
     * @category 2. Editing
     **/
    append(item: Item, after?: number, privacy?: "private" | "trusting"): void;
    /**
     * Appends `items` to the list at index `after`. If `after` is negative, it is treated as `0`.
     *
     * If `privacy` is `"private"` **(default)**, `items` are encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
     *
     * If `privacy` is `"trusting"`, `items` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
     *
     * @category 2. Editing
     */
    appendItems(items: Item[], after?: number, privacy?: "private" | "trusting"): void;
    /**
     * Prepends `item` before the item currently at index `before`.
     *
     * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
     *
     * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
     *
     * @category 2. Editing
     */
    prepend(item: Item, before?: number, privacy?: "private" | "trusting"): void;
    /** Deletes the item at index `at`.
     *
     * If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
     *
     * If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
     *
     * @category 2. Editing
     **/
    delete(at: number, privacy?: "private" | "trusting"): void;
    replace(at: number, newItem: Item, privacy?: "private" | "trusting"): void;
    /** @internal */
    rebuildFromCore(): void;
}
export {};
//# sourceMappingURL=coList.d.ts.map