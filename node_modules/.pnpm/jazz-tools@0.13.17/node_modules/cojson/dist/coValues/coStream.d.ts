import { CoID, RawCoValue } from "../coValue.js";
import { CoValueCore } from "../coValueCore.js";
import { AgentID, SessionID, TransactionID } from "../ids.js";
import { JsonObject, JsonValue } from "../jsonValue.js";
import { CoValueKnownState } from "../sync.js";
import { RawAccountID } from "./account.js";
import { RawGroup } from "./group.js";
export type BinaryStreamInfo = {
    mimeType: string;
    fileName?: string;
    totalSizeBytes?: number;
};
export type BinaryStreamStart = {
    type: "start";
} & BinaryStreamInfo;
export type BinaryStreamChunk = {
    type: "chunk";
    chunk: `binary_U${string}`;
};
export type BinaryStreamEnd = {
    type: "end";
};
export type BinaryCoStreamMeta = JsonObject & {
    type: "binary";
};
export type BinaryStreamItem = BinaryStreamStart | BinaryStreamChunk | BinaryStreamEnd;
export type CoStreamItem<Item extends JsonValue> = {
    value: Item;
    tx: TransactionID;
    madeAt: number;
};
export declare class RawCoStreamView<Item extends JsonValue = JsonValue, Meta extends JsonObject | null = JsonObject | null> implements RawCoValue {
    id: CoID<this>;
    type: "costream";
    core: CoValueCore;
    items: {
        [key: SessionID]: CoStreamItem<Item>[];
    };
    /** @internal */
    knownTransactions: CoValueKnownState["sessions"];
    totalValidTransactions: number;
    readonly _item: Item;
    constructor(core: CoValueCore);
    get headerMeta(): Meta;
    get group(): RawGroup;
    /** Not yet implemented */
    atTime(_time: number): this;
    /** @internal */
    protected compareStreamItems(a: CoStreamItem<Item>, b: CoStreamItem<Item>): number;
    /** @internal */
    processNewTransactions(): void;
    getSingleStream(): Item[] | undefined;
    sessions(): SessionID[];
    accounts(): Set<RawAccountID>;
    nthItemIn(sessionID: SessionID, n: number): {
        by: RawAccountID | AgentID;
        tx: TransactionID;
        at: Date;
        value: Item;
    } | undefined;
    lastItemIn(sessionID: SessionID): {
        by: RawAccountID | AgentID;
        tx: TransactionID;
        at: Date;
        value: Item;
    } | undefined;
    itemsIn(sessionID: SessionID): Generator<{
        by: RawAccountID | `sealer_z${string}/signer_z${string}`;
        tx: TransactionID;
        at: Date;
        value: Item;
    }, void, unknown>;
    lastItemBy(account: RawAccountID | AgentID): {
        by: RawAccountID | AgentID;
        tx: TransactionID;
        at: Date;
        value: Item;
    } | undefined;
    itemsBy(account: RawAccountID | AgentID): Generator<{
        by: RawAccountID | `sealer_z${string}/signer_z${string}`;
        tx: TransactionID;
        at: Date;
        value: Item;
        in: SessionID;
    }, void, unknown>;
    toJSON(): {
        [key: SessionID]: Item[];
    };
    subscribe(listener: (coStream: this) => void): () => void;
}
export declare class RawCoStream<Item extends JsonValue = JsonValue, Meta extends JsonObject | null = JsonObject | null> extends RawCoStreamView<Item, Meta> implements RawCoValue {
    push(item: Item, privacy?: "private" | "trusting"): void;
}
export declare class RawBinaryCoStreamView<Meta extends BinaryCoStreamMeta = {
    type: "binary";
}> extends RawCoStreamView<BinaryStreamItem, Meta> implements RawCoValue {
    isBinaryStreamEnded(): boolean;
    getBinaryChunks(allowUnfinished?: boolean): (BinaryStreamInfo & {
        chunks: Uint8Array[];
        finished: boolean;
    }) | undefined;
}
export declare class RawBinaryCoStream<Meta extends BinaryCoStreamMeta = {
    type: "binary";
}> extends RawBinaryCoStreamView<Meta> implements RawCoValue {
    /** @internal */
    push(item: BinaryStreamItem, privacy?: "private" | "trusting", updateView?: boolean): void;
    startBinaryStream(settings: BinaryStreamInfo, privacy?: "private" | "trusting"): void;
    pushBinaryStreamChunk(chunk: Uint8Array, privacy?: "private" | "trusting"): void;
    endBinaryStream(privacy?: "private" | "trusting"): void;
}
//# sourceMappingURL=coStream.d.ts.map