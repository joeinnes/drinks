import { ValueType } from "@opentelemetry/api";
import { metrics } from "@opentelemetry/api";
import { emptyKnownState } from "./sync.js";
export const CO_VALUE_LOADING_CONFIG = {
    MAX_RETRIES: 2,
    TIMEOUT: 30000,
};
export class CoValueState {
    constructor(id) {
        this.peers = new Map();
        this.core = null;
        this.listeners = new Set();
        this.id = id;
        this.counter = metrics
            .getMeter("cojson")
            .createUpDownCounter("jazz.covalues.loaded", {
            description: "The number of covalues in the system",
            unit: "covalue",
            valueType: ValueType.INT,
        });
        this.updateCounter(null);
    }
    get highLevelState() {
        if (this.core) {
            return "available";
        }
        else if (this.peers.size === 0) {
            return "unknown";
        }
        for (const peer of this.peers.values()) {
            if (peer.type === "pending") {
                return "loading";
            }
            else if (peer.type === "unknown") {
                return "unknown";
            }
        }
        return "unavailable";
    }
    isErroredInPeer(peerId) {
        return this.peers.get(peerId)?.type === "errored";
    }
    isAvailable() {
        return !!this.core;
    }
    addListener(listener) {
        this.listeners.add(listener);
        listener(this);
    }
    removeListener(listener) {
        this.listeners.delete(listener);
    }
    notifyListeners() {
        for (const listener of this.listeners) {
            listener(this);
        }
    }
    async getCoValue() {
        if (this.core) {
            return this.core;
        }
        if (this.highLevelState === "unavailable") {
            return "unavailable";
        }
        return new Promise((resolve) => {
            const listener = (state) => {
                if (state.core) {
                    resolve(state.core);
                    this.removeListener(listener);
                }
                else if (state.highLevelState === "unavailable") {
                    resolve("unavailable");
                    this.removeListener(listener);
                }
            };
            this.addListener(listener);
        });
    }
    async loadFromPeers(peers) {
        if (peers.length === 0) {
            return;
        }
        const peersToActuallyLoadFrom = [];
        for (const peer of peers) {
            const currentState = this.peers.get(peer.id);
            if (currentState?.type === "available" ||
                currentState?.type === "pending") {
                continue;
            }
            if (currentState?.type === "errored") {
                continue;
            }
            if (currentState?.type === "unavailable") {
                if (peer.shouldRetryUnavailableCoValues()) {
                    this.markPending(peer.id);
                    peersToActuallyLoadFrom.push(peer);
                }
                continue;
            }
            if (!currentState || currentState?.type === "unknown") {
                this.markPending(peer.id);
                peersToActuallyLoadFrom.push(peer);
            }
        }
        for (const peer of peersToActuallyLoadFrom) {
            if (peer.closed) {
                this.markNotFoundInPeer(peer.id);
                continue;
            }
            peer.pushOutgoingMessage({
                action: "load",
                ...(this.core ? this.core.knownState() : emptyKnownState(this.id)),
            });
            /**
             * Use a very long timeout for storage peers, because under pressure
             * they may take a long time to consume the messages queue
             *
             * TODO: Track errors on storage and do not rely on timeout
             */
            const timeoutDuration = peer.role === "storage"
                ? CO_VALUE_LOADING_CONFIG.TIMEOUT * 10
                : CO_VALUE_LOADING_CONFIG.TIMEOUT;
            const waitingForPeer = new Promise((resolve) => {
                const markNotFound = () => {
                    if (this.peers.get(peer.id)?.type === "pending") {
                        this.markNotFoundInPeer(peer.id);
                    }
                };
                const timeout = setTimeout(markNotFound, timeoutDuration);
                const removeCloseListener = peer.addCloseListener(markNotFound);
                const listener = (state) => {
                    const peerState = state.peers.get(peer.id);
                    if (state.isAvailable() || // might have become available from another peer e.g. through handleNewContent
                        peerState?.type === "available" ||
                        peerState?.type === "errored" ||
                        peerState?.type === "unavailable") {
                        state.removeListener(listener);
                        removeCloseListener();
                        clearTimeout(timeout);
                        resolve();
                    }
                };
                this.addListener(listener);
            });
            await waitingForPeer;
        }
    }
    updateCounter(previousState) {
        const newState = this.highLevelState;
        if (previousState !== newState) {
            if (previousState) {
                this.counter.add(-1, { state: previousState });
            }
            this.counter.add(1, { state: newState });
        }
    }
    markNotFoundInPeer(peerId) {
        const previousState = this.highLevelState;
        this.peers.set(peerId, { type: "unavailable" });
        this.updateCounter(previousState);
        this.notifyListeners();
    }
    // TODO: rename to "provided"
    markAvailable(coValue, fromPeerId) {
        const previousState = this.highLevelState;
        this.core = coValue;
        this.peers.set(fromPeerId, { type: "available" });
        this.updateCounter(previousState);
        this.notifyListeners();
    }
    internalMarkMagicallyAvailable(coValue) {
        const previousState = this.highLevelState;
        this.core = coValue;
        this.updateCounter(previousState);
        this.notifyListeners();
    }
    markErrored(peerId, error) {
        const previousState = this.highLevelState;
        this.peers.set(peerId, { type: "errored", error });
        this.updateCounter(previousState);
        this.notifyListeners();
    }
    markPending(peerId) {
        const previousState = this.highLevelState;
        this.peers.set(peerId, { type: "pending" });
        this.updateCounter(previousState);
        this.notifyListeners();
    }
}
//# sourceMappingURL=coValueState.js.map