import React, { useCallback, useContext, useRef, useSyncExternalStore, } from "react";
import { InboxSender, createCoValueObservable, } from "jazz-tools";
import { JazzContext, JazzContextManagerContext, } from "./provider.js";
import { getCurrentAccountFromContextManager } from "./utils.js";
import { subscribeToContextManager } from "./utils.js";
export function useJazzContext() {
    const value = useContext(JazzContext);
    if (!value) {
        throw new Error("You need to set up a JazzProvider on top of your app to use this hook.");
    }
    return value;
}
export function useJazzContextManager() {
    const value = useContext(JazzContextManagerContext);
    if (!value) {
        throw new Error("You need to set up a JazzProvider on top of your app to use this hook.");
    }
    return value;
}
export function useAuthSecretStorage() {
    const value = useContext(JazzContextManagerContext);
    if (!value) {
        throw new Error("You need to set up a JazzProvider on top of your app to use this useAuthSecretStorage.");
    }
    return value.getAuthSecretStorage();
}
export function useIsAuthenticated() {
    const authSecretStorage = useAuthSecretStorage();
    return useSyncExternalStore(useCallback((callback) => {
        return authSecretStorage.onUpdate(callback);
    }, [authSecretStorage]), () => authSecretStorage.isAuthenticated, () => authSecretStorage.isAuthenticated);
}
function useCoValueObservable() {
    const [initialValue] = React.useState(() => createCoValueObservable());
    const ref = useRef(initialValue);
    return {
        getCurrentValue() {
            return ref.current.getCurrentValue();
        },
        getCurrentObservable() {
            return ref.current;
        },
        reset(initialValue) {
            ref.current = createCoValueObservable(initialValue);
        },
    };
}
export function useCoState(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
Schema, id, options) {
    const contextManager = useJazzContextManager();
    const observable = useCoValueObservable();
    const value = React.useSyncExternalStore(React.useCallback((callback) => {
        if (!id) {
            observable.reset(null);
            return () => { };
        }
        observable.reset();
        // We subscribe to the context manager to react to the account updates
        // faster than the useSyncExternalStore callback update to keep the isAuthenticated state
        // up to date with the data when logging in and out.
        return subscribeToContextManager(contextManager, () => {
            const agent = getCurrentAccountFromContextManager(contextManager);
            observable.reset();
            return observable.getCurrentObservable().subscribe(Schema, id, {
                loadAs: agent,
                resolve: options?.resolve,
                onUnauthorized: callback,
                onUnavailable: callback,
                syncResolution: true,
            }, callback);
        });
    }, [Schema, id, contextManager]), () => observable.getCurrentValue(), () => observable.getCurrentValue());
    return value;
}
function useAccount(options) {
    const context = useJazzContext();
    const contextManager = useJazzContextManager();
    if (!("me" in context)) {
        throw new Error("useAccount can't be used in a JazzProvider with auth === 'guest' - consider using useAccountOrGuest()");
    }
    const observable = useCoValueObservable();
    const me = React.useSyncExternalStore(React.useCallback((callback) => {
        return subscribeToContextManager(contextManager, () => {
            const agent = getCurrentAccountFromContextManager(contextManager);
            if (agent._type === "Anonymous") {
                throw new Error("useAccount can't be used in a JazzProvider with auth === 'guest' - consider using useAccountOrGuest()");
            }
            observable.reset();
            const Schema = agent.constructor;
            return observable.getCurrentObservable().subscribe(Schema, agent.id, {
                loadAs: agent,
                resolve: options?.resolve,
                onUnauthorized: callback,
                onUnavailable: callback,
                syncResolution: true,
            }, callback);
        });
    }, [contextManager]), () => observable.getCurrentValue(), () => observable.getCurrentValue());
    return {
        me: options?.resolve === undefined ? me || context.me : me,
        logOut: contextManager.logOut,
    };
}
function useAccountOrGuest(options) {
    const context = useJazzContext();
    const contextManager = useJazzContextManager();
    const observable = useCoValueObservable();
    const me = React.useSyncExternalStore(React.useCallback((callback) => {
        return subscribeToContextManager(contextManager, () => {
            const agent = getCurrentAccountFromContextManager(contextManager);
            if (agent._type === "Anonymous") {
                return () => { };
            }
            observable.reset();
            const Schema = agent.constructor;
            return observable.getCurrentObservable().subscribe(Schema, agent.id, {
                loadAs: agent,
                resolve: options?.resolve,
                onUnauthorized: callback,
                onUnavailable: callback,
                syncResolution: true,
            }, callback);
        });
    }, [contextManager]), () => observable.getCurrentValue(), () => observable.getCurrentValue());
    if ("me" in context) {
        return {
            me: options?.resolve === undefined ? me || context.me : me,
        };
    }
    else {
        return { me: context.guest };
    }
}
export { useAccount, useAccountOrGuest };
export function experimental_useInboxSender(inboxOwnerID) {
    const context = useJazzContext();
    if (!("me" in context)) {
        throw new Error("useInboxSender can't be used in a JazzProvider with auth === 'guest'.");
    }
    const me = context.me;
    const inboxRef = useRef(undefined);
    const sendMessage = useCallback(async (message) => {
        if (!inboxOwnerID)
            throw new Error("Inbox owner ID is required");
        if (!inboxRef.current) {
            const inbox = InboxSender.load(inboxOwnerID, me);
            inboxRef.current = inbox;
        }
        let inbox = await inboxRef.current;
        // @ts-expect-error inbox.owner.id is typed as RawAccount id
        if (inbox.owner.id !== inboxOwnerID) {
            const req = InboxSender.load(inboxOwnerID, me);
            inboxRef.current = req;
            inbox = await req;
        }
        return inbox.sendMessage(message);
    }, [inboxOwnerID]);
    return sendMessage;
}
//# sourceMappingURL=hooks.js.map