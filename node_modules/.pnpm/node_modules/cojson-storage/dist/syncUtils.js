import { cojsonInternals, } from "cojson";
export function collectNewTxs({ newTxsInSession, newContentMessages, sessionRow, firstNewTxIdx, }) {
    for (const tx of newTxsInSession) {
        const lastMessage = newContentMessages[newContentMessages.length - 1];
        if (!lastMessage)
            return;
        let sessionEntry = lastMessage.new[sessionRow.sessionID];
        if (!sessionEntry) {
            sessionEntry = {
                after: firstNewTxIdx,
                lastSignature: "WILL_BE_REPLACED",
                newTransactions: [],
            };
            lastMessage.new[sessionRow.sessionID] = sessionEntry;
        }
        sessionEntry.newTransactions.push(tx.tx);
        sessionEntry.lastSignature = sessionRow.lastSignature;
    }
}
export function getDependedOnCoValues({ coValueRow, newContentMessages, }) {
    return coValueRow.header.ruleset.type === "group"
        ? getGroupDependedOnCoValues(newContentMessages)
        : coValueRow.header.ruleset.type === "ownedByGroup"
            ? getOwnedByGroupDependedOnCoValues(coValueRow, newContentMessages)
            : [];
}
function getGroupDependedOnCoValues(newContentMessages) {
    const keys = [];
    /**
     * Collect all the signing keys inside the transactions to list all the
     * dependencies required to correctly access the CoValue.
     */
    for (const piece of newContentMessages) {
        for (const sessionEntry of Object.values(piece.new)) {
            for (const tx of sessionEntry.newTransactions) {
                if (tx.privacy !== "trusting")
                    continue;
                const changes = safeParseChanges(tx.changes);
                for (const change of changes) {
                    if (change &&
                        typeof change === "object" &&
                        "op" in change &&
                        change.op === "set" &&
                        "key" in change &&
                        change.key) {
                        const key = cojsonInternals.getGroupDependentKey(change.key);
                        if (key) {
                            keys.push(key);
                        }
                    }
                }
            }
        }
    }
    return keys;
}
function getOwnedByGroupDependedOnCoValues(coValueRow, newContentMessages) {
    if (coValueRow.header.ruleset.type !== "ownedByGroup")
        return [];
    const keys = [coValueRow.header.ruleset.group];
    /**
     * Collect all the signing keys inside the transactions to list all the
     * dependencies required to correctly access the CoValue.
     */
    for (const piece of newContentMessages) {
        for (const sessionID of Object.keys(piece.new)) {
            const accountId = cojsonInternals.accountOrAgentIDfromSessionID(sessionID);
            if (cojsonInternals.isAccountID(accountId) &&
                accountId !== coValueRow.id) {
                keys.push(accountId);
            }
        }
    }
    return keys;
}
function safeParseChanges(changes) {
    try {
        return cojsonInternals.parseJSON(changes);
    }
    catch (e) {
        return [];
    }
}
//# sourceMappingURL=syncUtils.js.map