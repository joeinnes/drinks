import { IDBStorage } from "cojson-storage-indexeddb";
import { WebSocketPeerWithReconnection } from "cojson-transport-ws";
import { WasmCrypto } from "cojson/crypto/WasmCrypto";
import { cojsonInternals, createAnonymousJazzContext, } from "jazz-tools";
import { createJazzContext } from "jazz-tools";
import { getStorageOptions } from "./storageOptions.js";
import { setupInspector } from "./utils/export-account-inspector.js";
setupInspector();
class BrowserWebSocketPeerWithReconnection extends WebSocketPeerWithReconnection {
    onNetworkChange(callback) {
        const handler = () => callback(navigator.onLine);
        window.addEventListener("online", handler);
        window.addEventListener("offline", handler);
        return () => {
            window.removeEventListener("online", handler);
            window.removeEventListener("offline", handler);
        };
    }
}
async function setupPeers(options) {
    const crypto = options.crypto || (await WasmCrypto.create());
    let node = undefined;
    const { useIndexedDB } = getStorageOptions(options.storage);
    const peersToLoadFrom = [];
    if (useIndexedDB) {
        peersToLoadFrom.push(await IDBStorage.asPeer());
    }
    if (options.sync.when === "never") {
        return {
            toggleNetwork: () => { },
            peersToLoadFrom,
            setNode: () => { },
            crypto,
        };
    }
    const wsPeer = new BrowserWebSocketPeerWithReconnection({
        peer: options.sync.peer,
        reconnectionTimeout: options.reconnectionTimeout,
        addPeer: (peer) => {
            if (node) {
                node.syncManager.addPeer(peer);
            }
            else {
                peersToLoadFrom.push(peer);
            }
        },
        removePeer: (peer) => {
            peersToLoadFrom.splice(peersToLoadFrom.indexOf(peer), 1);
        },
    });
    function toggleNetwork(enabled) {
        if (enabled) {
            wsPeer.enable();
        }
        else {
            wsPeer.disable();
        }
    }
    function setNode(value) {
        node = value;
    }
    if (options.sync.when === "always" || !options.sync.when) {
        toggleNetwork(true);
    }
    return {
        toggleNetwork,
        peersToLoadFrom,
        setNode,
        crypto,
    };
}
export async function createJazzBrowserGuestContext(options) {
    const { toggleNetwork, peersToLoadFrom, setNode, crypto } = await setupPeers(options);
    const context = await createAnonymousJazzContext({
        crypto,
        peersToLoadFrom,
    });
    setNode(context.agent.node);
    options.authSecretStorage.emitUpdate(null);
    return {
        guest: context.agent,
        node: context.agent.node,
        done: () => {
            // TODO: Sync all the covalues before closing the connection & context
            toggleNetwork(false);
            context.done();
        },
        logOut: () => {
            return context.logOut();
        },
    };
}
export async function createJazzBrowserContext(options) {
    const { toggleNetwork, peersToLoadFrom, setNode, crypto } = await setupPeers(options);
    let unsubscribeAuthUpdate = () => { };
    if (options.sync.when === "signedUp") {
        const authSecretStorage = options.authSecretStorage;
        const credentials = options.credentials ?? (await authSecretStorage.get());
        function handleAuthUpdate(isAuthenticated) {
            if (isAuthenticated) {
                toggleNetwork(true);
            }
            else {
                toggleNetwork(false);
            }
        }
        unsubscribeAuthUpdate = authSecretStorage.onUpdate(handleAuthUpdate);
        handleAuthUpdate(authSecretStorage.getIsAuthenticated(credentials));
    }
    const context = await createJazzContext({
        credentials: options.credentials,
        newAccountProps: options.newAccountProps,
        peersToLoadFrom,
        crypto,
        defaultProfileName: options.defaultProfileName,
        AccountSchema: options.AccountSchema,
        sessionProvider: provideBrowserLockSession,
        authSecretStorage: options.authSecretStorage,
    });
    setNode(context.node);
    return {
        me: context.account,
        node: context.node,
        authSecretStorage: context.authSecretStorage,
        done: () => {
            // TODO: Sync all the covalues before closing the connection & context
            toggleNetwork(false);
            unsubscribeAuthUpdate();
            context.done();
        },
        logOut: () => {
            unsubscribeAuthUpdate();
            return context.logOut();
        },
    };
}
export function provideBrowserLockSession(accountID, crypto) {
    let sessionDone;
    const donePromise = new Promise((resolve) => {
        sessionDone = resolve;
    });
    let resolveSession;
    const sessionPromise = new Promise((resolve) => {
        resolveSession = resolve;
    });
    void (async function () {
        for (let idx = 0; idx < 100; idx++) {
            // To work better around StrictMode
            for (let retry = 0; retry < 2; retry++) {
                // console.debug("Trying to get lock", accountID + "_" + idx);
                const sessionFinishedOrNoLock = await navigator.locks.request(accountID + "_" + idx, { ifAvailable: true }, async (lock) => {
                    if (!lock)
                        return "noLock";
                    const sessionID = localStorage.getItem(accountID + "_" + idx) ||
                        crypto.newRandomSessionID(accountID);
                    localStorage.setItem(accountID + "_" + idx, sessionID);
                    resolveSession(sessionID);
                    await donePromise;
                    console.log("Done with lock", accountID + "_" + idx, sessionID);
                    return "sessionFinished";
                });
                if (sessionFinishedOrNoLock === "sessionFinished") {
                    return;
                }
            }
        }
        throw new Error("Couldn't get lock on session after 100x2 tries");
    })();
    return sessionPromise.then((sessionID) => ({
        sessionID,
        sessionDone,
    }));
}
/** @category Invite Links */
export function createInviteLink(value, role, 
// default to same address as window.location, but without hash
{ baseURL = window.location.href.replace(/#.*$/, ""), valueHint, } = {}) {
    const coValueCore = value._raw.core;
    let currentCoValue = coValueCore;
    while (currentCoValue.header.ruleset.type === "ownedByGroup") {
        currentCoValue = currentCoValue.getGroup().core;
    }
    const { ruleset, meta } = currentCoValue.header;
    if (ruleset.type !== "group" || meta?.type === "account") {
        throw new Error("Can't create invite link for object without group");
    }
    const group = cojsonInternals.expectGroup(currentCoValue.getCurrentContent());
    const inviteSecret = group.createInvite(role);
    return `${baseURL}#/invite/${valueHint ? valueHint + "/" : ""}${value.id}/${inviteSecret}`;
}
/** @category Invite Links */
export function parseInviteLink(inviteURL) {
    const url = new URL(inviteURL);
    const parts = url.hash.split("/");
    let valueHint;
    let valueID;
    let inviteSecret;
    if (parts[0] === "#" && parts[1] === "invite") {
        if (parts.length === 5) {
            valueHint = parts[2];
            valueID = parts[3];
            inviteSecret = parts[4];
        }
        else if (parts.length === 4) {
            valueID = parts[2];
            inviteSecret = parts[3];
        }
        if (!valueID || !inviteSecret) {
            return undefined;
        }
        return { valueID, inviteSecret, valueHint };
    }
}
//# sourceMappingURL=createBrowserContext.js.map