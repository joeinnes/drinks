import { PeerKnownStates } from "./PeerKnownStates.js";
import { PriorityBasedMessageQueue } from "./PriorityBasedMessageQueue.js";
import { logger } from "./logger.js";
import { CO_VALUE_PRIORITY } from "./priority.js";
export class PeerState {
    constructor(peer, knownStates) {
        this.peer = peer;
        this.toldKnownState = new Set();
        this.processing = false;
        this.closed = false;
        this.closeListeners = new Set();
        /**
         * We set as default priority HIGH to handle all the messages without a
         * priority property as HIGH priority.
         *
         * This way we consider all the non-content messsages as HIGH priority.
         */
        this.queue = new PriorityBasedMessageQueue(CO_VALUE_PRIORITY.HIGH, {
            peerRole: peer.role,
        });
        this._knownStates = knownStates?.clone() ?? new PeerKnownStates();
        // We assume that exchanges with storage peers are always successful
        // hence we don't need to differentiate between knownStates and optimisticKnownStates
        if (peer.role === "storage") {
            this._optimisticKnownStates = "assumeInfallible";
        }
        else {
            this._optimisticKnownStates =
                knownStates?.clone() ?? new PeerKnownStates();
        }
    }
    get knownStates() {
        return this._knownStates;
    }
    get optimisticKnownStates() {
        if (this._optimisticKnownStates === "assumeInfallible") {
            return this.knownStates;
        }
        return this._optimisticKnownStates;
    }
    updateHeader(id, header) {
        this._knownStates.updateHeader(id, header);
        if (this._optimisticKnownStates !== "assumeInfallible") {
            this._optimisticKnownStates.updateHeader(id, header);
        }
    }
    combineWith(id, value) {
        this._knownStates.combineWith(id, value);
        if (this._optimisticKnownStates !== "assumeInfallible") {
            this._optimisticKnownStates.combineWith(id, value);
        }
    }
    combineOptimisticWith(id, value) {
        if (this._optimisticKnownStates === "assumeInfallible") {
            this._knownStates.combineWith(id, value);
        }
        else {
            this._optimisticKnownStates.combineWith(id, value);
        }
    }
    updateSessionCounter(id, sessionId, value) {
        this._knownStates.updateSessionCounter(id, sessionId, value);
        if (this._optimisticKnownStates !== "assumeInfallible") {
            this._optimisticKnownStates.updateSessionCounter(id, sessionId, value);
        }
    }
    setKnownState(id, knownState) {
        this._knownStates.set(id, knownState);
        if (this._optimisticKnownStates !== "assumeInfallible") {
            this._optimisticKnownStates.set(id, knownState);
        }
    }
    setOptimisticKnownState(id, knownState) {
        if (this._optimisticKnownStates === "assumeInfallible") {
            this._knownStates.set(id, knownState);
        }
        else {
            this._optimisticKnownStates.set(id, knownState);
        }
    }
    get id() {
        return this.peer.id;
    }
    get role() {
        return this.peer.role;
    }
    get priority() {
        return this.peer.priority;
    }
    get crashOnClose() {
        return this.peer.crashOnClose;
    }
    shouldRetryUnavailableCoValues() {
        return this.peer.role === "server";
    }
    isServerOrStoragePeer() {
        return this.peer.role === "server" || this.peer.role === "storage";
    }
    async processQueue() {
        if (this.processing) {
            return;
        }
        this.processing = true;
        let msg;
        while ((msg = this.queue.pull())) {
            if (this.closed) {
                break;
            }
            // Awaiting the push to send one message at a time
            // This way when the peer is "under pressure" we can enqueue all
            // the coming messages and organize them by priority
            try {
                await this.peer.outgoing.push(msg);
            }
            catch (e) {
                logger.error("Error sending message", {
                    err: e,
                    action: msg.action,
                    id: msg.id,
                    peerId: this.id,
                    peerRole: this.role,
                });
            }
        }
        this.processing = false;
    }
    pushOutgoingMessage(msg) {
        if (this.closed) {
            return;
        }
        this.queue.push(msg);
        void this.processQueue();
    }
    isProcessing() {
        return this.processing;
    }
    get incoming() {
        if (this.closed) {
            return (async function* () {
                yield "Disconnected";
            })();
        }
        return this.peer.incoming;
    }
    addCloseListener(listener) {
        if (this.closed) {
            listener();
            return () => { };
        }
        this.closeListeners.add(listener);
        return () => {
            this.closeListeners.delete(listener);
        };
    }
    emitClose() {
        for (const listener of this.closeListeners) {
            listener();
        }
        this.closeListeners.clear();
    }
    gracefulShutdown() {
        logger.debug("Gracefully closing", {
            peerId: this.id,
            peerRole: this.role,
        });
        this.peer.outgoing.close();
        this.closed = true;
        this.emitClose();
    }
    async processIncomingMessages(callback) {
        if (this.closed) {
            throw new Error("Peer is closed");
        }
        const processIncomingMessages = async () => {
            for await (const msg of this.incoming) {
                if (this.closed) {
                    return;
                }
                if (msg === "Disconnected") {
                    return;
                }
                if (msg === "PingTimeout") {
                    logger.error("Ping timeout from peer", {
                        peerId: this.id,
                        peerRole: this.role,
                    });
                    return;
                }
                callback(msg);
            }
        };
        return processIncomingMessages();
    }
}
//# sourceMappingURL=PeerState.js.map