import { accountOrAgentIDfromSessionID } from "../typeUtils/accountOrAgentIDfromSessionID.js";
import { isCoValue } from "../typeUtils/isCoValue.js";
export class RawCoMapView {
    /** @internal */
    constructor(core, options) {
        /** @category 6. Meta */
        this.type = "comap";
        /** @internal */
        this.atTimeFilter = undefined;
        this.totalValidTransactions = 0;
        this.id = core.id;
        this.core = core;
        this.latestTxMadeAt = 0;
        this.ignorePrivateTransactions =
            options?.ignorePrivateTransactions ?? false;
        this.ops = {};
        this.latest = {};
        this.knownTransactions = {};
        this.processNewTransactions();
    }
    processNewTransactions() {
        if (this.isTimeTravelEntity()) {
            throw new Error("Cannot process transactions on a time travel entity");
        }
        const newValidTransactions = this.core.getValidTransactions({
            ignorePrivateTransactions: this.ignorePrivateTransactions,
            knownTransactions: this.knownTransactions,
        });
        if (newValidTransactions.length === 0) {
            return;
        }
        const { ops } = this;
        const changedEntries = new Map();
        for (const { txID, changes, madeAt } of newValidTransactions) {
            for (let changeIdx = 0; changeIdx < changes.length; changeIdx++) {
                const change = changes[changeIdx];
                const entry = {
                    txID,
                    madeAt,
                    changeIdx,
                    change,
                };
                if (madeAt > this.latestTxMadeAt) {
                    this.latestTxMadeAt = madeAt;
                }
                const entries = ops[change.key];
                if (!entries) {
                    const entries = [entry];
                    ops[change.key] = entries;
                    changedEntries.set(change.key, entries);
                }
                else {
                    entries.push(entry);
                    changedEntries.set(change.key, entries);
                }
                this.knownTransactions[txID.sessionID] = Math.max(this.knownTransactions[txID.sessionID] ?? 0, txID.txIndex);
            }
        }
        this.totalValidTransactions += newValidTransactions.length;
        for (const entries of changedEntries.values()) {
            entries.sort(this.core.compareTransactions);
        }
        for (const [key, entries] of changedEntries.entries()) {
            this.latest[key] = entries[entries.length - 1];
        }
    }
    isTimeTravelEntity() {
        return Boolean(this.atTimeFilter);
    }
    /** @category 6. Meta */
    get headerMeta() {
        return this.core.header.meta;
    }
    /** @category 6. Meta */
    get group() {
        return this.core.getGroup();
    }
    /** @category 4. Time travel */
    atTime(time) {
        if (time >= this.latestTxMadeAt) {
            return this;
        }
        else {
            const clone = Object.create(this);
            clone.atTimeFilter = time;
            clone.latest = {};
            return clone;
        }
    }
    /** @internal */
    timeFilteredOps(key) {
        if (key === "constructor") {
            return undefined;
        }
        const atTimeFilter = this.atTimeFilter;
        if (atTimeFilter) {
            return this.ops[key]?.filter((op) => op.madeAt <= atTimeFilter);
        }
        else {
            return this.ops[key];
        }
    }
    /**
     * Get all keys currently in the map.
     *
     * @category 1. Reading */
    keys() {
        return Object.keys(this.ops).filter((key) => {
            const entry = this.getRaw(key);
            if (entry === undefined) {
                return false;
            }
            if (entry.change.op === "del") {
                return false;
            }
            return true;
        });
    }
    getRaw(key) {
        let latestChange = this.latest[key];
        if (latestChange === undefined) {
            const entries = this.ops[key];
            // Time travel values are lazily computed
            if (entries && !(key in this.latest)) {
                const atTimeFilter = this.atTimeFilter;
                if (!atTimeFilter) {
                    latestChange = entries[entries.length - 1];
                }
                else {
                    latestChange = entries.findLast((op) => op.madeAt <= atTimeFilter);
                }
                this.latest[key] = latestChange;
            }
            if (latestChange === undefined) {
                return undefined;
            }
        }
        return latestChange;
    }
    /**
     * Returns the current value for the given key.
     *
     * @category 1. Reading
     **/
    get(key) {
        const entry = this.getRaw(key);
        if (entry?.change === undefined) {
            return undefined;
        }
        if (entry.change.op === "del") {
            return undefined;
        }
        else {
            return entry.change.value;
        }
    }
    /** @category 1. Reading */
    asObject() {
        const object = {};
        for (const key of Object.keys(this.ops)) {
            const value = this.get(key);
            if (value !== undefined) {
                object[key] = value;
            }
        }
        return object;
    }
    /** @category 1. Reading */
    toJSON() {
        return this.asObject();
    }
    /** @category 5. Edit history */
    nthEditAt(key, n) {
        const ops = this.ops[key];
        const atTimeFilter = this.atTimeFilter;
        const entry = ops?.[n];
        if (!entry) {
            return undefined;
        }
        if (atTimeFilter && entry.madeAt > atTimeFilter) {
            return undefined;
        }
        return operationToEditEntry(entry);
    }
    /** @category 5. Edit history */
    lastEditAt(key) {
        const entry = this.getRaw(key);
        if (!entry) {
            return undefined;
        }
        return operationToEditEntry(entry);
    }
    /** @category 5. Edit history */
    *editsAt(key) {
        const entries = this.ops[key];
        if (!entries) {
            return;
        }
        const atTimeFilter = this.atTimeFilter;
        for (const entry of entries) {
            // Entries are sorted by madeAt
            if (atTimeFilter && entry.madeAt > atTimeFilter) {
                return;
            }
            yield operationToEditEntry(entry);
        }
    }
    /** @category 3. Subscription */
    subscribe(listener) {
        return this.core.subscribe((content) => {
            listener(content);
        });
    }
}
/** A collaborative map with precise shape `Shape` and optional static metadata `Meta` */
export class RawCoMap extends RawCoMapView {
    /** Set a new value for the given key.
     *
     * If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
     *
     * If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
     *
     * @category 2. Editing
     **/
    set(key, value, privacy = "private") {
        if (this.isTimeTravelEntity()) {
            throw new Error("Cannot set value on a time travel entity");
        }
        this.core.makeTransaction([
            {
                op: "set",
                key,
                value: isCoValue(value) ? value.id : value,
            },
        ], privacy);
        this.processNewTransactions();
    }
    assign(entries, privacy = "private") {
        if (this.isTimeTravelEntity()) {
            throw new Error("Cannot set value on a time travel entity");
        }
        this.core.makeTransaction(Object.entries(entries).map(([key, value]) => ({
            op: "set",
            key,
            value: isCoValue(value) ? value.id : value,
        })), privacy);
        this.processNewTransactions();
    }
    /** Delete the given key (setting it to undefined).
     *
     * If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
     *
     * If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
     *
     * @category 2. Editing
     **/
    delete(key, privacy = "private") {
        if (this.isTimeTravelEntity()) {
            throw new Error("Cannot delete value on a time travel entity");
        }
        this.core.makeTransaction([
            {
                op: "del",
                key,
            },
        ], privacy);
        this.processNewTransactions();
    }
}
export function operationToEditEntry(op) {
    return {
        by: accountOrAgentIDfromSessionID(op.txID.sessionID),
        tx: op.txID,
        at: new Date(op.madeAt),
        value: op.change.op === "del" ? undefined : op.change.value,
    };
}
//# sourceMappingURL=coMap.js.map