import { CoID, RawCoValue } from "../coValue.js";
import { CoValueCore, CoValueHeader, CoValueUniqueness } from "../coValueCore.js";
import { AgentSecret, CryptoProvider, SealerID, SealerSecret, SignerID, SignerSecret } from "../crypto/crypto.js";
import { AgentID } from "../ids.js";
import { JsonObject } from "../jsonValue.js";
import { LocalNode } from "../localNode.js";
import type { AccountRole } from "../permissions.js";
import { RawCoMap } from "./coMap.js";
import { InviteSecret, RawGroup } from "./group.js";
export declare function accountHeaderForInitialAgentSecret(agentSecret: AgentSecret, crypto: CryptoProvider): CoValueHeader;
export type InvalidAccountAgentIDError = {
    type: "InvalidAccountAgentID";
    reason: string;
};
export declare class RawAccount<Meta extends AccountMeta = AccountMeta> extends RawGroup<Meta> {
    _cachedCurrentAgentID: AgentID | undefined;
    currentAgentID(): AgentID;
    createInvite(_: AccountRole): InviteSecret;
}
export interface ControlledAccountOrAgent {
    id: RawAccountID | AgentID;
    agentSecret: AgentSecret;
    currentAgentID: () => AgentID;
    currentSignerID: () => SignerID;
    currentSignerSecret: () => SignerSecret;
    currentSealerID: () => SealerID;
    currentSealerSecret: () => SealerSecret;
}
/** @hidden */
export declare class RawControlledAccount<Meta extends AccountMeta = AccountMeta> extends RawAccount<Meta> implements ControlledAccountOrAgent {
    agentSecret: AgentSecret;
    crypto: CryptoProvider;
    constructor(core: CoValueCore, agentSecret: AgentSecret);
    /**
     * Creates a new group (with the current account as the group's first admin).
     * @category 1. High-level
     */
    createGroup(uniqueness?: CoValueUniqueness): RawGroup<JsonObject | null>;
    acceptInvite<T extends RawCoValue>(groupOrOwnedValueID: CoID<T>, inviteSecret: InviteSecret): Promise<void>;
    currentAgentID(): AgentID;
    currentSignerID(): `signer_z${string}`;
    currentSignerSecret(): SignerSecret;
    currentSealerID(): `sealer_z${string}`;
    currentSealerSecret(): SealerSecret;
}
export declare class ControlledAgent implements ControlledAccountOrAgent {
    agentSecret: AgentSecret;
    crypto: CryptoProvider;
    constructor(agentSecret: AgentSecret, crypto: CryptoProvider);
    get id(): AgentID;
    currentAgentID(): `sealer_z${string}/signer_z${string}`;
    currentSignerID(): `signer_z${string}`;
    currentSignerSecret(): SignerSecret;
    currentSealerID(): `sealer_z${string}`;
    currentSealerSecret(): SealerSecret;
}
export type AccountMeta = {
    type: "account";
};
export type RawAccountID = CoID<RawAccount>;
export type ProfileShape = {
    name: string;
};
export declare class RawProfile<Shape extends ProfileShape = ProfileShape, Meta extends JsonObject | null = JsonObject | null> extends RawCoMap<Shape, Meta> {
}
export type RawAccountMigration<Meta extends AccountMeta = AccountMeta> = (account: RawControlledAccount<Meta>, localNode: LocalNode, creationProps?: {
    name: string;
}) => void | Promise<void>;
//# sourceMappingURL=account.d.ts.map