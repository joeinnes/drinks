import { xsalsa20, xsalsa20_poly1305 } from "@noble/ciphers/salsa";
import { ed25519, x25519 } from "@noble/curves/ed25519";
import { blake3 } from "@noble/hashes/blake3";
import { base58 } from "@scure/base";
import { base64URLtoBytes, bytesToBase64url } from "../base64url.js";
import { stableStringify } from "../jsonStringify.js";
import { logger } from "../logger.js";
import { CryptoProvider, textDecoder, textEncoder, } from "./crypto.js";
/**
 * Pure JavaScript implementation of the CryptoProvider interface using noble-curves and noble-ciphers libraries.
 * This provides a fallback implementation that doesn't require WebAssembly, offering:
 * - Signing/verifying (Ed25519)
 * - Encryption/decryption (XSalsa20)
 * - Sealing/unsealing (X25519 + XSalsa20-Poly1305)
 * - Hashing (BLAKE3)
 */
export class PureJSCrypto extends CryptoProvider {
    static async create() {
        return new PureJSCrypto();
    }
    emptyBlake3State() {
        return blake3.create({});
    }
    cloneBlake3State(state) {
        return state.clone();
    }
    blake3HashOnce(data) {
        return blake3(data);
    }
    blake3HashOnceWithContext(data, { context }) {
        return blake3.create({}).update(context).update(data).digest();
    }
    blake3IncrementalUpdate(state, data) {
        return state.update(data);
    }
    blake3DigestForState(state) {
        return state.clone().digest();
    }
    generateNonce(input) {
        return this.blake3HashOnce(input).slice(0, 24);
    }
    generateJsonNonce(material) {
        return this.generateNonce(textEncoder.encode(stableStringify(material)));
    }
    newEd25519SigningKey() {
        return ed25519.utils.randomPrivateKey();
    }
    getSignerID(secret) {
        return `signer_z${base58.encode(ed25519.getPublicKey(base58.decode(secret.substring("signerSecret_z".length))))}`;
    }
    sign(secret, message) {
        const signature = ed25519.sign(textEncoder.encode(stableStringify(message)), base58.decode(secret.substring("signerSecret_z".length)));
        return `signature_z${base58.encode(signature)}`;
    }
    verify(signature, message, id) {
        return ed25519.verify(base58.decode(signature.substring("signature_z".length)), textEncoder.encode(stableStringify(message)), base58.decode(id.substring("signer_z".length)));
    }
    newX25519StaticSecret() {
        return x25519.utils.randomPrivateKey();
    }
    getSealerID(secret) {
        return `sealer_z${base58.encode(x25519.getPublicKey(base58.decode(secret.substring("sealerSecret_z".length))))}`;
    }
    encrypt(value, keySecret, nOnceMaterial) {
        const keySecretBytes = base58.decode(keySecret.substring("keySecret_z".length));
        const nOnce = this.generateJsonNonce(nOnceMaterial);
        const plaintext = textEncoder.encode(stableStringify(value));
        const ciphertext = xsalsa20(keySecretBytes, nOnce, plaintext);
        return `encrypted_U${bytesToBase64url(ciphertext)}`;
    }
    decryptRaw(encrypted, keySecret, nOnceMaterial) {
        const keySecretBytes = base58.decode(keySecret.substring("keySecret_z".length));
        const nOnce = this.generateJsonNonce(nOnceMaterial);
        const ciphertext = base64URLtoBytes(encrypted.substring("encrypted_U".length));
        const plaintext = xsalsa20(keySecretBytes, nOnce, ciphertext);
        return textDecoder.decode(plaintext);
    }
    seal({ message, from, to, nOnceMaterial, }) {
        const nOnce = this.generateJsonNonce(nOnceMaterial);
        const sealerPub = base58.decode(to.substring("sealer_z".length));
        const senderPriv = base58.decode(from.substring("sealerSecret_z".length));
        const plaintext = textEncoder.encode(stableStringify(message));
        const sharedSecret = x25519.getSharedSecret(senderPriv, sealerPub);
        const sealedBytes = xsalsa20_poly1305(sharedSecret, nOnce).encrypt(plaintext);
        return `sealed_U${bytesToBase64url(sealedBytes)}`;
    }
    unseal(sealed, sealer, from, nOnceMaterial) {
        const nOnce = this.generateJsonNonce(nOnceMaterial);
        const sealerPriv = base58.decode(sealer.substring("sealerSecret_z".length));
        const senderPub = base58.decode(from.substring("sealer_z".length));
        const sealedBytes = base64URLtoBytes(sealed.substring("sealed_U".length));
        const sharedSecret = x25519.getSharedSecret(sealerPriv, senderPub);
        const plaintext = xsalsa20_poly1305(sharedSecret, nOnce).decrypt(sealedBytes);
        try {
            return JSON.parse(textDecoder.decode(plaintext));
        }
        catch (e) {
            logger.error("Failed to decrypt/parse sealed message", { err: e });
            return undefined;
        }
    }
}
//# sourceMappingURL=PureJSCrypto.js.map