import { base58 } from "@scure/base";
import { parseJSON, stableStringify } from "../jsonStringify.js";
import { logger } from "../logger.js";
function randomBytes(bytesLength = 32) {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
}
export const textEncoder = new TextEncoder();
export const textDecoder = new TextDecoder();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export class CryptoProvider {
    randomBytes(length) {
        return randomBytes(length);
    }
    newRandomSigner() {
        return `signerSecret_z${base58.encode(this.newEd25519SigningKey())}`;
    }
    signerSecretToBytes(secret) {
        return base58.decode(secret.substring("signerSecret_z".length));
    }
    signerSecretFromBytes(bytes) {
        return `signerSecret_z${base58.encode(bytes)}`;
    }
    newRandomSealer() {
        return `sealerSecret_z${base58.encode(this.newX25519StaticSecret())}`;
    }
    sealerSecretToBytes(secret) {
        return base58.decode(secret.substring("sealerSecret_z".length));
    }
    sealerSecretFromBytes(bytes) {
        return `sealerSecret_z${base58.encode(bytes)}`;
    }
    newRandomAgentSecret() {
        return `${this.newRandomSealer()}/${this.newRandomSigner()}`;
    }
    agentSecretToBytes(secret) {
        const [sealerSecret, signerSecret] = secret.split("/");
        return new Uint8Array([
            ...this.sealerSecretToBytes(sealerSecret),
            ...this.signerSecretToBytes(signerSecret),
        ]);
    }
    agentSecretFromBytes(bytes) {
        const sealerSecret = this.sealerSecretFromBytes(bytes.slice(0, 32));
        const signerSecret = this.signerSecretFromBytes(bytes.slice(32));
        return `${sealerSecret}/${signerSecret}`;
    }
    getAgentID(secret) {
        const [sealerSecret, signerSecret] = secret.split("/");
        return `${this.getSealerID(sealerSecret)}/${this.getSignerID(signerSecret)}`;
    }
    getAgentSignerID(agentId) {
        return agentId.split("/")[1];
    }
    getAgentSignerSecret(agentSecret) {
        return agentSecret.split("/")[1];
    }
    getAgentSealerID(agentId) {
        return agentId.split("/")[0];
    }
    getAgentSealerSecret(agentSecret) {
        return agentSecret.split("/")[0];
    }
    secureHash(value) {
        return `hash_z${base58.encode(this.blake3HashOnce(textEncoder.encode(stableStringify(value))))}`;
    }
    shortHash(value) {
        return `shortHash_z${base58.encode(this.blake3HashOnce(textEncoder.encode(stableStringify(value))).slice(0, shortHashLength))}`;
    }
    encryptForTransaction(value, keySecret, nOnceMaterial) {
        return this.encrypt(value, keySecret, nOnceMaterial);
    }
    decrypt(encrypted, keySecret, nOnceMaterial) {
        try {
            return parseJSON(this.decryptRaw(encrypted, keySecret, nOnceMaterial));
        }
        catch (e) {
            logger.error("Decryption error", { err: e });
            return undefined;
        }
    }
    newRandomKeySecret() {
        return {
            secret: `keySecret_z${base58.encode(this.randomBytes(32))}`,
            id: `key_z${base58.encode(this.randomBytes(12))}`,
        };
    }
    decryptRawForTransaction(encrypted, keySecret, nOnceMaterial) {
        return this.decryptRaw(encrypted, keySecret, nOnceMaterial);
    }
    decryptForTransaction(encrypted, keySecret, nOnceMaterial) {
        return this.decrypt(encrypted, keySecret, nOnceMaterial);
    }
    encryptKeySecret(keys) {
        const nOnceMaterial = {
            encryptedID: keys.toEncrypt.id,
            encryptingID: keys.encrypting.id,
        };
        return {
            encryptedID: keys.toEncrypt.id,
            encryptingID: keys.encrypting.id,
            encrypted: this.encrypt(keys.toEncrypt.secret, keys.encrypting.secret, nOnceMaterial),
        };
    }
    decryptKeySecret(encryptedInfo, sealingSecret) {
        const nOnceMaterial = {
            encryptedID: encryptedInfo.encryptedID,
            encryptingID: encryptedInfo.encryptingID,
        };
        return this.decrypt(encryptedInfo.encrypted, sealingSecret, nOnceMaterial);
    }
    uniquenessForHeader() {
        return `z${base58.encode(this.randomBytes(12))}`;
    }
    createdNowUnique() {
        const createdAt = new Date().toISOString();
        return {
            createdAt,
            uniqueness: this.uniquenessForHeader(),
        };
    }
    newRandomSecretSeed() {
        return this.randomBytes(secretSeedLength);
    }
    agentSecretFromSecretSeed(secretSeed) {
        if (secretSeed.length !== secretSeedLength) {
            throw new Error(`Secret seed needs to be ${secretSeedLength} bytes long`);
        }
        return `sealerSecret_z${base58.encode(this.blake3HashOnceWithContext(secretSeed, {
            context: textEncoder.encode("seal"),
        }))}/signerSecret_z${base58.encode(this.blake3HashOnceWithContext(secretSeed, {
            context: textEncoder.encode("sign"),
        }))}`;
    }
    newRandomSessionID(accountID) {
        return `${accountID}_session_z${base58.encode(this.randomBytes(8))}`;
    }
}
export class StreamingHash {
    constructor(crypto, fromClone) {
        this.state = fromClone || crypto.emptyBlake3State();
        this.crypto = crypto;
    }
    update(value) {
        const encoded = textEncoder.encode(stableStringify(value));
        this.state = this.crypto.blake3IncrementalUpdate(this.state, encoded);
        return encoded;
    }
    digest() {
        const hash = this.crypto.blake3DigestForState(this.state);
        return `hash_z${base58.encode(hash)}`;
    }
    clone() {
        return new StreamingHash(this.crypto, this.crypto.cloneBlake3State(this.state));
    }
}
export const shortHashLength = 19;
export const secretSeedLength = 32;
//# sourceMappingURL=crypto.js.map