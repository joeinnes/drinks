import { ValueType, metrics } from "@opentelemetry/api";
import { CO_VALUE_PRIORITY } from "./priority.js";
/**
 * Using a linked list to make the shift operation O(1) instead of O(n)
 * as our queues can grow very large when the system is under pressure.
 */
export class LinkedList {
    constructor(meter) {
        this.meter = meter;
        this.head = undefined;
        this.tail = undefined;
        this.length = 0;
    }
    push(value) {
        const node = { value, next: undefined };
        if (this.head === undefined) {
            this.head = node;
            this.tail = node;
        }
        else if (this.tail) {
            this.tail.next = node;
            this.tail = node;
        }
        else {
            throw new Error("LinkedList is corrupted");
        }
        this.length++;
        this.meter?.push();
    }
    shift() {
        if (!this.head) {
            return undefined;
        }
        const node = this.head;
        const value = node.value;
        this.head = node.next;
        node.next = undefined;
        if (this.head === undefined) {
            this.tail = undefined;
        }
        this.length--;
        this.meter?.pull();
        return value;
    }
}
class QueueMeter {
    constructor(prefix, attrs) {
        this.attrs = attrs;
        this.pullCounter = metrics
            .getMeter("cojosn")
            .createCounter(`${prefix}.pulled`, {
            description: "Number of messages pulled from the queue",
            valueType: ValueType.INT,
            unit: "1",
        });
        this.pushCounter = metrics
            .getMeter("cojosn")
            .createCounter(`${prefix}.pushed`, {
            description: "Number of messages pushed to the queue",
            valueType: ValueType.INT,
            unit: "1",
        });
        /**
         * This makes sure that those metrics are generated (and emitted) as soon as the queue is created.
         * This is to avoid edge cases where one series reset is delayed, which would cause spikes or dips
         * when queried - and it also more correctly represents the actual state of the queue after a restart.
         */
        this.pullCounter.add(0, this.attrs);
        this.pushCounter.add(0, this.attrs);
    }
    pull() {
        this.pullCounter.add(1, this.attrs);
    }
    push() {
        this.pushCounter.add(1, this.attrs);
    }
}
function meteredList(attrs) {
    return new LinkedList(new QueueMeter("jazz.messagequeue", attrs));
}
const PRIORITY_TO_QUEUE_INDEX = {
    [CO_VALUE_PRIORITY.HIGH]: 0,
    [CO_VALUE_PRIORITY.MEDIUM]: 1,
    [CO_VALUE_PRIORITY.LOW]: 2,
};
export class PriorityBasedMessageQueue {
    constructor(defaultPriority, 
    /**
     * Optional attributes to be added to the generated metrics.
     * By default the metrics will have the priority as an attribute.
     */
    attrs) {
        this.defaultPriority = defaultPriority;
        this.queues = [
            meteredList({ priority: CO_VALUE_PRIORITY.HIGH, ...attrs }),
            meteredList({ priority: CO_VALUE_PRIORITY.MEDIUM, ...attrs }),
            meteredList({ priority: CO_VALUE_PRIORITY.LOW, ...attrs }),
        ];
    }
    getQueue(priority) {
        return this.queues[PRIORITY_TO_QUEUE_INDEX[priority]];
    }
    push(msg) {
        const priority = "priority" in msg ? msg.priority : this.defaultPriority;
        this.getQueue(priority).push(msg);
    }
    pull() {
        const priority = this.queues.findIndex((queue) => queue.length > 0);
        return this.queues[priority]?.shift();
    }
}
//# sourceMappingURL=PriorityBasedMessageQueue.js.map