import { CoID } from "../coValue.js";
import { CoValueUniqueness } from "../coValueCore.js";
import { Encrypted, KeyID, KeySecret, Sealed } from "../crypto/crypto.js";
import { AgentID, ChildGroupReference, ParentGroupReference } from "../ids.js";
import { JsonObject } from "../jsonValue.js";
import { AccountRole, Role } from "../permissions.js";
import { ControlledAccountOrAgent, RawAccount, RawAccountID } from "./account.js";
import { RawCoList } from "./coList.js";
import { RawCoMap } from "./coMap.js";
import { RawCoPlainText } from "./coPlainText.js";
import { RawBinaryCoStream, RawCoStream } from "./coStream.js";
export declare const EVERYONE: "everyone";
export type Everyone = "everyone";
export type ParentGroupReferenceRole = "revoked" | "extend" | "reader" | "writer" | "admin";
export type GroupShape = {
    profile: CoID<RawCoMap> | null;
    root: CoID<RawCoMap> | null;
    [key: RawAccountID | AgentID]: Role;
    [EVERYONE]?: Role;
    readKey?: KeyID;
    [writeKeyFor: `writeKeyFor_${RawAccountID | AgentID}`]: KeyID;
    [revelationFor: `${KeyID}_for_${RawAccountID | AgentID}`]: Sealed<KeySecret>;
    [revelationFor: `${KeyID}_for_${Everyone}`]: KeySecret;
    [oldKeyForNewKey: `${KeyID}_for_${KeyID}`]: Encrypted<KeySecret, {
        encryptedID: KeyID;
        encryptingID: KeyID;
    }>;
    [parent: ParentGroupReference]: ParentGroupReferenceRole;
    [child: ChildGroupReference]: "revoked" | "extend";
};
/** A `Group` is a scope for permissions of its members (`"reader" | "writer" | "admin"`), applying to objects owned by that group.
 *
 *  A `Group` object exposes methods for permission management and allows you to create new CoValues owned by that group.
 *
 *  (Internally, a `Group` is also just a `CoMap`, mapping member accounts to roles and containing some
 *  state management for making cryptographic keys available to current members)
 *
 *  @example
 *  You typically get a group from a CoValue that you already have loaded:
 *
 *  ```typescript
 *  const group = coMap.group;
 *  ```
 *
 *  @example
 *  Or, you can create a new group with a `LocalNode`:
 *
 *  ```typescript
 *  const localNode.createGroup();
 *  ```
 * */
export declare class RawGroup<Meta extends JsonObject | null = JsonObject | null> extends RawCoMap<GroupShape, Meta> {
    /**
     * Returns the current role of a given account.
     *
     * @category 1. Role reading
     */
    roleOf(accountID: RawAccountID | typeof EVERYONE): Role | undefined;
    /**
     *  This is a performance-critical function, micro-optimizing it is important
     *
     *  Avoid to add objects/array allocations in this function
     */
    /** @internal */
    roleOfInternal(accountID: RawAccountID | AgentID | typeof EVERYONE): Role | undefined;
    getParentGroupFromKey(key: ParentGroupReference, atTime?: number): RawGroup<JsonObject | null> | null;
    getParentGroups(atTime?: number): RawGroup<JsonObject | null>[];
    loadAllChildGroups(): Promise<unknown[]>;
    getChildGroups(): RawGroup<JsonObject | null>[];
    /**
     * Returns the role of the current account in the group.
     *
     * @category 1. Role reading
     */
    myRole(): Role | undefined;
    /**
     * Directly grants a new member a role in the group. The current account must be an
     * admin to be able to do so. Throws otherwise.
     *
     * @category 2. Role changing
     */
    addMember(account: RawAccount | ControlledAccountOrAgent | Everyone, role: Role): void;
    /** @internal */
    addMemberInternal(account: RawAccount | ControlledAccountOrAgent | AgentID | Everyone, role: Role): void;
    internalCreateWriteOnlyKeyForMember(memberKey: RawAccountID | AgentID, agent: AgentID): void;
    private storeKeyRevelationForMember;
    private getWriteOnlyKeys;
    getCurrentReadKeyId(): `key_z${string}` | undefined;
    getMemberKeys(): (RawAccountID | AgentID)[];
    getAllMemberKeysSet(): Set<RawAccountID | `sealer_z${string}/signer_z${string}`>;
    /** @internal */
    rotateReadKey(removedMemberKey?: RawAccountID | AgentID | "everyone"): void;
    /** Detect circular references in group inheritance */
    isSelfExtension(parent: RawGroup): boolean;
    extend(parent: RawGroup, role?: "reader" | "writer" | "admin" | "inherit"): void;
    revokeExtend(parent: RawGroup): Promise<void>;
    /**
     * Strips the specified member of all roles (preventing future writes in
     *  the group and owned values) and rotates the read encryption key for that group
     * (preventing reads of new content in the group and owned values)
     *
     * @category 2. Role changing
     */
    removeMember(account: RawAccount | ControlledAccountOrAgent | Everyone): Promise<void>;
    /** @internal */
    removeMemberInternal(account: RawAccount | ControlledAccountOrAgent | AgentID | Everyone): void;
    /**
     * Creates an invite for new members to indirectly join the group,
     * allowing them to grant themselves the specified role with the InviteSecret
     * (a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.
     *
     * @category 2. Role changing
     */
    createInvite(role: AccountRole): InviteSecret;
    /**
     * Creates a new `CoMap` within this group, with the specified specialized
     * `CoMap` type `M` and optional static metadata.
     *
     * @category 3. Value creation
     */
    createMap<M extends RawCoMap>(init?: M["_shape"], meta?: M["headerMeta"], initPrivacy?: "trusting" | "private", uniqueness?: CoValueUniqueness): M;
    /**
     * Creates a new `CoList` within this group, with the specified specialized
     * `CoList` type `L` and optional static metadata.
     *
     * @category 3. Value creation
     */
    createList<L extends RawCoList>(init?: L["_item"][], meta?: L["headerMeta"], initPrivacy?: "trusting" | "private", uniqueness?: CoValueUniqueness): L;
    /**
     * Creates a new `CoPlainText` within this group, with the specified specialized
     * `CoPlainText` type `T` and optional static metadata.
     *
     * @category 3. Value creation
     */
    createPlainText<T extends RawCoPlainText>(init?: string, meta?: T["headerMeta"], initPrivacy?: "trusting" | "private"): T;
    /** @category 3. Value creation */
    createStream<C extends RawCoStream>(meta?: C["headerMeta"], uniqueness?: CoValueUniqueness): C;
    /** @category 3. Value creation */
    createBinaryStream<C extends RawBinaryCoStream>(meta?: C["headerMeta"], uniqueness?: CoValueUniqueness): C;
}
export declare function isInheritableRole(roleInParent: Role | undefined): roleInParent is "revoked" | "admin" | "writer" | "reader";
export type InviteSecret = `inviteSecret_z${string}`;
export declare function secretSeedFromInviteSecret(inviteSecret: InviteSecret): Uint8Array;
//# sourceMappingURL=group.d.ts.map